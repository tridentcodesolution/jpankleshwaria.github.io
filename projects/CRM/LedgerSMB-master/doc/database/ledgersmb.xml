<?xml version="1.0" encoding="UTF-8" ?>
<!-- $Header: /cvsroot/autodoc/autodoc/xml.tmpl,v 1.2 2006/05/16 19:01:27 rbt Exp $ -->

<book id="database.ledgersmb" xreflabel="ledgersmb database schema"><title>ledgersmb Model</title>




  <chapter id="lsmb13.schema"
           xreflabel="lsmb13">
    <title>Schema lsmb13</title>
    <para>standard public schema</para>


      <section id="lsmb13.table.ac-tax-form"
               xreflabel="lsmb13.ac_tax_form">
        <title id="lsmb13.table.ac-tax-form-title">
         Table:
         
         <structname>ac_tax_form</structname>
        </title>
 

        <para>
           Mapping acc_trans to country_tax_form for reporting purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ac_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.acc-trans"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.acc-trans"
               xreflabel="lsmb13.acc_trans">
        <title id="lsmb13.table.acc-trans-title">
         Table:
         
         <structname>acc_trans</structname>
        </title>
 

        <para>
          This table stores line items for financial transactions.  Please note that
payments in 1.3 are not full-fledged transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>acc_trans</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Document Source identifier for individual line items, usually used 
for payments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fx_transaction</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>project_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>memo</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reconciled_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.voucher"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on acc_trans</title>

          <varlistentry>
            <term>ac_transdate_year_idx</term>
            <listitem><para>date_part(&apos;YEAR&apos;::text, transdate)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_chart_id_key</term>
            <listitem><para>chart_id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_source_key</term>
            <listitem><para>lower(source)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_voucher_id_idx</term>
            <listitem><para>voucher_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.ac_tax_form via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.ac-tax-form"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.payment-links"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.tax-extended"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.account"
               xreflabel="lsmb13.account">
        <title id="lsmb13.table.account-title">
         Table:
         
         <structname>account</structname>
        </title>
 

        <para>
           This table stores the main account info.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>category</structfield></term>
              <listitem><para>
                <type>character(1)</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gifi_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>heading</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contra</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.account-checkpoint"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.account-link"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-coa-to-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.customertax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.partstax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.trial-balance-account-to-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.vendortax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.account-checkpoint"
               xreflabel="lsmb13.account_checkpoint">
        <title id="lsmb13.table.account-checkpoint-title">
         Table:
         
         <structname>account_checkpoint</structname>
        </title>
 

        <para>
           This table holds account balances at various dates.  Transactions MUST NOT
be posted prior to the latest end_date in this table, and no unapproved 
transactions (vouchers or drafts) can remain in the closed period.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_checkpoint</structname>
            </title>


            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>debits</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credits</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.account-heading"
               xreflabel="lsmb13.account_heading">
        <title id="lsmb13.table.account-heading-title">
         Table:
         
         <structname>account_heading</structname>
        </title>
 

        <para>
          
This table holds the account headings in the system.  Each account must belong 
to a heading, and a heading can belong to another heading.  In this way it is 
possible to nest accounts for reporting purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_heading</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.account-heading"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.trial-balance-heading-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.account-link"
               xreflabel="lsmb13.account_link">
        <title id="lsmb13.table.account-link-title">
         Table:
         
         <structname>account_link</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_link</structname>
            </title>


            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account-link-description"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.account-link-description"
               xreflabel="lsmb13.account_link_description">
        <title id="lsmb13.table.account-link-description-title">
         Table:
         
         <structname>account_link_description</structname>
        </title>
 

        <para>
           This is a lookup table which provide basic information as to categories and
dropdowns of accounts.  In general summary accounts cannot belong to more than 
one category (an AR summary account cannot appear in other dropdowns for 
example).  Custom fields are not overwritten when the account is edited from
the front-end.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_link_description</structname>
            </title>


            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>summary</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>custom</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.account_link via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.account-link"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.ap"
               xreflabel="lsmb13.ap">
        <title id="lsmb13.table.ap-title">
         Table:
         
         <structname>ap</structname>
        </title>
 

        <para>
           Summary/header information for AP transactions and vendor invoices.
Note that some constraints here are hard to enforce because we haven not gotten 
to rewriting the relevant code here.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ap</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Text identifier for the invoice.  Must be unique.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 This stores the total amount (including taxes) for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 Total amount excluding taxes for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>paid</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>datepaid</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>duedate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 True if the transaction tracks goods/services purchase using the invoice
table.  False otherwise.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

              <para>
                 3 letters to identify the currency.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are displayed on the invoice when printed or emailed
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-employee"/>


              </para>

              <para>
                Person who created the transaction
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>till</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Quotation Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are not displayed when the invoice is printed or emailed and
may be updated without reposting hte invocie.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Purchase Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

              <para>
                Only show in financial reports if true.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                If true numbers are displayed after multiplying by -1
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

              <para>
                 Not exposed to the UI, but can be set to prevent an invoice from showing up
for payment or in outstanding reports.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

              <para>
                 reference for the vendor account used.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on ap</title>

          <varlistentry>
            <term>ap_check</term>
            <listitem><para>CHECK ((((amount IS NULL) AND (curr IS NULL)) OR ((amount IS NOT NULL) AND (curr IS NOT NULL))))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on ap</title>

          <varlistentry>
            <term>ap_approved_idx</term>
            <listitem><para>approved</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ap_curr_idz</term>
            <listitem><para>curr</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ap_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ap_invnumber_key</term>
            <listitem><para>invnumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ap_ordnumber_key</term>
            <listitem><para>ordnumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ap_quonumber_key</term>
            <listitem><para>quonumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ap_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-item"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.ar"
               xreflabel="lsmb13.ar">
        <title id="lsmb13.table.ar-title">
         Table:
         
         <structname>ar</structname>
        </title>
 

        <para>
           Summary/header information for AR transactions and sales invoices.
Note that some constraints here are hard to enforce because we haven not gotten 
to rewriting the relevant code here.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ar</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invnumber</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>










              </para>

              <para>
                 Text identifier for the invoice.  Must be unique.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 This stores the total amount (including taxes) for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 Total amount excluding taxes for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>paid</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>datepaid</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>duedate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 True if the transaction tracks goods/services purchase using the invoice
table.  False otherwise.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are displayed on the invoice when printed or emailed
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

              <para>
                 3 letters to identify the currency.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-employee"/>


              </para>

              <para>
                Person who created the transaction
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>till</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Quotation Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are not displayed when the invoice is printed or emailed and
may be updated without reposting hte invocie.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Purchase Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                If true numbers are displayed after multiplying by -1
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

              <para>
                Only show in financial reports if true.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

              <para>
                 reference for the customer account used.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

              <para>
                 Not exposed to the UI, but can be set to prevent an invoice from showing up
for payment or in outstanding reports.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on ar</title>

          <varlistentry>
            <term>ar_approved_idx</term>
            <listitem><para>approved</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ar_curr_idz</term>
            <listitem><para>curr</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ar_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ar_ordnumber_key</term>
            <listitem><para>ordnumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ar_quonumber_key</term>
            <listitem><para>quonumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>ar_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.assembly"
               xreflabel="lsmb13.assembly">
        <title id="lsmb13.table.assembly-title">
         Table:
         
         <structname>assembly</structname>
        </title>
 

        <para>
          Holds mapping for parts that are members of assemblies.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>assembly</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.parts"/>




              </para>

              <para>
                This is the id of the assembly the part is being mapped to.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.parts"/>




              </para>

              <para>
                ID of part that is a member of the assembly.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bom</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>adj</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on assembly</title>

          <varlistentry>
            <term>assembly_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.asset-class"
               xreflabel="lsmb13.asset_class">
        <title id="lsmb13.table.asset-class-title">
         Table:
         
         <structname>asset_class</structname>
        </title>
 

        <para>
          
The account fields here set the defaults for the individual asset items.  They
are non-authoritative.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dep_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>method</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-dep-method"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.asset-dep-method"
               xreflabel="lsmb13.asset_dep_method">
        <title id="lsmb13.table.asset-dep-method-title">
         Table:
         
         <structname>asset_dep_method</structname>
        </title>
 

        <para>
           Stores asset depreciation methods, and their relevant stored procedures.

The fixed asset system is such depreciation methods can be plugged in via this
table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_dep_method</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>method</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 These are keyed to specific stored procedures.  Currently only &quot;straight_line&quot; is supported
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sproc</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                The sproc mentioned here is a stored procedure which must have the following
arguments: (in_asset_ids int[],  in_report_date date, in_report_id int).

Here in_asset_ids are the assets to be depreciated, in_report_date is the date
of the report, and in_report_id is the id of the report.  The sproc MUST
insert the relevant lines into asset_report_line. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit_label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_name</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-unit-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_class via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-class"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.asset-disposal-method"
               xreflabel="lsmb13.asset_disposal_method">
        <title id="lsmb13.table.asset-disposal-method-title">
         Table:
         
         <structname>asset_disposal_method</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_disposal_method</structname>
            </title>


            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>multiple</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_label</structfield></term>
              <listitem><para>
                <type>character(1)</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on asset_disposal_method</title>

          <varlistentry>
            <term>asset_disposal_method_multiple_check</term>
            <listitem><para>CHECK ((multiple = ANY (ARRAY[1, 0, (-1)])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_rl_to_disposal_method via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.asset-item"
               xreflabel="lsmb13.asset_item">
        <title id="lsmb13.table.asset-item-title">
         Table:
         
         <structname>asset_item</structname>
        </title>
 

        <para>
           Stores details of asset items.  The account fields here are authoritative,
while the ones in the asset_class table are defaults.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_item</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tag</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                 This can be plugged into other routines to generate it automatically via ALTER TABLE .... SET DEFAULT.....
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>purchase_value</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salvage_value</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>usable_life</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>purchase_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_depreciation</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.warehouse"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.department"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.ap"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dep_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>exp_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_by</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>









                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.asset-note"
               xreflabel="lsmb13.asset_note">
        <title id="lsmb13.table.asset-note-title">
         Table:
         
         <structname>asset_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 4</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::pg_catalog.tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-item"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on asset_note</title>

          <varlistentry>
            <term>asset_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 4))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.asset-report"
               xreflabel="lsmb13.asset_report">
        <title id="lsmb13.table.asset-report-title">
         Table:
         
         <structname>asset_report</structname>
        </title>
 

        <para>
           Asset reports are discrete sets of depreciation or disposal transctions,
and each one may be turned into no more than one GL transaction.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gl_id</structfield></term>
              <listitem><para>
                <type>bigint</type>








                      <literal>UNIQUE</literal>









                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.gl"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_class</structfield></term>
              <listitem><para>
                <type>bigint</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_class</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-report-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>bigint</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>bigint</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>depreciated_qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dont_approve</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>submitted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.asset-report-class"
               xreflabel="lsmb13.asset_report_class">
        <title id="lsmb13.table.asset-report-class-title">
         Table:
         
         <structname>asset_report_class</structname>
        </title>
 

        <para>
            By default only four types of asset reports are supported.  In the future
others may be added.  Please correspond on the list before adding more types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.asset-report-line"
               xreflabel="lsmb13.asset_report_line">
        <title id="lsmb13.table.asset-report-line-title">
         Table:
         
         <structname>asset_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>asset_id</structfield></term>
              <listitem><para>
                <type>bigint</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>bigint</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.department"/>


              </para>

              <para>
                 In case assets are moved between departments, we have to store this here.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>warehouse_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.warehouse"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.asset-rl-to-disposal-method"
               xreflabel="lsmb13.asset_rl_to_disposal_method">
        <title id="lsmb13.table.asset-rl-to-disposal-method-title">
         Table:
         
         <structname>asset_rl_to_disposal_method</structname>
        </title>
 

        <para>
           Maps disposal method to line items in the asset disposal report.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_rl_to_disposal_method</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>disposal_method_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.asset-disposal-method"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>percent_disposed</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.asset-unit-class"
               xreflabel="lsmb13.asset_unit_class">
        <title id="lsmb13.table.asset-unit-class-title">
         Table:
         
         <structname>asset_unit_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_unit_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_dep_method via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-dep-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.audittrail"
               xreflabel="lsmb13.audittrail">
        <title id="lsmb13.table.audittrail-title">
         Table:
         
         <structname>audittrail</structname>
        </title>
 

        <para>
           This stores information on who entered or updated rows in the ar, ap, or gl
tables.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>audittrail</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tablename</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>action</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on audittrail</title>

          <varlistentry>
            <term>audittrail_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.batch"
               xreflabel="lsmb13.batch">
        <title id="lsmb13.table.batch-title">
         Table:
         
         <structname>batch</structname>
        </title>
 

        <para>
           Stores batch header info.  Batches are groups of vouchers that are posted
together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>batch</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.batch-class"/>


              </para>

              <para>
                 Note that this field is largely used for sorting the vouchers.  A given batch is NOT restricted to this type.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.session"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_on</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on batch</title>

          <varlistentry>
            <term>batch_control_code_check</term>
            <listitem><para>CHECK ((length(control_code) &gt; 0))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.pending_job via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.pending-job"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.batch-class"
               xreflabel="lsmb13.batch_class">
        <title id="lsmb13.table.batch-class-title">
         Table:
         
         <structname>batch_class</structname>
        </title>
 

        <para>
           These values are hard-coded.  Please coordinate before adding standard
values.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>batch_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.batch via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.pending-job"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.budget-info"
               xreflabel="lsmb13.budget_info">
        <title id="lsmb13.table.budget-info-title">
         Table:
         
         <structname>budget_info</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_info</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on budget_info</title>

          <varlistentry>
            <term>budget_info_check</term>
            <listitem><para>CHECK ((start_date &lt; end_date))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.budget_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-to-department"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-to-project"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.budget-line"
               xreflabel="lsmb13.budget_line">
        <title id="lsmb13.table.budget-line-title">
         Table:
         
         <structname>budget_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_line</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.budget-info"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.budget-note"
               xreflabel="lsmb13.budget_note">
        <title id="lsmb13.table.budget-note-title">
         Table:
         
         <structname>budget_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 6</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::pg_catalog.tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.budget-info"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on budget_note</title>

          <varlistentry>
            <term>budget_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 6))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.budget-to-department"
               xreflabel="lsmb13.budget_to_department">
        <title id="lsmb13.table.budget-to-department-title">
         Table:
         
         <structname>budget_to_department</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_to_department</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.budget-info"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.department"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.budget-to-project"
               xreflabel="lsmb13.budget_to_project">
        <title id="lsmb13.table.budget-to-project-title">
         Table:
         
         <structname>budget_to_project</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_to_project</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.budget-info"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>project_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.project"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.business"
               xreflabel="lsmb13.business">
        <title id="lsmb13.table.business-title">
         Table:
         
         <structname>business</structname>
        </title>
 

        <para>
          Groups of Customers assigned joint discounts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.view.chart"
               xreflabel="lsmb13.chart">
        <title id="lsmb13.view.chart-title">
         View:
         
         <structname>chart</structname>
        </title>
 

        <para>
          Compatibility chart for 1.2 and earlier.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>chart</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>charttype</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>category</structfield></term>
              <listitem><para>
                <type>bpchar</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>link</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_heading</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gifi_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contra</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view chart</title>
         <programlisting>
SELECT account_heading.id
, account_heading.accno
, account_heading.description
,&apos;H&apos;::text AS charttype
, NULL::bpchar AS category
, NULL::text AS link
, NULL::integer AS account_heading
, NULL::text AS gifi_accno
, false AS contra
, false AS tax 
FROM lsmb13.account_heading 
UNIONSELECT c.id
, c.accno
, c.description
,&apos;A&apos;::text AS charttype
, c.category
, lsmb13.concat_colon
(l.description) AS link
, c.heading AS account_heading
, c.gifi_accno
, c.contra
, c.tax 
FROM (lsmb13.account c 
LEFT JOIN lsmb13.account_link l 
    ON (
           (c.id = l.account_id)
     )
)
GROUP BY c.id
, c.accno
, c.description
, c.category
, c.heading
, c.gifi_accno
, c.contra
, c.tax;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.company"
               xreflabel="lsmb13.company">
        <title id="lsmb13.table.company-title">
         Table:
         
         <structname>company</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>company</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>legal_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax_id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 In the US this would be a EIN. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sic_code</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on company</title>

          <varlistentry>
            <term>company_legal_name_check</term>
            <listitem><para>CHECK ((legal_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on company</title>

          <varlistentry>
            <term>company_name_gist__idx</term>
            <listitem><para>legal_name lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.company_to_contact via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.company-to-contact"
               xreflabel="lsmb13.company_to_contact">
        <title id="lsmb13.table.company-to-contact-title">
         Table:
         
         <structname>company_to_contact</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>company_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>company_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.company"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on company_to_contact</title>

          <varlistentry>
            <term>company_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.company-to-entity"
               xreflabel="lsmb13.company_to_entity">
        <title id="lsmb13.table.company-to-entity-title">
         Table:
         
         <structname>company_to_entity</structname>
        </title>
 

        <para>
           This provides a map so that entities can also be used like groups.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>company_to_entity</structname>
            </title>


            <varlistentry>
              <term><structfield>company_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.company"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>related_how</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on company_to_entity</title>

          <varlistentry>
            <term>company_to_entity_check</term>
            <listitem><para>CHECK ((company_id &lt;&gt; entity_id))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.company-to-location"
               xreflabel="lsmb13.company_to_location">
        <title id="lsmb13.table.company-to-location-title">
         Table:
         
         <structname>company_to_location</structname>
        </title>
 

        <para>
           This table is used for locations generic to companies.  For contract-bound
addresses, use eca_to_location instead 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>company_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>company_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.company"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.contact-class"
               xreflabel="lsmb13.contact_class">
        <title id="lsmb13.table.contact-class-title">
         Table:
         
         <structname>contact_class</structname>
        </title>
 

        <para>
           Stores type of contact information attached to companies and persons.
Please coordinate with others before adding new types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>contact_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on contact_class</title>

          <varlistentry>
            <term>contact_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.company_to_contact via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.eca-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-contact"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.country"
               xreflabel="lsmb13.country">
        <title id="lsmb13.table.country-title">
         Table:
         
         <structname>country</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>country</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>itu</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 The ITU Telecommunication Standardization Sector code for calling internationally. For example, the US is 1, Great Britain is 44 
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on country</title>

          <varlistentry>
            <term>country_name_check</term>
            <listitem><para>CHECK ((name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>country_short_name_check</term>
            <listitem><para>CHECK ((short_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.country_tax_form via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.country-tax-form"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.location"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.country-tax-form"
               xreflabel="lsmb13.country_tax_form">
        <title id="lsmb13.table.country-tax-form-title">
         Table:
         
         <structname>country_tax_form</structname>
        </title>
 

        <para>
           This table was designed for holding information relating to reportable
sales or purchases, such as IRS 1099 forms and international equivalents.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>country_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.country"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>form_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.cr-coa-to-account"
               xreflabel="lsmb13.cr_coa_to_account">
        <title id="lsmb13.table.cr-coa-to-account-title">
         Table:
         
         <structname>cr_coa_to_account</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_coa_to_account</structname>
            </title>


            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.cr-report"
               xreflabel="lsmb13.cr_report">
        <title id="lsmb13.table.cr-report-title">
         Table:
         
         <structname>cr_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_total</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>submitted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>updated</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_username</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deleted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deleted_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_username</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>recon_fx</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on cr_report</title>

          <varlistentry>
            <term>cr_report_check</term>
            <listitem><para>CHECK (((deleted IS NOT TRUE) OR (approved IS NOT TRUE)))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.cr_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.cr-report-line"
               xreflabel="lsmb13.cr_report_line">
        <title id="lsmb13.table.cr-report-line-title">
         Table:
         
         <structname>cr_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.cr-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>scn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>our_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>errorcode</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>user</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>clear_time</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>insert_time</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ledger_id</structfield></term>
              <listitem><para>
                <type>integer</type>
















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.acc-trans"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.acc-trans"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.voucher"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>overlook</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.custom-field-catalog"
               xreflabel="lsmb13.custom_field_catalog">
        <title id="lsmb13.table.custom-field-catalog-title">
         Table:
         
         <structname>custom_field_catalog</structname>
        </title>
 

        <para>
           Deprecated, use only with old code.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>custom_field_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>field_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.custom-table-catalog"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>field_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.custom-table-catalog"
               xreflabel="lsmb13.custom_table_catalog">
        <title id="lsmb13.table.custom-table-catalog-title">
         Table:
         
         <structname>custom_table_catalog</structname>
        </title>
 

        <para>
           Deprecated, use only with old code.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>custom_table_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>table_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>extends</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.custom_field_catalog via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.custom-field-catalog"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.customertax"
               xreflabel="lsmb13.customertax">
        <title id="lsmb13.table.customertax-title">
         Table:
         
         <structname>customertax</structname>
        </title>
 

        <para>
           Mapping customer to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>customertax</structname>
            </title>


            <varlistentry>
              <term><structfield>customer_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on customertax</title>

          <varlistentry>
            <term>customer_customer_id_key</term>
            <listitem><para>customer_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.defaults"
               xreflabel="lsmb13.defaults">
        <title id="lsmb13.table.defaults-title">
         Table:
         
         <structname>defaults</structname>
        </title>
 

        <para>
            This is a free-form table for managing application settings per company
database.  We use key-value modelling here because this most accurately maps 
the actual semantics of the data.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>defaults</structname>
            </title>


            <varlistentry>
              <term><structfield>setting_key</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>value</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.department"
               xreflabel="lsmb13.department">
        <title id="lsmb13.table.department-title">
         Table:
         
         <structname>department</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>department</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character(1)</type>





                <literal>DEFAULT &apos;P&apos;::bpchar</literal>



              </para>

              <para>
                P for Profit Center, C for Cost Center
              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on department</title>

          <varlistentry>
            <term>department_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-to-department"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.dpt-trans"
               xreflabel="lsmb13.dpt_trans">
        <title id="lsmb13.table.dpt-trans-title">
         Table:
         
         <structname>dpt_trans</structname>
        </title>
 

        <para>
          Department to Transaction Map
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>dpt_trans</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.eca-note"
               xreflabel="lsmb13.eca_note">
        <title id="lsmb13.table.eca-note-title">
         Table:
         
         <structname>eca_note</structname>
        </title>
 

        <para>
           Notes for entity_credit_account entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::pg_catalog.tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

              <para>
                 references entity_credit_account.id
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on eca_note</title>

          <varlistentry>
            <term>eca_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 3))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.eca-to-contact"
               xreflabel="lsmb13.eca_to_contact">
        <title id="lsmb13.table.eca-to-contact-title">
         Table:
         
         <structname>eca_to_contact</structname>
        </title>
 

        <para>
           To keep track of the relationship between multiple contact methods and a single vendor or customer account. For generic 
contacts, use company_to_contact or person_to_contact instead.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on eca_to_contact</title>

          <varlistentry>
            <term>eca_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.eca-to-location"
               xreflabel="lsmb13.eca_to_location">
        <title id="lsmb13.table.eca-to-location-title">
         Table:
         
         <structname>eca_to_location</structname>
        </title>
 

        <para>
           This table is used for locations bound to contracts.  For generic contact
addresses, use company_to_location instead 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.view.employee-search"
               xreflabel="lsmb13.employee_search">
        <title id="lsmb13.view.employee-search-title">
         View:
         
         <structname>employee_search</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_search</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view employee_search</title>
         <programlisting>
SELECT e.entity_id
, e.startdate
, e.enddate
, e.role
, e.ssn
, e.sales
, e.manager_id
, e.employeenumber
, e.dob
, em.name AS manager
, emn.note
, en.name 
FROM (
     (
           (
                 (lsmb13.entity_employee e 
               LEFT JOIN lsmb13.entity en 
                      ON (
                             (e.entity_id = en.id)
                       )
                 )
         LEFT JOIN lsmb13.entity_employee m 
                ON (
                       (e.manager_id = m.entity_id)
                 )
           )
   LEFT JOIN lsmb13.entity em 
          ON (
                 (em.id = m.entity_id)
           )
     )
LEFT JOIN lsmb13.entity_note emn 
    ON (
           (emn.ref_key = em.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.view.employees"
               xreflabel="lsmb13.employees">
        <title id="lsmb13.view.employees-title">
         View:
         
         <structname>employees</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employees</structname>
            </title>


            <varlistentry>
              <term><structfield>salutation</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>first_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view employees</title>
         <programlisting>
SELECT s.salutation
, p.first_name
, p.last_name
, ee.entity_id
, ee.startdate
, ee.enddate
, ee.role
, ee.ssn
, ee.sales
, ee.manager_id
, ee.employeenumber
, ee.dob 
FROM (
     (lsmb13.person p 
        JOIN lsmb13.entity_employee ee 
       USING (entity_id)
     )
LEFT JOIN lsmb13.salutation s 
    ON (
           (p.salutation_id = s.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.entity"
               xreflabel="lsmb13.entity">
        <title id="lsmb13.table.entity-title">
         Table:
         
         <structname>entity</structname>
        </title>
 

        <para>
           The primary entity table to map to all contacts 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the common name of an entity. If it was a person it may be Joshua Drake, a company Acme Corp. You may also choose to use a domain such as commandprompt.com 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_class</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-class"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>



                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT setting_increment(&apos;entity_control&apos;::character varying)</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.country"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity</title>

          <varlistentry>
            <term>entity_name_check</term>
            <listitem><para>CHECK ((name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity</title>

          <varlistentry>
            <term>entity_name_gist_idx</term>
            <listitem><para>name lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-info"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.company"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-bank-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-class-to-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-employee"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-other-name"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-base"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-secondary-attachment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.transactions"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.users"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.entity-bank-account"
               xreflabel="lsmb13.entity_bank_account">
        <title id="lsmb13.table.entity-bank-account-title">
         Table:
         
         <structname>entity_bank_account</structname>
        </title>
 

        <para>
          This stores bank account information for both companies and persons.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_bank_account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bic</structfield></term>
              <listitem><para>
                <type>character varying</type>




                      <literal>UNIQUE#1</literal>










              </para>

              <para>
                 Banking Institution Code, such as routing number of SWIFT code.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>iban</structfield></term>
              <listitem><para>
                <type>character varying</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                 International Bank Account Number.  used to store the actual account number
for the banking institution.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.entity-class"
               xreflabel="lsmb13.entity_class">
        <title id="lsmb13.table.entity-class-title">
         Table:
         
         <structname>entity_class</structname>
        </title>
 

        <para>
           Defines the class type such as vendor, customer, contact, employee 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 The first 7 values are reserved and 
permanent.  Individuals who create new classes, however, should coordinate 
with others for ranges to use.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.country"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_class</title>

          <varlistentry>
            <term>entity_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity_class</title>

          <varlistentry>
            <term>entity_class_idx</term>
            <listitem><para>lower(class)</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.entity via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-class-to-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.entity-class-to-entity"
               xreflabel="lsmb13.entity_class_to_entity">
        <title id="lsmb13.table.entity-class-to-entity-title">
         Table:
         
         <structname>entity_class_to_entity</structname>
        </title>
 

        <para>
           Relation builder for classes to entity 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_class_to_entity</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.entity-credit-account"
               xreflabel="lsmb13.entity_credit_account">
        <title id="lsmb13.table.entity-credit-account-title">
         Table:
         
         <structname>entity_credit_account</structname>
        </title>
 

        <para>
          This table stores informmation relating to general relationships regarding 
moneys owed on invoice.  Invoices, whether AR or AP, must be attached to 
a record in this table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_credit_account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pay_to_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount_terms</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>creditlimit</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>meta_number</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 This stores the human readable control code for the customer/vendor record.
This is typically called the customer/vendor &quot;account&quot; in the application.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>business_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.pricegroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>threshold</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>primary_contact</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ar_ap_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cash_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bank_account</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-bank-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxform_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.country-tax-form"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_credit_account</title>

          <varlistentry>
            <term>entity_credit_account_check</term>
            <listitem><para>CHECK (((ar_ap_account_id IS NOT NULL) OR (entity_id = 0)))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>entity_credit_account_entity_class_check</term>
            <listitem><para>CHECK ((entity_class = ANY (ARRAY[1, 2])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.customertax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.eca-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.eca-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.partscustomer"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.partsvendor"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.project"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.vendortax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.entity-employee"
               xreflabel="lsmb13.entity_employee">
        <title id="lsmb13.table.entity-employee-title">
         Table:
         
         <structname>entity_employee</structname>
        </title>
 

        <para>
           This contains employee-specific extensions to person/entity. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_employee</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.inventory"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.entity-note"
               xreflabel="lsmb13.entity_note">
        <title id="lsmb13.table.entity-note-title">
         Table:
         
         <structname>entity_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::pg_catalog.tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_note</title>

          <varlistentry>
            <term>entity_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity_note</title>

          <varlistentry>
            <term>entity_note_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>entity_note_vectors_idx</term>
            <listitem><para>vector</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>notes_idx</term>
            <listitem><para>note lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.entity-other-name"
               xreflabel="lsmb13.entity_other_name">
        <title id="lsmb13.table.entity-other-name-title">
         Table:
         
         <structname>entity_other_name</structname>
        </title>
 

        <para>
           Similar to company_other_name, a person
may be jd, Joshua Drake, linuxpoet... all are the same person.  Currently
unused in the front-end but will likely be added in future versions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_other_name</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>other_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_other_name</title>

          <varlistentry>
            <term>entity_other_name_other_name_check</term>
            <listitem><para>CHECK ((other_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.exchangerate"
               xreflabel="lsmb13.exchangerate">
        <title id="lsmb13.table.exchangerate-title">
         Table:
         
         <structname>exchangerate</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>exchangerate</structname>
            </title>


            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>buy</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sell</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on exchangerate</title>

          <varlistentry>
            <term>exchangerate_ct_key</term>
            <listitem><para>curr, transdate</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.file-base"
               xreflabel="lsmb13.file_base">
        <title id="lsmb13.table.file-base-title">
         Table:
         
         <structname>file_base</structname>
        </title>
 

        <para>
          Abstract table, holds no records.  Inheriting table store actual file
attachment data. Can be queried however to retrieve lists of all files. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_base</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.mime-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                This column inheriting tables is used to reference the database row for the
attachment.  Inheriting tables MUST set the foreign key here appropriately.

This can also be used to create classifications of other documents, such as by
source of automatic import (where the file is not yet attached) or
even standard,
long-lived documents.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.file-class"
               xreflabel="lsmb13.file_class">
        <title id="lsmb13.table.file-class-title">
         Table:
         
         <structname>file_class</structname>
        </title>
 

        <para>
           File classes are collections of files attached against rows in specific 
tables in the database.  They can be used in the future to implement other form 
of file attachment. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.file_base via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-base"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-secondary-attachment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-view-catalog"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.view.file-links"
               xreflabel="lsmb13.file_links">
        <title id="lsmb13.view.file-links-title">
         View:
         
         <structname>file_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_links</title>
         <programlisting>
SELECT file_tx_links.file_id
, file_tx_links.ref_key
, file_tx_links.reference
, file_tx_links.type
, file_tx_links.dest_class
, file_tx_links.source_class
, file_tx_links.dest_ref 
FROM lsmb13.file_tx_links 
UNIONSELECT file_order_links.file_id
, file_order_links.ref_key
, file_order_links.reference
, file_order_links.oe_class AS type
, file_order_links.dest_class
, file_order_links.source_class
, file_order_links.dest_ref 
FROM lsmb13.file_order_links;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.file-order"
               xreflabel="lsmb13.file_order">
        <title id="lsmb13.table.file-order-title">
         Table:
         
         <structname>file_order</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order</title>

          <varlistentry>
            <term>file_order_file_class_check</term>
            <listitem><para>CHECK ((file_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.file_order_to_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-order-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-order-to-tx"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.view.file-order-links"
               xreflabel="lsmb13.file_order_links">
        <title id="lsmb13.view.file-order-links-title">
         View:
         
         <structname>file_order_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_order_links</title>
         <programlisting>
SELECT sl.file_id
, sl.ref_key
, oe.ordnumber AS reference
, oc.oe_class
, sl.dest_class
, sl.source_class
, sl.ref_key AS dest_ref 
FROM (
     (lsmb13.file_secondary_attachment sl 
        JOIN lsmb13.oe 
          ON (
                 (sl.ref_key = oe.id)
           )
     )
  JOIN lsmb13.oe_class oc 
    ON (
           (oe.oe_class_id = oc.id)
     )
)
WHERE (sl.source_class = 2);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.file-order-to-order"
               xreflabel="lsmb13.file_order_to_order">
        <title id="lsmb13.table.file-order-to-order-title">
         Table:
         
         <structname>file_order_to_order</structname>
        </title>
 

        <para>
           Secondary links from one order to another, for example to support order
consolidation.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_to_order</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-order"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order_to_order</title>

          <varlistentry>
            <term>file_order_to_order_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 2))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_order_to_order_source_class_check</term>
            <listitem><para>CHECK ((source_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.file-order-to-tx"
               xreflabel="lsmb13.file_order_to_tx">
        <title id="lsmb13.table.file-order-to-tx-title">
         Table:
         
         <structname>file_order_to_tx</structname>
        </title>
 

        <para>
           Secondary links from orders to transactions, for example to track files when
invoices are generated from orders.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_to_tx</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-order"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order_to_tx</title>

          <varlistentry>
            <term>file_order_to_tx_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 1))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_order_to_tx_source_class_check</term>
            <listitem><para>CHECK ((source_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.file-part"
               xreflabel="lsmb13.file_part">
        <title id="lsmb13.table.file-part-title">
         Table:
         
         <structname>file_part</structname>
        </title>
 

        <para>
           File attachments primarily attached to orders and quotations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_part</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_part</title>

          <varlistentry>
            <term>file_part_file_class_check</term>
            <listitem><para>CHECK ((file_class = 3))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.file-secondary-attachment"
               xreflabel="lsmb13.file_secondary_attachment">
        <title id="lsmb13.table.file-secondary-attachment-title">
         Table:
         
         <structname>file_secondary_attachment</structname>
        </title>
 

        <para>
          Another abstract table.  This one will use rewrite rules to make inserts safe
because of the difficulty in managing inserts otherwise. Inheriting tables 
provide secondary links between the file and other database objects.

Due to the nature of database inheritance and unique constraints
in PostgreSQL, this must be partitioned in a star format.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_secondary_attachment</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.file-transaction"
               xreflabel="lsmb13.file_transaction">
        <title id="lsmb13.table.file-transaction-title">
         Table:
         
         <structname>file_transaction</structname>
        </title>
 

        <para>
           File attachments primarily attached to orders and quotatoins.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_transaction</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_transaction</title>

          <varlistentry>
            <term>file_transaction_file_class_check</term>
            <listitem><para>CHECK ((file_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.file_tx_to_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-tx-to-order"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.view.file-tx-links"
               xreflabel="lsmb13.file_tx_links">
        <title id="lsmb13.view.file-tx-links-title">
         View:
         
         <structname>file_tx_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_tx_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_tx_links</title>
         <programlisting>
SELECT sl.file_id
, sl.ref_key
, gl.reference
, gl.type
, sl.dest_class
, sl.source_class
, sl.ref_key AS dest_ref 
FROM (lsmb13.file_secondary_attachment sl 
  JOIN (
           (
            SELECT gl.id
                 , gl.reference
                 ,&apos;gl&apos;::text AS type 
              FROM lsmb13.gl 
             UNIONSELECT ar.id
                 , ar.invnumber
                 , CASE WHEN ar.invoice THEN &apos;is&apos;::text ELSE &apos;ar&apos;::text END AS type 
              FROM lsmb13.ar
           )
       UNIONSELECT ap.id
           , ap.invnumber
           , CASE WHEN ap.invoice THEN &apos;ir&apos;::text ELSE &apos;ap&apos;::text END AS type 
        FROM lsmb13.ap
     ) gl 
    ON (
           (
                 (sl.ref_key = gl.id)
               AND (sl.source_class = 1)
           )
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.file-tx-to-order"
               xreflabel="lsmb13.file_tx_to_order">
        <title id="lsmb13.table.file-tx-to-order-title">
         Table:
         
         <structname>file_tx_to_order</structname>
        </title>
 

        <para>
           Secondary links from transactions to orders.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_tx_to_order</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-transaction"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_tx_to_order</title>

          <varlistentry>
            <term>file_tx_to_order_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 2))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_tx_to_order_source_class_check</term>
            <listitem><para>CHECK ((source_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.file-view-catalog"
               xreflabel="lsmb13.file_view_catalog">
        <title id="lsmb13.table.file-view-catalog-title">
         Table:
         
         <structname>file_view_catalog</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_view_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>view_name</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.gifi"
               xreflabel="lsmb13.gifi">
        <title id="lsmb13.table.gifi-title">
         Table:
         
         <structname>gifi</structname>
        </title>
 

        <para>
           GIFI labels for accounts, used in Canada and some EU countries for tax 
reporting
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>gifi</structname>
            </title>


            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.gl"
               xreflabel="lsmb13.gl">
        <title id="lsmb13.table.gl-title">
         Table:
         
         <structname>gl</structname>
        </title>
 

        <para>
           This table holds summary information for entries in the general journal.
Does not hold summary information in 1.3 for AR or AP entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>gl</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>


              </para>

              <para>
                 the person_id of the employee who created
the entry.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on gl</title>

          <varlistentry>
            <term>gl_approved_idx</term>
            <listitem><para>approved</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>gl_description_key</term>
            <listitem><para>lower(description)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>gl_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>gl_reference_key</term>
            <listitem><para>reference</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>gl_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.yearend"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.inventory"
               xreflabel="lsmb13.inventory">
        <title id="lsmb13.table.inventory-title">
         Table:
         
         <structname>inventory</structname>
        </title>
 

        <para>
           This table contains inventory mappings to warehouses, not general inventory
management data.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>warehouse_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>orderitems_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.invoice"
               xreflabel="lsmb13.invoice">
        <title id="lsmb13.table.invoice-title">
         Table:
         
         <structname>invoice</structname>
        </title>
 

        <para>
          Line items of invoices with goods/services attached.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                Positive is normal for sales invoices, negative for vendor invoices.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>allocated</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                Number of allocated items, negative relative to qty.
When qty + allocated = 0, then the item is fully used for purposes of COGS 
calculations.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>precision</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fxsellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>assemblyitem</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>project_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deliverydate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on invoice</title>

          <varlistentry>
            <term>invoice_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>invoice_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.invoice_note via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.invoice-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.invoice-tax-form"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.invoice-note"
               xreflabel="lsmb13.invoice_note">
        <title id="lsmb13.table.invoice-note-title">
         Table:
         
         <structname>invoice_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::pg_catalog.tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.invoice"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on invoice_note</title>

          <varlistentry>
            <term>invoice_note_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>invoice_note_vectors_idx</term>
            <listitem><para>vector</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.invoice-tax-form"
               xreflabel="lsmb13.invoice_tax_form">
        <title id="lsmb13.table.invoice-tax-form-title">
         Table:
         
         <structname>invoice_tax_form</structname>
        </title>
 

        <para>
           Maping invoice to country_tax_form.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.invoice"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.jcitems"
               xreflabel="lsmb13.jcitems">
        <title id="lsmb13.table.jcitems-title">
         Table:
         
         <structname>jcitems</structname>
        </title>
 

        <para>
           Time and materials cards. 
Materials cards not implemented.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>jcitems</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>project_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>allocated</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fxsellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>checkedin</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>checkedout</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>total</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>non_billable</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on jcitems</title>

          <varlistentry>
            <term>jcitems_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.language"
               xreflabel="lsmb13.language">
        <title id="lsmb13.table.language-title">
         Table:
         
         <structname>language</structname>
        </title>
 

        <para>
           Languages for manual translations and so forth.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>language</structname>
            </title>


            <varlistentry>
              <term><structfield>code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.user-preference"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.location"
               xreflabel="lsmb13.location">
        <title id="lsmb13.table.location-title">
         Table:
         
         <structname>location</structname>
        </title>
 

        <para>
          
This table stores addresses, such as shipto and bill to addresses.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>location</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_one</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_two</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_three</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>city</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>state</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.country"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mail_code</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>inactive_date</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on location</title>

          <varlistentry>
            <term>location_city_check</term>
            <listitem><para>CHECK ((city ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_line_one_check</term>
            <listitem><para>CHECK ((line_one ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_mail_code_check</term>
            <listitem><para>CHECK ((mail_code ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_state_check</term>
            <listitem><para>CHECK ((state ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on location</title>

          <varlistentry>
            <term>location_address_one_gist__idx</term>
            <listitem><para>line_one lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_address_three_gist__idx</term>
            <listitem><para>line_three lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_address_two_gist__idx</term>
            <listitem><para>line_two lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_city_prov_gist_idx</term>
            <listitem><para>city lsmb13.gist_trgm_ops</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.company_to_location via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.new-shipto"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-company"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-location"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.location-class"
               xreflabel="lsmb13.location_class">
        <title id="lsmb13.table.location-class-title">
         Table:
         
         <structname>location_class</structname>
        </title>
 

        <para>
          
Individuals seeking to add new location classes should coordinate with others.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>location_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>authoritative</structfield></term>
              <listitem><para>
                <type>boolean</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on location_class</title>

          <varlistentry>
            <term>location_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.company_to_location via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.company-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-location"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.lsmb-group"
               xreflabel="lsmb13.lsmb_group">
        <title id="lsmb13.table.lsmb-group-title">
         Table:
         
         <structname>lsmb_group</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_group</structname>
            </title>


            <varlistentry>
              <term><structfield>role_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.lsmb_group_grants via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.lsmb-group-grants"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.lsmb-group-grants"
               xreflabel="lsmb13.lsmb_group_grants">
        <title id="lsmb13.table.lsmb-group-grants-title">
         Table:
         
         <structname>lsmb_group_grants</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_group_grants</structname>
            </title>


            <varlistentry>
              <term><structfield>group_name</structfield></term>
              <listitem><para>
                <type>text</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.lsmb-group"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>granted_role</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.lsmb-roles"
               xreflabel="lsmb13.lsmb_roles">
        <title id="lsmb13.table.lsmb-roles-title">
         Table:
         
         <structname>lsmb_roles</structname>
        </title>
 

        <para>
          A beginning of a group tracking system.  Not exposed through the front end yet.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_roles</structname>
            </title>


            <varlistentry>
              <term><structfield>user_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.makemodel"
               xreflabel="lsmb13.makemodel">
        <title id="lsmb13.table.makemodel-title">
         Table:
         
         <structname>makemodel</structname>
        </title>
 

        <para>
           A single parts entry can have multiple make/model entries.  These
store manufacturer/model number info.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>makemodel</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>make</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>model</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on makemodel</title>

          <varlistentry>
            <term>makemodel_make_key</term>
            <listitem><para>lower(make)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>makemodel_model_key</term>
            <listitem><para>lower(model)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>makemodel_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.menu-acl"
               xreflabel="lsmb13.menu_acl">
        <title id="lsmb13.table.menu-acl-title">
         Table:
         
         <structname>menu_acl</structname>
        </title>
 

        <para>
          Provides access control list entries for menu nodes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_acl</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role_name</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>acl_type</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

              <para>
                 Nodes are hidden unless a role is found of which the user is a member, and
where the acl_type for that role type and node is set to &apos;allow&apos; and no acl is 
found for any role of which the user is a member, where the acl_type is set to
&apos;deny&apos;.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>node_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on menu_acl</title>

          <varlistentry>
            <term>menu_acl_acl_type_check</term>
            <listitem><para>CHECK ((((acl_type)::text = &apos;allow&apos;::text) OR ((acl_type)::text = &apos;deny&apos;::text)))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.menu-attribute"
               xreflabel="lsmb13.menu_attribute">
        <title id="lsmb13.table.menu-attribute-title">
         Table:
         
         <structname>menu_attribute</structname>
        </title>
 

        <para>
           This table stores the callback information for each menu item.  The 
attributes are stored in key/value modelling because of the fact that this
best matches the semantic structure of the information.

Each node should have EITHER a menu or a module attribute, menu for a menu with 
sub-items, module for an executiable script.  The module attribute identifies
the perl script to be run.  The action attribute identifies the entry point.

Beyond this, any other attributes that should be passed in can be done as other
attributes.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_attribute</structname>
            </title>


            <varlistentry>
              <term><structfield>node_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attribute</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>value</structfield></term>
              <listitem><para>
                <type>character varying</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.view.menu-friendly"
               xreflabel="lsmb13.menu_friendly">
        <title id="lsmb13.view.menu-friendly-title">
         View:
         
         <structname>menu_friendly</structname>
        </title>
 

        <para>
           A nice human-readable view for investigating the menu tree.  Does not
show menu attributes or acls.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_friendly</structname>
            </title>


            <varlistentry>
              <term><structfield>level</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>path</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>position</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view menu_friendly</title>
         <programlisting>WITH RECURSIVE tree
(path
     , id
     , parent
     , level
     , positions
) AS 
(
SELECT (menu_node.id)::text AS path
     , menu_node.id
     , menu_node.parent
     , 0 AS level
     , (menu_node.&quot;position&quot;)::text AS &quot;position&quot;
  FROM lsmb13.menu_node 
 WHERE (menu_node.parent IS NULL)
 UNIONSELECT (
           (t.path || 
               &apos;,&apos;::text
           ) || 
           (n.id)::text
     )
     , n.id
     , n.parent
     , (t.level + 1)
     , (
           (t.positions || 
               &apos;,&apos;::text
           ) || n.&quot;position&quot;
     )
  FROM (lsmb13.menu_node n 
        JOIN tree t 
          ON (
                 (t.id = n.parent)
           )
     )
)
SELECT t.level
, t.path
, (repeat
     (&apos; &apos;::text
           , (2 * t.level)
     ) || 
     (n.label)::text
) AS label
, n.id
, n.&quot;position&quot;
FROM (tree t 
  JOIN lsmb13.menu_node n 
 USING (id)
)
ORDER BY (string_to_array
     (t.positions
           ,&apos;,&apos;::text
     )
)::integer[];</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.menu-node"
               xreflabel="lsmb13.menu_node">
        <title id="lsmb13.table.menu-node-title">
         Table:
         
         <structname>menu_node</structname>
        </title>
 

        <para>
          This table stores the tree structure of the menu.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_node</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>character varying</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>









                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>position</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.menu_acl via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.menu-acl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.menu-attribute"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.menu-node"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.mime-type"
               xreflabel="lsmb13.mime_type">
        <title id="lsmb13.table.mime-type-title">
         Table:
         
         <structname>mime_type</structname>
        </title>
 

        <para>
           This is a lookup table for storing MIME types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>mime_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_include</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.file_base via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-base"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.new-shipto"
               xreflabel="lsmb13.new_shipto">
        <title id="lsmb13.table.new-shipto-title">
         Table:
         
         <structname>new_shipto</structname>
        </title>
 

        <para>
           Tracks ship_to information for orders and invoices.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>new_shipto</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.note"
               xreflabel="lsmb13.note">
        <title id="lsmb13.table.note-title">
         Table:
         
         <structname>note</structname>
        </title>
 

        <para>
           This is an abstract table which should have zero rows.  It is inherited by
other tables for specific notes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.note-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                Body of note.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::pg_catalog.tsvector</literal>



              </para>

              <para>
                tsvector for full text indexing, requires 
both setting up tsearch dictionaries and adding triggers to use at present.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 Subclassed tables use this column as a foreign key against the table storing
the record a note is attached to.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.note-class"
               xreflabel="lsmb13.note_class">
        <title id="lsmb13.table.note-class-title">
         Table:
         
         <structname>note_class</structname>
        </title>
 

        <para>
           Coordinate with others before adding entries. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>note_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on note_class</title>

          <varlistentry>
            <term>note_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.note via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.note"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.oe"
               xreflabel="lsmb13.oe">
        <title id="lsmb13.table.oe-title">
         Table:
         
         <structname>oe</structname>
        </title>
 

        <para>
           Header information for:
* Sales orders
* Purchase Orders
* Quotations
* Requests for Quotation

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>oe</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reqdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>closed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quotation</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.oe-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on oe</title>

          <varlistentry>
            <term>oe_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>oe_ordnumber_key</term>
            <listitem><para>ordnumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>oe_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.file_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-order-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-tx-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.new-shipto"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.oe-class"
               xreflabel="lsmb13.oe_class">
        <title id="lsmb13.table.oe-class-title">
         Table:
         
         <structname>oe_class</structname>
        </title>
 

        <para>
           Hardwired classifications for orders and quotations. 
Coordinate before adding.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>oe_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>smallint</type>




                      <literal>UNIQUE</literal>










              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on oe_class</title>

          <varlistentry>
            <term>oe_class_id_check</term>
            <listitem><para>CHECK ((id = ANY (ARRAY[1, 2, 3, 4])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.oe via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.oe"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.open-forms"
               xreflabel="lsmb13.open_forms">
        <title id="lsmb13.table.open-forms-title">
         Table:
         
         <structname>open_forms</structname>
        </title>
 

        <para>
           This is our primary anti-xsrf measure, as this allows us to require a full
round trip to the web server in order to save data.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>open_forms</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>session_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.session"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.orderitems"
               xreflabel="lsmb13.orderitems">
        <title id="lsmb13.table.orderitems-title">
         Table:
         
         <structname>orderitems</structname>
        </title>
 

        <para>
           Line items for sales/purchase orders and quotations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>orderitems</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>precision</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>project_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reqdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ship</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on orderitems</title>

          <varlistentry>
            <term>orderitems_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>orderitems_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.view.overpayments"
               xreflabel="lsmb13.overpayments">
        <title id="lsmb13.view.overpayments-title">
         View:
         
         <structname>overpayments</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>overpayments</structname>
            </title>


            <varlistentry>
              <term><structfield>payment_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>available</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>legal_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>meta_number</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view overpayments</title>
         <programlisting>
SELECT p.id AS payment_id
, p.reference AS payment_reference
, p.payment_class
, p.closed AS payment_closed
, p.payment_date
, ac.chart_id
, c.accno
, c.description AS chart_description
, abs
(sum
     (ac.amount)
) AS available
, cmp.legal_name
, eca.id AS entity_credit_id
, eca.entity_id
, eca.discount
, eca.meta_number 
FROM (
     (
           (
                 (
                       (lsmb13.payment p 
                          JOIN lsmb13.payment_links pl 
                            ON (
                                   (pl.payment_id = p.id)
                             )
                       )
                    JOIN lsmb13.acc_trans ac 
                      ON (
                             (ac.entry_id = pl.entry_id)
                       )
                 )
              JOIN lsmb13.chart c 
                ON (
                       (c.id = ac.chart_id)
                 )
           )
        JOIN lsmb13.entity_credit_account eca 
          ON (
                 (eca.id = p.entity_credit_id)
           )
     )
  JOIN lsmb13.company cmp 
    ON (
           (cmp.entity_id = eca.entity_id)
     )
)
WHERE (
     (
           (p.gl_id IS NOT NULL)
         AND (
                 (pl.type = 2)
                OR (pl.type = 0)
           )
     )
   AND (c.link ~~ &apos;%overpayment%&apos;::text)
)
GROUP BY p.id
, c.accno
, p.reference
, p.payment_class
, p.closed
, p.payment_date
, ac.chart_id
, c.description
, cmp.legal_name
, eca.id
, eca.entity_id
, eca.discount
, eca.meta_number;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.parts"
               xreflabel="lsmb13.parts">
        <title id="lsmb13.table.parts-title">
         Table:
         
         <structname>parts</structname>
        </title>
 

        <para>
          This stores detail information about goods and services.  The type of part
is currently defined according to the following rules:
* If assembly is true, then an assembly
* If inventory_accno_id, income_accno_id, and expense_accno_id are not null then
  a part.
* If inventory_accno_id is null but the other two are not, then a service.
* Otherwise, a labor/overhead entry.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>parts</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>listprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>lastcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>priceupdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>weight</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>onhand</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>makemodel</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>assembly</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>alternate</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rop</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                Re-order point.  Used to select parts for short inventory report.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>inventory_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>income_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>expense_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bin</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Text identifier for where a part is stored.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bom</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                Show on Bill of Materials.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>image</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Hyperlink to product image.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>drawing</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>microfiche</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partsgroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>project_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>avgcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on parts</title>

          <varlistentry>
            <term>parts_description_key</term>
            <listitem><para>lower(description)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>parts_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>parts_partnumber_key</term>
            <listitem><para>lower(partnumber)</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.assembly via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.assembly"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-part"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.parts-translation"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.partstax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.parts-translation"
               xreflabel="lsmb13.parts_translation">
        <title id="lsmb13.table.parts-translation-title">
         Table:
         
         <structname>parts_translation</structname>
        </title>
 

        <para>
           Translation information for parts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>parts_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.partscustomer"
               xreflabel="lsmb13.partscustomer">
        <title id="lsmb13.table.partscustomer-title">
         Table:
         
         <structname>partscustomer</structname>
        </title>
 

        <para>
           Tracks per-customer pricing.  Discounts can be offered for periods of time
and for pricegroups as well as per customer
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partscustomer</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.pricegroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricebreak</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validfrom</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validto</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.partsgroup"
               xreflabel="lsmb13.partsgroup">
        <title id="lsmb13.table.partsgroup-title">
         Table:
         
         <structname>partsgroup</structname>
        </title>
 

        <para>
           Groups of parts for Point of Sale screen.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsgroup</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partsgroup</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partsgroup</title>

          <varlistentry>
            <term>partsgroup_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.partsgroup_translation via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.partsgroup-translation"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.partsgroup-translation"
               xreflabel="lsmb13.partsgroup_translation">
        <title id="lsmb13.table.partsgroup-translation-title">
         Table:
         
         <structname>partsgroup_translation</structname>
        </title>
 

        <para>
           Translation information for partsgroups.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsgroup_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.partsgroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.partstax"
               xreflabel="lsmb13.partstax">
        <title id="lsmb13.table.partstax-title">
         Table:
         
         <structname>partstax</structname>
        </title>
 

        <para>
           Mapping of parts to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partstax</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.parts"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxcategory_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.taxcategory"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partstax</title>

          <varlistentry>
            <term>partstax_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.partsvendor"
               xreflabel="lsmb13.partsvendor">
        <title id="lsmb13.table.partsvendor-title">
         Table:
         
         <structname>partsvendor</structname>
        </title>
 

        <para>
           Tracks vendor&apos;s pricing, as well as vendor&apos;s part number, lead time 
required and currency.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsvendor</structname>
            </title>


            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>leadtime</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>lastcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partsvendor</title>

          <varlistentry>
            <term>partsvendor_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.payment"
               xreflabel="lsmb13.payment">
        <title id="lsmb13.table.payment-title">
         Table:
         
         <structname>payment</structname>
        </title>
 

        <para>
           This table will store the main data on a payment, prepayment, overpayment, et
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 This field will store the code for both receipts and payment order  
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gl_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.gl"/>


              </para>

              <para>
                 A payment should always be linked to a GL movement 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>closed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 This will store the current state of a payment/receipt order 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>currency</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on payment</title>

          <varlistentry>
            <term>payment_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.payment_links via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.payment-links"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.payment-links"
               xreflabel="lsmb13.payment_links">
        <title id="lsmb13.table.payment-links-title">
         Table:
         
         <structname>payment_links</structname>
        </title>
 

        <para>
            
 An explanation to the type field.
 * A type 0 means the link is referencing an ar/ap  and was created
   using an overpayment movement after the receipt was created 
 * A type 1 means the link is referencing an ar/ap and  was made 
   on the payment creation, its not the product of an overpayment movement 
 * A type 2 means the link is not referencing an ar/ap and its the product
   of the overpayment logic 

 With this ideas in order we can do the following

 To get the payment amount we will sum the entries with type &gt; 0.
 To get the linked amount we will sum the entries with type &lt; 2.
 The overpayment account can be obtained from the entries with type = 2.

 This reasoning is hacky and i hope it can dissapear when we get to 1.4 - D.M.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_links</structname>
            </title>


            <varlistentry>
              <term><structfield>payment_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.payment"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.acc-trans"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.payment-type"
               xreflabel="lsmb13.payment_type">
        <title id="lsmb13.table.payment-type-title">
         Table:
         
         <structname>payment_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.payments-queue"
               xreflabel="lsmb13.payments_queue">
        <title id="lsmb13.table.payments-queue-title">
         Table:
         
         <structname>payments_queue</structname>
        </title>
 

        <para>
           This is a holding table and hence not a candidate for normalization.
Jobs should be deleted from this table when they complete successfully.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payments_queue</structname>
            </title>


            <varlistentry>
              <term><structfield>transactions</structfield></term>
              <listitem><para>
                <type>numeric[]</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>total</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ar_ap_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cash_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>job_id</structfield></term>
              <listitem><para>
                <type>integer</type>









                <literal>DEFAULT currval(&apos;pending_job_id_seq&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.pending-job"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on payments_queue</title>

          <varlistentry>
            <term>payments_queue_job_id</term>
            <listitem><para>job_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.pending-job"
               xreflabel="lsmb13.pending_job">
        <title id="lsmb13.table.pending-job-title">
         Table:
         
         <structname>pending_job</structname>
        </title>
 

        <para>
           Purpose:  This table stores pending/queued jobs to be processed async.
Additionally, this functions as a log of all such processing for purposes of 
internal audits, performance tuning, and the like. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>pending_job</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.batch-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>text</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT &quot;session_user&quot;()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.batch"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>completed_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>success</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>error_condition</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on pending_job</title>

          <varlistentry>
            <term>pending_job_check</term>
            <listitem><para>CHECK (((completed_at IS NULL) OR (success IS NOT NULL)))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>pending_job_check1</term>
            <listitem><para>CHECK (((success IS NOT FALSE) OR (error_condition IS NOT NULL)))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on pending_job</title>

          <varlistentry>
            <term>pending_job_batch_id_pending</term>
            <listitem><para>batch_id) WHERE (success IS NULL</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>pending_job_entered_by</term>
            <listitem><para>entered_by</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.payments_queue via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.payments-queue"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.view.periods"
               xreflabel="lsmb13.periods">
        <title id="lsmb13.view.periods-title">
         View:
         
         <structname>periods</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>periods</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_to</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_from</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view periods</title>
         <programlisting>
SELECT&apos;ytd&apos;::text AS id
,&apos;Year to Date&apos;::text AS label
, (now
     ()
)::date AS date_to
, (
     (
           (date_part
                 (&apos;year&apos;::text
                       , now
                       ()
                 )
           )::text || &apos;-01-01&apos;::text
     )
)::date AS date_from 
UNIONSELECT&apos;last_year&apos;::text AS id
,&apos;Last Year&apos;::text AS label
, (
     (
           (
                 (date_part
                       (&apos;YEAR&apos;::text
                             , now
                             ()
                       ) - 
                       (1)::double precision
                 )
           )::text || &apos;-12-31&apos;::text
     )
)::date AS date_to
, (
     (
           (
                 (date_part
                       (&apos;YEAR&apos;::text
                             , now
                             ()
                       ) - 
                       (1)::double precision
                 )
           )::text || &apos;-01-01&apos;::text
     )
)::date AS date_from;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.person"
               xreflabel="lsmb13.person">
        <title id="lsmb13.table.person-title">
         Table:
         
         <structname>person</structname>
        </title>
 

        <para>
           Every person, must have an entity to derive a common or display name. The correct way to get class information on a person would be person.entity_id-&gt;entity_class_to_entity.entity_id. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salutation_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.salutation"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>first_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>middle_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on person</title>

          <varlistentry>
            <term>person_first_name_check</term>
            <listitem><para>CHECK ((first_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>person_last_name_check</term>
            <listitem><para>CHECK ((last_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.audittrail via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.audittrail"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.gl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.jcitems"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-company"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.person-to-location"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.person-to-company"
               xreflabel="lsmb13.person_to_company">
        <title id="lsmb13.table.person-to-company-title">
         Table:
         
         <structname>person_to_company</structname>
        </title>
 

        <para>
           currently unused in the front-end, but can be used to map persons
to companies.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person_to_company</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>company_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.company"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.person-to-contact"
               xreflabel="lsmb13.person_to_contact">
        <title id="lsmb13.table.person-to-contact-title">
         Table:
         
         <structname>person_to_contact</structname>
        </title>
 

        <para>
           This table stores contact information for companies
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on person_to_contact</title>

          <varlistentry>
            <term>person_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.person-to-entity"
               xreflabel="lsmb13.person_to_entity">
        <title id="lsmb13.table.person-to-entity-title">
         Table:
         
         <structname>person_to_entity</structname>
        </title>
 

        <para>
           This provides a map so that entities can also be used like groups.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person_to_entity</structname>
            </title>


            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>related_how</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on person_to_entity</title>

          <varlistentry>
            <term>person_to_entity_check</term>
            <listitem><para>CHECK ((entity_id &lt;&gt; person_id))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.person-to-location"
               xreflabel="lsmb13.person_to_location">
        <title id="lsmb13.table.person-to-location-title">
         Table:
         
         <structname>person_to_location</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>person_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.location-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.person"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.pricegroup"
               xreflabel="lsmb13.pricegroup">
        <title id="lsmb13.table.pricegroup-title">
         Table:
         
         <structname>pricegroup</structname>
        </title>
 

        <para>
           Pricegroups are groups of customers who are assigned prices and discounts
together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>pricegroup</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on pricegroup</title>

          <varlistentry>
            <term>pricegroup_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>pricegroup_pricegroup_key</term>
            <listitem><para>pricegroup</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.partscustomer"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.project"
               xreflabel="lsmb13.project">
        <title id="lsmb13.table.project-title">
         Table:
         
         <structname>project</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>project</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>projectnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                 Job costing/manufacturing here not implemented.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>production</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>completed</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on project</title>

          <varlistentry>
            <term>project_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.budget_to_project via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.budget-to-project"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.project-translation"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.project-translation"
               xreflabel="lsmb13.project_translation">
        <title id="lsmb13.table.project-translation-title">
         Table:
         
         <structname>project_translation</structname>
        </title>
 

        <para>
           Translation information for projects.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>project_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.project"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.view.recon-payee"
               xreflabel="lsmb13.recon_payee">
        <title id="lsmb13.view.recon-payee-title">
         View:
         
         <structname>recon_payee</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>recon_payee</structname>
            </title>


            <varlistentry>
              <term><structfield>payee</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>scn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>our_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>errorcode</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>user</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>clear_time</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>insert_time</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ledger_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>overlook</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view recon_payee</title>
         <programlisting>
SELECT n.name AS payee
, rr.id
, rr.report_id
, rr.scn
, rr.their_balance
, rr.our_balance
, rr.errorcode
, rr.&quot;user&quot;
, rr.clear_time
, rr.insert_time
, rr.trans_type
, rr.post_date
, rr.ledger_id
, ac.voucher_id
, rr.overlook
, rr.cleared 
FROM (
     (
           (lsmb13.cr_report_line rr 
         LEFT JOIN lsmb13.acc_trans ac 
                ON (
                       (rr.ledger_id = ac.entry_id)
                 )
           )
   LEFT JOIN lsmb13.gl 
          ON (
                 (ac.trans_id = gl.id)
           )
     )
LEFT JOIN (
           (
            SELECT ap.id
                 , e.name 
              FROM (
                       (lsmb13.ap 
                          JOIN lsmb13.entity_credit_account eca 
                            ON (
                                   (ap.entity_credit_account = eca.id)
                             )
                       )
                    JOIN lsmb13.entity e 
                      ON (
                             (eca.entity_id = e.id)
                       )
                 )
             UNIONSELECT ar.id
                 , e.name 
              FROM (
                       (lsmb13.ar 
                          JOIN lsmb13.entity_credit_account eca 
                            ON (
                                   (ar.entity_credit_account = eca.id)
                             )
                       )
                    JOIN lsmb13.entity e 
                      ON (
                             (eca.entity_id = e.id)
                       )
                 )
           )
       UNIONSELECT gl.id
           , gl.description 
        FROM lsmb13.gl
     ) n 
    ON (
           (n.id = ac.trans_id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.recurring"
               xreflabel="lsmb13.recurring">
        <title id="lsmb13.table.recurring-title">
         Table:
         
         <structname>recurring</structname>
        </title>
 

        <para>
           Stores recurring information on transactions which will recur in the future.
Note that this means that only fully posted transactions can recur. 
I would highly recommend depricating this table and working instead on extending
the template transaction addon to handle recurring information.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurring</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>nextdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>repeat</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>howmany</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.recurringemail"
               xreflabel="lsmb13.recurringemail">
        <title id="lsmb13.table.recurringemail-title">
         Table:
         
         <structname>recurringemail</structname>
        </title>
 

        <para>
          Email  to be sent out when recurring transaction is posted.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurringemail</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>format</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>message</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.recurringprint"
               xreflabel="lsmb13.recurringprint">
        <title id="lsmb13.table.recurringprint-title">
         Table:
         
         <structname>recurringprint</structname>
        </title>
 

        <para>
           Template, printer etc. to print to when recurring transaction posts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurringprint</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>format</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printer</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.view.role-view"
               xreflabel="lsmb13.role_view">
        <title id="lsmb13.view.role-view-title">
         View:
         
         <structname>role_view</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>role_view</structname>
            </title>


            <varlistentry>
              <term><structfield>roleid</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>member</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>grantor</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>admin_option</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolname</structfield></term>
              <listitem><para>
                <type>name</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolsuper</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolinherit</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcreaterole</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcreatedb</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcatupdate</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcanlogin</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolconnlimit</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolpassword</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolvaliduntil</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolconfig</structfield></term>
              <listitem><para>
                <type>text[]</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oid</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view role_view</title>
         <programlisting>
SELECT m.roleid
, m.member
, m.grantor
, m.admin_option
, a.rolname
, a.rolsuper
, a.rolinherit
, a.rolcreaterole
, a.rolcreatedb
, a.rolcatupdate
, a.rolcanlogin
, a.rolconnlimit
, a.rolpassword
, a.rolvaliduntil
, a.rolconfig
, a.oid 
FROM (pg_auth_members m 
  JOIN pg_roles a 
    ON (
           (m.roleid = a.oid)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.salutation"
               xreflabel="lsmb13.salutation">
        <title id="lsmb13.table.salutation-title">
         Table:
         
         <structname>salutation</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>salutation</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salutation</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.person via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.person"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.session"
               xreflabel="lsmb13.session">
        <title id="lsmb13.table.session-title">
         Table:
         
         <structname>session</structname>
        </title>
 

        <para>
           This table is used to track sessions on a database level across page 
requests.  Because of the way LedgerSMB authentication works currently we do 
not time out authentication when the session times out.  We do time out 
highly pessimistic locks used for large batch payment workflows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>session</structname>
            </title>


            <varlistentry>
              <term><structfield>session_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>token</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_used</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ttl</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 3600</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>users_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notify_pasword</structfield></term>
              <listitem><para>
                <type>interval</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;7 days&apos;::interval</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on session</title>

          <varlistentry>
            <term>session_token_check</term>
            <listitem><para>CHECK ((length((token)::text) = 32))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.batch via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.open-forms"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.transactions"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.sic"
               xreflabel="lsmb13.sic">
        <title id="lsmb13.table.sic-title">
         Table:
         
         <structname>sic</structname>
        </title>
 

        <para>
          
This can be used SIC codes or any equivalent, such as ISIC, NAICS, etc.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>sic</structname>
            </title>


            <varlistentry>
              <term><structfield>code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sictype</structfield></term>
              <listitem><para>
                <type>character(1)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.status"
               xreflabel="lsmb13.status">
        <title id="lsmb13.table.status-title">
         Table:
         
         <structname>status</structname>
        </title>
 

        <para>
           Whether AR/AP transactions and invoices have been emailed and/or printed 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>status</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>emailed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>spoolfile</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on status</title>

          <varlistentry>
            <term>status_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.tax"
               xreflabel="lsmb13.tax">
        <title id="lsmb13.table.tax-title">
         Table:
         
         <structname>tax</structname>
        </title>
 

        <para>
          Information on tax rates.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tax</structname>
            </title>


            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validto</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT &apos;infinity&apos;::timestamp without time zone</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pass</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                This is an integer indicating the pass of the tax. This is to support 
cumultative sales tax rules (for example, Quebec charging taxes on the federal
taxes collected).
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT 1</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.taxmodule"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>minvalue</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>maxvalue</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.tax-extended"
               xreflabel="lsmb13.tax_extended">
        <title id="lsmb13.table.tax-extended-title">
         Table:
         
         <structname>tax_extended</structname>
        </title>
 

        <para>
           This stores extended information for manual tax calculations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tax_extended</structname>
            </title>


            <varlistentry>
              <term><structfield>tax_basis</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.acc-trans"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.taxcategory"
               xreflabel="lsmb13.taxcategory">
        <title id="lsmb13.table.taxcategory-title">
         Table:
         
         <structname>taxcategory</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>taxcategory</structname>
            </title>


            <varlistentry>
              <term><structfield>taxcategory_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxcategoryname</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.taxmodule"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.partstax via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.partstax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.taxmodule"
               xreflabel="lsmb13.taxmodule">
        <title id="lsmb13.table.taxmodule-title">
         Table:
         
         <structname>taxmodule</structname>
        </title>
 

        <para>
          This is used to store information on tax modules.  the module name is used
to determine the Perl class for the taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>taxmodule</structname>
            </title>


            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodulename</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.tax via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.taxcategory"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.transactions"
               xreflabel="lsmb13.transactions">
        <title id="lsmb13.table.transactions-title">
         Table:
         
         <structname>transactions</structname>
        </title>
 

        <para>
           This table provides referential integrity between AR, AP, GL tables on one
hand and acc_trans on the other, pending the refactoring of those tables.  It
also is used to provide discretionary locking of financial transactions across 
database connections, for example in batch payment workflows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>transactions</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.session"/>


              </para>

              <para>
                 This should only be used in pessimistic locking measures as required by large
batch work flows. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on transactions</title>

          <varlistentry>
            <term>transactions_locked_by_i</term>
            <listitem><para>locked_by</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb13.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-order-to-tx"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.file-transaction"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.gl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.new-shipto"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.translation"
               xreflabel="lsmb13.translation">
        <title id="lsmb13.table.translation-title">
         Table:
         
         <structname>translation</structname>
        </title>
 

        <para>
          abstract table for manual translation data. Should have zero rows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on translation</title>

          <varlistentry>
            <term>translation_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb13.table.trial-balance"
               xreflabel="lsmb13.trial_balance">
        <title id="lsmb13.table.trial-balance-title">
         Table:
         
         <structname>trial_balance</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_from</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_to</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>yearend</structfield></term>
              <listitem><para>
                <type>text</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.trial-balance-yearend-types"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.trial_balance__account_to_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.trial-balance-account-to-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.trial-balance-heading-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.trial-balance-account-to-report"
               xreflabel="lsmb13.trial_balance__account_to_report">
        <title id="lsmb13.table.trial-balance-account-to-report-title">
         Table:
         
         <structname>trial_balance__account_to_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__account_to_report</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.trial-balance"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.trial-balance-heading-to-report"
               xreflabel="lsmb13.trial_balance__heading_to_report">
        <title id="lsmb13.table.trial-balance-heading-to-report-title">
         Table:
         
         <structname>trial_balance__heading_to_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__heading_to_report</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.trial-balance"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>heading_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.trial-balance-yearend-types"
               xreflabel="lsmb13.trial_balance__yearend_types">
        <title id="lsmb13.table.trial-balance-yearend-types-title">
         Table:
         
         <structname>trial_balance__yearend_types</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__yearend_types</structname>
            </title>


            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.trial_balance via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.trial-balance"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.view.user-listable"
               xreflabel="lsmb13.user_listable">
        <title id="lsmb13.view.user-listable-title">
         View:
         
         <structname>user_listable</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>user_listable</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>username</structfield></term>
              <listitem><para>
                <type>character varying(30)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view user_listable</title>
         <programlisting>
SELECT u.id
, u.username
, e.created 
FROM (lsmb13.entity e 
  JOIN lsmb13.users u 
    ON (
           (u.entity_id = e.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb13.table.user-preference"
               xreflabel="lsmb13.user_preference">
        <title id="lsmb13.table.user-preference-title">
         Table:
         
         <structname>user_preference</structname>
        </title>
 

        <para>
           This table sets the basic preferences for formats, languages, printers, and user-selected stylesheets.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>user_preference</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.users"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>stylesheet</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;ledgersmb.css&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printer</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dateformat</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;yyyy-mm-dd&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>numberformat</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;1000.00&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.users"
               xreflabel="lsmb13.users">
        <title id="lsmb13.table.users-title">
         Table:
         
         <structname>users</structname>
        </title>
 

        <para>
          username is the actual primary key here because we 
do not want duplicate users
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>users</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>username</structfield></term>
              <listitem><para>
                <type>character varying(30)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notify_password</structfield></term>
              <listitem><para>
                <type>interval</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;7 days&apos;::interval</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.lsmb_roles via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.lsmb-roles"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.pending-job"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.session"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.user-preference"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.vendortax"
               xreflabel="lsmb13.vendortax">
        <title id="lsmb13.table.vendortax-title">
         Table:
         
         <structname>vendortax</structname>
        </title>
 

        <para>
           Mapping vendor to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>vendortax</structname>
            </title>


            <varlistentry>
              <term><structfield>vendor_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb13.table.voucher"
               xreflabel="lsmb13.voucher">
        <title id="lsmb13.table.voucher-title">
         Table:
         
         <structname>voucher</structname>
        </title>
 

        <para>
          Mapping transactions to batches for batch approval.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>voucher</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.batch"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 This is simply a surrogate key for easy reference.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.batch-class"/>


              </para>

              <para>
                 This is the authoritative class of the 
voucher. 
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.cr-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.warehouse"
               xreflabel="lsmb13.warehouse">
        <title id="lsmb13.table.warehouse-title">
         Table:
         
         <structname>warehouse</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>warehouse</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb13.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb13.table.asset-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb13.table.yearend"
               xreflabel="lsmb13.yearend">
        <title id="lsmb13.table.yearend-title">
         Table:
         
         <structname>yearend</structname>
        </title>
 

        <para>
           An extension to the gl table to track transactionsactions which close out 
the books at yearend.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>yearend</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb13.table.gl"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reversed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>



<!-- Function _entity_location_save(in_country_code integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer) -->
    <section id="lsmb13.function.-entity-location-save-in-country-code-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer"
             xreflabel="lsmb13_entity_location_save(in_country_code integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)">
      <title id="lsmb13.function.-entity-location-save-in-country-code-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer-title">
       _entity_location_save(in_country_code integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.-entity-location-save-in-country-code-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer-titleabbrev">
       _entity_location_save(in_country_code integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Private method for storing locations to an entity.  Do not call directly.
Returns the location id that was inserted or updated.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
	t_company_id int;
    BEGIN
	SELECT id INTO t_company_id
	FROM company WHERE entity_id = in_entity_id;

	DELETE FROM company_to_location
	WHERE company_id = t_company_id
		AND location_class = in_location_class
		AND location_id = in_location_id;

	SELECT location_save(NULL, in_line_one, in_line_two, in_line_three, in_city,
		in_state, in_mail_code, in_country_code) 
	INTO l_id;

	INSERT INTO company_to_location 
		(company_id, location_class, location_id)
	VALUES  (t_company_id, in_location_class, l_id);

	RETURN l_id;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function _get_parser_from_curcfg() -->
    <section id="lsmb13.function.-get-parser-from-curcfg"
             xreflabel="lsmb13_get_parser_from_curcfg()">
      <title id="lsmb13.function.-get-parser-from-curcfg-title">
       _get_parser_from_curcfg()
      </title>
      <titleabbrev id="lsmb13.function.-get-parser-from-curcfg-titleabbrev">
       _get_parser_from_curcfg()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>select prsname::text from pg_catalog.pg_ts_parser p join pg_ts_config c on cfgparser = p.oid where c.oid = show_curcfg();</programlisting>
      </para>
    </section>

<!-- Function account__delete(in_id integer) -->
    <section id="lsmb13.function.account-delete-in-id-integer"
             xreflabel="lsmb13account__delete(in_id integer)">
      <title id="lsmb13.function.account-delete-in-id-integer-title">
       account__delete(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.account-delete-in-id-integer-titleabbrev">
       account__delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes an account with the id specified.  If the account has 
transactions associated with it, it will fail and raise a foreign key constraint.

        <programlisting>
BEGIN
DELETE FROM account_link WHERE account_id = in_id;
DELETE FROM account WHERE id = in_id;
RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__get_by_link_desc(in_description text) -->
    <section id="lsmb13.function.account-get-by-link-desc-in-description-text"
             xreflabel="lsmb13account__get_by_link_desc(in_description text)">
      <title id="lsmb13.function.account-get-by-link-desc-in-description-text-title">
       account__get_by_link_desc(in_description text)
      </title>
      <titleabbrev id="lsmb13.function.account-get-by-link-desc-in-description-text-titleabbrev">
       account__get_by_link_desc(in_description text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets a list of accounts with a specific link description set.  For example,
for a dropdown list.
        <programlisting>
SELECT * FROM account
WHERE id IN (SELECT account_id FROM account_link WHERE description = $1);
</programlisting>
      </para>
    </section>

<!-- Function account__get_from_accno(in_accno text) -->
    <section id="lsmb13.function.account-get-from-accno-in-accno-text"
             xreflabel="lsmb13account__get_from_accno(in_accno text)">
      <title id="lsmb13.function.account-get-from-accno-in-accno-text-title">
       account__get_from_accno(in_accno text)
      </title>
      <titleabbrev id="lsmb13.function.account-get-from-accno-in-accno-text-titleabbrev">
       account__get_from_accno(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the account where the accno field matches (excatly) the 
in_accno provided.
        <programlisting>
     select * from account where accno = $1;
</programlisting>
      </para>
    </section>

<!-- Function account__get_taxes() -->
    <section id="lsmb13.function.account-get-taxes"
             xreflabel="lsmb13account__get_taxes()">
      <title id="lsmb13.function.account-get-taxes-title">
       account__get_taxes()
      </title>
      <titleabbrev id="lsmb13.function.account-get-taxes-titleabbrev">
       account__get_taxes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns set of accounts where the tax attribute is true.
        <programlisting>
SELECT * FROM account 
 WHERE tax is true
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function account__is_recon(in_accno text) -->
    <section id="lsmb13.function.account-is-recon-in-accno-text"
             xreflabel="lsmb13account__is_recon(in_accno text)">
      <title id="lsmb13.function.account-is-recon-in-accno-text-title">
       account__is_recon(in_accno text)
      </title>
      <titleabbrev id="lsmb13.function.account-is-recon-in-accno-text-titleabbrev">
       account__is_recon(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if account is set up for reconciliation, false otherwise.
Note that returns false on invalid account number too
        <programlisting> SELECT count(*) &gt; 0 
     FROM cr_coa_to_account c2a
     JOIN account ON account.id = c2a.chart_id 
    WHERE accno = $1; </programlisting>
      </para>
    </section>

<!-- Function account__list_by_heading() -->
    <section id="lsmb13.function.account-list-by-heading"
             xreflabel="lsmb13account__list_by_heading()">
      <title id="lsmb13.function.account-list-by-heading-title">
       account__list_by_heading()
      </title>
      <titleabbrev id="lsmb13.function.account-list-by-heading-titleabbrev">
       account__list_by_heading()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM account ORDER BY heading;
</programlisting>
      </para>
    </section>

<!-- Function account__obtain_balance(in_account_id date, in_transdate integer) -->
    <section id="lsmb13.function.account-obtain-balance-in-account-id-date-in-transdate-integer"
             xreflabel="lsmb13account__obtain_balance(in_account_id date, in_transdate integer)">
      <title id="lsmb13.function.account-obtain-balance-in-account-id-date-in-transdate-integer-title">
       account__obtain_balance(in_account_id date, in_transdate integer)
      </title>
      <titleabbrev id="lsmb13.function.account-obtain-balance-in-account-id-date-in-transdate-integer-titleabbrev">
       account__obtain_balance(in_account_id date, in_transdate integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the account balance at a given point in time, calculating forward 
from most recent check point.
        <programlisting>
DECLARE balance numeric;
BEGIN
	SELECT coalesce(sum(ac.amount) + cp.amount, sum(ac.amount))
	INTO balance
	FROM acc_trans ac
	JOIN (select id, approved from ar union
		select id, approved from ap union
		select id, approved from gl) a ON (a.id = ac.trans_id)
	LEFT JOIN (select account_id, end_date, amount from account_checkpoint
		WHERE account_id = in_account_id AND end_date &lt; in_transdate
		ORDER BY end_date desc limit 1
	) cp ON (cp.account_id = ac.chart_id)
	WHERE ac.chart_id = in_account_id 
		AND ac.transdate &gt; coalesce(cp.end_date, ac.transdate - &#39;1 day&#39;::interval)
		and ac.approved and a.approved
		and ac.transdate &lt;= in_transdate
	GROUP BY cp.amount, ac.chart_id;

	RETURN balance;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean) -->
    <section id="lsmb13.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean"
             xreflabel="lsmb13account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)">
      <title id="lsmb13.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean-title">
       account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean-titleabbrev">
       account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes existing account_link entries, where the 
account_link.description is not designated as a custom one in the 
account_link_description table.

If no account heading is provided, the account heading which has an accno field
closest to but prior (by collation order) is used.

Then it saves the account information, and rebuilds the account_link records 
based on the in_link array.

        <programlisting>
DECLARE 
	t_heading_id int;
	t_link record;
	t_id int;
        t_tax bool;
BEGIN

    SELECT count(*) &gt; 0 INTO t_tax FROM tax WHERE in_id = chart_id;
    t_tax := t_tax OR in_tax;
	-- check to ensure summary accounts are exclusive
        -- necessary for proper handling by legacy code
    FOR t_link IN SELECT description FROM account_link_description 
    WHERE summary=&#39;t&#39;
	LOOP
		IF t_link.description = ANY (in_link) and array_upper(in_link, 1) &gt; 1 THEN
			RAISE EXCEPTION &#39;Invalid link settings:  Summary&#39;;
		END IF;
	END LOOP;
	-- heading settings
	IF in_heading IS NULL THEN
		SELECT id INTO t_heading_id FROM account_heading 
		WHERE accno &lt; in_accno order by accno desc limit 1;
	ELSE
		t_heading_id := in_heading;
	END IF;

    -- don&#39;t remove custom links.
	DELETE FROM account_link 
	WHERE account_id = in_id 
              and description in ( select description 
                                    from  account_link_description
                                    where custom = &#39;f&#39;);

	UPDATE account 
	SET accno = in_accno,
		description = in_description,
		category = in_category,
		gifi_accno = in_gifi_accno,
		heading = t_heading_id,
		contra = in_contra,
                obsolete = in_obsolete,
                tax = t_tax,
                is_temp = in_is_temp
	WHERE id = in_id;

	IF FOUND THEN
		t_id := in_id;
	ELSE
                -- can&#39;t obsolete on insert, but this can be changed if users
                -- request it --CT
		INSERT INTO account (accno, description, category, gifi_accno,
			heading, contra, tax, is_temp)
		VALUES (in_accno, in_description, in_category, in_gifi_accno,
			t_heading_id, in_contra, in_tax, in_is_temp);

		t_id := currval(&#39;account_id_seq&#39;);
	END IF;

	FOR t_link IN 
		select in_link[generate_series] AS val
		FROM generate_series(array_lower(in_link, 1), 
			array_upper(in_link, 1))
	LOOP
		INSERT INTO account_link (account_id, description)
		VALUES (t_id, t_link.val);
	END LOOP;

	
	RETURN t_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date) -->
    <section id="lsmb13.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date"
             xreflabel="lsmb13account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)">
      <title id="lsmb13.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date-title">
       account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)
      </title>
      <titleabbrev id="lsmb13.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date-titleabbrev">
       account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This saves tax rates.
        <programlisting>
BEGIN
	UPDATE tax SET validto = in_validto,
               rate = in_rate,
               minvalue = in_minvalue,
               maxvalue = in_maxvalue,
               taxnumber = in_taxnumber,
               pass = in_pass,
               taxmodule_id = in_taxmodule_id
         WHERE chart_id = in_chart_id and validto = in_old_validto;

         IF FOUND THEN
             return true;
         END IF;

         INSERT INTO tax(chart_id, validto, rate, minvalue, maxvalue, taxnumber,
                        pass, taxmodule_id)
         VALUES (in_chart_id, in_validto, in_rate, in_minvalue, in_maxvalue, 
                in_taxnumber, in_pass, in_taxmodule_id);

         RETURN TRUE;

END;
</programlisting>
      </para>
    </section>

<!-- Function account_get(in_id integer) -->
    <section id="lsmb13.function.account-get-in-id-integer"
             xreflabel="lsmb13account_get(in_id integer)">
      <title id="lsmb13.function.account-get-in-id-integer-title">
       account_get(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.account-get-in-id-integer-titleabbrev">
       account_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns an entry from the chart view which matches the id requested, and which
is an account, not a heading.
        <programlisting>
SELECT * from chart where id = $1 and charttype = &#39;A&#39;;
</programlisting>
      </para>
    </section>

<!-- Function account_has_transactions(in_id integer) -->
    <section id="lsmb13.function.account-has-transactions-in-id-integer"
             xreflabel="lsmb13account_has_transactions(in_id integer)">
      <title id="lsmb13.function.account-has-transactions-in-id-integer-title">
       account_has_transactions(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.account-has-transactions-in-id-integer-titleabbrev">
       account_has_transactions(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Checks to see if any transactions use this account.  If so, returns true.
If not, returns false.
        <programlisting>
BEGIN
	PERFORM trans_id FROM acc_trans WHERE chart_id = in_id LIMIT 1;
	IF FOUND THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function account_heading__list() -->
    <section id="lsmb13.function.account-heading-list"
             xreflabel="lsmb13account_heading__list()">
      <title id="lsmb13.function.account-heading-list-title">
       account_heading__list()
      </title>
      <titleabbrev id="lsmb13.function.account-heading-list-titleabbrev">
       account_heading__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_heading</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all account headings, currently ordered by account number.

        <programlisting> SELECT * FROM account_heading order by accno; </programlisting>
      </para>
    </section>

<!-- Function account_heading_get(in_id integer) -->
    <section id="lsmb13.function.account-heading-get-in-id-integer"
             xreflabel="lsmb13account_heading_get(in_id integer)">
      <title id="lsmb13.function.account-heading-get-in-id-integer-title">
       account_heading_get(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.account-heading-get-in-id-integer-titleabbrev">
       account_heading_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>chart</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns an entry from the chart view which matches the id requested, and which
is a heading, not an account.
        <programlisting>
DECLARE
	account chart%ROWTYPE;
BEGIN
	SELECT * INTO account FROM chart WHERE id = in_id AND charttype = &#39;H&#39;;
	RETURN account;
END;
</programlisting>
      </para>
    </section>

<!-- Function account_heading_list() -->
    <section id="lsmb13.function.account-heading-list"
             xreflabel="lsmb13account_heading_list()">
      <title id="lsmb13.function.account-heading-list-title">
       account_heading_list()
      </title>
      <titleabbrev id="lsmb13.function.account-heading-list-titleabbrev">
       account_heading_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_heading</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all existing account headings.
        <programlisting>
SELECT * FROM account_heading order by accno;
</programlisting>
      </para>
    </section>

<!-- Function account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer) -->
    <section id="lsmb13.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer"
             xreflabel="lsmb13account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)">
      <title id="lsmb13.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer-title">
       account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer-titleabbrev">
       account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an account heading. 
        <programlisting>
BEGIN
	UPDATE account_heading
	SET accno = in_accno,
		description = in_description,
		parent_id = in_parent
	WHERE id = in_id;

	IF FOUND THEN
		RETURN in_id;
	END IF;
	INSERT INTO account_heading (accno, description, parent_id)
	VALUES (in_accno, in_description, in_parent);

	RETURN currval(&#39;account_heading_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function account_save(in_link integer, in_tax text, in_contra text, in_heading bpchar, in_gifi_accno text, in_category integer, in_description boolean, in_accno boolean, in_id text[]) -->
    <section id="lsmb13.function.account-save-in-link-integer-in-tax-text-in-contra-text-in-heading-bpchar-in-gifi-accno-text-in-category-integer-in-description-boolean-in-accno-boolean-in-id-textARRAY"
             xreflabel="lsmb13account_save(in_link integer, in_tax text, in_contra text, in_heading bpchar, in_gifi_accno text, in_category integer, in_description boolean, in_accno boolean, in_id text[])">
      <title id="lsmb13.function.account-save-in-link-integer-in-tax-text-in-contra-text-in-heading-bpchar-in-gifi-accno-text-in-category-integer-in-description-boolean-in-accno-boolean-in-id-textARRAY-title">
       account_save(in_link integer, in_tax text, in_contra text, in_heading bpchar, in_gifi_accno text, in_category integer, in_description boolean, in_accno boolean, in_id text[])
      </title>
      <titleabbrev id="lsmb13.function.account-save-in-link-integer-in-tax-text-in-contra-text-in-heading-bpchar-in-gifi-accno-text-in-category-integer-in-description-boolean-in-accno-boolean-in-id-textARRAY-titleabbrev">
       account_save(in_link integer, in_tax text, in_contra text, in_heading bpchar, in_gifi_accno text, in_category integer, in_description boolean, in_accno boolean, in_id text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes existing account_link entries, where the 
account_link.description is not designated as a custom one in the 
account_link_description table.

If no account heading is provided, the account heading which has an accno field
closest to but prior (by collation order) is used.

Then it saves the account information, and rebuilds the account_link records 
based on the in_link array.

        <programlisting>
DECLARE 
	t_heading_id int;
	t_link record;
	t_id int;
        t_tax bool;
BEGIN

    SELECT count(*) &gt; 0 INTO t_tax FROM tax WHERE in_id = chart_id;
    t_tax := t_tax OR in_tax;
	-- check to ensure summary accounts are exclusive
        -- necessary for proper handling by legacy code
    FOR t_link IN SELECT description FROM account_link_description 
    WHERE summary=&#39;t&#39;
	LOOP
		IF t_link.description = ANY (in_link) and array_upper(in_link, 1) &gt; 1 THEN
			RAISE EXCEPTION &#39;Invalid link settings:  Summary&#39;;
		END IF;
	END LOOP;
	-- heading settings
	IF in_heading IS NULL THEN
		SELECT id INTO t_heading_id FROM account_heading 
		WHERE accno &lt; in_accno order by accno desc limit 1;
	ELSE
		t_heading_id := in_heading;
	END IF;

    -- don&#39;t remove custom links.
	DELETE FROM account_link 
	WHERE account_id = in_id 
              and description in ( select description 
                                    from  account_link_description
                                    where custom = &#39;f&#39;);

	UPDATE account 
	SET accno = in_accno,
		description = in_description,
		category = in_category,
		gifi_accno = in_gifi_accno,
		heading = t_heading_id,
		contra = in_contra,
                tax = t_tax
	WHERE id = in_id;

	IF FOUND THEN
		t_id := in_id;
	ELSE
		INSERT INTO account (accno, description, category, gifi_accno,
			heading, contra, tax)
		VALUES (in_accno, in_description, in_category, in_gifi_accno,
			t_heading_id, in_contra, in_tax);

		t_id := currval(&#39;account_id_seq&#39;);
	END IF;

	FOR t_link IN 
		select in_link[generate_series] AS val
		FROM generate_series(array_lower(in_link, 1), 
			array_upper(in_link, 1))
	LOOP
		INSERT INTO account_link (account_id, description)
		VALUES (t_id, t_link.val);
	END LOOP;

	
	RETURN t_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function add_custom_field(character varying, character varying, character varying) -->
    <section id="lsmb13.function.add-custom-field-character-varying-character-varying-character-varying"
             xreflabel="lsmb13add_custom_field(character varying, character varying, character varying)">
      <title id="lsmb13.function.add-custom-field-character-varying-character-varying-character-varying-title">
       add_custom_field(character varying, character varying, character varying)
      </title>
      <titleabbrev id="lsmb13.function.add-custom-field-character-varying-character-varying-character-varying-titleabbrev">
       add_custom_field(character varying, character varying, character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
table_name ALIAS FOR $1;
new_field_name ALIAS FOR $2;
field_datatype ALIAS FOR $3;

BEGIN
	perform TABLE_ID FROM custom_table_catalog 
		WHERE extends = table_name;
	IF NOT FOUND THEN
		BEGIN
			INSERT INTO custom_table_catalog (extends) 
				VALUES (table_name);
			EXECUTE &#39;CREATE TABLE &#39; || 
                               quote_ident(&#39;custom_&#39; ||table_name) ||
				&#39; (row_id INT PRIMARY KEY)&#39;;
		EXCEPTION WHEN duplicate_table THEN
			-- do nothing
		END;
	END IF;
	INSERT INTO custom_field_catalog (field_name, table_id)
	values (new_field_name, (SELECT table_id 
                                        FROM custom_table_catalog
		WHERE extends = table_name));
	EXECUTE &#39;ALTER TABLE &#39;|| quote_ident(&#39;custom_&#39;||table_name) || 
                &#39; ADD COLUMN &#39; || quote_ident(new_field_name) || &#39; &#39; || 
                  quote_ident(field_datatype);
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__add_function_to_group(in_role text, in_func text) -->
    <section id="lsmb13.function.admin-add-function-to-group-in-role-text-in-func-text"
             xreflabel="lsmb13admin__add_function_to_group(in_role text, in_func text)">
      <title id="lsmb13.function.admin-add-function-to-group-in-role-text-in-func-text-title">
       admin__add_function_to_group(in_role text, in_func text)
      </title>
      <titleabbrev id="lsmb13.function.admin-add-function-to-group-in-role-text-in-func-text-titleabbrev">
       admin__add_function_to_group(in_role text, in_func text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions to a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;GRANT EXECUTE ON FUNCTION &#39;|| quote_ident(in_func) ||&#39; to &#39;|| quote_ident(in_role);
        
        EXECUTE stmt;
        
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__add_user_to_role(in_role text, in_username text) -->
    <section id="lsmb13.function.admin-add-user-to-role-in-role-text-in-username-text"
             xreflabel="lsmb13admin__add_user_to_role(in_role text, in_username text)">
      <title id="lsmb13.function.admin-add-user-to-role-in-role-text-in-username-text-title">
       admin__add_user_to_role(in_role text, in_username text)
      </title>
      <titleabbrev id="lsmb13.function.admin-add-user-to-role-in-role-text-in-username-text-titleabbrev">
       admin__add_user_to_role(in_role text, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions to a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;GRANT &#39;|| quote_ident(in_role) ||&#39; to &#39;|| quote_ident(in_username);
        
        EXECUTE stmt;
        insert into lsmb_roles (user_id, role) 
        SELECT id, in_role from users where username = in_username;
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__create_group(in_group_name text) -->
    <section id="lsmb13.function.admin-create-group-in-group-name-text"
             xreflabel="lsmb13admin__create_group(in_group_name text)">
      <title id="lsmb13.function.admin-create-group-in-group-name-text-title">
       admin__create_group(in_group_name text)
      </title>
      <titleabbrev id="lsmb13.function.admin-create-group-in-group-name-text-titleabbrev">
       admin__create_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    DECLARE
        
        stmt text;
        t_dbname text;
    BEGIN
	t_dbname := current_database();
        stmt := &#39;create role lsmb_&#39;|| quote_ident(t_dbname || &#39;__&#39; || in_group_name);
        execute stmt;
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__delete_group(in_group_name text) -->
    <section id="lsmb13.function.admin-delete-group-in-group-name-text"
             xreflabel="lsmb13admin__delete_group(in_group_name text)">
      <title id="lsmb13.function.admin-delete-group-in-group-name-text-title">
       admin__delete_group(in_group_name text)
      </title>
      <titleabbrev id="lsmb13.function.admin-delete-group-in-group-name-text-titleabbrev">
       admin__delete_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        
    Deletes the input group from the database. Not designed to be used to 
    remove a login-capable user.

        <programlisting>
    
    DECLARE
        stmt text;
        a_role role_view;
        t_dbname text;
    BEGIN
        t_dbname := current_database();
        

        select * into a_role from role_view where rolname = in_group_name;
        
        if not found then
            return &#39;f&#39;::bool;
        else
            stmt := &#39;drop role lsmb_&#39; || quote_ident(t_dbname || &#39;__&#39; || in_group_name);
            execute stmt;
            return &#39;t&#39;::bool;
        end if;
    END;
</programlisting>
      </para>
    </section>

<!-- Function admin__delete_user(in_drop_role text, in_username boolean) -->
    <section id="lsmb13.function.admin-delete-user-in-drop-role-text-in-username-boolean"
             xreflabel="lsmb13admin__delete_user(in_drop_role text, in_username boolean)">
      <title id="lsmb13.function.admin-delete-user-in-drop-role-text-in-username-boolean-title">
       admin__delete_user(in_drop_role text, in_username boolean)
      </title>
      <titleabbrev id="lsmb13.function.admin-delete-user-in-drop-role-text-in-username-boolean-titleabbrev">
       admin__delete_user(in_drop_role text, in_username boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        
    Drops the provided user, as well as deletes the user configuration data.
It leaves the entity and person references.

If in_drop_role is set, it drops the role too.

        <programlisting>
    
    DECLARE
        stmt text;
        a_user users;
    BEGIN
    
        select * into a_user from users where username = in_username;
        
        IF NOT FOUND THEN
        
            raise exception &#39;User not found.&#39;;
        ELSIF FOUND THEN
            IF in_drop_role IS TRUE then 
                stmt := &#39; drop user &#39; || quote_ident(a_user.username);
                execute stmt;
            END IF;    
            -- also gets user_connection
            delete from user_preference where id = (
                   select id from users where entity_id = a_user.entity_id);
            delete from users where entity_id = a_user.entity_id;
            return 1;
        END IF;   
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__drop_session(in_session_id integer) -->
    <section id="lsmb13.function.admin-drop-session-in-session-id-integer"
             xreflabel="lsmb13admin__drop_session(in_session_id integer)">
      <title id="lsmb13.function.admin-drop-session-in-session-id-integer-title">
       admin__drop_session(in_session_id integer)
      </title>
      <titleabbrev id="lsmb13.function.admin-drop-session-in-session-id-integer-titleabbrev">
       admin__drop_session(in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Drops the session identified, releasing all locks held.
        <programlisting>
BEGIN
	DELETE FROM &quot;session&quot; WHERE session_id = in_session_id;
	RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__get_roles() -->
    <section id="lsmb13.function.admin-get-roles"
             xreflabel="lsmb13admin__get_roles()">
      <title id="lsmb13.function.admin-get-roles-title">
       admin__get_roles()
      </title>
      <titleabbrev id="lsmb13.function.admin-get-roles-titleabbrev">
       admin__get_roles()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF pg_roles</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
    v_rol record;
    t_dbname text;
BEGIN
    t_dbname := current_database();
    FOR v_rol in 
        SELECT *
        from 
            pg_roles
        where 
            rolname ~ (&#39;^lsmb_&#39; || t_dbname || &#39;__&#39;) 
            and rolcanlogin is false
        order by rolname ASC
    LOOP
        RETURN NEXT v_rol;
    END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__get_roles_for_user(in_user_id integer) -->
    <section id="lsmb13.function.admin-get-roles-for-user-in-user-id-integer"
             xreflabel="lsmb13admin__get_roles_for_user(in_user_id integer)">
      <title id="lsmb13.function.admin-get-roles-for-user-in-user-id-integer-title">
       admin__get_roles_for_user(in_user_id integer)
      </title>
      <titleabbrev id="lsmb13.function.admin-get-roles-for-user-in-user-id-integer-titleabbrev">
       admin__get_roles_for_user(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF text</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of roles that  a user is a part of.
        <programlisting>
    
    declare
        u_role record;
        a_user users;
    begin
        select * into a_user from admin__get_user(in_user_id);
        
        FOR u_role IN 
        select r.rolname 
        from 
            pg_roles r,
            (select 
                m.roleid 
             from 
                pg_auth_members m, pg_roles b 
             where 
                m.member = b.oid 
             and 
                b.rolname = a_user.username
            ) as ar
         where 
            r.oid = ar.roleid
         LOOP
        
            RETURN NEXT u_role.rolname::text;
        
        END LOOP;
        RETURN;
    end;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__get_user(in_user_id integer) -->
    <section id="lsmb13.function.admin-get-user-in-user-id-integer"
             xreflabel="lsmb13admin__get_user(in_user_id integer)">
      <title id="lsmb13.function.admin-get-user-in-user-id-integer-title">
       admin__get_user(in_user_id integer)
      </title>
      <titleabbrev id="lsmb13.function.admin-get-user-in-user-id-integer-titleabbrev">
       admin__get_user(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) user specified by the id.
        <programlisting>
    
    DECLARE
        a_user users;
    BEGIN
        
        select * into a_user from users where id = in_user_id;
        return next a_user;
        return;
    
    END;    
</programlisting>
      </para>
    </section>

<!-- Function admin__is_group(in_group_name text) -->
    <section id="lsmb13.function.admin-is-group-in-group-name-text"
             xreflabel="lsmb13admin__is_group(in_group_name text)">
      <title id="lsmb13.function.admin-is-group-in-group-name-text-title">
       admin__is_group(in_group_name text)
      </title>
      <titleabbrev id="lsmb13.function.admin-is-group-in-group-name-text-titleabbrev">
       admin__is_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    -- This needs some work.  CT 
    DECLARE
        
        existant_role pg_roles;
        stmt text;
        
    BEGIN
        select * into existant_role from pg_roles 
        where rolname = in_group_name AND rolcanlogin is false;
        
        if not found then
            return &#39;f&#39;::bool;
            
        else
            return &#39;t&#39;::bool;
        end if;            
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__is_user(in_user text) -->
    <section id="lsmb13.function.admin-is-user-in-user-text"
             xreflabel="lsmb13admin__is_user(in_user text)">
      <title id="lsmb13.function.admin-is-user-in-user-text-title">
       admin__is_user(in_user text)
      </title>
      <titleabbrev id="lsmb13.function.admin-is-user-in-user-text-titleabbrev">
       admin__is_user(in_user text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if user is set up in LedgerSMB.  False otherwise.
        <programlisting>
    BEGIN
    
        PERFORM * from users where username = in_user;
        RETURN found;     
    
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__list_roles(in_username text) -->
    <section id="lsmb13.function.admin-list-roles-in-username-text"
             xreflabel="lsmb13admin__list_roles(in_username text)">
      <title id="lsmb13.function.admin-list-roles-in-username-text-title">
       admin__list_roles(in_username text)
      </title>
      <titleabbrev id="lsmb13.function.admin-list-roles-in-username-text-titleabbrev">
       admin__list_roles(in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_rolename RECORD;
BEGIN
	FOR out_rolename IN 
		SELECT rolname FROM pg_roles 
		WHERE oid IN (SELECT id FROM connectby (
			&#39;(SELECT m.member, m.roleid, r.oid FROM pg_roles r 
			LEFT JOIN pg_auth_members m ON (r.oid = m.roleid)) a&#39;,
			&#39;oid&#39;, &#39;member&#39;, &#39;oid&#39;, &#39;320461&#39;, &#39;0&#39;, &#39;,&#39;
			) c(id integer, parent integer, &quot;level&quot; integer, 
				path text, list_order integer)
			)
	LOOP
		RETURN NEXT out_rolename.rolname;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__list_sessions() -->
    <section id="lsmb13.function.admin-list-sessions"
             xreflabel="lsmb13admin__list_sessions()">
      <title id="lsmb13.function.admin-list-sessions-title">
       admin__list_sessions()
      </title>
      <titleabbrev id="lsmb13.function.admin-list-sessions-titleabbrev">
       admin__list_sessions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF session_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all active sessions.
        <programlisting>
SELECT s.session_id, u.username, s.last_used, count(t.id)
FROM &quot;session&quot; s
JOIN users u ON (s.users_id = u.id)
LEFT JOIN transactions t ON (t.locked_by = s.session_id)
GROUP BY s.session_id, u.username, s.last_used
ORDER BY u.username;
</programlisting>
      </para>
    </section>

<!-- Function admin__remove_function_from_group(in_role text, in_func text) -->
    <section id="lsmb13.function.admin-remove-function-from-group-in-role-text-in-func-text"
             xreflabel="lsmb13admin__remove_function_from_group(in_role text, in_func text)">
      <title id="lsmb13.function.admin-remove-function-from-group-in-role-text-in-func-text-title">
       admin__remove_function_from_group(in_role text, in_func text)
      </title>
      <titleabbrev id="lsmb13.function.admin-remove-function-from-group-in-role-text-in-func-text-titleabbrev">
       admin__remove_function_from_group(in_role text, in_func text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions of non-existant role $.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions from a non-existant function.&#39;;
        END IF;
        
        stmt := &#39;REVOKE EXECUTE ON FUNCTION &#39;|| quote_ident(in_func) ||&#39; FROM &#39;|| quote_ident(in_role);
        
        EXECUTE stmt;
        
        return 1;    
    END;
    
    
</programlisting>
      </para>
    </section>

<!-- Function admin__remove_user_from_role(in_role text, in_username text) -->
    <section id="lsmb13.function.admin-remove-user-from-role-in-role-text-in-username-text"
             xreflabel="lsmb13admin__remove_user_from_role(in_role text, in_username text)">
      <title id="lsmb13.function.admin-remove-user-from-role-in-role-text-in-username-text-title">
       admin__remove_user_from_role(in_role text, in_username text)
      </title>
      <titleabbrev id="lsmb13.function.admin-remove-user-from-role-in-role-text-in-username-text-titleabbrev">
       admin__remove_user_from_role(in_role text, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions from a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;REVOKE &#39;|| quote_ident(in_role) ||&#39; FROM &#39;|| quote_ident(in_username);
        
        EXECUTE stmt;
        
        return 1;    
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean) -->
    <section id="lsmb13.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean"
             xreflabel="lsmb13admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)">
      <title id="lsmb13.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean-title">
       admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean-titleabbrev">
       admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates a user and relevant records in LedgerSMB and PostgreSQL.
        <programlisting>
    DECLARE
    
        a_user users;
        v_user_id int;
        p_id int;
        l_id int;
        stmt text;
        t_is_role bool;
        t_is_user bool;
    BEGIN
        -- WARNING TO PROGRAMMERS:  This function runs as the definer and runs
        -- utility statements via EXECUTE.
        -- PLEASE BE VERY CAREFUL ABOUT SQL-INJECTION INSIDE THIS FUNCTION.

       PERFORM rolname FROM pg_roles WHERE rolname = in_username;
       t_is_role := found;
       t_is_user := admin__is_user(in_username);

       IF t_is_role is true and t_is_user is false and in_import is false THEN
          RAISE EXCEPTION &#39;Duplicate user&#39;;
        END IF;

        if t_is_role and in_password is not null then
                execute &#39;ALTER USER &#39; || quote_ident( in_username ) || 
                     &#39; WITH ENCRYPTED PASSWORD &#39; || quote_literal (in_password)
                     || $e$ valid until $e$ || 
                      quote_literal(now() + &#39;1 day&#39;::interval);
        elsif in_import is false AND t_is_user is false 
              AND in_password IS NULL THEN
                RAISE EXCEPTION &#39;No password&#39;;
        elsif  t_is_role is false THEN
            -- create an actual user
                execute &#39;CREATE USER &#39; || quote_ident( in_username ) || 
                     &#39; WITH ENCRYPTED PASSWORD &#39; || quote_literal (in_password)
                     || $e$ valid until $e$ || quote_literal(now() + &#39;1 day&#39;::interval);
       END IF;         
        
        select * into a_user from users lu where lu.id = in_id;
        IF FOUND THEN 
            return a_user.id;
        ELSE
            -- Insert cycle
            
            --- The entity is expected to already BE created. See admin.pm.
            
            
            v_user_id := nextval(&#39;users_id_seq&#39;);
            insert into users (id, username, entity_id) VALUES (
                v_user_id,
                in_username,
                in_entity_id
            );
            
            insert into user_preference (id) values (v_user_id);

            IF NOT exists(SELECT * FROM entity_employee WHERE entity_id = in_entity_id) THEN
                INSERT into entity_employee (entity_id) values (in_entity_id);
            END IF;
            -- Finally, issue the create user statement
            
            return v_user_id ;

            
        
        END IF;
    
    END;
</programlisting>
      </para>
    </section>

<!-- Function admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date) -->
    <section id="lsmb13.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date"
             xreflabel="lsmb13admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)">
      <title id="lsmb13.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date-title">
       admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)
      </title>
      <titleabbrev id="lsmb13.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date-titleabbrev">
       admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF user_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of users matching search criteria.  Nulls match all values.
only username is not an exact match.
        <programlisting>
DECLARE t_return_row user_result;
BEGIN
	FOR t_return_row IN
		SELECT u.id, u.username, p.first_name, p.last_name, e.ssn, e.dob
		FROM users u
		JOIN person p ON (u.entity_id = p.entity_id)
		JOIN entity_employee e ON (e.entity_id = p.entity_id)
		WHERE u.username LIKE &#39;%&#39; || coalesce(in_username,&#39;&#39;) || &#39;%&#39; AND
			(p.first_name = in_first_name or in_first_name is null)
			AND (p.last_name = in_last_name or in_last_name is null)
			AND (in_ssn is NULL or in_ssn = e.ssn) 
			AND (e.dob = in_dob::date or in_dob is NULL)
	LOOP
		RETURN NEXT t_return_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function as_array(anyelement) -->
    <section id="lsmb13.function.as-array-anyelement"
             xreflabel="lsmb13as_array(anyelement)">
      <title id="lsmb13.function.as-array-anyelement-title">
       as_array(anyelement)
      </title>
      <titleabbrev id="lsmb13.function.as-array-anyelement-titleabbrev">
       as_array(anyelement)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>anyarray</seg>
        </seglistitem>
       </segmentedlist>
 
        A basic array aggregate to take elements and return a one-dimensional array.

Example:  SELECT as_array(id) from entity_class;

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function asset__get(in_tag integer, in_id text) -->
    <section id="lsmb13.function.asset-get-in-tag-integer-in-id-text"
             xreflabel="lsmb13asset__get(in_tag integer, in_id text)">
      <title id="lsmb13.function.asset-get-in-tag-integer-in-id-text-title">
       asset__get(in_tag integer, in_id text)
      </title>
      <titleabbrev id="lsmb13.function.asset-get-in-tag-integer-in-id-text-titleabbrev">
       asset__get(in_tag integer, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a given asset either by id or tag.  Both are complete matches.

Note that the behavior is undefined if both id and tag are provided.
        <programlisting>
DECLARE ret_val asset_item;
BEGIN
	SELECT * into ret_val from asset_item WHERE id = in_id OR in_tag = tag
        ORDER BY id desc limit 1;
	return ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__import_from_disposal(in_id integer) -->
    <section id="lsmb13.function.asset-import-from-disposal-in-id-integer"
             xreflabel="lsmb13asset__import_from_disposal(in_id integer)">
      <title id="lsmb13.function.asset-import-from-disposal-in-id-integer-title">
       asset__import_from_disposal(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-import-from-disposal-in-id-integer-titleabbrev">
       asset__import_from_disposal(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Imports items from partial disposal reports. This function should not be
called dirctly by programmers but rather through the other disposal approval
api&apos;s.
        <programlisting>
DECLARE t_report asset_report;
        t_import asset_report;
BEGIN

    SELECT * INTO t_report from asset_report where id = in_id;

    if t_report.report_class &lt;&gt; 4 THEN RETURN FALSE;
    END IF;

    SELECT * 
      INTO t_import 
      FROM  asset_report__begin_import 
            (t_report.asset_class::int, t_report.report_date);

    PERFORM asset_report__import(
	ai.description,
	ai.tag,
	ai.purchase_value * rld.percent_disposed / 100,
	ai.salvage_value * rld.percent_disposed / 100,
	ai.usable_life,
	ai.purchase_date,
        ai.start_depreciation,
	ai.location_id,
	ai.department_id,
	ai.asset_account_id,
	ai.dep_account_id,
	ai.exp_account_id,
	ai.asset_class_id,
        ai.invoice_id,
        t_import.id,
        r.accum_depreciation * rld.percent_disposed / 100,
        TRUE)
    FROM asset_item ai
    JOIN asset_report__get_disposal(t_report.id) r  ON (ai.id = r.id)
    JOIN asset_report_line rl ON (rl.asset_id = ai.id AND rl.report_id = in_id)
    join asset_rl_to_disposal_method rld 
         ON (rl.report_id = rld.report_id and ai.id = rld.asset_id)
   where rld.percent_disposed is null or percent_disposed &lt; 100;
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer) -->
    <section id="lsmb13.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer"
             xreflabel="lsmb13asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)">
      <title id="lsmb13.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-title">
       asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-titleabbrev">
       asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the asset with the information provided.  If the id is provided, 
overwrites the record with the id.  Otherwise, or if that record is not found,
inserts.  Returns the row inserted or updated.

        <programlisting>
DECLARE ret_val asset_item;
BEGIN
	UPDATE asset_item
	SET asset_class_id = in_asset_class,
		description = in_description,
		tag = in_tag,
		purchase_date = in_purchase_date,
		purchase_value = in_purchase_value,
		usable_life = in_usable_life,
		location_id = in_warehouse_id,
		department_id = in_department_id,
		invoice_id = in_invoice_id,
		salvage_value = in_salvage_value,
                asset_account_id = in_asset_account_id,
                exp_account_id = in_exp_account_id,
                start_depreciation = 
                         coalesce(in_start_depreciation, in_purchase_date),
                dep_account_id = in_dep_account_id
	WHERE id = in_id;
	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_item WHERE id = in_id;
		return ret_val;
	END IF;

	INSERT INTO asset_item (asset_class_id, description, tag, purchase_date,
		purchase_value, usable_life, salvage_value, department_id,
		location_id, invoice_id, asset_account_id, dep_account_id,
                start_depreciation, exp_account_id)
	VALUES (in_asset_class, in_description, in_tag, in_purchase_date,
		in_purchase_value, in_usable_life, in_salvage_value,
		in_department_id, in_warehouse_id, in_invoice_id,
                in_asset_account_id, in_dep_account_id,
                coalesce(in_start_depreciation, in_purchase_date),
                in_exp_account_id);

	SELECT * INTO ret_val FROM asset_item 
	WHERE id = currval(&#39;asset_item_id_seq&#39;);
	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric) -->
    <section id="lsmb13.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric"
             xreflabel="lsmb13asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)">
      <title id="lsmb13.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric-title">
       asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)
      </title>
      <titleabbrev id="lsmb13.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric-titleabbrev">
       asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
       Searches for assets.  Nulls match all records.  Asset class is exact,
as is purchase date, purchase value, and salvage value. Tag and description
are partial matches.
        <programlisting>
DECLARE out_val asset_item;
BEGIN
	FOR out_val IN
		SELECT * FROM asset_item
		WHERE (in_asset_class is null 
			or asset_class_id = in_asset_class)
			AND (in_description is null or description 
				LIKE &#39;%&#39; || in_description || &#39;%&#39;)
			and (in_tag is not null or tag like &#39;%&#39;||in_tag||&#39;%&#39;)
			AND (in_purchase_date is null 
				or purchase_date = in_purchase_date)
			AND (in_purchase_value is null
				or in_purchase_value = purchase_value)
			AND (in_usable_life is null
				or in_usable_life = usable_life)
			AND (in_salvage_value is null
				OR in_salvage_value = salvage_value)
	LOOP
		RETURN NEXT out_val;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get(in_id integer) -->
    <section id="lsmb13.function.asset-class-get-in-id-integer"
             xreflabel="lsmb13asset_class__get(in_id integer)">
      <title id="lsmb13.function.asset-class-get-in-id-integer-title">
       asset_class__get(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-class-get-in-id-integer-titleabbrev">
       asset_class__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        returns the row from asset_class identified by in_id.
        <programlisting>
DECLARE ret_val asset_class;
BEGIN 
	SELECT * INTO ret_val FROM asset_class WHERE id = in_id;
	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_asset_accounts() -->
    <section id="lsmb13.function.asset-class-get-asset-accounts"
             xreflabel="lsmb13asset_class__get_asset_accounts()">
      <title id="lsmb13.function.asset-class-get-asset-accounts-title">
       asset_class__get_asset_accounts()
      </title>
      <titleabbrev id="lsmb13.function.asset-class-get-asset-accounts-titleabbrev">
       asset_class__get_asset_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of fixed asset accounts, ordered by account number
        <programlisting>
SELECT * FROM account 
WHERE id IN 
	(select account_id from account_link where description = &#39;Fixed_Asset&#39;)
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_accounts() -->
    <section id="lsmb13.function.asset-class-get-dep-accounts"
             xreflabel="lsmb13asset_class__get_dep_accounts()">
      <title id="lsmb13.function.asset-class-get-dep-accounts-title">
       asset_class__get_dep_accounts()
      </title>
      <titleabbrev id="lsmb13.function.asset-class-get-dep-accounts-titleabbrev">
       asset_class__get_dep_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of asset depreciation accounts, ordered by account number
        <programlisting>
SELECT * FROM account 
WHERE id IN 
	(select account_id from account_link where description = &#39;Asset_Dep&#39;)
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_method(in_asset_class integer) -->
    <section id="lsmb13.function.asset-class-get-dep-method-in-asset-class-integer"
             xreflabel="lsmb13asset_class__get_dep_method(in_asset_class integer)">
      <title id="lsmb13.function.asset-class-get-dep-method-in-asset-class-integer-title">
       asset_class__get_dep_method(in_asset_class integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-class-get-dep-method-in-asset-class-integer-titleabbrev">
       asset_class__get_dep_method(in_asset_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_dep_method</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the depreciation method associated with the asset class.
        <programlisting>
SELECT * from asset_dep_method 
WHERE id = (select method from asset_class where id = $1);
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_methods() -->
    <section id="lsmb13.function.asset-class-get-dep-methods"
             xreflabel="lsmb13asset_class__get_dep_methods()">
      <title id="lsmb13.function.asset-class-get-dep-methods-title">
       asset_class__get_dep_methods()
      </title>
      <titleabbrev id="lsmb13.function.asset-class-get-dep-methods-titleabbrev">
       asset_class__get_dep_methods()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_dep_method</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of asset_dep_methods ordered by the method label.
        <programlisting>
SELECT * FROM asset_dep_method ORDER BY method;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__list() -->
    <section id="lsmb13.function.asset-class-list"
             xreflabel="lsmb13asset_class__list()">
      <title id="lsmb13.function.asset-class-list-title">
       asset_class__list()
      </title>
      <titleabbrev id="lsmb13.function.asset-class-list-titleabbrev">
       asset_class__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an alphabetical list of asset classes.
        <programlisting>
SELECT * FROM asset_class ORDER BY label;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text) -->
    <section id="lsmb13.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text"
             xreflabel="lsmb13asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)">
      <title id="lsmb13.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text-title">
       asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)
      </title>
      <titleabbrev id="lsmb13.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text-titleabbrev">
       asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves this data as an asset_class record.  If in_id is NULL or is not found
in the table, inserts a new row.  Returns the row saved.
        <programlisting>
DECLARE ret_val asset_class;
BEGIN
	UPDATE asset_class 
	SET asset_account_id = in_asset_account_id,
		dep_account_id = in_dep_account_id,
		method = in_method,
		label = in_label
	WHERE id = in_id;

	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_class where id = in_id;
		RETURN ret_val;
	END IF;

	INSERT INTO asset_class (asset_account_id, dep_account_id, method,
		label)
	VALUES (in_asset_account_id, in_dep_account_id, in_method, 
		in_label);

	SELECT * INTO ret_val FROM asset_class 
	WHERE id = currval(&#39;asset_class_id_seq&#39;);

	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text) -->
    <section id="lsmb13.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text"
             xreflabel="lsmb13asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)">
      <title id="lsmb13.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-title">
       asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)
      </title>
      <titleabbrev id="lsmb13.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-titleabbrev">
       asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_class_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of matching asset classes.  The account id&apos;s are exact matches
as is the method, but the label is a partial match.  NULL&apos;s match all.
        <programlisting>
DECLARE out_var asset_class_result;
BEGIN
	FOR out_var IN
		SELECT ac.id, ac.asset_account_id, aa.accno, aa.description, 
			ad.accno, ad.description, m.method, ac.method,
			ac.label
		FROM asset_class ac
		JOIN account aa ON (aa.id = ac.asset_account_id)
		JOIN account ad ON (ad.id = ac.dep_account_id)
		JOIN asset_dep_method m ON (ac.method = m.id)
		WHERE 
			(in_asset_account_id is null 
				or in_asset_account_id = ac.asset_account_id)
			AND (in_dep_account_id is null OR
				in_dep_account_id = ac.dep_account_id)
			AND (in_method is null OR in_method = ac.method)
			AND (in_label IS NULL OR ac.label LIKE 
				&#39;%&#39; || in_label || &#39;%&#39;)
               ORDER BY label
	LOOP
		RETURN NEXT out_var;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric) -->
    <section id="lsmb13.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric"
             xreflabel="lsmb13asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)">
      <title id="lsmb13.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric-title">
       asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)
      </title>
      <titleabbrev id="lsmb13.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric-titleabbrev">
       asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This function is a basic function which does the actual calculation for 
straight line depreciation.
        <programlisting>
SELECT CASE WHEN $3/$1 * $4 &lt; $4 - $5 THEN $3/$1 * $4 
            ELSE $4 - $5
            END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric) -->
    <section id="lsmb13.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric"
             xreflabel="lsmb13asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)">
      <title id="lsmb13.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric-title">
       asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)
      </title>
      <titleabbrev id="lsmb13.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric-titleabbrev">
       asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks the interval between the two dates, and if longer than the 
usable life, returns the months in that interval.  Otherwise returns the 
usable life.
        <programlisting>
select CASE WHEN extract(&#39;MONTHS&#39; FROM (date_trunc(&#39;day&#39;, $2) - date_trunc(&#39;day&#39;, $1))) 
                 &gt; $3
            THEN $3
            ELSE extract(&#39;MONTHS&#39; FROM (date_trunc(&#39;day&#39;, $2) - date_trunc(&#39;day&#39;, $1)))::numeric
            END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date) -->
    <section id="lsmb13.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date"
             xreflabel="lsmb13asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)">
      <title id="lsmb13.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date-title">
       asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)
      </title>
      <titleabbrev id="lsmb13.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date-titleabbrev">
       asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       If the interval is less than 0 then 0.  If the interval is greater than the 
usable life, then the usable life.  Otherwise, return the interval as a 
fractional year.
        <programlisting>
   SELECT CASE WHEN $3 IS NULL or get_fractional_year($2, $3) &gt; $1 
               then $1
               WHEN get_fractional_year($2, $3) &lt; 0
               THEN 0
               ELSE get_fractional_year($2, $3)
          END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="lsmb13.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="lsmb13asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="lsmb13.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Performs straight line depreciation, selecting depreciation amounts, etc. 
into a report for further review and approval.  Usable life is in months, and
depreciation is an equal amount every month.
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life,
                  ai.usable_life --months
                  - months_passed(coalesce(start_depreciation, purchase_date),
                                  coalesce(max(report_date),
                                           start_depreciation,
                                           purchase_date)),
                  months_passed(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="lsmb13.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="lsmb13asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="lsmb13.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life, -- years
                  ai.usable_life - 
                  get_fractional_year(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                       coalesce(start_depreciation,
                                         purchase_date)),
                  get_fractional_year(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="lsmb13.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="lsmb13asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="lsmb13.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Performs straight line depreciation on a set of selected assets, selecting
the depreciation values into a report.

Assumes the usable life is measured in years, and is depreciated eavenly every
month.
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life * 12,
                  ai.usable_life * 12 --months
                  - months_passed(coalesce(start_depreciation, purchase_date),
                                  coalesce(max(report_date),
                                           start_depreciation,
                                           purchase_date)),
                  months_passed(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_depreciation__approve(in_expense_acct integer, in_report_id integer) -->
    <section id="lsmb13.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer"
             xreflabel="lsmb13asset_depreciation__approve(in_expense_acct integer, in_report_id integer)">
      <title id="lsmb13.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer-title">
       asset_depreciation__approve(in_expense_acct integer, in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer-titleabbrev">
       asset_depreciation__approve(in_expense_acct integer, in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Approves an asset depreciation report and creats the GL draft.
        <programlisting>
declare retval asset_report;
begin

retval := asset_report__record_approve(in_report_id);

INSERT INTO gl (reference, description, approved)
select &#39;Asset Report &#39; || in_id, &#39;Asset Depreciation Report for &#39; || report_date,
       false
 FROM asset_report where id = in_id;

INSERT INTO acc_trans (amount, chart_id, transdate, approved, trans_id)
SELECT l.amount, a.dep_account_id, r.report_date, true, currval(&#39;id&#39;)
  FROM asset_report r
  JOIN asset_report_line l ON (r.id = l.report_id)
  JOIN asset_item a ON (a.id = l.asset_id)
 WHERE r.id = in_id;

INSERT INTO acc_trans (amount, chart_id, transdate, approved, trans_id)
SELECT sum(l.amount) * -1, in_expense_acct, r.report_date, approved, 
       currval(&#39;id&#39;)
  FROM asset_report r
  JOIN asset_report_line l ON (r.id = l.report_id)
  JOIN asset_item a ON (a.id = l.asset_id)
 WHERE r.id = in_id
 GROUP BY r.report_date;


return retval;

end;
</programlisting>
      </para>
    </section>

<!-- Function asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer) -->
    <section id="lsmb13.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer"
             xreflabel="lsmb13asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)">
      <title id="lsmb13.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-title">
       asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-titleabbrev">
       asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        This approves the asset_report for disposals, creating relevant GL drafts.

If the report is a partial disposal report, imports remaining percentages as new
asset items.
        <programlisting>
DECLARE 
   retval asset_report;
   iter record;
   t_disposed_percent numeric;
begin
-- this code is fairly opaque and needs more documentation that would be 
-- otherwise optimal. This is mostly due to the fact that we have fairly
-- repetitive insert/select routines and the fact that the accounting 
-- requirements are not immediately intuitive.  Inserts marked functionally along
-- with typical debit/credit designations.  Note debits are always negative.


retval := asset_report__record_approve(in_id);
if retval.report_class = 2 then
     t_disposed_percent := 100;
end if;

INSERT INTO gl (reference, description, approved, transdate)
select &#39;Asset Report &#39; || in_id, &#39;Asset Disposal Report for &#39; || report_date,
       false, report_date
 FROM asset_report where id = in_id;

-- REMOVING ASSETS FROM ACCOUNT (Credit)
insert into acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), a.asset_account_id, 
       a.purchase_value 
       * (coalesce(t_disposed_percent, m.percent_disposed)/100), 
       true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 WHERE r.id = in_id;

-- REMOVING ACCUM DEP. (Debit)
INSERT into acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), a.dep_account_id, 
       sum(dl.amount) * -1 
       * (coalesce(t_disposed_percent, m.percent_disposed)/100), 
       true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_report_line dl ON (l.asset_id = dl.asset_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 JOIN  asset_report dr ON (dl.report_id = dr.id 
                           and dr.report_class = 1
                           and dr.approved_at is not null)
 WHERE r.id = in_id
group by a.dep_account_id, m.percent_disposed, r.report_date;

-- INSERT asset/proceeds (Debit, credit for negative values)
INSERT INTO acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), in_asset_acct, coalesce(l.amount, 0) * -1, true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 WHERE r.id = in_id;

-- INSERT GAIN/LOSS (Credit for gain, debit for loss)
INSERT INTO acc_trans(trans_id, chart_id, amount, approved, transdate)
select currval(&#39;id&#39;), 
            CASE WHEN sum(amount) &gt; 0 THEN in_loss_acct
            else in_gain_acct
        END,
        sum(amount) * -1 , true, 
        retval.report_date
  FROM acc_trans
  WHERE trans_id = currval(&#39;id&#39;);

IF retval.report_class = 4 then
   PERFORM asset__import_from_disposal(retval.id);
end if;

return retval;
end;
</programlisting>
      </para>
    </section>

<!-- Function asset_item__add_note(in_note integer, in_subject text, in_id text) -->
    <section id="lsmb13.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text"
             xreflabel="lsmb13asset_item__add_note(in_note integer, in_subject text, in_id text)">
      <title id="lsmb13.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text-title">
       asset_item__add_note(in_note integer, in_subject text, in_id text)
      </title>
      <titleabbrev id="lsmb13.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text-titleabbrev">
       asset_item__add_note(in_note integer, in_subject text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Adds a note to an asset item
        <programlisting>
INSERT INTO asset_note (ref_key, subject, note) values ($1, $2, $3);
SELECT * FROM asset_note WHERE id = currval(&#39;note_id_seq&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer) -->
    <section id="lsmb13.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer"
             xreflabel="lsmb13asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)">
      <title id="lsmb13.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-title">
       asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-titleabbrev">
       asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of matching asset items.  Nulls match all records.
Tag and description allow for partial match.  All other matches are exact.
        <programlisting>
DECLARE retval asset_item;
BEGIN
    FOR retval IN
         SELECT * FROM asset_item
          WHERE (id = in_id or in_id is null)
                and (asset_class_id = in_asset_class or in_asset_class is null)
                and (description like &#39;%&#39;||in_description||&#39;%&#39;
                     or in_description is null)
                and (tag like &#39;%&#39; || in_tag || &#39;%&#39; or in_tag is null)
                and (purchase_value = in_purchase_value 
                    or in_purchase_value is null)
                and (in_purchase_date = purchase_date 
                    or in_purchase_date is null)
                and (start_depreciation = in_start_depreciation
                    or in_start_depreciation is null)
                and (in_warehouse_id = location_id OR in_warehouse_id is null)
                and (department_id = in_department_id 
                    or in_department_id is null)
                and (in_invoice_id = invoice_id OR in_invoice_id IS NULL)
                and (asset_account_id = in_asset_account_id
                    or in_asset_account_id is null)
                and (dep_account_id = in_dep_account_id
                    or in_dep_account_id is null)
   LOOP
       return next retval;
   end loop;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_nbv_report() -->
    <section id="lsmb13.function.asset-nbv-report"
             xreflabel="lsmb13asset_nbv_report()">
      <title id="lsmb13.function.asset-nbv-report-title">
       asset_nbv_report()
      </title>
      <titleabbrev id="lsmb13.function.asset-nbv-report-titleabbrev">
       asset_nbv_report()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_nbv_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the current net book value report.
        <programlisting>
   SELECT ai.id, ai.tag, ai.description, coalesce(ai.start_depreciation, ai.purchase_date),
          adm.short_name, ai.usable_life 
           - months_passed(coalesce(ai.start_depreciation, ai.purchase_date),
                                  coalesce(max(r.report_date),
                                           ai.start_depreciation,
                                           ai.purchase_date))/ 12,
          ai.purchase_value - ai.salvage_value, ai.salvage_value, max(r.report_date),
          sum(rl.amount), ai.purchase_value - sum(rl.amount) 
     FROM asset_item ai
     JOIN asset_class ac ON (ai.asset_class_id = ac.id)
     JOIN asset_dep_method adm ON (adm.id = ac.method)
LEFT JOIN asset_report_line rl ON (ai.id = rl.asset_id)
LEFT JOIN asset_report r on (rl.report_id = r.id)
    WHERE r.id IS NULL OR r.approved_at IS NOT NULL
 GROUP BY ai.id, ai.tag, ai.description, ai.start_depreciation, ai.purchase_date,
          adm.short_name, ai.usable_life, ai.purchase_value, salvage_value
   HAVING (NOT 2 = ANY(as_array(r.report_class))) 
          AND (NOT 4 = ANY(as_array(r.report_class)))
          OR max(r.report_class) IS NULL
 ORDER BY ai.id, ai.tag, ai.description;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer) -->
    <section id="lsmb13.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer"
             xreflabel="lsmb13asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)">
      <title id="lsmb13.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer-title">
       asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer-titleabbrev">
       asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        This function approves an asset report (whether depreciation or disposal).
Also generates relevant GL drafts for review and posting.
        <programlisting>
DECLARE ret_val asset_report;
BEGIN
        UPDATE asset_report 
           SET approved_at = now(),
               approved_by = person__get_my_entity_id()
         where id = in_id;
	SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
        if ret_val.dont_approve is not true then 
                if ret_val.report_class = 1 THEN
                    PERFORM asset_report__generate_gl(in_id, in_expense_acct);
                ELSIF ret_val.report_class = 2 THEN
                    PERFORM asset_report__disposal_gl(
                                 in_id, in_gain_acct, in_loss_acct);
                ELSIF ret_val.report_class = 4 THEN
                    PERFORM asset_disposal__approve(in_id, in_gain_acct, in_loss_acct, (select asset_account_id from asset_class 
                                                                                         where id = ret_val.asset_class)
                                                   );
                ELSE RAISE EXCEPTION &#39;Invalid report class&#39;;
                END IF;
        end if;
	SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
	RETURN ret_val;
end;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer) -->
    <section id="lsmb13.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer"
             xreflabel="lsmb13asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)">
      <title id="lsmb13.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer-title">
       asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer-titleabbrev">
       asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates the asset report recofd for the asset disposal report.
        <programlisting>
DECLARE retval asset_report;

begin

INSERT INTO asset_report (asset_class, report_date, entered_at, entered_by, 
            report_class)
     VALUES (in_asset_class, in_report_date, now(), person__get_my_entity_id(), 
            in_report_class);

SELECT * INTO retval FROM asset_report where id = currval(&#39;asset_report_id_seq&#39;);

return retval;

end;

</programlisting>
      </para>
    </section>

<!-- Function asset_report__begin_import(in_report_date integer, in_asset_class date) -->
    <section id="lsmb13.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date"
             xreflabel="lsmb13asset_report__begin_import(in_report_date integer, in_asset_class date)">
      <title id="lsmb13.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date-title">
       asset_report__begin_import(in_report_date integer, in_asset_class date)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date-titleabbrev">
       asset_report__begin_import(in_report_date integer, in_asset_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates the outline of an asset import report
        <programlisting>
INSERT INTO asset_report (asset_class, report_date, entered_at, entered_by, 
            report_class, dont_approve)
     VALUES ($1, $2, now(), person__get_my_entity_id(), 
            3, true);

SELECT * FROM asset_report where id = currval(&#39;asset_report_id_seq&#39;);

</programlisting>
      </para>
    </section>

<!-- Function asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer) -->
    <section id="lsmb13.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer"
             xreflabel="lsmb13asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)">
      <title id="lsmb13.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-title">
       asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-titleabbrev">
       asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates GL transactions for ful disposal reports.
        <programlisting>
  INSERT 
    INTO gl (reference, description, transdate, approved)
  SELECT setting_increment(&#39;glnumber&#39;), &#39;Asset Report &#39; || asset_report.id,
		report_date, false
    FROM asset_report 
    JOIN asset_report_line ON (asset_report.id = asset_report_line.report_id)
    JOIN asset_item        ON (asset_report_line.asset_id = asset_item.id)
   WHERE asset_report.id = $1
GROUP BY asset_report.id, asset_report.report_date;

  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT a.dep_account_id, currval(&#39;id&#39;)::int, sum(r.accum_depreciation) * -1,
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item a ON (r.id = a.id)
GROUP BY a.dep_account_id, r.disposed_on;

  -- GAIN is negative since it is a debit
  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT case when sum(r.gain_loss) &gt; 0 THEN $3 else $2 end,
         currval(&#39;id&#39;)::int, sum(r.gain_loss),
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item ai ON (r.id = ai.id)
GROUP BY r.disposed_on;

  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT a.asset_account_id, currval(&#39;id&#39;)::int, sum(r.purchase_value),
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item a ON (r.id = a.id)
GROUP BY a.asset_account_id, r.disposed_on;


  SELECT TRUE;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric) -->
    <section id="lsmb13.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric"
             xreflabel="lsmb13asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)">
      <title id="lsmb13.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric-title">
       asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric-titleabbrev">
       asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Disposes of an asset.  in_dm is the disposal method id.
        <programlisting>
BEGIN
    INSERT 
      INTO asset_report_line (report_id, asset_id, amount)
    values (in_id, in_asset_id, in_amount);

    INSERT 
      INTO asset_rl_to_disposal_method 
           (report_id, asset_id, disposal_method_id, percent_disposed)
    VALUES (in_id, in_asset_id, in_dm, in_percent_disposed);

    RETURN TRUE;
    END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date) -->
    <section id="lsmb13.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date"
             xreflabel="lsmb13asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)">
      <title id="lsmb13.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date-title">
       asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date-titleabbrev">
       asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates lines to select/deselect for the asset report (depreciation or
disposal).
        <programlisting>
   SELECT ai.*
     FROM asset_item ai
     JOIN asset_class ac ON (ai.asset_class_id = ac.id)
LEFT JOIN asset_report_line arl ON (arl.asset_id = ai.id)
LEFT JOIN asset_report ar ON (arl.report_id = ar.id)
    WHERE COALESCE(ai.start_depreciation, ai.purchase_date) &lt;= $3 AND ac.id = $2
          AND obsolete_by IS NULL
 GROUP BY ai.id, ai.tag, ai.description, ai.purchase_value, ai.usable_life,
          ai.purchase_date, ai.location_id, ai.invoice_id, ai.asset_account_id,
          ai.dep_account_id, ai.asset_class_id, ai.start_depreciation,
          ai.salvage_value, ai.department_id, ai.exp_account_id, ai.obsolete_by
   HAVING (count(ar.report_class) = 0 OR    
          (2 &lt;&gt; ALL(as_array(ar.report_class)) 
          and 4 &lt;&gt; ALL(as_array(ar.report_class))))
          AND ((ai.purchase_value - coalesce(sum(arl.amount), 0) 
               &gt; ai.salvage_value) and ai.obsolete_by is null)
               OR $1 is not true;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__generate_gl(in_accum_account_id integer, in_report_id integer) -->
    <section id="lsmb13.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer"
             xreflabel="lsmb13asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)">
      <title id="lsmb13.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer-title">
       asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer-titleabbrev">
       asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates a GL transaction when the Asset report is approved.

Currently this creates GL drafts, not approved transctions

        <programlisting>
DECLARE 
	t_report_dept record;
	t_dep_amount numeric;

Begin
	INSERT INTO gl (reference, description, transdate, approved)
	SELECT setting_increment(&#39;glnumber&#39;), &#39;Asset Report &#39; || asset_report.id,
		report_date, false
	FROM asset_report 
	JOIN asset_report_line 
		ON (asset_report.id = asset_report_line.report_id)
	JOIN asset_item 
		ON (asset_report_line.asset_id = asset_item.id)
	WHERE asset_report.id = in_report_id
	GROUP BY asset_report.id, asset_report.report_date;

	INSERT INTO acc_trans (trans_id, chart_id, transdate, approved, amount)
	SELECT gl.id, a.exp_account_id, r.report_date, true, sum(amount) * -1
	FROM asset_report r
	JOIN asset_report_line l ON (r.id = l.report_id)
	JOIN asset_item a ON (l.asset_id = a.id)
	JOIN gl ON (gl.description = &#39;Asset Report &#39; || l.report_id)
	WHERE r.id = in_report_id
	GROUP BY gl.id, r.report_date, a.exp_account_id;

	INSERT INTO acc_trans (trans_id, chart_id, transdate, approved, amount)
	SELECT gl.id, a.dep_account_id, r.report_date, true, sum(amount)
	FROM asset_report r
	JOIN asset_report_line l ON (r.id = l.report_id)
	JOIN asset_item a ON (l.asset_id = a.id)
	JOIN gl ON (gl.description = &#39;Asset Report &#39; || l.report_id) 
	WHERE r.id = in_report_id
	GROUP BY gl.id, a.dep_account_id, r.report_date, a.tag, a.description;

	RETURN in_report_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get(in_id integer) -->
    <section id="lsmb13.function.asset-report-get-in-id-integer"
             xreflabel="lsmb13asset_report__get(in_id integer)">
      <title id="lsmb13.function.asset-report-get-in-id-integer-title">
       asset_report__get(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-in-id-integer-titleabbrev">
       asset_report__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the asset_report line identified by id.
        <programlisting>
select * from asset_report where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_disposal(in_id integer) -->
    <section id="lsmb13.function.asset-report-get-disposal-in-id-integer"
             xreflabel="lsmb13asset_report__get_disposal(in_id integer)">
      <title id="lsmb13.function.asset-report-get-disposal-in-id-integer-title">
       asset_report__get_disposal(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-disposal-in-id-integer-titleabbrev">
       asset_report__get_disposal(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_disposal_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of lines of disposed assets in a disposal report, specified
by the report id.
        <programlisting>
   SELECT ai.id, ai.tag, ai.description, ai.start_depreciation, r.report_date,
          dm.short_label, ai.purchase_value, 
          sum (CASE WHEN pr.report_class in (1,3) THEN prl.amount ELSE 0 END) 
          as accum_dep,
          l.amount, 
          ai.purchase_value - sum(CASE WHEN pr.report_class in (1,3) 
                                       THEN prl.amount 
                                       ELSE 0 
                                   END) as adjusted_basis,
          l.amount - ai.purchase_value + sum(CASE WHEN pr.report_class in (1,3)
                                                  THEN prl.amount 
                                                  ELSE 0 
                                              END) as gain_loss
     FROM asset_item ai
     JOIN asset_report_line l   ON (l.report_id = $1 AND ai.id = l.asset_id)
     JOIN asset_report r        ON (l.report_id = r.id)
LEFT JOIN asset_rl_to_disposal_method adm 
                             USING (report_id, asset_id)
     JOIN asset_disposal_method dm
                                ON (adm.disposal_method_id = dm.id)
LEFT JOIN asset_report_line prl ON (prl.report_id &lt;&gt; $1 
                                   AND ai.id = prl.asset_id)
LEFT JOIN asset_report pr       ON (prl.report_id = pr.id)
 GROUP BY ai.id, ai.tag, ai.description, ai.start_depreciation, r.report_date,
          ai.purchase_value, l.amount, dm.short_label
 ORDER BY ai.id, ai.tag;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_disposal_methods() -->
    <section id="lsmb13.function.asset-report-get-disposal-methods"
             xreflabel="lsmb13asset_report__get_disposal_methods()">
      <title id="lsmb13.function.asset-report-get-disposal-methods-title">
       asset_report__get_disposal_methods()
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-disposal-methods-titleabbrev">
       asset_report__get_disposal_methods()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_disposal_method</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of asset_disposal_method items ordered by label.
        <programlisting>
SELECT * FROM asset_disposal_method order by label;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_expense_accts() -->
    <section id="lsmb13.function.asset-report-get-expense-accts"
             xreflabel="lsmb13asset_report__get_expense_accts()">
      <title id="lsmb13.function.asset-report-get-expense-accts-title">
       asset_report__get_expense_accts()
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-expense-accts-titleabbrev">
       asset_report__get_expense_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all asset expense reports.
        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_expense&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_gain_accts() -->
    <section id="lsmb13.function.asset-report-get-gain-accts"
             xreflabel="lsmb13asset_report__get_gain_accts()">
      <title id="lsmb13.function.asset-report-get-gain-accts-title">
       asset_report__get_gain_accts()
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-gain-accts-titleabbrev">
       asset_report__get_gain_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of gain accounts for asset depreciation and disposal reports.

        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_gain&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_lines(in_id integer) -->
    <section id="lsmb13.function.asset-report-get-lines-in-id-integer"
             xreflabel="lsmb13asset_report__get_lines(in_id integer)">
      <title id="lsmb13.function.asset-report-get-lines-in-id-integer-title">
       asset_report__get_lines(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-lines-in-id-integer-titleabbrev">
       asset_report__get_lines(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_report_line_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the lines of an asset depreciation report.
        <programlisting>
   select ai.tag, coalesce(ai.start_depreciation, ai.purchase_date), ai.purchase_value, m.short_name, 
          ai.usable_life, 
          ai.purchase_value - ai.salvage_value, max(pr.report_date),
          sum(case when pr.report_date &lt; r.report_date then prl.amount
                   else 0
                end), 
          rl.amount, 
          sum (case when extract(year from pr.report_date)
                         = extract(year from r.report_date)
                         AND pr.report_date &lt; r.report_date
                    then prl.amount
                    else 0
                end), 
          sum(prl.amount), 
          ai.description, ai.purchase_date
     FROM asset_item ai
     JOIN asset_class c ON (ai.asset_class_id = c.id)
     JOIN asset_dep_method m ON (c.method = m.id)
     JOIN asset_report_line rl ON (rl.asset_id = ai.id)
     JOIN asset_report r ON (rl.report_id = r.id)
LEFT JOIN asset_report_line prl ON (prl.asset_id = ai.id)
LEFT JOIN asset_report pr ON (prl.report_id = pr.id)
    WHERE rl.report_id = $1
 GROUP BY ai.tag, ai.start_depreciation, ai.purchase_value, m.short_name,
          ai.usable_life, ai.salvage_value, r.report_date, rl.amount,
          ai.description, ai.purchase_date;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_loss_accts() -->
    <section id="lsmb13.function.asset-report-get-loss-accts"
             xreflabel="lsmb13asset_report__get_loss_accts()">
      <title id="lsmb13.function.asset-report-get-loss-accts-title">
       asset_report__get_loss_accts()
      </title>
      <titleabbrev id="lsmb13.function.asset-report-get-loss-accts-titleabbrev">
       asset_report__get_loss_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of loss accounts for asset depreciation and disposal reports.

        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_loss&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean) -->
    <section id="lsmb13.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean"
             xreflabel="lsmb13asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)">
      <title id="lsmb13.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean-title">
       asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean-titleabbrev">
       asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Imports an asset with the supplied information.  If in_obsolete_other is
false, this creates a new depreciable asset.  If it is true, it sets up the 
other asset as obsolete.  This is the way partial disposal reports are handled.

        <programlisting>

SET CONSTRAINTS asset_item_obsolete_by_fkey DEFERRED;
-- This fails a deferrable fkey constraint but avoids a partial unique index
-- so in this case, the foreign key is deferred for the duration of this 
-- specific stored proc call.

UPDATE asset_item
   SET obsolete_by = -1 
 WHERE tag = $2 and $17 is true;

INSERT 
  INTO asset_report_line 
       (report_id, asset_id, amount, department_id, warehouse_id)
select $15, id, $16, department_id, location_id
  from asset__save
       (NULL, $13, $1, $2, $6, $3, $5, coalesce($4, 0), $7, $8, $9, $14, $10, $11, $12);

UPDATE asset_item 
   SET obsolete_by = currval(&#39;asset_item_id_seq&#39;)
 WHERE obsolete_by = -1;

-- enforce fkeys now and raise exception if fail
SET CONSTRAINTS asset_item_obsolete_by_fkey IMMEDIATE;
SELECT true;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__record_approve(in_id integer) -->
    <section id="lsmb13.function.asset-report-record-approve-in-id-integer"
             xreflabel="lsmb13asset_report__record_approve(in_id integer)">
      <title id="lsmb13.function.asset-report-record-approve-in-id-integer-title">
       asset_report__record_approve(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-record-approve-in-id-integer-titleabbrev">
       asset_report__record_approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Marks the asset_report record approved.  Not generally recommended to call
directly.
        <programlisting>
UPDATE asset_report 
   set approved_by = person__get_my_entity_id(),
       approved_at = now()
 where id = $1;

select * from asset_report where id = $1;

</programlisting>
      </para>
    </section>

<!-- Function asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean) -->
    <section id="lsmb13.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean"
             xreflabel="lsmb13asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)">
      <title id="lsmb13.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean-title">
       asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean-titleabbrev">
       asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates or updates an asset report with the information presented.  Note that
approval values are not set here, and that one cannot unsubmit a report though
this function.
        <programlisting>
DECLARE 
	ret_val asset_report;
	item record;
	method_text text;
BEGIN
	UPDATE asset_report 
	set asset_class = in_asset_class,
		report_class = in_report_class,
		report_date = in_report_date,
		submitted = (in_submit or submitted)
	WHERE id = in_id;

	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
	ELSE 
		INSERT INTO asset_report(report_class, asset_class, report_date,
			submitted)
		values (in_report_class, in_asset_class, in_report_date, 
			coalesce(in_submit, true));

		SELECT * INTO ret_val FROM asset_report 
		WHERE id = currval(&#39;asset_report_id_seq&#39;);
                
	END IF;
        RETURN ret_val;

END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer) -->
    <section id="lsmb13.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer"
             xreflabel="lsmb13asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)">
      <title id="lsmb13.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer-title">
       asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer-titleabbrev">
       asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_report_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for asset reports.  Nulls match all rows.  Approved, asset class, 
and entered_by are exact matches.  Start_date and end_date define the beginning
and end of the search date. 
        <programlisting>

  SELECT r.id, r.report_date, r.gl_id, r.asset_class, r.report_class, 
         r.entered_by, r.approved_by, r.entered_at, r.approved_at, 
         r.depreciated_qty, r.dont_approve, r.submitted, sum(l.amount)
    FROM asset_report r
    JOIN asset_report_line l ON (l.report_id = r.id)
   where ($1 is null or $1 &lt;= report_date)
         and ($2 is null or $2 &gt;= report_date)
         and ($3 is null or $3 = asset_class)
         and ($4 is null 
              or ($4 is true and approved_by is not null)
              or ($4 is false and approved_by is null))
         and ($5 is null or $5 = entered_by)
GROUP BY r.id, r.report_date, r.gl_id, r.asset_class, r.report_class,
         r.entered_by, r.approved_by, r.entered_at, r.approved_at,
         r.depreciated_qty, r.dont_approve, r.submitted;
</programlisting>
      </para>
    </section>

<!-- Function asset_report_partial_disposal_details(in_id integer) -->
    <section id="lsmb13.function.asset-report-partial-disposal-details-in-id-integer"
             xreflabel="lsmb13asset_report_partial_disposal_details(in_id integer)">
      <title id="lsmb13.function.asset-report-partial-disposal-details-in-id-integer-title">
       asset_report_partial_disposal_details(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.asset-report-partial-disposal-details-in-id-integer-titleabbrev">
       asset_report_partial_disposal_details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF partial_disposal_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the partial disposal details for a partial disposal report.
        <programlisting>
SELECT ai.id, ai.tag, ai.start_depreciation, ai.purchase_value, ai.description,
       ar.report_date, arld.percent_disposed, 
       (arld.percent_disposed / 100) * ai.purchase_value, 
       100 - arld.percent_disposed,
       ((100 - arld.percent_disposed)/100) * ai.purchase_value
  FROM asset_item ai
  JOIN asset_report_line l ON (ai.id = l.asset_id)
  JOIN asset_report ar ON (ar.id = l.report_id)
  JOIN asset_rl_to_disposal_method arld
       ON  ((arld.report_id, arld.asset_id) = (l.report_id, l.asset_id))
 WHERE ar.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function avgcost(integer) -->
    <section id="lsmb13.function.avgcost-integer"
             xreflabel="lsmb13avgcost(integer)">
      <title id="lsmb13.function.avgcost-integer-title">
       avgcost(integer)
      </title>
      <titleabbrev id="lsmb13.function.avgcost-integer-titleabbrev">
       avgcost(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE

v_cost float;
v_qty float;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost, v_qty SUM(i.sellprice * i.qty), SUM(i.qty)
  FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id;
  
  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

  IF NOT v_qty IS NULL THEN
    IF v_qty = 0 THEN
      v_cost := 0;
    ELSE
      v_cost := v_cost/v_qty;
    END IF;
  END IF;

RETURN v_cost;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date) -->
    <section id="lsmb13.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date"
             xreflabel="lsmb13batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)">
      <title id="lsmb13.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date-title">
       batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)
      </title>
      <titleabbrev id="lsmb13.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date-titleabbrev">
       batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts the batch into the table.
        <programlisting>
BEGIN
	INSERT INTO 
		batch (batch_class_id, default_date, description, control_code,
			created_by)
	VALUES ((SELECT id FROM batch_class WHERE class = in_batch_class),
		in_batch_date, in_description, in_batch_number, 
			(select entity_id FROM users WHERE username = session_user));

	return currval(&#39;batch_id_seq&#39;);
END;	
</programlisting>
      </para>
    </section>

<!-- Function batch_delete(in_batch_id integer) -->
    <section id="lsmb13.function.batch-delete-in-batch-id-integer"
             xreflabel="lsmb13batch_delete(in_batch_id integer)">
      <title id="lsmb13.function.batch-delete-in-batch-id-integer-title">
       batch_delete(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb13.function.batch-delete-in-batch-id-integer-titleabbrev">
       batch_delete(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        If the batch is found and unapproved, deletes it and returns 1.
Otherwise raises an exception.
        <programlisting>
DECLARE 
	t_transaction_ids int[];
BEGIN
	-- Adjust AR/AP tables for payment and payment reversal vouchers
	-- voucher_id is only set in acc_trans on payment/receipt vouchers and
	-- their reversals. -CT
        perform * from batch where id = in_batch_id and approved_on IS NULL;
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Batch not found&#39;;
        END IF; 
	update ar set paid = amount + 
		(select sum(amount) from acc_trans 
		join chart ON (acc_trans.chart_id = chart.id)
		where link = &#39;AR&#39; AND trans_id = ar.id
			AND (voucher_id IS NULL OR voucher_id NOT IN 
				(select id from voucher 
				WHERE batch_id = in_batch_id))) 
	where id in (select trans_id from acc_trans where voucher_id IN 
		(select id from voucher where batch_id = in_batch_id));

	update ap set paid = amount - (select sum(amount) from acc_trans 
		join chart ON (acc_trans.chart_id = chart.id)
		where link = &#39;AP&#39; AND trans_id = ap.id
			AND (voucher_id IS NULL OR voucher_id NOT IN 
				(select id from voucher 
				WHERE batch_id = in_batch_id))) 
	where id in (select trans_id from acc_trans where voucher_id IN 
		(select id from voucher where batch_id = in_batch_id));

        DELETE FROM ac_tax_form WHERE entry_id IN
               (select entry_id from acc_trans where voucher_id in
                       (select id from voucher where batch_id = in_batch_id)
               );

	DELETE FROM acc_trans WHERE voucher_id IN 
		(select id FROM voucher where batch_id = in_batch_id);

	-- The rest of this function involves the deletion of actual
	-- transactions, vouchers, and batches, and jobs which are in progress.
	-- -CT
	SELECT as_array(trans_id) INTO t_transaction_ids
	FROM voucher WHERE batch_id = in_batch_id AND batch_class IN (1, 2, 5);

        DELETE FROM ac_tax_form WHERE entry_id in
               (select entry_id from acc_trans 
                 where trans_id = any(t_transaction_ids));

	DELETE FROM acc_trans WHERE trans_id = ANY(t_transaction_ids);
	DELETE FROM ap WHERE id = ANY(t_transaction_ids);
	DELETE FROM gl WHERE id = ANY(t_transaction_ids);
	DELETE FROM voucher WHERE batch_id = in_batch_id;
	DELETE FROM batch WHERE id = in_batch_id;
	DELETE FROM transactions WHERE id = ANY(t_transaction_ids);

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_get_class_id(in_type text) -->
    <section id="lsmb13.function.batch-get-class-id-in-type-text"
             xreflabel="lsmb13batch_get_class_id(in_type text)">
      <title id="lsmb13.function.batch-get-class-id-in-type-text-title">
       batch_get_class_id(in_type text)
      </title>
      <titleabbrev id="lsmb13.function.batch-get-class-id-in-type-text-titleabbrev">
       batch_get_class_id(in_type text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        returns the batch class id associated with the in_type label provided.
        <programlisting>
SELECT id FROM batch_class WHERE class = $1;
</programlisting>
      </para>
    </section>

<!-- Function batch_get_users() -->
    <section id="lsmb13.function.batch-get-users"
             xreflabel="lsmb13batch_get_users()">
      <title id="lsmb13.function.batch-get-users-title">
       batch_get_users()
      </title>
      <titleabbrev id="lsmb13.function.batch-get-users-titleabbrev">
       batch_get_users()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a sim[ple set of user objects.  This should be renamed so that 
it is more obvious it is a general purpose function.
        <programlisting>
DECLARE out_record users%ROWTYPE;
BEGIN
	FOR out_record IN
		SELECT * from users WHERE entity_id IN (select created_by from batch)
	LOOP
		RETURN NEXT out_record;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_list_classes() -->
    <section id="lsmb13.function.batch-list-classes"
             xreflabel="lsmb13batch_list_classes()">
      <title id="lsmb13.function.batch-list-classes-title">
       batch_list_classes()
      </title>
      <titleabbrev id="lsmb13.function.batch-list-classes-titleabbrev">
       batch_list_classes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all batch classes.
        <programlisting>
DECLARE out_val record;
BEGIN
	FOR out_val IN select * from batch_class order by id
 	LOOP
		return next out_val;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_post(in_batch_id integer) -->
    <section id="lsmb13.function.batch-post-in-batch-id-integer"
             xreflabel="lsmb13batch_post(in_batch_id integer)">
      <title id="lsmb13.function.batch-post-in-batch-id-integer-title">
       batch_post(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb13.function.batch-post-in-batch-id-integer-titleabbrev">
       batch_post(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts the specified batch to the books.  Only posted batches should show up
on standard financial reports.
        <programlisting>
BEGIN
	UPDATE ar SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 2);
	
	UPDATE ap SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 1);

	UPDATE gl SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 5);

	UPDATE acc_trans SET approved = true 
	WHERE voucher_id IN (select id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class IN (3, 4, 6, 7));

	UPDATE batch 
	SET approved_on = now(),
		approved_by = (select entity_id FROM users 
			WHERE username = SESSION_USER)
	WHERE id = in_batch_id;

	RETURN now()::date;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean) -->
    <section id="lsmb13.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean"
             xreflabel="lsmb13batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)">
      <title id="lsmb13.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-title">
       batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-titleabbrev">
       batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of batches and amounts processed on the batch.

Nulls match all values.
in_date_from and in_date_to specify date ranges.
in_description is a partial match.
All other criteria are exact matches.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
		SELECT b.id, c.class, b.control_code, b.description, u.username,
			b.created_on, b.default_date,
			sum(
				CASE WHEN vc.id = 5 AND al.amount &lt; 0 -- GL
				     THEN al.amount 
				     WHEN vc.id  = 1
				     THEN ap.amount 
				     WHEN vc.id = 2
                                     THEN ap.amount
				     ELSE 0
                                END) AS transaction_total,
			sum(
				CASE WHEN alc.link = &#39;AR&#39; AND vc.id IN (6, 7)
				     THEN al.amount
				     WHEN alc.link = &#39;AP&#39; AND vc.id IN (3, 4)
				     THEN al.amount * -1
				     ELSE 0
				END
			   ) AS payment_total
		FROM batch b
		JOIN batch_class c ON (b.batch_class_id = c.id)
		LEFT JOIN users u ON (u.entity_id = b.created_by)
		LEFT JOIN voucher v ON (v.batch_id = b.id)
		LEFT JOIN batch_class vc ON (v.batch_class = vc.id)
		LEFT JOIN ar ON (vc.id = 2 AND v.trans_id = ar.id)
		LEFT JOIN ap ON (vc.id = 1 AND v.trans_id = ap.id)
		LEFT JOIN acc_trans al ON 
			((vc.id = 5 AND v.trans_id = al.trans_id) OR
				(vc.id IN (3, 4, 6, 7) 
					AND al.voucher_id = v.id))
		LEFT JOIN chart alc ON (al.chart_id = alc.id)
		WHERE (c.id = in_class_id OR in_class_id IS NULL) AND 
			(b.description LIKE 
				&#39;%&#39; || in_description || &#39;%&#39; OR
				in_description IS NULL) AND
			(in_created_by_eid = b.created_by OR
				in_created_by_eid IS NULL) AND
			((in_approved = false OR in_approved IS NULL AND
				approved_on IS NULL) OR
				(in_approved = true AND approved_on IS NOT NULL)
			) 
			and (in_date_from IS NULL 
				or b.default_date &gt;= in_date_from)
			and (in_date_to IS NULL
				or b.default_date &lt;= in_date_to)
		GROUP BY b.id, c.class, b.description, u.username, b.created_on,
			b.control_code, b.default_date
		HAVING  
			(in_amount_gt IS NULL OR
			sum(coalesce(ar.amount - ar.paid, ap.amount - ap.paid, 
				al.amount)) 
			&gt;= in_amount_gt) 
			AND 
			(in_amount_lt IS NULL OR
			sum(coalesce(ar.amount - ar.paid, ap.amount - ap.paid, 
				al.amount))
			&lt;= in_amount_lt)
		ORDER BY b.control_code, b.description
		
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean) -->
    <section id="lsmb13.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean"
             xreflabel="lsmb13batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)">
      <title id="lsmb13.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-title">
       batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-titleabbrev">
       batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a full search for the batches, listing them by amount processed.
in_amount_gt and in_amount_lt provide a range to search for.
in_description is a partial match field.
Other fields are exact matches.

NULLs match all values.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
               SELECT b.id, c.class, b.control_code, b.description, u.username,
                        b.created_on, b.default_date, 0, 0
                FROM batch b
                JOIN batch_class c ON (b.batch_class_id = c.id)
                JOIN users u ON (u.entity_id = b.created_by)
                LEFT JOIN voucher v ON (v.batch_id = b.id) 
               where v.id is null
                     and(u.entity_id = in_created_by_eid 
                     or in_created_by_eid is null) and
                     (in_description is null or b.description 
                     like &#39;%&#39;  || in_description || &#39;%&#39;) and
                     (in_class_id is null or c.id = in_class_id)
            GROUP BY b.id, c.class, b.description, u.username, b.created_on, 
                     b.control_code, b.default_date
            ORDER BY b.control_code, b.description

		
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean) -->
    <section id="lsmb13.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean"
             xreflabel="lsmb13batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)">
      <title id="lsmb13.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean-title">
       batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean-titleabbrev">
       batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This performs a simple search of open batches created by the entity_id
in question.  This is used to pull up batches that were currently used so that
they can be picked up and more vouchers added.

NULLs match all values.
in_description is a partial match
All other inouts are exact matches.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
		SELECT b.id, c.class, b.control_code, b.description, u.username,
			b.created_on, b.default_date, NULL
		FROM batch b
		JOIN batch_class c ON (b.batch_class_id = c.id)
		LEFT JOIN users u ON (u.entity_id = b.created_by)
		WHERE (c.id = in_class_id OR in_class_id IS NULL) AND 
			(b.description LIKE 
				&#39;%&#39; || in_description || &#39;%&#39; OR
				in_description IS NULL) AND
			(in_created_by_eid = b.created_by OR
				in_created_by_eid IS NULL) AND
			((in_approved = false OR in_approved IS NULL AND
				approved_on IS NULL) OR
				(in_approved = true AND approved_on IS NOT NULL)
			)
		GROUP BY b.id, c.class, b.description, u.username, b.created_on,
			b.control_code, b.default_date
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__approve(in_id integer) -->
    <section id="lsmb13.function.budget-approve-in-id-integer"
             xreflabel="lsmb13budget__approve(in_id integer)">
      <title id="lsmb13.function.budget-approve-in-id-integer-title">
       budget__approve(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-approve-in-id-integer-titleabbrev">
       budget__approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
UPDATE budget_info 
   set approved_at = now(), approved_by = person__get_my_entity_id()
 WHERE id = $1;

SELECT budget__get_info($1);
</programlisting>
      </para>
    </section>

<!-- Function budget__get_details(in_id integer) -->
    <section id="lsmb13.function.budget-get-details-in-id-integer"
             xreflabel="lsmb13budget__get_details(in_id integer)">
      <title id="lsmb13.function.budget-get-details-in-id-integer-title">
       budget__get_details(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-get-details-in-id-integer-titleabbrev">
       budget__get_details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_line</seg>
        </seglistitem>
       </segmentedlist>
 
        This retrieves the budget lines associated with a budget.
        <programlisting>
  SELECT * FROM budget_line where budget_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function budget__get_info(in_id integer) -->
    <section id="lsmb13.function.budget-get-info-in-id-integer"
             xreflabel="lsmb13budget__get_info(in_id integer)">
      <title id="lsmb13.function.budget-get-info-in-id-integer-title">
       budget__get_info(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-get-info-in-id-integer-titleabbrev">
       budget__get_info(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        Selects the budget info. 
        <programlisting> 
select bi.id, bi.start_date, bi.end_date, bi.reference, bi.description, 
       bi.entered_by, bi.approved_by, bi.obsolete_by, bi.entered_at, 
       bi.approved_at, bi.obsolete_at, 
       ee.name, ae.name, oe.name, bd.department_id, d.description, 
       bp.project_id, p.projectnumber
  from budget_info bi
  JOIN entity ee ON bi.entered_by = ee.id
  LEFT JOIN budget_to_department bd ON bd.budget_id = bi.id
  LEFT JOIN entity ae ON bi.approved_by = ae.id
  LEFT JOIN entity oe ON bi.obsolete_by = oe.id
  LEFT JOIN budget_to_project bp ON bp.budget_id = bi.id
  LEFT JOIN department d ON d.id = bd.department_id
  LEFT JOIN project p ON bp.project_id = p.id
 where bi.id = $1; 
</programlisting>
      </para>
    </section>

<!-- Function budget__get_notes(in_id integer) -->
    <section id="lsmb13.function.budget-get-notes-in-id-integer"
             xreflabel="lsmb13budget__get_notes(in_id integer)">
      <title id="lsmb13.function.budget-get-notes-in-id-integer-title">
       budget__get_notes(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-get-notes-in-id-integer-titleabbrev">
       budget__get_notes(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all notes associated with a budget, by default in the order they 
were created.
        <programlisting> 
SELECT * FROM budget_note WHERE ref_key = $1
 ORDER BY created;
</programlisting>
      </para>
    </section>

<!-- Function budget__mark_obsolete(in_id integer) -->
    <section id="lsmb13.function.budget-mark-obsolete-in-id-integer"
             xreflabel="lsmb13budget__mark_obsolete(in_id integer)">
      <title id="lsmb13.function.budget-mark-obsolete-in-id-integer-title">
       budget__mark_obsolete(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-mark-obsolete-in-id-integer-titleabbrev">
       budget__mark_obsolete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        Marks a budget as obsolete 
        <programlisting>
UPDATE budget_info 
   set obsolete_by = person__get_my_entity_id(), obsolete_at = now()
 WHERE id = $1 and approved_by is not null;
SELECT budget__get_info($1)
</programlisting>
      </para>
    </section>

<!-- Function budget__reject(in_id integer) -->
    <section id="lsmb13.function.budget-reject-in-id-integer"
             xreflabel="lsmb13budget__reject(in_id integer)">
      <title id="lsmb13.function.budget-reject-in-id-integer-title">
       budget__reject(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-reject-in-id-integer-titleabbrev">
       budget__reject(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes unapproved budgets only.
        <programlisting>
BEGIN

DELETE FROM budget_line 
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_to_project
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_to_department
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_info WHERE id = in_id AND approved_by IS NULL;

RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_details(in_details integer, in_id text[]) -->
    <section id="lsmb13.function.budget-save-details-in-details-integer-in-id-textARRAY"
             xreflabel="lsmb13budget__save_details(in_details integer, in_id text[])">
      <title id="lsmb13.function.budget-save-details-in-details-integer-in-id-textARRAY-title">
       budget__save_details(in_details integer, in_id text[])
      </title>
      <titleabbrev id="lsmb13.function.budget-save-details-in-details-integer-in-id-textARRAY-titleabbrev">
       budget__save_details(in_details integer, in_id text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        This saves the line items for the budget.  in_details is an array n long
where each entry is {int account_id, text description, numeric amount}.  The
in_id parameter is the budget_id.
        <programlisting>
DECLARE
   loop_count int;
   retval budget_info_ext;
BEGIN
    FOR loop_count in   
        array_lower(in_details, 1) ..
        array_upper(in_details, 1)
    LOOP
        INSERT INTO budget_line 
                    (budget_id, 
                     account_id, 
                     description, 
                     amount)
             VALUES (in_id, 
                     in_details[loop_count][1]::int, 
                     in_details[loop_count][2], 
                     in_details[loop_count][3]::numeric);
    END LOOP;
    retval := budget__get_info(in_id);
    return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_info(in_project_id integer, in_department_id date, in_description date, in_reference text, in_end_date text, in_start_date integer, in_id integer) -->
    <section id="lsmb13.function.budget-save-info-in-project-id-integer-in-department-id-date-in-description-date-in-reference-text-in-end-date-text-in-start-date-integer-in-id-integer"
             xreflabel="lsmb13budget__save_info(in_project_id integer, in_department_id date, in_description date, in_reference text, in_end_date text, in_start_date integer, in_id integer)">
      <title id="lsmb13.function.budget-save-info-in-project-id-integer-in-department-id-date-in-description-date-in-reference-text-in-end-date-text-in-start-date-integer-in-id-integer-title">
       budget__save_info(in_project_id integer, in_department_id date, in_description date, in_reference text, in_end_date text, in_start_date integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-save-info-in-project-id-integer-in-department-id-date-in-description-date-in-reference-text-in-end-date-text-in-start-date-integer-in-id-integer-titleabbrev">
       budget__save_info(in_project_id integer, in_department_id date, in_description date, in_reference text, in_end_date text, in_start_date integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves the extended budget info passed through to the function.  See the 
comment on type budget_info_ext for more information.
        <programlisting>
DECLARE 
   retval budget_info_ext;
   t_id int;
BEGIN
  UPDATE budget_info
     SET start_date = in_start_date,
         end_date = in_end_date,
         reference = in_reference,
         description = in_description
   WHERE id = in_id and approved_by is null;
  IF FOUND THEN
      t_id := in_id;
  ELSE
       PERFORM * FROM budget_info WHERE id = in_id and approved_by is not null;
       IF FOUND THEN
           RAISE EXCEPTION &#39;report approved&#39;;
       END IF;
       INSERT INTO budget_info (start_date, end_date, reference, description)
            VALUES (in_start_date, in_end_date, in_reference, in_description);
       t_id = currval(&#39;budget_info_id_seq&#39;);
  END IF;
  IF in_project_id IS NOT NULL THEN
     UPDATE budget_to_project 
        SET project_id = in_project_id 
      WHERE budget_id = t_id;

     IF NOT FOUND THEN
        INSERT INTO budget_to_project(budget_id, project_id)
             VALUES (t_id, in_project_id);
     END IF;
  END IF;
  IF in_department_id IS NOT NULL THEN
     UPDATE budget_to_department 
        SET department_id = in_department_id 
      WHERE budget_id = t_id;

     IF NOT FOUND THEN
        INSERT INTO budget_to_department(budget_id, department_id)
             VALUES (t_id, in_department_id);
     END IF;
  END IF;
  retval := budget__get_info(t_id);
  return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_note(in_note integer, in_subject text, in_id text) -->
    <section id="lsmb13.function.budget-save-note-in-note-integer-in-subject-text-in-id-text"
             xreflabel="lsmb13budget__save_note(in_note integer, in_subject text, in_id text)">
      <title id="lsmb13.function.budget-save-note-in-note-integer-in-subject-text-in-id-text-title">
       budget__save_note(in_note integer, in_subject text, in_id text)
      </title>
      <titleabbrev id="lsmb13.function.budget-save-note-in-note-integer-in-subject-text-in-id-text-titleabbrev">
       budget__save_note(in_note integer, in_subject text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a note attached to a budget.
        <programlisting>
INSERT INTO budget_note (subject, note, ref_key) 
     values ($2, $3, $1);

SELECT * FROM budget_note WHERE id = currval(&#39;note_id_seq&#39;::regclass);
</programlisting>
      </para>
    </section>

<!-- Function budget__search(in_is_obsolete date, in_is_approved date, in_project_id date, in_department_id text, in_obsolete_by text, in_approved_by integer, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer, in_end_date boolean, in_start_date boolean) -->
    <section id="lsmb13.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-project-id-date-in-department-id-text-in-obsolete-by-text-in-approved-by-integer-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integer-in-end-date-boolean-in-start-date-boolean"
             xreflabel="lsmb13budget__search(in_is_obsolete date, in_is_approved date, in_project_id date, in_department_id text, in_obsolete_by text, in_approved_by integer, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer, in_end_date boolean, in_start_date boolean)">
      <title id="lsmb13.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-project-id-date-in-department-id-text-in-obsolete-by-text-in-approved-by-integer-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integer-in-end-date-boolean-in-start-date-boolean-title">
       budget__search(in_is_obsolete date, in_is_approved date, in_project_id date, in_department_id text, in_obsolete_by text, in_approved_by integer, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer, in_end_date boolean, in_start_date boolean)
      </title>
      <titleabbrev id="lsmb13.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-project-id-date-in-department-id-text-in-obsolete-by-text-in-approved-by-integer-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integer-in-end-date-boolean-in-start-date-boolean-titleabbrev">
       budget__search(in_is_obsolete date, in_is_approved date, in_project_id date, in_department_id text, in_obsolete_by text, in_approved_by integer, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer, in_end_date boolean, in_start_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a general search for budgets
        <programlisting>
select bi.id, bi.start_date, bi.end_date, bi.reference, bi.description, 
       bi.entered_by, bi.approved_by, bi.obsolete_by, bi.entered_at, 
       bi.approved_at, bi.obsolete_at, 
       ee.name, ae.name, oe.name, bd.department_id, d.description, 
       bp.project_id, p.projectnumber
  from budget_info bi 
  JOIN entity ee ON bi.entered_by = ee.id
  LEFT JOIN budget_to_department bd ON bd.budget_id = bi.id
  LEFT JOIN entity ae ON bi.approved_by = ae.id
  LEFT JOIN entity oe ON bi.obsolete_by = oe.id
  LEFT JOIN budget_to_project bp ON bp.budget_id = bi.id
  LEFT JOIN department d ON d.id = bd.department_id
  LEFT JOIN project p ON bp.project_id = p.id
 WHERE (start_date = $1 or $1 is null) AND ($2 = end_date or $2 is null) 
       AND ($3 BETWEEN start_date AND end_date or $2 is null)
       AND ($4 ilike reference || &#39;%&#39; or $4 is null) 
       AND (bi.description @@ plainto_tsquery($5) or $5 is null) 
       AND ($6 = entered_by or $6 is null) 
       AND ($7 = approved_by or $7 is null) 
       AND ($8 = obsolete_by or $8 is null) 
       AND ($9 = department_id OR $9 is null) 
       AND ($10 = project_id OR  $10 IS NULL)
       AND ($11 IS NULL OR ($11 = (approved_by IS NOT NULL)))
       AND ($12 IS NULL OR ($12 = (obsolete_by IS NOT NULL)))
 ORDER BY department_id, project_id, reference;
</programlisting>
      </para>
    </section>

<!-- Function budget__variance_report(in_id integer) -->
    <section id="lsmb13.function.budget-variance-report-in-id-integer"
             xreflabel="lsmb13budget__variance_report(in_id integer)">
      <title id="lsmb13.function.budget-variance-report-in-id-integer-title">
       budget__variance_report(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.budget-variance-report-in-id-integer-titleabbrev">
       budget__variance_report(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_variance_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a variance report for budget with an id of in_id.
        <programlisting>
   WITH agg_account (amount, id, transdate)
        AS ( SELECT ac.amount *
                    CASE WHEN a.contra THEN -1 ELSE 1 END *
                    CASE WHEN a.category IN (&#39;A&#39;, &#39;E&#39;) THEN -1 ELSE 1 END
                    AS amount,
                    ac.chart_id, ac.transdate
               FROM acc_trans ac
               JOIN account a ON ac.chart_id = a.id
           )
   SELECT act.accno, act.description, act.id, b.description, b.amount,
          coalesce(sum(a.amount), 0), 
          b.amount - coalesce(sum(a.amount), 0) AS variance
     FROM budget_info bi
     JOIN budget_line b ON bi.id = b.budget_id
     JOIN account act ON act.id = b.account_id
LEFT JOIN agg_account a ON a.transdate BETWEEN bi.start_date and bi.end_date
                           AND a.id = b.account_id
    WHERE bi.id = $1
 GROUP BY act.accno, act.description, act.id, b.description, b.amount
 ORDER BY act.accno;
</programlisting>
      </para>
    </section>

<!-- Function business_type__list() -->
    <section id="lsmb13.function.business-type-list"
             xreflabel="lsmb13business_type__list()">
      <title id="lsmb13.function.business-type-list-title">
       business_type__list()
      </title>
      <titleabbrev id="lsmb13.function.business-type-list-titleabbrev">
       business_type__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF business</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of all business types. Ordered by description by default.
        <programlisting>
DECLARE out_row business%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM business ORDER BY description LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_get_ar_ap(in_account_class integer) -->
    <section id="lsmb13.function.chart-get-ar-ap-in-account-class-integer"
             xreflabel="lsmb13chart_get_ar_ap(in_account_class integer)">
      <title id="lsmb13.function.chart-get-ar-ap-in-account-class-integer-title">
       chart_get_ar_ap(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.chart-get-ar-ap-in-account-class-integer-titleabbrev">
       chart_get_ar_ap(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the cash account acording with in_account_class which 
must be 1 or 2.

If in_account_class is 1 then it returns a list of AP accounts, and if 
in_account_class is 2, then a list of AR accounts.
        <programlisting>
DECLARE out_row chart%ROWTYPE;
BEGIN
	IF in_account_class NOT IN (1, 2) THEN
		RAISE EXCEPTION &#39;Bad Account Type&#39;;
	END IF;
       FOR out_row IN
               SELECT * FROM chart 
               WHERE link = CASE WHEN in_account_class = 1 THEN &#39;AP&#39;
                               WHEN in_account_class = 2 THEN &#39;AR&#39;
                               END
               ORDER BY accno
       LOOP
               RETURN NEXT out_row;
       END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_all() -->
    <section id="lsmb13.function.chart-list-all"
             xreflabel="lsmb13chart_list_all()">
      <title id="lsmb13.function.chart-list-all-title">
       chart_list_all()
      </title>
      <titleabbrev id="lsmb13.function.chart-list-all-titleabbrev">
       chart_list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates a list of chart view entries.
        <programlisting>
DECLARE out_row chart%ROWTYPE;
BEGIN
	FOR out_row IN 
		SELECT * FROM chart ORDER BY accno
	LOOP
		RETURN next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_cash(in_account_class integer) -->
    <section id="lsmb13.function.chart-list-cash-in-account-class-integer"
             xreflabel="lsmb13chart_list_cash(in_account_class integer)">
      <title id="lsmb13.function.chart-list-cash-in-account-class-integer-title">
       chart_list_cash(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.chart-list-cash-in-account-class-integer-titleabbrev">
       chart_list_cash(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the overpayment accounts acording with 
in_account_class which must be 1 or 2.

If in_account_class is 1 it returns a list of AP cash accounts and 
if 2, AR cash accounts.
        <programlisting>
 DECLARE resultrow record;
         link_string text;
 BEGIN
         IF in_account_class = 1 THEN
            link_string := &#39;%AP_paid%&#39;;
         ELSE 
            link_string := &#39;%AR_paid%&#39;;
         END IF;
 
         FOR resultrow IN
           SELECT *  FROM chart
           WHERE link LIKE link_string
           ORDER BY accno
           LOOP
           return next resultrow;
         END LOOP;
 END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_discount(in_account_class integer) -->
    <section id="lsmb13.function.chart-list-discount-in-account-class-integer"
             xreflabel="lsmb13chart_list_discount(in_account_class integer)">
      <title id="lsmb13.function.chart-list-discount-in-account-class-integer-title">
       chart_list_discount(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.chart-list-discount-in-account-class-integer-titleabbrev">
       chart_list_discount(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the discount accounts acording with in_account_class 
which must be 1 or 2.

If in_account_class is 1, returns AP discount accounts, if 2, AR discount 
accounts.
        <programlisting>
DECLARE resultrow record;
        link_string text;
BEGIN
        IF in_account_class = 1 THEN
           link_string := &#39;%AP_discount%&#39;;
        ELSE
           link_string := &#39;%AR_discount%&#39;;
        END IF;

        FOR resultrow IN
          SELECT *  FROM chart
          WHERE link LIKE link_string
          ORDER BY accno
          LOOP
          return next resultrow;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_overpayment(in_account_class integer) -->
    <section id="lsmb13.function.chart-list-overpayment-in-account-class-integer"
             xreflabel="lsmb13chart_list_overpayment(in_account_class integer)">
      <title id="lsmb13.function.chart-list-overpayment-in-account-class-integer-title">
       chart_list_overpayment(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.chart-list-overpayment-in-account-class-integer-titleabbrev">
       chart_list_overpayment(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of AP_overpayment accounts if in_account_class is 1
Otherwise it returns a list of AR_overpayment accounts.
        <programlisting>
DECLARE resultrow record;
        link_string text;
BEGIN
        IF in_account_class = 1 THEN
           link_string := &#39;%AP_overpayment%&#39;;
        ELSE 
           link_string := &#39;%AR_overpayment%&#39;;
        END IF;

        FOR resultrow IN
          SELECT *  FROM chart
          WHERE link LIKE link_string
          ORDER BY accno
          LOOP
          return next resultrow;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_search(in_link_desc text, in_search text) -->
    <section id="lsmb13.function.chart-list-search-in-link-desc-text-in-search-text"
             xreflabel="lsmb13chart_list_search(in_link_desc text, in_search text)">
      <title id="lsmb13.function.chart-list-search-in-link-desc-text-in-search-text-title">
       chart_list_search(in_link_desc text, in_search text)
      </title>
      <titleabbrev id="lsmb13.function.chart-list-search-in-link-desc-text-in-search-text-titleabbrev">
       chart_list_search(in_link_desc text, in_search text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        This returns a list of account entries where the description or account 
number begins with in_search.

If in_link_desc is provided, the list is further filtered by which accounts are 
set to an account_link.description equal to that provided.
        <programlisting>
DECLARE out_row account%ROWTYPE;
BEGIN
	FOR out_row IN 
		SELECT * FROM account 
                 WHERE (accno ~* (&#39;^&#39;||in_search) 
                       OR description ~* (&#39;^&#39;||in_search))
                       AND (in_link_desc IS NULL 
                           or id in 
                          (select account_id from account_link 
                            where description = in_link_desc))
                       AND not obsolete
              ORDER BY accno
	LOOP
		RETURN next out_row;
	END LOOP;
END;</programlisting>
      </para>
    </section>

<!-- Function check_department() -->
    <section id="lsmb13.function.check-department"
             xreflabel="lsmb13check_department()">
      <title id="lsmb13.function.check-department-title">
       check_department()
      </title>
      <titleabbrev id="lsmb13.function.check-department-titleabbrev">
       check_department()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

declare
  dpt_id int;

begin
 
  if new.department_id = 0 then
    delete from dpt_trans where trans_id = new.id;
    return NULL;
  end if;

  select into dpt_id trans_id from dpt_trans where trans_id = new.id;
  
  if dpt_id &gt; 0 then
    update dpt_trans set department_id = new.department_id where trans_id = dpt_id;
  else
    insert into dpt_trans (trans_id, department_id) values (new.id, new.department_id);
  end if;
return NULL;

end;
</programlisting>
      </para>
    </section>

<!-- Function check_expiration() -->
    <section id="lsmb13.function.check-expiration"
             xreflabel="lsmb13check_expiration()">
      <title id="lsmb13.function.check-expiration-title">
       check_expiration()
      </title>
      <titleabbrev id="lsmb13.function.check-expiration-titleabbrev">
       check_expiration()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks whether the user needs to be notified of a pending expiration of 
his/her password.  Returns true if needed, false if not.

The function also records the next time when the notification will again need to
be displayed. 
        <programlisting>
DECLARE test_result BOOL;
	expires_in interval;
	notify_again interval;
BEGIN
	expires_in := user__check_my_expiration();

	SELECT expires_in &lt; notify_password INTO test_result
	FROM users WHERE username = SESSION_USER;

	IF test_result THEN 
		IF expires_in &lt; &#39;1 week&#39; THEN
			notify_again := &#39;1 hour&#39;;
		ELSE
			notify_again := &#39;1 day&#39;;
		END IF;

		UPDATE users 
		SET notify_password = expires_in - notify_again
		WHERE username = SESSION_USER;
	END IF;
	RETURN test_result;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric) -->
    <section id="lsmb13.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric"
             xreflabel="lsmb13cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)">
      <title id="lsmb13.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric-title">
       cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb13.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric-titleabbrev">
       cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_cp account_checkpoint;
        t_ar ar;
        t_avail numeric;
BEGIN


IF in_qty &gt; 0 THEN
   return cogs__reverse_ap(in_parts_id, in_qty * -1) * in_lastcost;
END IF;

SELECT * INTO t_cp FROM account_checkpoint ORDER BY end_date DESC LIMIT 1;

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN ar a ON a.id = i.trans_id
     WHERE qty + allocated &gt; 0 and parts_id  = in_parts_id
  ORDER BY a.transdate, a.id, i.id
LOOP
   t_avail := t_inv.qty + t_inv.allocated;
   SELECT * INTO t_ar FROM ar WHERE id = t_inv.trans_id;
   IF t_alloc &lt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return t_alloc;
   ELSIF (in_qty + t_alloc) * -1 &lt;=  t_avail  THEN
       UPDATE invoice SET allocated = allocated + (in_qty + t_alloc)
        WHERE id = t_inv.id;

       INSERT INTO acc_trans 
              (chart_id, transdate, amount, invoice_id, approved, trans_id)
       SELECT expense_accno_id, 
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, (in_qty + t_alloc) * in_lastcost, t_inv.id, true,
              t_inv.trans_id
         FROM parts 
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL
       UNION
       SELECT income_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, -1 * (in_qty + t_alloc) * in_lastcost, t_inv.id, true,
              t_inv.trans_id
         FROM parts 
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL;
                                    
       t_cogs := t_cogs + (in_qty + t_alloc) * in_lastcost;
       return in_qty * -1;
   ELSE
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_cogs := t_cogs + t_avail * in_lastcost;

       INSERT INTO acc_trans
              (chart_id, transdate, amount, invoice_id, approved, trans_id)
       SELECT expense_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END,  -1 * t_avail * in_lastcost, 
              t_inv.id, true, t_inv.trans_id
         FROM parts
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL
       UNION
       SELECT income_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, -t_avail * in_lastcost, t_inv.id, true, t_inv.trans_id
         FROM parts
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL;
       t_alloc := t_alloc + t_avail;
       t_cogs := t_cogs + t_avail * in_lastcost;
   END IF;


END LOOP;

RETURN t_alloc;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ap_line(in_invoice_id integer) -->
    <section id="lsmb13.function.cogs-add-for-ap-line-in-invoice-id-integer"
             xreflabel="lsmb13cogs__add_for_ap_line(in_invoice_id integer)">
      <title id="lsmb13.function.cogs-add-for-ap-line-in-invoice-id-integer-title">
       cogs__add_for_ap_line(in_invoice_id integer)
      </title>
      <titleabbrev id="lsmb13.function.cogs-add-for-ap-line-in-invoice-id-integer-titleabbrev">
       cogs__add_for_ap_line(in_invoice_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval numeric;
        r_cogs numeric[];
        t_inv invoice;
        t_adj numeric;
        t_ap  ap;
BEGIN

SELECT * INTO t_inv FROM invoice 
 WHERE id = in_invoice_id;

IF t_inv.qty + t_inv.allocated = 0 THEN
   return 0;
END IF;

SELECT * INTO t_ap FROM ap WHERE id = t_inv.trans_id;

IF t_inv.qty &lt; 0 THEN -- normal COGS

    SELECT cogs__add_for_ap(i.parts_id, i.qty + i.allocated, i.sellprice) 
      INTO retval
      FROM invoice i
      JOIN parts p ON p.id = i.parts_id
     WHERE i.id = $1;

    UPDATE invoice 
       SET allocated = allocated + retval
     WHERE id = $1;
ELSE -- reversal

   r_cogs := cogs__reverse_ap(t_inv.parts_id, t_inv.qty + t_inv.allocated);

   UPDATE invoice
      SET allocated = allocated + r_cogs[1]
    WHERE id = in_invoice_id;

   t_adj := t_inv.sellprice * r_cogs[1] + r_cogs[2];

   INSERT INTO acc_trans 
          (chart_id, trans_id, approved,  amount, transdate, invoice_id)
   SELECT p.inventory_accno_id, t_inv.trans_id, true, t_adj, t_ap.transdate, 
          in_invoice_id
     FROM parts p
    WHERE id = t_inv.parts_id
    UNION
   SELECT p.expense_accno_id, t_inv.trans_id, true, t_adj * -1, t_ap.transdate,
          in_invoice_id
     FROM parts p
    WHERE id = t_inv.parts_id;
   retval := r_cogs[1];
   raise notice &#39;cogs reversal returned %&#39;, r_cogs;

END IF;

RETURN retval;

END;

</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ar(in_qty integer, in_parts_id numeric) -->
    <section id="lsmb13.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric"
             xreflabel="lsmb13cogs__add_for_ar(in_qty integer, in_parts_id numeric)">
      <title id="lsmb13.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric-title">
       cogs__add_for_ar(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb13.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__add_for_ar(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
        This function accepts a parts_id and a quantity, and iterates through AP 
records in order, calculating COGS on a FIFO basis and returning it to the 
application to attach to the current transaction.

Return values are an array of {allocated, cogs}.

        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_avail numeric;
BEGIN


FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN (select id, approved, transdate from ap
             union
            select id, approved, transdate from gl) a ON a.id = i.trans_id
     WHERE qty + allocated &lt; 0 AND i.parts_id = in_parts_id
  ORDER BY a.transdate asc, a.id asc, i.id asc
LOOP
   t_avail := (t_inv.qty + t_inv.allocated) * -1;
   IF t_alloc &gt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty + t_alloc) &lt;= t_avail THEN
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       t_cogs := t_cogs + (in_qty - t_alloc) * t_inv.sellprice;
       t_alloc := in_qty;
       return ARRAY[t_alloc, t_cogs];
   ELSE
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_cogs := t_cogs + (t_avail * t_inv.sellprice);
       t_alloc := t_alloc + t_avail;
   END IF;
END LOOP;

RETURN ARRAY[t_alloc, t_cogs];

END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ar_line(in_invoice_id integer) -->
    <section id="lsmb13.function.cogs-add-for-ar-line-in-invoice-id-integer"
             xreflabel="lsmb13cogs__add_for_ar_line(in_invoice_id integer)">
      <title id="lsmb13.function.cogs-add-for-ar-line-in-invoice-id-integer-title">
       cogs__add_for_ar_line(in_invoice_id integer)
      </title>
      <titleabbrev id="lsmb13.function.cogs-add-for-ar-line-in-invoice-id-integer-titleabbrev">
       cogs__add_for_ar_line(in_invoice_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   t_cogs numeric[];
   t_inv invoice;
   t_part parts;
   t_ar ar;
   t_transdate date;
BEGIN

SELECT * INTO t_inv FROM invoice WHERE id = in_invoice_id;
SELECT * INTO t_part FROM parts WHERE id = t_inv.parts_id;
SELECT * INTO t_ar FROM ar WHERE id = t_inv.trans_id;

IF t_inv.qty + t_inv.allocated = 0 THEN
   return 0;
END IF;

IF t_inv.qty &gt; 0 THEN 
   t_cogs := cogs__add_for_ar(t_inv.parts_id, t_inv.qty + t_inv.allocated);
ELSE
   t_cogs := cogs__reverse_ar(t_inv.parts_id, t_inv.qty + t_inv.allocated);
END IF;


UPDATE invoice set allocated = allocated - t_cogs[1]
 WHERE id = in_invoice_id;

SELECT CASE WHEN t_ar.transdate &gt; max(end_date) THEN t_ar.transdate
            ELSE max(end_date) + &#39;1 day&#39;::interval
        END INTO t_transdate
  from account_checkpoint td; 
INSERT INTO acc_trans 
       (trans_id, chart_id, approved, amount, transdate,  invoice_id)
VALUES (t_inv.trans_id, CASE WHEN t_inv.qty &lt; 0 AND t_ar.is_return 
                           THEN t_part.returns_accno_id
                           ELSE t_part.expense_accno_id
                      END, TRUE, t_cogs[2] * -1, t_transdate, t_inv.id),
       (t_inv.trans_id, t_part.inventory_accno_id, TRUE, t_cogs[2], 
       t_transdate, t_inv.id);

RETURN t_cogs[1];

END;

</programlisting>
      </para>
    </section>

<!-- Function cogs__reverse_ap(in_qty integer, in_parts_id numeric) -->
    <section id="lsmb13.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric"
             xreflabel="lsmb13cogs__reverse_ap(in_qty integer, in_parts_id numeric)">
      <title id="lsmb13.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric-title">
       cogs__reverse_ap(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb13.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__reverse_ap(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
        This function iterates through invoice rows attached to ap transactions and 
allocates them on a first-in first-out basis.  The sort of pseudo-&quot;COGS&quot; value 
is returned to the application for further handling.
        <programlisting>
DECLARE t_alloc numeric :=0;
        t_inv invoice;
        t_cogs numeric :=0;
        retval numeric[];
BEGIN
RAISE NOTICE &#39;reversing AP: parts_id %, qty %&#39;, in_parts_id, in_qty;

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN ap a ON a.id = i.trans_id
     WHERE qty + allocated &lt; 0 AND parts_id = in_parts_id
  ORDER BY a.transdate, a.id, i.id
LOOP
   RAISE NOTICE &#39;id %, avail %, allocated %, requesting %&#39;, t_inv.id, t_inv.qty + t_inv.allocated, t_alloc, in_qty - t_alloc;
   IF t_alloc &gt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty - t_alloc) &lt;= -1 * (t_inv.qty + t_inv.allocated) THEN
       raise notice &#39;partial reversal&#39;;
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       return ARRAY[in_qty * -1, t_cogs + (in_qty - t_alloc) * t_inv.sellprice];
   ELSE
       raise notice &#39;total reversal&#39;;
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_alloc := t_alloc - (t_inv.qty + t_inv.allocated);
       t_cogs := t_cogs - (t_inv.qty + t_inv.allocated) * t_inv.sellprice;
   END IF;
END LOOP;

RETURN ARRAY[t_alloc, t_cogs];

RAISE EXCEPTION &#39;TOO FEW TO ALLOCATE&#39;;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__reverse_ar(in_qty integer, in_parts_id numeric) -->
    <section id="lsmb13.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric"
             xreflabel="lsmb13cogs__reverse_ar(in_qty integer, in_parts_id numeric)">
      <title id="lsmb13.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric-title">
       cogs__reverse_ar(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb13.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__reverse_ar(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
       This function accepts a part id and quantity to reverse.  It then iterates 
backwards over AP related records, calculating COGS.  This does not save COGS
but rather returns it to the application to save.

Return values are an array of {allocated, cogs}.

        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_avail numeric;
BEGIN

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN (select id, approved, transdate from ap 
            union
            select id, approved, transdate from gl) a ON a.id = i.trans_id
     WHERE allocated &gt; 0 and a.approved and parts_id = in_parts_id
  ORDER BY a.transdate DESC, a.id DESC, i.id DESC
LOOP
   t_avail := t_inv.allocated;
   IF t_alloc &lt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       RETURN ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty - t_alloc) * -1 &lt;=  t_inv.allocated THEN
       raise notice &#39;partial reversal&#39;;
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       t_cogs := t_cogs +  (in_qty - t_alloc) * t_inv.sellprice;
       return ARRAY[t_alloc + (in_qty - t_alloc), t_cogs];
   ELSE
       raise notice &#39;full reversal&#39;;
       UPDATE invoice SET allocated = 0
        WHERE id = t_inv.id;
       t_alloc := t_alloc + t_inv.allocated * -1;
       t_cogs := t_cogs + -1 * (t_inv.allocated) * t_inv.sellprice;
   END IF;
END LOOP;

RAISE EXCEPTION &#39;TOO FEW TO REVERSE&#39;;

END;
</programlisting>
      </para>
    </section>

<!-- Function company__delete_contact(in_contact integer, in_contact_class_id integer, in_company_id text) -->
    <section id="lsmb13.function.company-delete-contact-in-contact-integer-in-contact-class-id-integer-in-company-id-text"
             xreflabel="lsmb13company__delete_contact(in_contact integer, in_contact_class_id integer, in_company_id text)">
      <title id="lsmb13.function.company-delete-contact-in-contact-integer-in-contact-class-id-integer-in-company-id-text-title">
       company__delete_contact(in_contact integer, in_contact_class_id integer, in_company_id text)
      </title>
      <titleabbrev id="lsmb13.function.company-delete-contact-in-contact-integer-in-contact-class-id-integer-in-company-id-text-titleabbrev">
       company__delete_contact(in_contact integer, in_contact_class_id integer, in_company_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if at least one record was deleted.  False if no records were 
affected.
        <programlisting>
BEGIN

DELETE FROM company_to_contact
 WHERE company_id = in_company_id and contact_class_id = in_contact_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function company__delete_location(in_location_class integer, in_location_id integer, in_company_id integer) -->
    <section id="lsmb13.function.company-delete-location-in-location-class-integer-in-location-id-integer-in-company-id-integer"
             xreflabel="lsmb13company__delete_location(in_location_class integer, in_location_id integer, in_company_id integer)">
      <title id="lsmb13.function.company-delete-location-in-location-class-integer-in-location-id-integer-in-company-id-integer-title">
       company__delete_location(in_location_class integer, in_location_id integer, in_company_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-delete-location-in-location-class-integer-in-location-id-integer-in-company-id-integer-titleabbrev">
       company__delete_location(in_location_class integer, in_location_id integer, in_company_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the record identified.  Returns true if successful, false if no record
found.
        <programlisting>
BEGIN

DELETE FROM eca_to_location
 WHERE company_id = in_company_id AND location_id = in_location_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function company__get_all_accounts(in_entity_class integer, in_entity_id integer) -->
    <section id="lsmb13.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer"
             xreflabel="lsmb13company__get_all_accounts(in_entity_class integer, in_entity_id integer)">
      <title id="lsmb13.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer-title">
       company__get_all_accounts(in_entity_class integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer-titleabbrev">
       company__get_all_accounts(in_entity_class integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all entity credit accounts attached to that entity.
        <programlisting>
    
    SELECT * 
      FROM entity_credit_account 
     WHERE entity_id = $1
       AND entity_class = $2;
    
</programlisting>
      </para>
    </section>

<!-- Function company__list_bank_account(in_entity_id integer) -->
    <section id="lsmb13.function.company-list-bank-account-in-entity-id-integer"
             xreflabel="lsmb13company__list_bank_account(in_entity_id integer)">
      <title id="lsmb13.function.company-list-bank-account-in-entity-id-integer-title">
       company__list_bank_account(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-list-bank-account-in-entity-id-integer-titleabbrev">
       company__list_bank_account(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_bank_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all bank accounts for the entity.
        <programlisting>
DECLARE out_row entity_bank_account%ROWTYPE;
BEGIN
	FOR out_row IN
		SELECT * from entity_bank_account where entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function company__list_contacts(in_entity_id integer) -->
    <section id="lsmb13.function.company-list-contacts-in-entity-id-integer"
             xreflabel="lsmb13company__list_contacts(in_entity_id integer)">
      <title id="lsmb13.function.company-list-contacts-in-entity-id-integer-title">
       company__list_contacts(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-list-contacts-in-entity-id-integer-titleabbrev">
       company__list_contacts(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all contact info for the entity.
        <programlisting>
DECLARE out_row contact_list;
BEGIN
	FOR out_row IN
		SELECT cl.class, cl.id, c.description, c.contact
		FROM company_to_contact c
		JOIN contact_class cl ON (c.contact_class_id = cl.id)
		WHERE company_id = 
			(select id FROM company 
			WHERE entity_id = in_entity_id)
	LOOP
		return next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function company__list_notes(in_entity_id integer) -->
    <section id="lsmb13.function.company-list-notes-in-entity-id-integer"
             xreflabel="lsmb13company__list_notes(in_entity_id integer)">
      <title id="lsmb13.function.company-list-notes-in-entity-id-integer-title">
       company__list_notes(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-list-notes-in-entity-id-integer-titleabbrev">
       company__list_notes(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of notes (including content) attached to the entity.
        <programlisting>
DECLARE out_row record;
BEGIN
	FOR out_row IN
		SELECT *
		FROM entity_note
		WHERE ref_key = in_entity_id
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function company__location_save(in_created integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id date) -->
    <section id="lsmb13.function.company-location-save-in-created-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-date"
             xreflabel="lsmb13company__location_save(in_created integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id date)">
      <title id="lsmb13.function.company-location-save-in-created-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-date-title">
       company__location_save(in_created integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id date)
      </title>
      <titleabbrev id="lsmb13.function.company-location-save-in-created-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-date-titleabbrev">
       company__location_save(in_created integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location to a company.  Returns the location id.
        <programlisting>
    BEGIN
    return _entity_location_save(
        in_entity_id, in_location_id,
        in_location_class, in_line_one, in_line_two, 
        &#39;&#39;, in_city , in_state, in_mail_code, in_country_code);
    END;

</programlisting>
      </para>
    </section>

<!-- Function company__next_id() -->
    <section id="lsmb13.function.company-next-id"
             xreflabel="lsmb13company__next_id()">
      <title id="lsmb13.function.company-next-id-title">
       company__next_id()
      </title>
      <titleabbrev id="lsmb13.function.company-next-id-titleabbrev">
       company__next_id()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>bigint</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    select nextval(&#39;company_id_seq&#39;);
    
</programlisting>
      </para>
    </section>

<!-- Function company__save_contact(in_contact integer, in_description integer, in_contact_class text, in_entity_id text) -->
    <section id="lsmb13.function.company-save-contact-in-contact-integer-in-description-integer-in-contact-class-text-in-entity-id-text"
             xreflabel="lsmb13company__save_contact(in_contact integer, in_description integer, in_contact_class text, in_entity_id text)">
      <title id="lsmb13.function.company-save-contact-in-contact-integer-in-description-integer-in-contact-class-text-in-entity-id-text-title">
       company__save_contact(in_contact integer, in_description integer, in_contact_class text, in_entity_id text)
      </title>
      <titleabbrev id="lsmb13.function.company-save-contact-in-contact-integer-in-description-integer-in-contact-class-text-in-entity-id-text-titleabbrev">
       company__save_contact(in_contact integer, in_description integer, in_contact_class text, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves company contact information.  The return value is meaningless. 
        <programlisting>
DECLARE out_id int;
BEGIN
	INSERT INTO company_to_contact(company_id, contact_class_id, 
		description, contact)
	SELECT id, in_contact_class, in_description, in_contact FROM company
	WHERE entity_id = in_entity_id;

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function company__search(in_control_code integer, in_legal_name text, in_business_id text[], in_date_to text, in_date_from text, in_country text, in_mail_code text, in_state text, in_city text, in_address date, in_meta_number date, in_contact_info integer, in_contact text, in_account_class text) -->
    <section id="lsmb13.function.company-search-in-control-code-integer-in-legal-name-text-in-business-id-textARRAY-in-date-to-text-in-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-text-in-address-date-in-meta-number-date-in-contact-info-integer-in-contact-text-in-account-class-text"
             xreflabel="lsmb13company__search(in_control_code integer, in_legal_name text, in_business_id text[], in_date_to text, in_date_from text, in_country text, in_mail_code text, in_state text, in_city text, in_address date, in_meta_number date, in_contact_info integer, in_contact text, in_account_class text)">
      <title id="lsmb13.function.company-search-in-control-code-integer-in-legal-name-text-in-business-id-textARRAY-in-date-to-text-in-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-text-in-address-date-in-meta-number-date-in-contact-info-integer-in-contact-text-in-account-class-text-title">
       company__search(in_control_code integer, in_legal_name text, in_business_id text[], in_date_to text, in_date_from text, in_country text, in_mail_code text, in_state text, in_city text, in_address date, in_meta_number date, in_contact_info integer, in_contact text, in_account_class text)
      </title>
      <titleabbrev id="lsmb13.function.company-search-in-control-code-integer-in-legal-name-text-in-business-id-textARRAY-in-date-to-text-in-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-text-in-address-date-in-meta-number-date-in-contact-info-integer-in-contact-text-in-account-class-text-titleabbrev">
       company__search(in_control_code integer, in_legal_name text, in_business_id text[], in_date_to text, in_date_from text, in_country text, in_mail_code text, in_state text, in_city text, in_address date, in_meta_number date, in_contact_info integer, in_contact text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF company_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	out_row company_search_result;
	loop_count int;
	t_contact_info text[];
BEGIN
	t_contact_info = in_contact_info;


	FOR out_row IN
		SELECT e.id, e.control_code, c.id, ec.id, ec.meta_number, 
			ec.description, ec.entity_class, 
			c.legal_name, c.sic_code, b.description , ec.curr::text
		FROM (select * from entity where in_control_code = control_code
                      union
                      select * from entity where in_control_code is null) e
		JOIN (SELECT * FROM company 
                       WHERE legal_name ilike  &#39;%&#39; || in_legal_name || &#39;%&#39;
                      UNION ALL
                      SELECT * FROM company
                       WHERE in_legal_name IS NULL) c ON (e.id = c.entity_id)
		LEFT JOIN entity_credit_account ec ON (ec.entity_id = e.id)
		LEFT JOIN business b ON (ec.business_id = b.id)
		WHERE coalesce(ec.entity_class,e.entity_class) = in_account_class
			AND (c.id IN (select company_id FROM company_to_contact
				WHERE contact ILIKE ALL(t_contact_info))
				OR &#39;&#39; ILIKE ALL(t_contact_info)
				OR t_contact_info IS NULL)
			
			AND (c.legal_name ilike &#39;%&#39; || in_legal_name || &#39;%&#39;
				OR in_legal_name IS NULL)
			AND ((in_address IS NULL AND in_city IS NULL 
					AND in_state IS NULL 
					AND in_country IS NULL)
				OR (c.id IN 
				(select company_id FROM company_to_location
				WHERE location_id IN 
					(SELECT id FROM location
					WHERE line_one 
						ilike &#39;%&#39; || 
							coalesce(in_address, &#39;&#39;)
							|| &#39;%&#39;
						AND city ILIKE 
							&#39;%&#39; || 
							coalesce(in_city, &#39;&#39;) 
							|| &#39;%&#39;
						AND state ILIKE
							&#39;%&#39; || 
							coalesce(in_state, &#39;&#39;) 
							|| &#39;%&#39;
						AND mail_code ILIKE
							&#39;%&#39; || 
							coalesce(in_mail_code,
								&#39;&#39;)
							|| &#39;%&#39;
						AND country_id IN 
							(SELECT id FROM country
							WHERE name ILIKE &#39;%&#39; ||
								in_country ||&#39;%&#39;
								OR short_name
								ilike 
								in_country)))))
			AND (ec.business_id = 
				coalesce(in_business_id, ec.business_id)
				OR (ec.business_id IS NULL 
					AND in_business_id IS NULL))
			AND (ec.startdate &lt;= coalesce(in_date_to, 
						ec.startdate)
				OR (ec.startdate IS NULL))
			AND (ec.enddate &gt;= coalesce(in_date_from, ec.enddate)
				OR (ec.enddate IS NULL))
	 		AND (ec.meta_number = in_meta_number
			     OR in_meta_number IS NULL)
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function company_get_billing_info(in_id integer) -->
    <section id="lsmb13.function.company-get-billing-info-in-id-integer"
             xreflabel="lsmb13company_get_billing_info(in_id integer)">
      <title id="lsmb13.function.company-get-billing-info-in-id-integer-title">
       company_get_billing_info(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-get-billing-info-in-id-integer-titleabbrev">
       company_get_billing_info(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>company_billing_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns billing information (billing name and address) for a given credit 
account.
        <programlisting>
DECLARE out_var company_billing_info;
	t_id INT;
BEGIN
	select coalesce(eca.pay_to_name, c.legal_name), eca.meta_number, 
		e.control_code, c.tax_id, a.line_one, a.line_two, a.line_three, 
		a.city, a.state, a.mail_code, cc.name
	into out_var
	FROM company c
	JOIN entity e ON (c.entity_id = e.id)
	JOIN entity_credit_account eca ON (eca.entity_id = e.id)
	LEFT JOIN eca_to_location cl ON (eca.id = cl.credit_id)
	LEFT JOIN location a ON (a.id = cl.location_id)
	LEFT JOIN country cc ON (cc.id = a.country_id)
	WHERE eca.id = in_id AND (location_class = 1 or location_class is null);

	RETURN out_var;
END;
</programlisting>
      </para>
    </section>

<!-- Function company_retrieve(in_entity_id integer) -->
    <section id="lsmb13.function.company-retrieve-in-entity-id-integer"
             xreflabel="lsmb13company_retrieve(in_entity_id integer)">
      <title id="lsmb13.function.company-retrieve-in-entity-id-integer-title">
       company_retrieve(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-retrieve-in-entity-id-integer-titleabbrev">
       company_retrieve(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>company</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all attributes for the company attached to the entity.
        <programlisting>
DECLARE t_company company;
BEGIN
	SELECT * INTO t_company FROM company WHERE entity_id = in_entity_id;
	RETURN t_company;
END;
</programlisting>
      </para>
    </section>

<!-- Function company_save(in_country_id integer, in_sic_code text, in_entity_id integer, in_tax_id text, in_name text, in_entity_class integer, in_control_code text, in_id integer) -->
    <section id="lsmb13.function.company-save-in-country-id-integer-in-sic-code-text-in-entity-id-integer-in-tax-id-text-in-name-text-in-entity-class-integer-in-control-code-text-in-id-integer"
             xreflabel="lsmb13company_save(in_country_id integer, in_sic_code text, in_entity_id integer, in_tax_id text, in_name text, in_entity_class integer, in_control_code text, in_id integer)">
      <title id="lsmb13.function.company-save-in-country-id-integer-in-sic-code-text-in-entity-id-integer-in-tax-id-text-in-name-text-in-entity-class-integer-in-control-code-text-in-id-integer-title">
       company_save(in_country_id integer, in_sic_code text, in_entity_id integer, in_tax_id text, in_name text, in_entity_class integer, in_control_code text, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.company-save-in-country-id-integer-in-sic-code-text-in-entity-id-integer-in-tax-id-text-in-name-text-in-entity-class-integer-in-control-code-text-in-id-integer-titleabbrev">
       company_save(in_country_id integer, in_sic_code text, in_entity_id integer, in_tax_id text, in_name text, in_entity_class integer, in_control_code text, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a company.  Returns the id number of the record stored.
        <programlisting>
DECLARE t_entity_id INT;
	t_company_id INT;
	t_control_code TEXT;
BEGIN
	t_company_id := in_id;

	IF in_control_code IS NULL THEN
		t_control_code := setting_increment(&#39;company_control&#39;);
	ELSE
		t_control_code := in_control_code;
	END IF;

	UPDATE entity 
	SET name = in_name, 
		entity_class = in_entity_class,
		control_code = in_control_code
	WHERE id = in_entity_id;

	IF FOUND THEN
		t_entity_id = in_entity_id;
	ELSE
		INSERT INTO entity (name, entity_class, control_code,country_id)
		VALUES (in_name, in_entity_class, t_control_code,in_country_id);
		t_entity_id := currval(&#39;entity_id_seq&#39;);
	END IF;

	UPDATE company
	SET legal_name = in_name,
		tax_id = in_tax_id,
		sic_code = in_sic_code
	WHERE id = t_company_id;


	IF NOT FOUND THEN
		INSERT INTO company(entity_id, legal_name, tax_id, sic_code)
		VALUES (t_entity_id, in_name, in_tax_id, in_sic_code);

	END IF;
	RETURN t_entity_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function compound_array(anyarray) -->
    <section id="lsmb13.function.compound-array-anyarray"
             xreflabel="lsmb13compound_array(anyarray)">
      <title id="lsmb13.function.compound-array-anyarray-title">
       compound_array(anyarray)
      </title>
      <titleabbrev id="lsmb13.function.compound-array-anyarray-titleabbrev">
       compound_array(anyarray)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>anyarray</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an n dimensional array.

Example: SELECT as_array(ARRAY[id::text, class]) from contact_class

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function concat(tsvector, tsvector) -->
    <section id="lsmb13.function.concat-tsvector-tsvector"
             xreflabel="lsmb13concat(tsvector, tsvector)">
      <title id="lsmb13.function.concat-tsvector-tsvector-title">
       concat(tsvector, tsvector)
      </title>
      <titleabbrev id="lsmb13.function.concat-tsvector-tsvector-titleabbrev">
       concat(tsvector, tsvector)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsvector</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsvector_concat</programlisting>
      </para>
    </section>

<!-- Function concat_colon(text) -->
    <section id="lsmb13.function.concat-colon-text"
             xreflabel="lsmb13concat_colon(text)">
      <title id="lsmb13.function.concat-colon-text-title">
       concat_colon(text)
      </title>
      <titleabbrev id="lsmb13.function.concat-colon-text-titleabbrev">
       concat_colon(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a sumple aggregate to return values from the database in a 
colon-separated list.  Other programs probably should not rely on this since 
it is primarily included for the chart view.
        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function concat_colon(text, text) -->
    <section id="lsmb13.function.concat-colon-text-text"
             xreflabel="lsmb13concat_colon(text, text)">
      <title id="lsmb13.function.concat-colon-text-text-title">
       concat_colon(text, text)
      </title>
      <titleabbrev id="lsmb13.function.concat-colon-text-text-titleabbrev">
       concat_colon(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes two arguments and creates a list out  of them.  It&apos;s useful 
as an aggregate base (see aggregate concat_colon).  However this is a temporary
function only and should not be relied upon.
        <programlisting>
select CASE WHEN $1 IS NULL THEN $2 ELSE $1 || &#39;:&#39; || $2 END;
</programlisting>
      </para>
    </section>

<!-- Function connectby(text, text, text, text, integer) -->
    <section id="lsmb13.function.connectby-text-text-text-text-integer"
             xreflabel="lsmb13connectby(text, text, text, text, integer)">
      <title id="lsmb13.function.connectby-text-text-text-text-integer-title">
       connectby(text, text, text, text, integer)
      </title>
      <titleabbrev id="lsmb13.function.connectby-text-text-text-text-integer-titleabbrev">
       connectby(text, text, text, text, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>connectby_text</programlisting>
      </para>
    </section>

<!-- Function connectby(text, text, text, text, integer, text) -->
    <section id="lsmb13.function.connectby-text-text-text-text-integer-text"
             xreflabel="lsmb13connectby(text, text, text, text, integer, text)">
      <title id="lsmb13.function.connectby-text-text-text-text-integer-text-title">
       connectby(text, text, text, text, integer, text)
      </title>
      <titleabbrev id="lsmb13.function.connectby-text-text-text-text-integer-text-titleabbrev">
       connectby(text, text, text, text, integer, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>connectby_text</programlisting>
      </para>
    </section>

<!-- Function connectby(text, text, text, text, text, integer) -->
    <section id="lsmb13.function.connectby-text-text-text-text-text-integer"
             xreflabel="lsmb13connectby(text, text, text, text, text, integer)">
      <title id="lsmb13.function.connectby-text-text-text-text-text-integer-title">
       connectby(text, text, text, text, text, integer)
      </title>
      <titleabbrev id="lsmb13.function.connectby-text-text-text-text-text-integer-titleabbrev">
       connectby(text, text, text, text, text, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>connectby_text_serial</programlisting>
      </para>
    </section>

<!-- Function connectby(text, text, text, text, text, integer, text) -->
    <section id="lsmb13.function.connectby-text-text-text-text-text-integer-text"
             xreflabel="lsmb13connectby(text, text, text, text, text, integer, text)">
      <title id="lsmb13.function.connectby-text-text-text-text-text-integer-text-title">
       connectby(text, text, text, text, text, integer, text)
      </title>
      <titleabbrev id="lsmb13.function.connectby-text-text-text-text-text-integer-text-titleabbrev">
       connectby(text, text, text, text, text, integer, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>connectby_text_serial</programlisting>
      </para>
    </section>

<!-- Function cr_coa_to_account_save(in_description text, in_accno text) -->
    <section id="lsmb13.function.cr-coa-to-account-save-in-description-text-in-accno-text"
             xreflabel="lsmb13cr_coa_to_account_save(in_description text, in_accno text)">
      <title id="lsmb13.function.cr-coa-to-account-save-in-description-text-in-accno-text-title">
       cr_coa_to_account_save(in_description text, in_accno text)
      </title>
      <titleabbrev id="lsmb13.function.cr-coa-to-account-save-in-description-text-in-accno-text-titleabbrev">
       cr_coa_to_account_save(in_description text, in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
        Provides default rules for setting reconciliation labels.  Currently 
saves a label of accno ||&apos;--&apos; || description.
        <programlisting>
    DECLARE
       v_chart_id int;
    BEGIN
        -- Check for existence of the account already
        PERFORM * FROM cr_coa_to_account WHERE account = in_accno;

        IF NOT FOUND THEN
           -- This is a new account. Insert the relevant data.
           SELECT id INTO v_chart_id FROM chart WHERE accno = in_accno;
           INSERT INTO cr_coa_to_account (chart_id, account) VALUES (v_chart_id, in_accno||&#39;--&#39;||in_description);
        END IF;
        -- Already found, no need to do anything. =) 
    END;
</programlisting>
      </para>
    </section>

<!-- Function cr_report_block_changing_approved() -->
    <section id="lsmb13.function.cr-report-block-changing-approved"
             xreflabel="lsmb13cr_report_block_changing_approved()">
      <title id="lsmb13.function.cr-report-block-changing-approved-title">
       cr_report_block_changing_approved()
      </title>
      <titleabbrev id="lsmb13.function.cr-report-block-changing-approved-titleabbrev">
       cr_report_block_changing_approved()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a simple filter that prevents updating or deleting reconciliation
reports that have already been approved.  To purge old reconciliations you must
disable the block_change_when_approved trigger on cr_report.
        <programlisting>
BEGIN
   IF OLD.approved IS TRUE THEN
       RAISE EXCEPTION &#39;Report is approved.  Cannot change!&#39;;
   END IF;
   IF TG_OP = &#39;DELETE&#39; THEN
       RETURN OLD;
   ELSE
      RETURN NEW;
   END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function crosstab(text) -->
    <section id="lsmb13.function.crosstab-text"
             xreflabel="lsmb13crosstab(text)">
      <title id="lsmb13.function.crosstab-text-title">
       crosstab(text)
      </title>
      <titleabbrev id="lsmb13.function.crosstab-text-titleabbrev">
       crosstab(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>crosstab</programlisting>
      </para>
    </section>

<!-- Function crosstab(text, integer) -->
    <section id="lsmb13.function.crosstab-text-integer"
             xreflabel="lsmb13crosstab(text, integer)">
      <title id="lsmb13.function.crosstab-text-integer-title">
       crosstab(text, integer)
      </title>
      <titleabbrev id="lsmb13.function.crosstab-text-integer-titleabbrev">
       crosstab(text, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>crosstab</programlisting>
      </para>
    </section>

<!-- Function crosstab(text, text) -->
    <section id="lsmb13.function.crosstab-text-text"
             xreflabel="lsmb13crosstab(text, text)">
      <title id="lsmb13.function.crosstab-text-text-title">
       crosstab(text, text)
      </title>
      <titleabbrev id="lsmb13.function.crosstab-text-text-titleabbrev">
       crosstab(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF record</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>crosstab_hash</programlisting>
      </para>
    </section>

<!-- Function crosstab2(text) -->
    <section id="lsmb13.function.crosstab2-text"
             xreflabel="lsmb13crosstab2(text)">
      <title id="lsmb13.function.crosstab2-text-title">
       crosstab2(text)
      </title>
      <titleabbrev id="lsmb13.function.crosstab2-text-titleabbrev">
       crosstab2(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF tablefunc_crosstab_2</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>crosstab</programlisting>
      </para>
    </section>

<!-- Function crosstab3(text) -->
    <section id="lsmb13.function.crosstab3-text"
             xreflabel="lsmb13crosstab3(text)">
      <title id="lsmb13.function.crosstab3-text-title">
       crosstab3(text)
      </title>
      <titleabbrev id="lsmb13.function.crosstab3-text-titleabbrev">
       crosstab3(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF tablefunc_crosstab_3</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>crosstab</programlisting>
      </para>
    </section>

<!-- Function crosstab4(text) -->
    <section id="lsmb13.function.crosstab4-text"
             xreflabel="lsmb13crosstab4(text)">
      <title id="lsmb13.function.crosstab4-text-title">
       crosstab4(text)
      </title>
      <titleabbrev id="lsmb13.function.crosstab4-text-titleabbrev">
       crosstab4(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF tablefunc_crosstab_4</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>crosstab</programlisting>
      </para>
    </section>

<!-- Function currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer) -->
    <section id="lsmb13.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer"
             xreflabel="lsmb13currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)">
      <title id="lsmb13.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer-title">
       currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)
      </title>
      <titleabbrev id="lsmb13.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer-titleabbrev">
       currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return the exchange rate of a given currency, date and exchange rate class (buy or sell). 
        <programlisting>
DECLARE 
    out_exrate exchangerate.buy%TYPE;
    default_currency char(3);
    
    BEGIN 
        SELECT * INTO default_currency  FROM defaults_get_defaultcurrency();
        IF default_currency = in_currency THEN
           RETURN 1;
        END IF; 
        IF in_account_class = 2 THEN
          SELECT buy INTO out_exrate 
          FROM exchangerate
          WHERE transdate = in_date AND curr = in_currency;
        ELSE 
          SELECT sell INTO out_exrate 
          FROM exchangerate
          WHERE transdate = in_date AND curr = in_currency;   
        END IF;
        RETURN out_exrate;
    END;
</programlisting>
      </para>
    </section>

<!-- Function customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer) -->
    <section id="lsmb13.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer"
             xreflabel="lsmb13customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)">
      <title id="lsmb13.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer-title">
       customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer-titleabbrev">
       customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    BEGIN
    return _entity_location_save(
        in_entity_id, NULL,
        in_location_class, in_line_one, in_line_two, in_line_three,
        in_city, in_state, in_mail_code, in_country_id);
    END;

</programlisting>
      </para>
    </section>

<!-- Function date_get_all_years() -->
    <section id="lsmb13.function.date-get-all-years"
             xreflabel="lsmb13date_get_all_years()">
      <title id="lsmb13.function.date-get-all-years-title">
       date_get_all_years()
      </title>
      <titleabbrev id="lsmb13.function.date-get-all-years-titleabbrev">
       date_get_all_years()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return each year inside transdate in transactions. 
Currently it uses a sparse index scan because the number of rows returned is 
very small and the table can be very large.
        <programlisting>
DECLARE next_record int;
BEGIN

SELECT MIN(EXTRACT (&#39;YEAR&#39; FROM transdate))::INT
INTO next_record
FROM acc_trans;

LOOP

  EXIT WHEN next_record IS NULL;
  RETURN NEXT next_record;
  SELECT MIN(EXTRACT (&#39;YEAR&#39; FROM transdate))::INT AS YEAR
  INTO next_record
  FROM acc_trans
  WHERE EXTRACT (&#39;YEAR&#39; FROM transdate) &gt; next_record;


END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function days_in_month(in_date date) -->
    <section id="lsmb13.function.days-in-month-in-date-date"
             xreflabel="lsmb13days_in_month(in_date date)">
      <title id="lsmb13.function.days-in-month-in-date-date-title">
       days_in_month(in_date date)
      </title>
      <titleabbrev id="lsmb13.function.days-in-month-in-date-date-titleabbrev">
       days_in_month(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of days in the month that includes in_date.
        <programlisting>
SELECT (extract(DOM FROM date_trunc(&#39;month&#39;, $1)
                         + &#39;1 month - 1 second&#39;::interval)
      )::int;

</programlisting>
      </para>
    </section>

<!-- Function defaults_get_defaultcurrency() -->
    <section id="lsmb13.function.defaults-get-defaultcurrency"
             xreflabel="lsmb13defaults_get_defaultcurrency()">
      <title id="lsmb13.function.defaults-get-defaultcurrency-title">
       defaults_get_defaultcurrency()
      </title>
      <titleabbrev id="lsmb13.function.defaults-get-defaultcurrency-titleabbrev">
       defaults_get_defaultcurrency()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF bpchar</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return the default currency asigned by the program. 
        <programlisting>
DECLARE defaultcurrency defaults.value%TYPE;
      BEGIN   
           SELECT INTO defaultcurrency substr(value,1,3)
           FROM defaults
           WHERE setting_key = &#39;curr&#39;;
           RETURN NEXT defaultcurrency;
      END;
</programlisting>
      </para>
    </section>

<!-- Function del_department() -->
    <section id="lsmb13.function.del-department"
             xreflabel="lsmb13del_department()">
      <title id="lsmb13.function.del-department-title">
       del_department()
      </title>
      <titleabbrev id="lsmb13.function.del-department-titleabbrev">
       del_department()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
begin
  delete from dpt_trans where trans_id = old.id;
  return NULL;
end;
</programlisting>
      </para>
    </section>

<!-- Function del_exchangerate() -->
    <section id="lsmb13.function.del-exchangerate"
             xreflabel="lsmb13del_exchangerate()">
      <title id="lsmb13.function.del-exchangerate-title">
       del_exchangerate()
      </title>
      <titleabbrev id="lsmb13.function.del-exchangerate-titleabbrev">
       del_exchangerate()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

declare
  t_transdate date;
  t_curr char(3);
  t_id int;
  d_curr text;

begin

  select into d_curr substr(value,1,3) from defaults where setting_key = &#39;curr&#39;;
  
  if TG_RELNAME = &#39;ar&#39; then
    select into t_curr, t_transdate curr, transdate from ar where id = old.id;
  end if;
  if TG_RELNAME = &#39;ap&#39; then
    select into t_curr, t_transdate curr, transdate from ap where id = old.id;
  end if;
  if TG_RELNAME = &#39;oe&#39; then
    select into t_curr, t_transdate curr, transdate from oe where id = old.id;
  end if;

  if d_curr != t_curr then

    select into t_id a.id from acc_trans ac
    join ar a on (a.id = ac.trans_id)
    where a.curr = t_curr
    and ac.transdate = t_transdate

    except select a.id from ar a where a.id = old.id
    
    union
    
    select a.id from acc_trans ac
    join ap a on (a.id = ac.trans_id)
    where a.curr = t_curr
    and ac.transdate = t_transdate
    
    except select a.id from ap a where a.id = old.id
    
    union
    
    select o.id from oe o
    where o.curr = t_curr
    and o.transdate = t_transdate
    
    except select o.id from oe o where o.id = old.id;

    if not found then
      delete from exchangerate where curr = t_curr and transdate = t_transdate;
    end if;
  end if;
return old;

end;
</programlisting>
      </para>
    </section>

<!-- Function del_recurring() -->
    <section id="lsmb13.function.del-recurring"
             xreflabel="lsmb13del_recurring()">
      <title id="lsmb13.function.del-recurring-title">
       del_recurring()
      </title>
      <titleabbrev id="lsmb13.function.del-recurring-titleabbrev">
       del_recurring()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  DELETE FROM recurring WHERE id = old.id;
  DELETE FROM recurringemail WHERE id = old.id;
  DELETE FROM recurringprint WHERE id = old.id;
  RETURN NULL;
END;
</programlisting>
      </para>
    </section>

<!-- Function del_yearend() -->
    <section id="lsmb13.function.del-yearend"
             xreflabel="lsmb13del_yearend()">
      <title id="lsmb13.function.del-yearend-title">
       del_yearend()
      </title>
      <titleabbrev id="lsmb13.function.del-yearend-titleabbrev">
       del_yearend()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
begin
  delete from yearend where trans_id = old.id;
  return NULL;
end;
</programlisting>
      </para>
    </section>

<!-- Function department__list_all() -->
    <section id="lsmb13.function.department-list-all"
             xreflabel="lsmb13department__list_all()">
      <title id="lsmb13.function.department-list-all-title">
       department__list_all()
      </title>
      <titleabbrev id="lsmb13.function.department-list-all-titleabbrev">
       department__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF department</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM department order by description;
</programlisting>
      </para>
    </section>

<!-- Function department_list() -->
    <section id="lsmb13.function.department-list"
             xreflabel="lsmb13department_list()">
      <title id="lsmb13.function.department-list-title">
       department_list()
      </title>
      <titleabbrev id="lsmb13.function.department-list-titleabbrev">
       department_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF department</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM department ORDER BY description </programlisting>
      </para>
    </section>

<!-- Function department_list(in_role bpchar) -->
    <section id="lsmb13.function.department-list-in-role-bpchar"
             xreflabel="lsmb13department_list(in_role bpchar)">
      <title id="lsmb13.function.department-list-in-role-bpchar-title">
       department_list(in_role bpchar)
      </title>
      <titleabbrev id="lsmb13.function.department-list-in-role-bpchar-titleabbrev">
       department_list(in_role bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF department</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns all department that match the role provided as
the argument.
        <programlisting>
DECLARE out_department department%ROWTYPE;
BEGIN
       FOR out_department IN
               SELECT * from department
               WHERE role = coalesce(in_role, role)
       LOOP
               return next out_department;
       END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function dex_init(internal) -->
    <section id="lsmb13.function.dex-init-internal"
             xreflabel="lsmb13dex_init(internal)">
      <title id="lsmb13.function.dex-init-internal-title">
       dex_init(internal)
      </title>
      <titleabbrev id="lsmb13.function.dex-init-internal-titleabbrev">
       dex_init(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_dex_init</programlisting>
      </para>
    </section>

<!-- Function dex_lexize(internal, internal, integer) -->
    <section id="lsmb13.function.dex-lexize-internal-internal-integer"
             xreflabel="lsmb13dex_lexize(internal, internal, integer)">
      <title id="lsmb13.function.dex-lexize-internal-internal-integer-title">
       dex_lexize(internal, internal, integer)
      </title>
      <titleabbrev id="lsmb13.function.dex-lexize-internal-internal-integer-titleabbrev">
       dex_lexize(internal, internal, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_dex_lexize</programlisting>
      </para>
    </section>

<!-- Function draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric) -->
    <section id="lsmb13.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric"
             xreflabel="lsmb13draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)">
      <title id="lsmb13.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric-title">
       draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)
      </title>
      <titleabbrev id="lsmb13.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric-titleabbrev">
       draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF draft_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for drafts.  in_type may be any of &apos;ar&apos;, &apos;ap&apos;, or &apos;gl&apos;.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT trans.id, trans.transdate, trans.invoice, 
                       trans.reference, trans.description, 
			sum(case when lower(in_type) = &#39;ap&#39; AND chart.link = &#39;AP&#39;
				 THEN line.amount
				 WHEN lower(in_type) = &#39;ar&#39; AND chart.link = &#39;AR&#39;
				 THEN line.amount * -1
				 WHEN lower(in_type) = &#39;gl&#39; AND line.amount &gt; 0
				 THEN line.amount
			 	 ELSE 0
			    END) as amount
		FROM (
			SELECT id, transdate, reference, 
				description, false as invoice,
                                approved from gl
			WHERE lower(in_type) = &#39;gl&#39;
			UNION
			SELECT id, transdate, invnumber as reference, 
				(SELECT name FROM eca__get_entity(entity_credit_account)),
				invoice, approved from ap
			WHERE lower(in_type) = &#39;ap&#39;
			UNION
			SELECT id, transdate, invnumber as reference,
				description, 
				invoice, approved from ar
			WHERE lower(in_type) = &#39;ar&#39;
			) trans
		JOIN acc_trans line ON (trans.id = line.trans_id)
		JOIN chart ON (line.chart_id = chart.id and charttype = &#39;A&#39;)
           LEFT JOIN voucher v ON (v.trans_id = trans.id)
		WHERE (in_from_date IS NULL or trans.transdate &gt;= in_from_date)
			AND (in_to_date IS NULL 
				or trans.transdate &lt;= in_to_date)
			AND trans.approved IS FALSE
			AND v.id IS NULL
		GROUP BY trans.id, trans.transdate, trans.description, 
                         trans.reference, trans.invoice
		HAVING (in_with_accno IS NULL or in_with_accno = 
			ANY(as_array(chart.accno)))
		ORDER BY trans.reference
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function draft_approve(in_id integer) -->
    <section id="lsmb13.function.draft-approve-in-id-integer"
             xreflabel="lsmb13draft_approve(in_id integer)">
      <title id="lsmb13.function.draft-approve-in-id-integer-title">
       draft_approve(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.draft-approve-in-id-integer-titleabbrev">
       draft_approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the draft from the book.  Only will delete unapproved transactions.
Otherwise an exception is raised and the transaction terminated.
        <programlisting>
declare 
	t_table text;
begin
	SELECT table_name into t_table FROM transactions where id = in_id;

        IF (t_table = &#39;ar&#39;) THEN
                PERFORM cogs__add_for_ar_line(id) FROM invoice 
                  WHERE trans_id = in_id;
		UPDATE ar set approved = true where id = in_id;
	ELSIF (t_table = &#39;ap&#39;) THEN
                PERFORM cogs__add_for_ap_line(id) FROM invoice 
                  WHERE trans_id = in_id;
		UPDATE ap set approved = true where id = in_id;
	ELSIF (t_table = &#39;gl&#39;) THEN
		UPDATE gl set approved = true where id = in_id;
	ELSE
		raise exception &#39;Invalid table % in draft_approve for transaction %&#39;, t_table, in_id;
	END IF;

	IF NOT FOUND THEN
		RETURN FALSE;
	END IF;

	UPDATE transactions 
	SET approved_by = 
			(select entity_id FROM users 
			WHERE username = SESSION_USER), 
		approved_at = now() 
	WHERE id = in_id;

	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function draft_delete(in_id integer) -->
    <section id="lsmb13.function.draft-delete-in-id-integer"
             xreflabel="lsmb13draft_delete(in_id integer)">
      <title id="lsmb13.function.draft-delete-in-id-integer-title">
       draft_delete(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.draft-delete-in-id-integer-titleabbrev">
       draft_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
declare 
	t_table text;
begin
	DELETE FROM ac_tax_form 
	WHERE entry_id IN 
		(SELECT entry_id FROM acc_trans WHERE trans_id = in_id);

        DELETE FROM acc_trans WHERE trans_id = in_id;
	SELECT lower(table_name) into t_table FROM transactions where id = in_id;

        IF t_table = &#39;ar&#39; THEN
		DELETE FROM ar WHERE id = in_id AND approved IS FALSE;
	ELSIF t_table = &#39;ap&#39; THEN
		DELETE FROM ap WHERE id = in_id AND approved IS FALSE;
	ELSIF t_table = &#39;gl&#39; THEN
		DELETE FROM gl WHERE id = in_id AND approved IS FALSE;
	ELSE
		raise exception &#39;Invalid table % in draft_delete for transaction %&#39;, t_table, in_id;
	END IF;
	IF NOT FOUND THEN
		RAISE EXCEPTION &#39;Invalid transaction id %&#39;, in_id;
	END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function drop_custom_field(character varying, character varying) -->
    <section id="lsmb13.function.drop-custom-field-character-varying-character-varying"
             xreflabel="lsmb13drop_custom_field(character varying, character varying)">
      <title id="lsmb13.function.drop-custom-field-character-varying-character-varying-title">
       drop_custom_field(character varying, character varying)
      </title>
      <titleabbrev id="lsmb13.function.drop-custom-field-character-varying-character-varying-titleabbrev">
       drop_custom_field(character varying, character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
table_name ALIAS FOR $1;
custom_field_name ALIAS FOR $2;
BEGIN
	DELETE FROM custom_field_catalog 
	WHERE field_name = custom_field_name AND 
		table_id = (SELECT table_id FROM custom_table_catalog 
			WHERE extends = table_name);
	EXECUTE &#39;ALTER TABLE &#39; || quote_ident(&#39;custom_&#39; || table_name) || 
		&#39; DROP COLUMN &#39; || quote_ident(custom_field_name);
	RETURN TRUE;	
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__delete_contact(in_contact integer, in_contact_class_id integer, in_credit_id text) -->
    <section id="lsmb13.function.eca-delete-contact-in-contact-integer-in-contact-class-id-integer-in-credit-id-text"
             xreflabel="lsmb13eca__delete_contact(in_contact integer, in_contact_class_id integer, in_credit_id text)">
      <title id="lsmb13.function.eca-delete-contact-in-contact-integer-in-contact-class-id-integer-in-credit-id-text-title">
       eca__delete_contact(in_contact integer, in_contact_class_id integer, in_credit_id text)
      </title>
      <titleabbrev id="lsmb13.function.eca-delete-contact-in-contact-integer-in-contact-class-id-integer-in-credit-id-text-titleabbrev">
       eca__delete_contact(in_contact integer, in_contact_class_id integer, in_credit_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if at least one record was deleted.  False if no records were
affected.
        <programlisting>
BEGIN

DELETE FROM eca_to_contact
 WHERE credit_id = in_credit_id and contact_class_id = in_contact_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function eca__delete_location(in_location_class integer, in_location_id integer, in_credit_id integer) -->
    <section id="lsmb13.function.eca-delete-location-in-location-class-integer-in-location-id-integer-in-credit-id-integer"
             xreflabel="lsmb13eca__delete_location(in_location_class integer, in_location_id integer, in_credit_id integer)">
      <title id="lsmb13.function.eca-delete-location-in-location-class-integer-in-location-id-integer-in-credit-id-integer-title">
       eca__delete_location(in_location_class integer, in_location_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-delete-location-in-location-class-integer-in-location-id-integer-in-credit-id-integer-titleabbrev">
       eca__delete_location(in_location_class integer, in_location_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the record identified.  Returns true if successful, false if no record
found.
        <programlisting>
BEGIN

DELETE FROM eca_to_location
 WHERE credit_id = in_credit_id AND location_id = in_location_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function eca__delete_pricematrix(in_entry_id integer, in_credit_id integer) -->
    <section id="lsmb13.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer"
             xreflabel="lsmb13eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)">
      <title id="lsmb13.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer-title">
       eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer-titleabbrev">
       eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval bool;

BEGIN

retval := false;

DELETE FROM partsvendor 
 WHERE entry_id = in_entry_id 
       AND credit_id = in_credit_id;

retval := FOUND;

DELETE FROM partscustomer
 WHERE entry_id = in_entry_id
       AND credit_id = in_credit_id;

RETURN FOUND or retval;

END;
</programlisting>
      </para>
    </section>

<!-- Function eca__get_entity(in_credit_id integer) -->
    <section id="lsmb13.function.eca-get-entity-in-credit-id-integer"
             xreflabel="lsmb13eca__get_entity(in_credit_id integer)">
      <title id="lsmb13.function.eca-get-entity-in-credit-id-integer-title">
       eca__get_entity(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-get-entity-in-credit-id-integer-titleabbrev">
       eca__get_entity(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity to which the entity credit account is
attached.
        <programlisting>

declare
    v_row entity;
BEGIN
    SELECT entity.* INTO v_row FROM entity_credit_account JOIN entity ON entity_credit_account.entity_id = entity.id WHERE entity_credit_account.id = in_credit_id;
    IF NOT FOUND THEN
        raise exception &#39;Could not find entity with ID %&#39;, in_credit_id;
    ELSE
        return next v_row;
    END IF;
END;

</programlisting>
      </para>
    </section>

<!-- Function eca__get_pricematrix(in_credit_id integer) -->
    <section id="lsmb13.function.eca-get-pricematrix-in-credit-id-integer"
             xreflabel="lsmb13eca__get_pricematrix(in_credit_id integer)">
      <title id="lsmb13.function.eca-get-pricematrix-in-credit-id-integer-title">
       eca__get_pricematrix(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-get-pricematrix-in-credit-id-integer-titleabbrev">
       eca__get_pricematrix(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
        This returns the pricematrix for the customer or vendor 
(entity_credit_account identified by in_id), orderd by partnumber, validfrom

        <programlisting>

SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, pc.pricebreak,
       pc.sellprice, NULL, NULL::int, NULL, pc.validfrom, pc.validto, pc.curr,
       pc.entry_id
  FROM partscustomer pc
  JOIN parts p on pc.parts_id = p.id
  JOIN entity_credit_account eca ON pc.credit_id = eca.id
 WHERE pc.credit_id = $1 AND eca.entity_class = 2
 UNION
SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
       pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
       pv.entry_id
  FROM partsvendor pv
  JOIN parts p on pv.parts_id = p.id
  JOIN entity_credit_account eca ON pv.credit_id = eca.id
 WHERE pv.credit_id = $1 and eca.entity_class = 1
 ORDER BY partnumber, validfrom

</programlisting>
      </para>
    </section>

<!-- Function eca__get_pricematrix_by_pricegroup(in_credit_id integer) -->
    <section id="lsmb13.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer"
             xreflabel="lsmb13eca__get_pricematrix_by_pricegroup(in_credit_id integer)">
      <title id="lsmb13.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer-title">
       eca__get_pricematrix_by_pricegroup(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer-titleabbrev">
       eca__get_pricematrix_by_pricegroup(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, pc.pricebreak,
       pc.sellprice, NULL::numeric, NULL::int, NULL::text, pc.validfrom, 
       pc.validto, pc.curr, pc.entry_id
  FROM partscustomer pc
  JOIN parts p on pc.parts_id = p.id
  JOIN entity_credit_account eca ON pc.pricegroup_id = eca.pricegroup_id
 WHERE eca.id = $1 AND eca.entity_class = 2
</programlisting>
      </para>
    </section>

<!-- Function eca__get_taxes(in_credit_id integer) -->
    <section id="lsmb13.function.eca-get-taxes-in-credit-id-integer"
             xreflabel="lsmb13eca__get_taxes(in_credit_id integer)">
      <title id="lsmb13.function.eca-get-taxes-in-credit-id-integer-title">
       eca__get_taxes(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-get-taxes-in-credit-id-integer-titleabbrev">
       eca__get_taxes(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF customertax</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of taxable account id&apos;s.
        <programlisting>
select * from customertax where customer_id = $1
union
select * from vendortax where vendor_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_contacts(in_credit_id integer) -->
    <section id="lsmb13.function.eca-list-contacts-in-credit-id-integer"
             xreflabel="lsmb13eca__list_contacts(in_credit_id integer)">
      <title id="lsmb13.function.eca-list-contacts-in-credit-id-integer-title">
       eca__list_contacts(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-list-contacts-in-credit-id-integer-titleabbrev">
       eca__list_contacts(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contact info attached to the entity credit account.
        <programlisting>
DECLARE out_row contact_list;
BEGIN
	FOR out_row IN
		SELECT cl.class, cl.id, c.description, c.contact
		FROM eca_to_contact c
		JOIN contact_class cl ON (c.contact_class_id = cl.id)
		WHERE credit_id = in_credit_id
	LOOP
		return next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_notes(in_credit_id integer) -->
    <section id="lsmb13.function.eca-list-notes-in-credit-id-integer"
             xreflabel="lsmb13eca__list_notes(in_credit_id integer)">
      <title id="lsmb13.function.eca-list-notes-in-credit-id-integer-title">
       eca__list_notes(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-list-notes-in-credit-id-integer-titleabbrev">
       eca__list_notes(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF note</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of notes attached to the entity credit account.
        <programlisting>
DECLARE out_row record;
	t_entity_id int;
BEGIN
        -- ALERT: security definer function.  Be extra careful about EXECUTE
        -- in here. --CT
	SELECT entity_id INTO t_entity_id
	FROM entity_credit_account
	WHERE id = in_credit_id;

	FOR out_row IN
		SELECT *
		FROM note
		WHERE (note_class = 3 and ref_key = in_credit_id) or
			(note_class = 1 and ref_key = t_entity_id)
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__location_save(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_credit_id integer) -->
    <section id="lsmb13.function.eca-location-save-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-credit-id-integer"
             xreflabel="lsmb13eca__location_save(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_credit_id integer)">
      <title id="lsmb13.function.eca-location-save-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-credit-id-integer-title">
       eca__location_save(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-location-save-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-credit-id-integer-titleabbrev">
       eca__location_save(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location to an entity credit account. Returns id of saved record.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
        l_orig_id INT;
    BEGIN
       
        UPDATE eca_to_location
           SET location_class = in_location_class
         WHERE credit_id = in_credit_id
           AND location_class = in_old_location_class
           AND location_id = in_location_id;
           
         IF FOUND THEN
            SELECT location_save(
                in_location_id, 
                in_line_one, 
                in_line_two, 
                in_line_three, 
                in_city,
                in_state, 
                in_mail_code, 
                in_country_code
            )
        	INTO l_id; 
        ELSE
            SELECT location_save(
                NULL, 
                in_line_one, 
                in_line_two, 
                in_line_three, 
                in_city,
                in_state, 
                in_mail_code, 
                in_country_code
            )
        	INTO l_id; 
            INSERT INTO eca_to_location 
        		(credit_id, location_class, location_id)
        	VALUES  (in_credit_id, in_location_class, l_id);
        
        END IF;

	RETURN l_id;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function eca__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer) -->
    <section id="lsmb13.function.eca-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer"
             xreflabel="lsmb13eca__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)">
      <title id="lsmb13.function.eca-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer-title">
       eca__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer-titleabbrev">
       eca__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves bank account to the credit account.
        <programlisting>
DECLARE out_id int;
BEGIN
        UPDATE entity_bank_account
           SET bic = in_bic,
               iban = in_iban
         WHERE id = in_bank_account_id;

        IF FOUND THEN
                out_id = in_bank_account_id;
        ELSE
	  	INSERT INTO entity_bank_account(entity_id, bic, iban)
		VALUES(in_entity_id, in_bic, in_iban);
	        SELECT CURRVAL(&#39;entity_bank_account_id_seq&#39;) INTO out_id ;
	END IF;

	IF in_credit_id IS NOT NULL THEN
		UPDATE entity_credit_account SET bank_account = out_id
		WHERE id = in_credit_id;
	END IF;

	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_contact_class text, in_credit_id integer) -->
    <section id="lsmb13.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-contact-class-text-in-credit-id-integer"
             xreflabel="lsmb13eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_contact_class text, in_credit_id integer)">
      <title id="lsmb13.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-contact-class-text-in-credit-id-integer-title">
       eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_contact_class text, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-contact-class-text-in-credit-id-integer-titleabbrev">
       eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_contact_class text, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the contact record at the entity credit account level.  Returns 1.
        <programlisting>
DECLARE out_id int;
BEGIN

    PERFORM *
       FROM eca_to_contact
      WHERE credit_id = in_credit_id
        AND contact_class_id = in_old_contact_class
        AND contact = in_old_contact;
        
    IF FOUND THEN
        UPDATE eca_to_contact
           SET contact = in_contact,
               description = in_description,
               contact_class_id = in_contact_class
         WHERE credit_id = in_credit_id
           AND contact_class_id = in_old_contact_class
           AND contact = in_old_contact;
    ELSE
        INSERT INTO eca_to_contact(credit_id, contact_class_id, 
                description, contact)
        VALUES (in_credit_id, in_contact_class, in_description, in_contact);
        
    END IF;

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_notes(in_subject integer, in_note text, in_credit_id text) -->
    <section id="lsmb13.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text"
             xreflabel="lsmb13eca__save_notes(in_subject integer, in_note text, in_credit_id text)">
      <title id="lsmb13.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text-title">
       eca__save_notes(in_subject integer, in_note text, in_credit_id text)
      </title>
      <titleabbrev id="lsmb13.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text-titleabbrev">
       eca__save_notes(in_subject integer, in_note text, in_credit_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity credit account-level note.  Such a note is valid for only one
credit account. Returns the id of the note.  
        <programlisting>
DECLARE out_id int;
BEGIN
	-- TODO, change this to create vector too
	INSERT INTO eca_note (ref_key, note_class, note, vector, subject)
	VALUES (in_credit_id, 3, in_note, &#39;&#39;, in_subject);

	SELECT currval(&#39;note_id_seq&#39;) INTO out_id;
	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer) -->
    <section id="lsmb13.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer"
             xreflabel="lsmb13eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)">
      <title id="lsmb13.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-title">
       eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </title>
      <titleabbrev id="lsmb13.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-titleabbrev">
       eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   retval eca__pricematrix;
   t_insert bool;

BEGIN

t_insert := false;

PERFORM * FROM entity_credit_account 
  WHERE id = in_credit_id AND entity_class = 1;

IF FOUND THEN -- VENDOR
    UPDATE partsvendor
       SET lastcost = in_price,
           leadtime = in_lead_time,
           partnumber = in_partnumber,
           curr = in_curr
     WHERE credit_id = in_credit_id AND entry_id = in_entry_id;

    IF NOT FOUND THEN
        INSERT INTO partsvendor
               (parts_id, credit_id, lastcost, leadtime, partnumber, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_leadtime::int2, 
               in_partnumber, in_curr);
    END IF;

    SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
           pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
           pv.entry_id
      INTO retval
      FROM partsvendor pv
      JOIN parts p ON p.id = pv.parts_id
     WHERE parts_id = in_parts_id and credit_id = in_credit_id;

    RETURN retval;
END IF;

PERFORM * FROM entity_credit_account
  WHERE id = in_credit_id AND entity_class = 2;

IF FOUND THEN -- CUSTOMER
    UPDATE partscustomer
       SET pricebreak = in_pricebreak,
           sellprice  = in_price,
           validfrom  = in_validfrom,
           validto    = in_validto,
           curr       = in_curr
     WHERE entry_id = in_entry_id and credit_id = in_credit_id;

    IF NOT FOUND THEN
        INSERT INTO partscustomer
               (parts_id, credit_id, sellprice, validfrom, validto, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_validfrom, in_validto, 
                in_curr);

        t_insert := true;
    END IF;

    SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, 
           pc.pricebreak, pc.sellprice, NULL, NULL, NULL, pc.validfrom, 
           pc.validto, pc.curr, pc.entry_id
      INTO retval
      FROM partscustomer pc
      JOIN parts p on pc.parts_id = p.id
     WHERE entry_id = CASE WHEN t_insert 
                           THEN currval(&#39;partscustomer_entry_id_seq&#39;) 
                           ELSE in_entry_id 
                      END;
                           
    RETURN retval;

END IF;

RAISE EXCEPTION &#39;No valid entity credit account found&#39;;
   
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__set_taxes(in_tax_ids integer, in_credit_id integer[]) -->
    <section id="lsmb13.function.eca-set-taxes-in-tax-ids-integer-in-credit-id-integerARRAY"
             xreflabel="lsmb13eca__set_taxes(in_tax_ids integer, in_credit_id integer[])">
      <title id="lsmb13.function.eca-set-taxes-in-tax-ids-integer-in-credit-id-integerARRAY-title">
       eca__set_taxes(in_tax_ids integer, in_credit_id integer[])
      </title>
      <titleabbrev id="lsmb13.function.eca-set-taxes-in-tax-ids-integer-in-credit-id-integerARRAY-titleabbrev">
       eca__set_taxes(in_tax_ids integer, in_credit_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Sets the tax values for the customer or vendor.

The entity credit account must exist before calling this function, and must
have a type of either 1 or 2.

        <programlisting>
DECLARE 
    eca entity_credit_account;
    iter int;
BEGIN
     SELECT * FROM entity_credit_account into eca WHERE id = in_credit_id;

     IF eca.entity_class = 1 then
        DELETE FROM vendortax WHERE vendor_id = in_credit_id;
        FOR iter in array_lower(in_tax_ids, 1) .. array_upper(in_tax_ids, 1)
        LOOP
             INSERT INTO vendortax (vendor_id, chart_id)
             values (in_credit_id, in_tax_ids[iter]);
        END LOOP;
     ELSIF eca.entity_class = 2 then
        DELETE FROM customertax WHERE customer_id = in_credit_id;
        FOR iter in array_lower(in_tax_ids, 1) .. array_upper(in_tax_ids, 1)
        LOOP
             INSERT INTO customertax (customer_id, chart_id)
             values (in_credit_id, in_tax_ids[iter]);
        END LOOP;
     ELSE 
        RAISE EXCEPTION &#39;Wrong entity class or credit account not found!&#39;;
     END IF;
     RETURN TRUE;
end;
</programlisting>
      </para>
    </section>

<!-- Function eca_history(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean) -->
    <section id="lsmb13.function.eca-history-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean"
             xreflabel="lsmb13eca_history(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)">
      <title id="lsmb13.function.eca-history-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-title">
       eca_history(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </title>
      <titleabbrev id="lsmb13.function.eca-history-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-titleabbrev">
       eca_history(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_history_result</seg>
        </seglistitem>
       </segmentedlist>
 
       This produces a history detail report, i.e. a list of all products purchased by
a customer over a specific date range.  

meta_number is an exact match, as are in_open and inc_closed.  All other fields
allow for partial matches.  NULL matches all values.
        <programlisting>
     SELECT eca.id, e.name, eca.meta_number, 
            a.id as invoice_id, a.invnumber, a.curr::text, 
            p.id AS parts_id, p.partnumber, 
            i.description, i.qty, i.unit::text, i.sellprice, i.discount, 
            i.deliverydate, pr.id as project_id, pr.projectnumber,
            i.serialnumber, 
            case when $16 = 1 then xr.buy else xr.sell end as exchange_rate,
            ee.id as salesperson_id, 
            ep.last_name || &#39;, &#39; || ep.first_name as salesperson_name
     FROM (select * from entity_credit_account 
            where meta_number = $2
           UNION 
          select * from entity_credit_account WHERE $2 is null
          ) eca  -- broken into unions for performance
     join entity e on eca.entity_id = e.id
     JOIN (select  invnumber, curr, transdate, entity_credit_account, id,
                   person_id
             FROM ar 
            where $16 = 2 and $13 = &#39;i&#39;
                  and (($17 and amount = paid) or ($18 and amount &lt;&gt; paid))
            UNION 
           select invnumber, curr, transdate, entity_credit_account, id,
                  person_id
             FROM ap 
            where $16 = 1 and $13 = &#39;i&#39;
                  and (($17 and amount = paid) or ($18 and amount &lt;&gt; paid))
           union 
           select ordnumber, curr, transdate, entity_credit_account, id,
                  person_id
           from oe 
           where ($16= 1 and oe.oe_class_id = 2 and $13 = &#39;o&#39; 
                  and quotation is not true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select ordnumber, curr, transdate, entity_credit_account, id,
                  person_id
           from oe 
           where ($16= 2 and oe.oe_class_id = 1 and $13 = &#39;o&#39;
                  and quotation is not true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select quonumber, curr, transdate, entity_credit_account, id,
                  person_id
           from oe 
           where($16= 1 and oe.oe_class_id = 4 and $13 = &#39;q&#39;
                and quotation is true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select quonumber, curr, transdate, entity_credit_account, id,
                  person_id
           from oe 
           where($16= 2 and oe.oe_class_id = 4 and $13 = &#39;q&#39;
                 and quotation is true)
                  and (($17 and not closed) or ($18 and closed))
          ) a ON (a.entity_credit_account = eca.id) -- broken into unions 
                                                    -- for performance
     JOIN ( select trans_id, parts_id, qty, description, unit, discount,
                   deliverydate, serialnumber, project_id, sellprice
             FROM  invoice where $13 = &#39;i&#39;
            union 
            select trans_id, parts_id, qty, description, unit, discount,
                   reqdate, serialnumber, project_id, sellprice
             FROM orderitems where $13 &lt;&gt; &#39;i&#39;
          ) i on i.trans_id = a.id
     JOIN parts p ON (p.id = i.parts_id)
LEFT JOIN exchangerate ex ON (ex.transdate = a.transdate)
LEFT JOIN project pr ON (pr.id = i.project_id)
LEFT JOIN entity ee ON (a.person_id = ee.id)
LEFT JOIN person ep ON (ep.entity_id = ee.id)
     JOIN exchangerate xr ON a.transdate = xr.transdate
    -- these filters don&#39;t perform as well on large databases
    WHERE (e.name ilike &#39;%&#39; || $1 || &#39;%&#39; or $1 is null)
          and ($3 is null or eca.id in 
                 (select credit_id from eca_to_contact
                   where contact ilike &#39;%&#39; || $3 || &#39;%&#39;))
          and (($4 is null and $5 is null and $6 is null and $7 is null)
               or eca.id in
                  (select credit_id from eca_to_location 
                    where location_id in
                          (select id from location
                            where ($4 is null or line_one ilike &#39;%&#39; || $4 || &#39;%&#39;
                                   or line_two ilike &#39;%&#39; || $4 || &#39;%&#39;) 
                                  and ($5 is null or city 
                                                     ilike &#39;%&#39; || $5 || &#39;%&#39;)
                                  and ($6 is null or state 
                                                    ilike &#39;%&#39; || $6 || &#39;%&#39;)
                                  and ($7 is null or mail_code 
                                                    ilike &#39;%&#39; || $7 || &#39;%&#39;)
                                  and ($10 is null or country_id = $10))
                   )
              )
          and (a.transdate &gt;= $11 or $11 is null)
          and (a.transdate &lt;= $12 or $12 is null)
          and (eca.startdate &gt;= $14 or $14 is null)
          and (eca.startdate &lt;= $15 or $15 is null)
 ORDER BY eca.meta_number;
</programlisting>
      </para>
    </section>

<!-- Function eca_history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean) -->
    <section id="lsmb13.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean"
             xreflabel="lsmb13eca_history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)">
      <title id="lsmb13.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-title">
       eca_history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </title>
      <titleabbrev id="lsmb13.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-titleabbrev">
       eca_history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_history_result</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates a summary account (no quantities, just parts group by invoice).

meta_number must match exactly or be NULL.  inc_open and inc_closed are exact
matches too.  All other values specify ranges or may match partially.
        <programlisting>
SELECT id, name, meta_number, null::int, null::text, curr, parts_id, partnumber,
       description, sum(qty), unit, null::numeric, null::numeric, null::date, 
       null::int, null::text, null::text, null::numeric,
       null::int, null::text
FROM   eca_history($1, $2, $3, $4, $5, $6, $7, $8, $9,
                   $10, $11, $12, $13, $14, $15, $16, $17, $18)
 group by id, name, meta_number, curr, parts_id, partnumber, description, unit
 order by meta_number;
</programlisting>
      </para>
    </section>

<!-- Function employee__all_managers() -->
    <section id="lsmb13.function.employee-all-managers"
             xreflabel="lsmb13employee__all_managers()">
      <title id="lsmb13.function.employee-all-managers-title">
       employee__all_managers()
      </title>
      <titleabbrev id="lsmb13.function.employee-all-managers-titleabbrev">
       employee__all_managers()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
   SELECT p.entity_id, p.id, s.salutation,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ee.role = &#39;manager&#39;
 ORDER BY ee.employeenumber;
</programlisting>
      </para>
    </section>

<!-- Function employee__get(in_entity_id integer) -->
    <section id="lsmb13.function.employee-get-in-entity-id-integer"
             xreflabel="lsmb13employee__get(in_entity_id integer)">
      <title id="lsmb13.function.employee-get-in-entity-id-integer-title">
       employee__get(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.employee-get-in-entity-id-integer-titleabbrev">
       employee__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an employee_result tuple with information specified by the entity_id.

        <programlisting>
   SELECT p.entity_id, p.id, s.salutation, 
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE p.entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function employee__get_user(in_entity_id integer) -->
    <section id="lsmb13.function.employee-get-user-in-entity-id-integer"
             xreflabel="lsmb13employee__get_user(in_entity_id integer)">
      <title id="lsmb13.function.employee-get-user-in-entity-id-integer-title">
       employee__get_user(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.employee-get-user-in-entity-id-integer-titleabbrev">
       employee__get_user(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns username, user_id, etc. information if the employee is a user.
        <programlisting>SELECT * FROM users WHERE entity_id = $1;</programlisting>
      </para>
    </section>

<!-- Function employee__list_managers(in_id integer) -->
    <section id="lsmb13.function.employee-list-managers-in-id-integer"
             xreflabel="lsmb13employee__list_managers(in_id integer)">
      <title id="lsmb13.function.employee-list-managers-in-id-integer-title">
       employee__list_managers(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.employee-list-managers-in-id-integer-titleabbrev">
       employee__list_managers(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF employees</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of managers, that is employees with the &apos;manager&apos; role set.
        <programlisting>
DECLARE
	emp employees%ROWTYPE;
BEGIN
	FOR emp IN 
		SELECT 
		    e.salutation,
		    e.first_name,
		    e.last_name,
		    ee.* 
		FROM entity_employee ee
		JOIN entity e on e.id = ee.entity_id
		WHERE ee.sales = &#39;t&#39;::bool AND ee.role=&#39;manager&#39;
			AND ee.entity_id &lt;&gt; coalesce(in_id, -1)
		ORDER BY name
	LOOP
		RETURN NEXT emp;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__save(in_employee_number integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text) -->
    <section id="lsmb13.function.employee-save-in-employee-number-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text"
             xreflabel="lsmb13employee__save(in_employee_number integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)">
      <title id="lsmb13.function.employee-save-in-employee-number-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text-title">
       employee__save(in_employee_number integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)
      </title>
      <titleabbrev id="lsmb13.function.employee-save-in-employee-number-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text-titleabbrev">
       employee__save(in_employee_number integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an employeerecord with the specified information.
        <programlisting>
DECLARE out_id INT;
BEGIN
	UPDATE entity_employee 
	SET startdate = coalesce(in_start_date, now()::date),
		enddate = in_end_date,
		dob = in_dob,
		role = in_role,
		ssn = in_ssn,
		manager_id = in_manager_id,
		employeenumber = in_employee_number
	WHERE entity_id = in_entity_id;

	out_id = in_entity_id;

	IF NOT FOUND THEN
		INSERT INTO entity_employee 
			(startdate, enddate, dob, role, ssn, manager_id, 
				employeenumber, entity_id)
		VALUES
			(coalesce(in_start_date, now()::date), in_end_date, 
                                in_dob, in_role, in_ssn,
				in_manager_id, in_employee_number, 
                                in_entity_id);
		RETURN in_entity_id;
	END IF;
        RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text) -->
    <section id="lsmb13.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text"
             xreflabel="lsmb13employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)">
      <title id="lsmb13.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text-title">
       employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)
      </title>
      <titleabbrev id="lsmb13.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text-titleabbrev">
       employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of employee_result records matching the search criteria.

employeenumber is an exact match.  
stardate_from and startdate_to specify the start dates for employee searches
All others are partial matches.

NULLs match all values.
        <programlisting>
SELECT p.entity_id, p.id, s.salutation,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity e ON p.entity_id = e.id
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ($7 is null or p.entity_id in (select ref_key from entity_note
                                          WHERE note ilike &#39;%&#39; || $7 || &#39;%&#39;))
          and ($1 is null or $1 = ee.employeenumber)
          and ($2 is null or $2 &lt;= ee.startdate)
          and ($3 is null or $3 &gt;= ee.startdate)
          and ($4 is null or p.first_name ilike &#39;%&#39; || $4 || &#39;%&#39;)
          and ($5 is null or p.middle_name ilike &#39;%&#39; || $5 || &#39;%&#39;)
          and ($6 is null or p.last_name ilike &#39;%&#39; || $6 || &#39;%&#39;);
</programlisting>
      </para>
    </section>

<!-- Function employee_delete(in_id integer) -->
    <section id="lsmb13.function.employee-delete-in-id-integer"
             xreflabel="lsmb13employee_delete(in_id integer)">
      <title id="lsmb13.function.employee-delete-in-id-integer-title">
       employee_delete(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.employee-delete-in-id-integer-titleabbrev">
       employee_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
	DELETE FROM employee WHERE entity_id = in_id;
	RETURN;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean) -->
    <section id="lsmb13.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean"
             xreflabel="lsmb13employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)">
      <title id="lsmb13.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean-title">
       employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)
      </title>
      <titleabbrev id="lsmb13.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean-titleabbrev">
       employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF employee_search</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	emp employee_search%ROWTYPE;
BEGIN
	FOR emp IN
		SELECT * FROM employee_search
		WHERE coalesce(startdate, &#39;infinity&#39;::timestamp)
			&gt;= coalesce(in_startdateto, &#39;-infinity&#39;::timestamp)
			AND coalesce(startdate, &#39;-infinity&#39;::timestamp) &lt;=
				coalesce(in_startdatefrom, 
						&#39;infinity&#39;::timestamp)
			AND coalesce(enddate, &#39;-infinity&#39;::timestamp) &lt;= 
				coalesce(in_enddateto, &#39;infinity&#39;::timestamp)
			AND coalesce(enddate, &#39;infinity&#39;::timestamp) &gt;= 
				coalesce(in_enddatefrom, &#39;-infinity&#39;::timestamp)
			AND (name % in_name
			    OR note % in_notes)
			AND (sales = &#39;t&#39; OR coalesce(in_sales, &#39;f&#39;) = &#39;f&#39;)
	LOOP
		RETURN NEXT emp;
	END LOOP;
	return;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee_set_location(in_location integer, in_employee integer) -->
    <section id="lsmb13.function.employee-set-location-in-location-integer-in-employee-integer"
             xreflabel="lsmb13employee_set_location(in_location integer, in_employee integer)">
      <title id="lsmb13.function.employee-set-location-in-location-integer-in-employee-integer-title">
       employee_set_location(in_location integer, in_employee integer)
      </title>
      <titleabbrev id="lsmb13.function.employee-set-location-in-location-integer-in-employee-integer-titleabbrev">
       employee_set_location(in_location integer, in_employee integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

    INSERT INTO person_to_location (person_id,location_id) 
        VALUES ($1, $2);
    
</programlisting>
      </para>
    </section>

<!-- Function entity__delete_bank_account(in_id integer, in_entity_id integer) -->
    <section id="lsmb13.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer"
             xreflabel="lsmb13entity__delete_bank_account(in_id integer, in_entity_id integer)">
      <title id="lsmb13.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer-title">
       entity__delete_bank_account(in_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer-titleabbrev">
       entity__delete_bank_account(in_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the bank account identitied by in_id if it is attached to the entity
identified by entity_id.  Returns true if a record is deleted, false if not.
        <programlisting>
BEGIN

UPDATE entity_credit_account SET bank_account = NULL
 WHERE entity_id = in_entity_id AND bank_account = in_id;

DELETE FROM entity_bank_account
 WHERE id = in_id AND entity_id = in_entity_id;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function entity__get(in_entity_id integer) -->
    <section id="lsmb13.function.entity-get-in-entity-id-integer"
             xreflabel="lsmb13entity__get(in_entity_id integer)">
      <title id="lsmb13.function.entity-get-in-entity-id-integer-title">
       entity__get(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-get-in-entity-id-integer-titleabbrev">
       entity__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity record with the entity id.
        <programlisting>

declare
    v_row entity;
BEGIN
    -- Removing the exception when not found handling.  Applications are
    -- perfectly capable of handling whether an entity was not found.  No need
    -- for a database-level exception here. Moreover such results may be useful
    -- --CT

    SELECT * INTO v_row FROM entity WHERE id = in_entity_id;
    return next v_row;
END;

</programlisting>
      </para>
    </section>

<!-- Function entity__get_by_cc(in_control_code text) -->
    <section id="lsmb13.function.entity-get-by-cc-in-control-code-text"
             xreflabel="lsmb13entity__get_by_cc(in_control_code text)">
      <title id="lsmb13.function.entity-get-by-cc-in-control-code-text-title">
       entity__get_by_cc(in_control_code text)
      </title>
      <titleabbrev id="lsmb13.function.entity-get-by-cc-in-control-code-text-titleabbrev">
       entity__get_by_cc(in_control_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity row attached to the control code. 
        <programlisting>
SELECT * FROM entity WHERE control_code = $1 </programlisting>
      </para>
    </section>

<!-- Function entity__get_entity(in_entity_id integer) -->
    <section id="lsmb13.function.entity-get-entity-in-entity-id-integer"
             xreflabel="lsmb13entity__get_entity(in_entity_id integer)">
      <title id="lsmb13.function.entity-get-entity-in-entity-id-integer-title">
       entity__get_entity(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-get-entity-in-entity-id-integer-titleabbrev">
       entity__get_entity(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity record with the entity id.
        <programlisting>

declare
    v_row entity;
BEGIN
    -- Removing the exception when not found handling.  Applications are
    -- perfectly capable of handling whether an entity was not found.  No need
    -- for a database-level exception here. Moreover such results may be useful
    -- --CT

    SELECT * INTO v_row FROM entity WHERE id = in_entity_id;
    return next v_row;
END;

</programlisting>
      </para>
    </section>

<!-- Function entity__list_classes() -->
    <section id="lsmb13.function.entity-list-classes"
             xreflabel="lsmb13entity__list_classes()">
      <title id="lsmb13.function.entity-list-classes-title">
       entity__list_classes()
      </title>
      <titleabbrev id="lsmb13.function.entity-list-classes-titleabbrev">
       entity__list_classes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of entity classes, ordered by assigned ids
        <programlisting>
DECLARE out_row entity_class;
BEGIN
	FOR out_row IN 
		SELECT * FROM entity_class
             LEFT JOIN defaults ON setting_key = &#39;roll_prefix&#39;
		WHERE active and pg_has_role(SESSION_USER, 
                                     coalesce(defaults.value, 
                                     &#39;lsmb_&#39; || current_database() || &#39;__&#39;) ||
                                     &#39;contact_class_&#39; ||
                                     lower(regexp_replace(class, &#39; &#39;, &#39;_&#39;)), 
                                     &#39;USAGE&#39;)
		ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_credit(in_entity_class integer, in_entity_id integer) -->
    <section id="lsmb13.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer"
             xreflabel="lsmb13entity__list_credit(in_entity_class integer, in_entity_id integer)">
      <title id="lsmb13.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer-title">
       entity__list_credit(in_entity_class integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer-titleabbrev">
       entity__list_credit(in_entity_class integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_credit_retrieve</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of entity credit account entries for the entity and of the
entity class.
        <programlisting>
DECLARE out_row entity_credit_retrieve;
BEGIN
	
	FOR out_row IN 
		SELECT  c.id, e.id, ec.entity_class, ec.discount, 
                        ec.discount_terms,
			ec.taxincluded, ec.creditlimit, ec.terms, 
			ec.meta_number, ec.description, ec.business_id, 
			ec.language_code, 
			ec.pricegroup_id, ec.curr, ec.startdate, 
			ec.enddate, ec.ar_ap_account_id, ec.cash_account_id, 
                        ec.discount_account_id,
			ec.threshold, e.control_code, ec.id, ec.pay_to_name,
                        ec.taxform_id
		FROM company c
		JOIN entity e ON (c.entity_id = e.id)
		JOIN entity_credit_account ec ON (c.entity_id = ec.entity_id)
		WHERE e.id = in_entity_id
			AND ec.entity_class = 
				CASE WHEN in_entity_class = 3 THEN 2
				     WHEN in_entity_class IS NULL 
					THEN ec.entity_class
				ELSE in_entity_class END
	LOOP

		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__save_bank_account(in_bank_account_id integer, in_iban text, in_bic text, in_entity_id integer) -->
    <section id="lsmb13.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-text-in-bic-text-in-entity-id-integer"
             xreflabel="lsmb13entity__save_bank_account(in_bank_account_id integer, in_iban text, in_bic text, in_entity_id integer)">
      <title id="lsmb13.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-text-in-bic-text-in-entity-id-integer-title">
       entity__save_bank_account(in_bank_account_id integer, in_iban text, in_bic text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-text-in-bic-text-in-entity-id-integer-titleabbrev">
       entity__save_bank_account(in_bank_account_id integer, in_iban text, in_bic text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves a bank account to the entity.
        <programlisting>
DECLARE out_id int;
BEGIN
        UPDATE entity_bank_account
           SET bic = in_bic,
               iban = in_iban
         WHERE id = in_bank_account_id;

        IF FOUND THEN
                out_id = in_bank_account_id;
        ELSE
	  	INSERT INTO entity_bank_account(entity_id, bic, iban)
		VALUES(in_entity_id, in_bic, in_iban);
	        SELECT CURRVAL(&#39;entity_bank_account_id_seq&#39;) INTO out_id ;
	END IF;

	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__save_notes(in_subject integer, in_note text, in_entity_id text) -->
    <section id="lsmb13.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text"
             xreflabel="lsmb13entity__save_notes(in_subject integer, in_note text, in_entity_id text)">
      <title id="lsmb13.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text-title">
       entity__save_notes(in_subject integer, in_note text, in_entity_id text)
      </title>
      <titleabbrev id="lsmb13.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text-titleabbrev">
       entity__save_notes(in_subject integer, in_note text, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity-level note.  Such a note is valid for all credit accounts 
attached to that entity.  Returns the id of the note.  
        <programlisting>
DECLARE out_id int;
BEGIN
	-- TODO, change this to create vector too
	INSERT INTO entity_note (ref_key, note_class, entity_id, note, vector, subject)
	VALUES (in_entity_id, 1, in_entity_id, in_note, &#39;&#39;, in_subject);

	SELECT currval(&#39;note_id_seq&#39;) INTO out_id;
	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit__get(in_id integer) -->
    <section id="lsmb13.function.entity-credit-get-in-id-integer"
             xreflabel="lsmb13entity_credit__get(in_id integer)">
      <title id="lsmb13.function.entity-credit-get-in-id-integer-title">
       entity_credit__get(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-credit-get-in-id-integer-titleabbrev">
       entity_credit__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity credit account info.
        <programlisting>
SELECT * FROM entity_credit_account WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text) -->
    <section id="lsmb13.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text"
             xreflabel="lsmb13entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)">
      <title id="lsmb13.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text-title">
       entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)
      </title>
      <titleabbrev id="lsmb13.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text-titleabbrev">
       entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an entity credit id, based on entity_id, entity_class, 
and meta_number.  This is the preferred way to locate an account if all three of 
these are known
        <programlisting>
DECLARE out_var int;
BEGIN
	SELECT id INTO out_var FROM entity_credit_account
	WHERE entity_id = in_entity_id 
		AND in_entity_class = entity_class
		AND in_meta_number = meta_number;

	RETURN out_var;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer) -->
    <section id="lsmb13.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer"
             xreflabel="lsmb13entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)">
      <title id="lsmb13.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer-title">
       entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer-titleabbrev">
       entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the credit id from the meta_number and entity_class.
        <programlisting>
DECLARE out_credit_id int;
BEGIN
	SELECT id INTO out_credit_id 
	FROM entity_credit_account 
	WHERE meta_number = in_meta_number 
		AND entity_class = in_account_class;

	RETURN out_credit_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_credit_id integer) -->
    <section id="lsmb13.function.entity-credit-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-credit-id-integer"
             xreflabel="lsmb13entity_credit_save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_credit_id integer)">
      <title id="lsmb13.function.entity-credit-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-credit-id-integer-title">
       entity_credit_save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-credit-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-credit-id-integer-titleabbrev">
       entity_credit_save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity credit account.  Returns the id of the record saved.  
        <programlisting>
    
    DECLARE
        t_entity_class int;
        l_id int;
	t_meta_number text; 
	t_mn_default_key text;
    BEGIN
	-- TODO:  Move to mapping table.
            IF in_entity_class = 1 THEN
	       t_mn_default_key := &#39;vendornumber&#39;;
	    ELSIF in_entity_class = 2 THEN
	       t_mn_default_key := &#39;customernumber&#39;;
	    END IF;
	    IF in_meta_number IS NULL THEN
		t_meta_number := setting_increment(t_mn_default_key);
	    ELSE
		t_meta_number := in_meta_number;
	    END IF;
            update entity_credit_account SET
                discount = in_discount,
                taxincluded = in_taxincluded,
                creditlimit = in_creditlimit,
		description = in_description,
                terms = in_terms,
                ar_ap_account_id = in_ar_ap_account_id,
                cash_account_id = in_cash_account_id,
                discount_account_id = in_discount_account_id,
                meta_number = t_meta_number,
                business_id = in_business_id,
                language_code = in_language_code,
                pricegroup_id = in_pricegroup_id,
                curr = in_curr,
                startdate = in_startdate,
                enddate = in_enddate,
                threshold = in_threshold,
		discount_terms = in_discount_terms,
		pay_to_name = in_pay_to_name,
		taxform_id = in_taxform_id
            where id = in_credit_id;
        
         IF FOUND THEN
            RETURN in_credit_id;
         ELSE
            INSERT INTO entity_credit_account (
                entity_id,
                entity_class,
                discount, 
                description,
                taxincluded,
                creditlimit,
                terms,
                meta_number,
                business_id,
                language_code,
                pricegroup_id,
                curr,
                startdate,
                enddate,
                discount_terms,
                threshold,
		ar_ap_account_id,
                pay_to_name,
                taxform_id,
                cash_account_id,
                discount_account_id
            )
            VALUES (
                in_entity_id,
                in_entity_class,
                in_discount, 
                in_description,
                in_taxincluded,
                in_creditlimit,
                in_terms,
                t_meta_number,
                in_business_id,
                in_language_code,
                in_pricegroup_id,
                in_curr,
                in_startdate,
                in_enddate,
                in_discount_terms,
                in_threshold,
                in_ar_ap_account_id,
                in_pay_to_name,
                in_taxform_id,
		in_cash_account_id,
                in_discount_account_id
            );
            RETURN currval(&#39;entity_credit_account_id_seq&#39;);
       END IF;

    END;
    
</programlisting>
      </para>
    </section>

<!-- Function entity_list_contact_class() -->
    <section id="lsmb13.function.entity-list-contact-class"
             xreflabel="lsmb13entity_list_contact_class()">
      <title id="lsmb13.function.entity-list-contact-class-title">
       entity_list_contact_class()
      </title>
      <titleabbrev id="lsmb13.function.entity-list-contact-class-titleabbrev">
       entity_list_contact_class()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contact classes ordered by ID.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM contact_class ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_save(in_entity_class integer, in_name text, in_entity_id integer) -->
    <section id="lsmb13.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer"
             xreflabel="lsmb13entity_save(in_entity_class integer, in_name text, in_entity_id integer)">
      <title id="lsmb13.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer-title">
       entity_save(in_entity_class integer, in_name text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer-titleabbrev">
       entity_save(in_entity_class integer, in_name text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Currently unused.  Left in because it is believed it may be helpful.

This saves an entity, with the control code being the next available via the 
defaults table.
        <programlisting>

    DECLARE
        e entity;
        e_id int;
        
    BEGIN
    
        select * into e from entity where id = in_entity_id;
        
        update 
            entity 
        SET
            name = in_name,
            entity_class = in_entity_class
        WHERE
            id = in_entity_id;
        IF NOT FOUND THEN
            -- do the insert magic.
            e_id = nextval(&#39;entity_id_seq&#39;);
            insert into entity (id, name, entity_class) values 
                (e_id,
                in_name,
                in_entity_class
                );
            return e_id;
        END IF;
        return in_entity_id;
            
    END;

</programlisting>
      </para>
    </section>

<!-- Function eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer) -->
    <section id="lsmb13.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer"
             xreflabel="lsmb13eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)">
      <title id="lsmb13.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-title">
       eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </title>
      <titleabbrev id="lsmb13.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-titleabbrev">
       eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Zeroes accounts and then creates a checkpoint. in_end_date is the date when
the books are to be closed, in_reference and in_description become the 
reference and description of the gl transaction, and in_retention_acc_id is
the retained earnings account id.
        <programlisting>
BEGIN
	IF eoy_zero_accounts(in_end_date, in_reference, in_description, in_retention_acc_id) &gt; 0 THEN
		PERFORM eoy_create_checkpoint(in_end_date);
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_create_checkpoint(in_end_date date) -->
    <section id="lsmb13.function.eoy-create-checkpoint-in-end-date-date"
             xreflabel="lsmb13eoy_create_checkpoint(in_end_date date)">
      <title id="lsmb13.function.eoy-create-checkpoint-in-end-date-date-title">
       eoy_create_checkpoint(in_end_date date)
      </title>
      <titleabbrev id="lsmb13.function.eoy-create-checkpoint-in-end-date-date-titleabbrev">
       eoy_create_checkpoint(in_end_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates checkpoints for each account at a specific date.  Books are considered
closed when they occur before the latest checkpoint timewise.  This means that
balances (and credit/debit amounts) can be calculated starting at a checkpoint
and moving forward (thus providing a mechanism for expunging old data while 
keeping balances correct at some future point).
        <programlisting>
DECLARE ret_val int;
	approval_check int;
	cp_date        date;
BEGIN
	IF in_end_date &gt; now()::date THEN
		RAISE EXCEPTION &#39;Invalid date:  Must be earlier than present&#39;;
	END IF;

	SELECT count(*) into approval_check
	FROM acc_trans ac
	JOIN (
		select id, approved, transdate FROM ar UNION
		SELECT id, approved, transdate FROM gl UNION
		SELECT id, approved, transdate FROM ap
	) gl ON (gl.id = ac.trans_id)
	WHERE (ac.approved IS NOT TRUE AND ac.transdate &lt;= in_end_date) 
		OR (gl.approved IS NOT TRUE AND gl.transdate &lt;= in_end_date);

	if approval_check &gt; 0 THEN
		RAISE EXCEPTION &#39;Unapproved transactions in closed period&#39;;
	END IF;
	
	SELECT max(end_date) INTO cp_date FROM account_checkpoint WHERE
	end_date &lt; in_end_date;

	INSERT INTO 
	account_checkpoint (end_date, account_id, amount, debits, credits)
    SELECT in_end_date, COALESCE(a.chart_id, cp.account_id),
	    COALESCE(SUM (a.amount),0) + coalesce(MAX (cp.amount), 0),
	    COALESCE(SUM (CASE WHEN (a.amount &lt; 0) THEN a.amount ELSE 0 END), 0) +
	     COALESCE( MIN (cp.debits), 0),
	    COALESCE(SUM (CASE WHEN (a.amount &gt; 0) THEN a.amount ELSE 0 END), 0) +
	     COALESCE( MAX (cp.credits), 0)
	FROM 
	(SELECT * FROM acc_trans WHERE transdate &lt;= in_end_date AND
	 transdate &gt; COALESCE(cp_date, &#39;1200-01-01&#39;)) a
	FULL OUTER JOIN (
		select account_id, end_date, amount, debits, credits 
		from account_checkpoint
		WHERE end_date = cp_date
		) cp on (a.chart_id = cp.account_id)
	group by COALESCE(a.chart_id, cp.account_id);

	SELECT count(*) INTO ret_val FROM account_checkpoint 
	where end_date = in_end_date;

	return ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_earnings_accounts() -->
    <section id="lsmb13.function.eoy-earnings-accounts"
             xreflabel="lsmb13eoy_earnings_accounts()">
      <title id="lsmb13.function.eoy-earnings-accounts-title">
       eoy_earnings_accounts()
      </title>
      <titleabbrev id="lsmb13.function.eoy-earnings-accounts-titleabbrev">
       eoy_earnings_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists equity accounts for the retained earnings dropdown.
        <programlisting>
    SELECT * 
      FROM account
     WHERE category = &#39;Q&#39;
     ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function eoy_reopen_books(in_end_date date) -->
    <section id="lsmb13.function.eoy-reopen-books-in-end-date-date"
             xreflabel="lsmb13eoy_reopen_books(in_end_date date)">
      <title id="lsmb13.function.eoy-reopen-books-in-end-date-date-title">
       eoy_reopen_books(in_end_date date)
      </title>
      <titleabbrev id="lsmb13.function.eoy-reopen-books-in-end-date-date-titleabbrev">
       eoy_reopen_books(in_end_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Removes checkpoints and reverses yearend transactions on in_end_date
        <programlisting>
BEGIN
	PERFORM count(*) FROM account_checkpoint WHERE end_date = in_end_date;

	IF NOT FOUND THEN
		RETURN FALSE;
	END IF;

	DELETE FROM account_checkpoint WHERE end_date = in_end_date;

	PERFORM count(*) FROM yearend 
	WHERE transdate = in_end_date and reversed is not true;

	IF FOUND THEN
		INSERT INTO gl (reference, description, approved)
		SELECT &#39;Reversing &#39; || reference, &#39;Reversing &#39; || description,
			true
		FROM gl WHERE id = (select trans_id from yearend 
			where transdate = in_end_date and reversed is not true);

		INSERT INTO acc_trans (chart_id, amount, transdate, trans_id,
			approved)
		SELECT chart_id, amount * -1, currval(&#39;id&#39;), true
		FROM acc_trans where trans_id = (select trans_id from yearend
			where transdate = in_end_date and reversed is not true);

		UPDATE yearend SET reversed = true where transdate = in_end_date
			and reversed is not true;
	END IF;

	DELETE FROM account_checkpoint WHERE end_date = in_end_date;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer) -->
    <section id="lsmb13.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer"
             xreflabel="lsmb13eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)">
      <title id="lsmb13.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-title">
       eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </title>
      <titleabbrev id="lsmb13.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-titleabbrev">
       eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts a transaction which zeroes the income and expense accounts, moving the
net balance there into a retained earnings account identified by 
in_retention_acc_id.
        <programlisting>
DECLARE ret_val int;
BEGIN
	INSERT INTO gl (transdate, reference, description, approved)
	VALUES (in_end_date, in_reference, in_description, true);

	INSERT INTO yearend (trans_id, transdate) values (currval(&#39;id&#39;), in_end_date);
	INSERT INTO acc_trans (transdate, chart_id, trans_id, amount)
	SELECT in_end_date, a.chart_id, currval(&#39;id&#39;),
		(sum(a.amount) + coalesce(max(cp.amount), 0)) * -1
	FROM acc_trans a
	LEFT JOIN (
		select account_id, end_date, amount from account_checkpoint
		WHERE end_date = (select max(end_date) from account_checkpoint
				where end_date &lt; in_end_date)
		) cp on (a.chart_id = cp.account_id)
	JOIN account acc ON (acc.id = a.chart_id)
	WHERE a.transdate &lt;= in_end_date 
		AND a.transdate &gt; coalesce(cp.end_date, a.transdate - 1)
		AND (acc.category IN (&#39;I&#39;, &#39;E&#39;)
                      OR acc.category = &#39;Q&#39; AND acc.is_temp)
	GROUP BY a.chart_id;

	INSERT INTO acc_trans (transdate, trans_id, chart_id, amount)
	SELECT in_end_date, currval(&#39;id&#39;), in_retention_acc_id, 
		coalesce(sum(amount) * -1, 0)
	FROM acc_trans WHERE trans_id = currval(&#39;id&#39;);


	SELECT count(*) INTO ret_val from acc_trans 
	where trans_id = currval(&#39;id&#39;);

	RETURN ret_val;
end;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb13.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb13file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb13.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb13.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a good or service.  in_content OR id can be set.
Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to entity credit accounts.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_eca
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb13.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb13file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb13.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb13.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a contact or entity.  in_content OR id can be 
set. Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to entities
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_entity
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb13.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb13file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb13.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb13.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to an order.  in_content OR id can be set.
Setting both raises an exception.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Conflicting options file_id and content$e$;
       END IF;
       IF in_file_class = 1 THEN
           INSERT INTO file_tx_to_order        
                  (file_id, source_class, ref_key, dest_class, attached_by,
                  attached_at)
           VALUES (in_id, 1, in_ref_key, 2, person__get_my_entity_id(), now());
       ELSIF in_file_class = 2 THEN
           INSERT INTO file_order_to_order
                  (file_id, source_class, ref_key, dest_class, attached_by,
                  attached_at)
           VALUES (in_id, 2, in_ref_key, 2, person__get_my_entity_id(), now());
       ELSE 
           RAISE EXCEPTION $E$Invalid file class$E$;
       END IF;
       SELECT * INTO retval FROM file_base where id = in_id;
       RETURN retval;
   ELSE
       INSERT INTO file_order
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb13.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb13file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb13.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb13.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a good or service.  in_content OR id can be set.
Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to parts
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_part
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb13.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb13file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb13.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb13.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a transaction.  in_content OR id can be set.
Setting both raises an exception.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       INSERT INTO file_order_to_tx        
              (file_id, source_class, ref_key, dest_class, attached_by,
              attached_at)
       VALUES (in_id, 2, in_ref_key, 1, person__get_my_entity_id(), now());

       SELECT * INTO retval FROM file_base where id = in_id;
       RETURN retval;
   ELSE
       INSERT INTO file_transaction 
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__get(in_file_class integer, in_id integer) -->
    <section id="lsmb13.function.file-get-in-file-class-integer-in-id-integer"
             xreflabel="lsmb13file__get(in_file_class integer, in_id integer)">
      <title id="lsmb13.function.file-get-in-file-class-integer-in-id-integer-title">
       file__get(in_file_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.file-get-in-file-class-integer-in-id-integer-titleabbrev">
       file__get(in_file_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves the file information specified including content.
        <programlisting>
SELECT * FROM file_base where id = $1 and file_class = $2;
</programlisting>
      </para>
    </section>

<!-- Function file__get_for_template(in_file_class integer, in_ref_key integer) -->
    <section id="lsmb13.function.file-get-for-template-in-file-class-integer-in-ref-key-integer"
             xreflabel="lsmb13file__get_for_template(in_file_class integer, in_ref_key integer)">
      <title id="lsmb13.function.file-get-for-template-in-file-class-integer-in-ref-key-integer-title">
       file__get_for_template(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="lsmb13.function.file-get-for-template-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__get_for_template(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 

SELECT m.mime_type, CASE WHEN f.file_class = 3 THEN ref_key ||&#39;-&#39;|| f.file_name
                         ELSE f.file_name END, 
       f.description, f.uploaded_by, e.name, 
       f.uploaded_at, f.id, f.ref_key, f.file_class,  f.content
  FROM mime_type m
  JOIN file_base f ON f.mime_type_id = m.id
  JOIN entity e ON f.uploaded_by = e.id
 WHERE f.ref_key = $1 and f.file_class = $2
       AND m.invoice_include 
       OR f.id IN (SELECT max(fb.id) 
                   FROM file_base fb
                   JOIN mime_type m ON fb.mime_type_id = m.id
                        AND m.mime_type ilike &#39;image%&#39;
                   JOIN invoice i ON i.trans_id = $1
                        AND i.parts_id = fb.ref_key
                  WHERE fb.file_class = 3)
</programlisting>
      </para>
    </section>

<!-- Function file__get_mime_type(in_mime_type_text integer, in_mime_type_id text) -->
    <section id="lsmb13.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text"
             xreflabel="lsmb13file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)">
      <title id="lsmb13.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text-title">
       file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)
      </title>
      <titleabbrev id="lsmb13.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text-titleabbrev">
       file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>mime_type</seg>
        </seglistitem>
       </segmentedlist>
 
       Retrieves mime type information associated with a file object.
        <programlisting>
select * from mime_type 
 where ($1 IS NULL OR id = $1) AND ($2 IS NULL OR mime_type = $2);
</programlisting>
      </para>
    </section>

<!-- Function file__list_by(in_file_class integer, in_ref_key integer) -->
    <section id="lsmb13.function.file-list-by-in-file-class-integer-in-ref-key-integer"
             xreflabel="lsmb13file__list_by(in_file_class integer, in_ref_key integer)">
      <title id="lsmb13.function.file-list-by-in-file-class-integer-in-ref-key-integer-title">
       file__list_by(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="lsmb13.function.file-list-by-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__list_by(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of files attached to a database object.  No content is 
retrieved.
        <programlisting>

SELECT m.mime_type, f.file_name, f.description, f.uploaded_by, e.name, 
       f.uploaded_at, f.id, f.ref_key, f.file_class, 
       case when m.mime_type = &#39;text/x-uri&#39; THEN f.content ELSE NULL END
  FROM mime_type m
  JOIN file_base f ON f.mime_type_id = m.id
  JOIN entity e ON f.uploaded_by = e.id
 WHERE f.ref_key = $1 and f.file_class = $2;

</programlisting>
      </para>
    </section>

<!-- Function file__list_links(in_file_class integer, in_ref_key integer) -->
    <section id="lsmb13.function.file-list-links-in-file-class-integer-in-ref-key-integer"
             xreflabel="lsmb13file__list_links(in_file_class integer, in_ref_key integer)">
      <title id="lsmb13.function.file-list-links-in-file-class-integer-in-ref-key-integer-title">
       file__list_links(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="lsmb13.function.file-list-links-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__list_links(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_links</seg>
        </seglistitem>
       </segmentedlist>
 
        This function retrieves a list of file attachments on a specified object.
        <programlisting> select * from file_links where ref_key = $1 and dest_class = $2;
</programlisting>
      </para>
    </section>

<!-- Function file_links_vrebuild() -->
    <section id="lsmb13.function.file-links-vrebuild"
             xreflabel="lsmb13file_links_vrebuild()">
      <title id="lsmb13.function.file-links-vrebuild-title">
       file_links_vrebuild()
      </title>
      <titleabbrev id="lsmb13.function.file-links-vrebuild-titleabbrev">
       file_links_vrebuild()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   viewline file_view_catalog%rowtype;
   stmt text;
BEGIN
   stmt := &#39;&#39;;
   FOR viewline IN
       select * from file_view_catalog
   LOOP
       IF stmt = &#39;&#39; THEN
           stmt := &#39;SELECT * FROM &#39; || quote_ident(viewline.view_name) || &#39;
&#39;;
       ELSE
           stmt := stmt || &#39; UNION
SELECT * FROM &#39;|| quote_ident(viewline.view_name) || &#39;
&#39;;
       END IF; 
   END LOOP;
   EXECUTE &#39;CREATE OR REPLACE VIEW file_links AS
&#39; || stmt;
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function form_check(in_form_id integer, in_session_id integer) -->
    <section id="lsmb13.function.form-check-in-form-id-integer-in-session-id-integer"
             xreflabel="lsmb13form_check(in_form_id integer, in_session_id integer)">
      <title id="lsmb13.function.form-check-in-form-id-integer-in-session-id-integer-title">
       form_check(in_form_id integer, in_session_id integer)
      </title>
      <titleabbrev id="lsmb13.function.form-check-in-form-id-integer-in-session-id-integer-titleabbrev">
       form_check(in_form_id integer, in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks to see if an open form (record in open_forms) exists with 
the form_id and session_id provided.  Returns true if exists, false if not.
        <programlisting>
SELECT count(*) = 1 
  FROM open_forms f
  JOIN &quot;session&quot; s USING (session_id)
  JOIN users u ON (s.users_id = u.id)
 WHERE f.session_id = $1 and f.id = $2 and u.username = SESSION_USER;
</programlisting>
      </para>
    </section>

<!-- Function form_close(in_form_id integer, in_session_id integer) -->
    <section id="lsmb13.function.form-close-in-form-id-integer-in-session-id-integer"
             xreflabel="lsmb13form_close(in_form_id integer, in_session_id integer)">
      <title id="lsmb13.function.form-close-in-form-id-integer-in-session-id-integer-title">
       form_close(in_form_id integer, in_session_id integer)
      </title>
      <titleabbrev id="lsmb13.function.form-close-in-form-id-integer-in-session-id-integer-titleabbrev">
       form_close(in_form_id integer, in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Closes out the form by deleting it from the open_forms table.

Returns true if found, false if not.

        <programlisting>
DECLARE form_test bool;
BEGIN
	form_test := form_check(in_session_id, in_form_id);

	IF form_test is true THEN 
		DELETE FROM open_forms 
		WHERE session_id = in_session_id AND id = in_form_id;

		RETURN TRUE;

	ELSE RETURN FALSE;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function form_open(in_session_id integer) -->
    <section id="lsmb13.function.form-open-in-session-id-integer"
             xreflabel="lsmb13form_open(in_session_id integer)">
      <title id="lsmb13.function.form-open-in-session-id-integer-title">
       form_open(in_session_id integer)
      </title>
      <titleabbrev id="lsmb13.function.form-open-in-session-id-integer-titleabbrev">
       form_open(in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This opens a form, and returns the id of the form opened.
        <programlisting>
DECLARE usertest bool;
BEGIN
        SELECT count(*) = 1 INTO usertest FROM session 
         WHERE session_id = in_session_id 
               AND users_id IN (select id from users 
                                WHERE username = SESSION_USER);

        IF usertest is not true THEN
            RAISE EXCEPTION &#39;Invalid session&#39;;
        END IF;
      
	INSERT INTO open_forms (session_id) VALUES (in_session_id);
	RETURN currval(&#39;open_forms_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function get_covers(tsvector, tsquery) -->
    <section id="lsmb13.function.get-covers-tsvector-tsquery"
             xreflabel="lsmb13get_covers(tsvector, tsquery)">
      <title id="lsmb13.function.get-covers-tsvector-tsquery-title">
       get_covers(tsvector, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.get-covers-tsvector-tsquery-titleabbrev">
       get_covers(tsvector, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_get_covers</programlisting>
      </para>
    </section>

<!-- Function get_default_lang() -->
    <section id="lsmb13.function.get-default-lang"
             xreflabel="lsmb13get_default_lang()">
      <title id="lsmb13.function.get-default-lang-title">
       get_default_lang()
      </title>
      <titleabbrev id="lsmb13.function.get-default-lang-titleabbrev">
       get_default_lang()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT coalesce((select description FROM language 
    WHERE code = (SELECT substring(value, 1, 2) FROM defaults
                   WHERE setting_key = &#39;default_language&#39;)), &#39;english&#39;);
</programlisting>
      </para>
    </section>

<!-- Function get_fractional_month(in_date_second date, in_date_first date) -->
    <section id="lsmb13.function.get-fractional-month-in-date-second-date-in-date-first-date"
             xreflabel="lsmb13get_fractional_month(in_date_second date, in_date_first date)">
      <title id="lsmb13.function.get-fractional-month-in-date-second-date-in-date-first-date-title">
       get_fractional_month(in_date_second date, in_date_first date)
      </title>
      <titleabbrev id="lsmb13.function.get-fractional-month-in-date-second-date-in-date-first-date-titleabbrev">
       get_fractional_month(in_date_second date, in_date_first date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of months between two dates in numeric form.
        <programlisting>
SELECT CASE WHEN is_same_month($1, $2)
            THEN ($2 - $1)::numeric
                 / days_in_month($1)
            ELSE (get_fractional_month(
                   $1, (date_trunc(&#39;MONTH&#39;, $1) 
                       + &#39;1 month - 1 second&#39;::interval)::date)
                 + get_fractional_month(date_trunc(&#39;MONTH&#39;, $2)::date, $2)
                 + (extract (&#39;YEAR&#39; from $2) - extract (&#39;YEAR&#39; from $1) * 12)
                 + extract (&#39;MONTH&#39; from $1) - extract (&#39;MONTH&#39; from $2) 
                 - 1)::numeric
            END;
</programlisting>
      </para>
    </section>

<!-- Function get_fractional_year(in_date_to date, in_date_from date) -->
    <section id="lsmb13.function.get-fractional-year-in-date-to-date-in-date-from-date"
             xreflabel="lsmb13get_fractional_year(in_date_to date, in_date_from date)">
      <title id="lsmb13.function.get-fractional-year-in-date-to-date-in-date-from-date-title">
       get_fractional_year(in_date_to date, in_date_from date)
      </title>
      <titleabbrev id="lsmb13.function.get-fractional-year-in-date-to-date-in-date-from-date-titleabbrev">
       get_fractional_year(in_date_to date, in_date_from date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the decimal representation of the fractional year.
        <programlisting>
   select ($2 - $1
            - leap_days(next_leap_year_calc($1, false), 
                       next_leap_year_calc($2, true)))
            /365::numeric;
</programlisting>
      </para>
    </section>

<!-- Function get_link_descriptions() -->
    <section id="lsmb13.function.get-link-descriptions"
             xreflabel="lsmb13get_link_descriptions()">
      <title id="lsmb13.function.get-link-descriptions-title">
       get_link_descriptions()
      </title>
      <titleabbrev id="lsmb13.function.get-link-descriptions-titleabbrev">
       get_link_descriptions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_link_description</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets a set of all valid account_link descriptions.
        <programlisting>
    SELECT * FROM account_link_description;
</programlisting>
      </para>
    </section>

<!-- Function gin_extract_trgm(text, internal) -->
    <section id="lsmb13.function.gin-extract-trgm-text-internal"
             xreflabel="lsmb13gin_extract_trgm(text, internal)">
      <title id="lsmb13.function.gin-extract-trgm-text-internal-title">
       gin_extract_trgm(text, internal)
      </title>
      <titleabbrev id="lsmb13.function.gin-extract-trgm-text-internal-titleabbrev">
       gin_extract_trgm(text, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gin_extract_trgm</programlisting>
      </para>
    </section>

<!-- Function gin_extract_trgm(text, internal, smallint, internal, internal) -->
    <section id="lsmb13.function.gin-extract-trgm-text-internal-smallint-internal-internal"
             xreflabel="lsmb13gin_extract_trgm(text, internal, smallint, internal, internal)">
      <title id="lsmb13.function.gin-extract-trgm-text-internal-smallint-internal-internal-title">
       gin_extract_trgm(text, internal, smallint, internal, internal)
      </title>
      <titleabbrev id="lsmb13.function.gin-extract-trgm-text-internal-smallint-internal-internal-titleabbrev">
       gin_extract_trgm(text, internal, smallint, internal, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gin_extract_trgm</programlisting>
      </para>
    </section>

<!-- Function gin_trgm_consistent(internal, smallint, text, integer, internal, internal) -->
    <section id="lsmb13.function.gin-trgm-consistent-internal-smallint-text-integer-internal-internal"
             xreflabel="lsmb13gin_trgm_consistent(internal, smallint, text, integer, internal, internal)">
      <title id="lsmb13.function.gin-trgm-consistent-internal-smallint-text-integer-internal-internal-title">
       gin_trgm_consistent(internal, smallint, text, integer, internal, internal)
      </title>
      <titleabbrev id="lsmb13.function.gin-trgm-consistent-internal-smallint-text-integer-internal-internal-titleabbrev">
       gin_trgm_consistent(internal, smallint, text, integer, internal, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gin_trgm_consistent</programlisting>
      </para>
    </section>

<!-- Function gl_audit_trail_append() -->
    <section id="lsmb13.function.gl-audit-trail-append"
             xreflabel="lsmb13gl_audit_trail_append()">
      <title id="lsmb13.function.gl-audit-trail-append-title">
       gl_audit_trail_append()
      </title>
      <titleabbrev id="lsmb13.function.gl-audit-trail-append-titleabbrev">
       gl_audit_trail_append()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides centralized support for insertions into audittrail.

        <programlisting>
DECLARE
   t_reference text;
   t_row RECORD;
BEGIN

IF TG_OP = &#39;INSERT&#39; then
   t_row := NEW;
ELSE
   t_row := OLD;
END IF;

IF TG_RELNAME IN (&#39;ar&#39;, &#39;ap&#39;) THEN
    t_reference := t_row.invnumber;
ELSE 
    t_reference := t_row.reference;
END IF;

INSERT INTO audittrail (trans_id, reference, action, person_id)
values (t_row.id, t_reference, TG_OP, person__get_my_entity_id());

return null; -- AFTER TRIGGER ONLY, SAFE
END;
</programlisting>
      </para>
    </section>

<!-- Function gtrgm_compress(internal) -->
    <section id="lsmb13.function.gtrgm-compress-internal"
             xreflabel="lsmb13gtrgm_compress(internal)">
      <title id="lsmb13.function.gtrgm-compress-internal-title">
       gtrgm_compress(internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-compress-internal-titleabbrev">
       gtrgm_compress(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_compress</programlisting>
      </para>
    </section>

<!-- Function gtrgm_consistent(internal, text, integer, oid, internal) -->
    <section id="lsmb13.function.gtrgm-consistent-internal-text-integer-oid-internal"
             xreflabel="lsmb13gtrgm_consistent(internal, text, integer, oid, internal)">
      <title id="lsmb13.function.gtrgm-consistent-internal-text-integer-oid-internal-title">
       gtrgm_consistent(internal, text, integer, oid, internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-consistent-internal-text-integer-oid-internal-titleabbrev">
       gtrgm_consistent(internal, text, integer, oid, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_consistent</programlisting>
      </para>
    </section>

<!-- Function gtrgm_decompress(internal) -->
    <section id="lsmb13.function.gtrgm-decompress-internal"
             xreflabel="lsmb13gtrgm_decompress(internal)">
      <title id="lsmb13.function.gtrgm-decompress-internal-title">
       gtrgm_decompress(internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-decompress-internal-titleabbrev">
       gtrgm_decompress(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_decompress</programlisting>
      </para>
    </section>

<!-- Function gtrgm_in(cstring) -->
    <section id="lsmb13.function.gtrgm-in-cstring"
             xreflabel="lsmb13gtrgm_in(cstring)">
      <title id="lsmb13.function.gtrgm-in-cstring-title">
       gtrgm_in(cstring)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-in-cstring-titleabbrev">
       gtrgm_in(cstring)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>gtrgm</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_in</programlisting>
      </para>
    </section>

<!-- Function gtrgm_out(lsmb13.gtrgm) -->
    <section id="lsmb13.function.gtrgm-out-lsmb13.gtrgm"
             xreflabel="lsmb13gtrgm_out(lsmb13.gtrgm)">
      <title id="lsmb13.function.gtrgm-out-lsmb13.gtrgm-title">
       gtrgm_out(lsmb13.gtrgm)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-out-lsmb13.gtrgm-titleabbrev">
       gtrgm_out(lsmb13.gtrgm)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>cstring</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_out</programlisting>
      </para>
    </section>

<!-- Function gtrgm_penalty(internal, internal, internal) -->
    <section id="lsmb13.function.gtrgm-penalty-internal-internal-internal"
             xreflabel="lsmb13gtrgm_penalty(internal, internal, internal)">
      <title id="lsmb13.function.gtrgm-penalty-internal-internal-internal-title">
       gtrgm_penalty(internal, internal, internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-penalty-internal-internal-internal-titleabbrev">
       gtrgm_penalty(internal, internal, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_penalty</programlisting>
      </para>
    </section>

<!-- Function gtrgm_picksplit(internal, internal) -->
    <section id="lsmb13.function.gtrgm-picksplit-internal-internal"
             xreflabel="lsmb13gtrgm_picksplit(internal, internal)">
      <title id="lsmb13.function.gtrgm-picksplit-internal-internal-title">
       gtrgm_picksplit(internal, internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-picksplit-internal-internal-titleabbrev">
       gtrgm_picksplit(internal, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_picksplit</programlisting>
      </para>
    </section>

<!-- Function gtrgm_same(lsmb13.gtrgm, lsmb13.gtrgm, internal) -->
    <section id="lsmb13.function.gtrgm-same-lsmb13.gtrgm-lsmb13.gtrgm-internal"
             xreflabel="lsmb13gtrgm_same(lsmb13.gtrgm, lsmb13.gtrgm, internal)">
      <title id="lsmb13.function.gtrgm-same-lsmb13.gtrgm-lsmb13.gtrgm-internal-title">
       gtrgm_same(lsmb13.gtrgm, lsmb13.gtrgm, internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-same-lsmb13.gtrgm-lsmb13.gtrgm-internal-titleabbrev">
       gtrgm_same(lsmb13.gtrgm, lsmb13.gtrgm, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_same</programlisting>
      </para>
    </section>

<!-- Function gtrgm_union(bytea, internal) -->
    <section id="lsmb13.function.gtrgm-union-bytea-internal"
             xreflabel="lsmb13gtrgm_union(bytea, internal)">
      <title id="lsmb13.function.gtrgm-union-bytea-internal-title">
       gtrgm_union(bytea, internal)
      </title>
      <titleabbrev id="lsmb13.function.gtrgm-union-bytea-internal-titleabbrev">
       gtrgm_union(bytea, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>integer[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>gtrgm_union</programlisting>
      </para>
    </section>

<!-- Function headline(oid, text, tsquery) -->
    <section id="lsmb13.function.headline-oid-text-tsquery"
             xreflabel="lsmb13headline(oid, text, tsquery)">
      <title id="lsmb13.function.headline-oid-text-tsquery-title">
       headline(oid, text, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.headline-oid-text-tsquery-titleabbrev">
       headline(oid, text, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_headline_byid</programlisting>
      </para>
    </section>

<!-- Function headline(oid, text, tsquery, text) -->
    <section id="lsmb13.function.headline-oid-text-tsquery-text"
             xreflabel="lsmb13headline(oid, text, tsquery, text)">
      <title id="lsmb13.function.headline-oid-text-tsquery-text-title">
       headline(oid, text, tsquery, text)
      </title>
      <titleabbrev id="lsmb13.function.headline-oid-text-tsquery-text-titleabbrev">
       headline(oid, text, tsquery, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_headline_byid_opt</programlisting>
      </para>
    </section>

<!-- Function headline(text, text, tsquery) -->
    <section id="lsmb13.function.headline-text-text-tsquery"
             xreflabel="lsmb13headline(text, text, tsquery)">
      <title id="lsmb13.function.headline-text-text-tsquery-title">
       headline(text, text, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.headline-text-text-tsquery-titleabbrev">
       headline(text, text, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_headline_byname</programlisting>
      </para>
    </section>

<!-- Function headline(text, text, tsquery, text) -->
    <section id="lsmb13.function.headline-text-text-tsquery-text"
             xreflabel="lsmb13headline(text, text, tsquery, text)">
      <title id="lsmb13.function.headline-text-text-tsquery-text-title">
       headline(text, text, tsquery, text)
      </title>
      <titleabbrev id="lsmb13.function.headline-text-text-tsquery-text-titleabbrev">
       headline(text, text, tsquery, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_headline_byname</programlisting>
      </para>
    </section>

<!-- Function headline(text, tsquery) -->
    <section id="lsmb13.function.headline-text-tsquery"
             xreflabel="lsmb13headline(text, tsquery)">
      <title id="lsmb13.function.headline-text-tsquery-title">
       headline(text, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.headline-text-tsquery-titleabbrev">
       headline(text, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_headline</programlisting>
      </para>
    </section>

<!-- Function headline(text, tsquery, text) -->
    <section id="lsmb13.function.headline-text-tsquery-text"
             xreflabel="lsmb13headline(text, tsquery, text)">
      <title id="lsmb13.function.headline-text-tsquery-text-title">
       headline(text, tsquery, text)
      </title>
      <titleabbrev id="lsmb13.function.headline-text-tsquery-text-titleabbrev">
       headline(text, tsquery, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_headline_opt</programlisting>
      </para>
    </section>

<!-- Function in_tree(in_search_array integer, in_node_id lsmb13.tree_record[]) -->
    <section id="lsmb13.function.in-tree-in-search-array-integer-in-node-id-lsmb13.tree-recordARRAY"
             xreflabel="lsmb13in_tree(in_search_array integer, in_node_id lsmb13.tree_record[])">
      <title id="lsmb13.function.in-tree-in-search-array-integer-in-node-id-lsmb13.tree-recordARRAY-title">
       in_tree(in_search_array integer, in_node_id lsmb13.tree_record[])
      </title>
      <titleabbrev id="lsmb13.function.in-tree-in-search-array-integer-in-node-id-lsmb13.tree-recordARRAY-titleabbrev">
       in_tree(in_search_array integer, in_node_id lsmb13.tree_record[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT CASE WHEN count(*) &gt; 0 THEN true ELSE false END
  FROM unnest($2) r
 WHERE t @&gt; array[$1];
</programlisting>
      </para>
    </section>

<!-- Function in_tree(in_search_array integer[], in_node_id lsmb13.tree_record[]) -->
    <section id="lsmb13.function.in-tree-in-search-array-integerARRAY-in-node-id-lsmb13.tree-recordARRAY"
             xreflabel="lsmb13in_tree(in_search_array integer[], in_node_id lsmb13.tree_record[])">
      <title id="lsmb13.function.in-tree-in-search-array-integerARRAY-in-node-id-lsmb13.tree-recordARRAY-title">
       in_tree(in_search_array integer[], in_node_id lsmb13.tree_record[])
      </title>
      <titleabbrev id="lsmb13.function.in-tree-in-search-array-integerARRAY-in-node-id-lsmb13.tree-recordARRAY-titleabbrev">
       in_tree(in_search_array integer[], in_node_id lsmb13.tree_record[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT bool_and(in_tree(e, $2))
  FROM unnest($1) e;
</programlisting>
      </para>
    </section>

<!-- Function invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text) -->
    <section id="lsmb13.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text"
             xreflabel="lsmb13invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)">
      <title id="lsmb13.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text-title">
       invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)
      </title>
      <titleabbrev id="lsmb13.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text-titleabbrev">
       invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>ap</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval ap;
BEGIN
	SELECT * INTO retval FROM ap WHERE entity_credit_id = 
		(select id from entity_credit_account where entity_class = 1
		AND meta_number = in_meta_number)
		AND invnumber = in_invoice_number;
	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function is_leapyear(in_date date) -->
    <section id="lsmb13.function.is-leapyear-in-date-date"
             xreflabel="lsmb13is_leapyear(in_date date)">
      <title id="lsmb13.function.is-leapyear-in-date-date-title">
       is_leapyear(in_date date)
      </title>
      <titleabbrev id="lsmb13.function.is-leapyear-in-date-date-titleabbrev">
       is_leapyear(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if date is in a leapyear.  False if not.  Uses the built-in 
PostgreSQL date handling, and no direct detection is done in our code.
        <programlisting>
    select extract(&#39;day&#39; FROM (
                           (extract(&#39;year&#39; FROM $1)::text 
                           || &#39;-02-28&#39;)::date + &#39;1 day&#39;::interval)::date) 
           = 29;
</programlisting>
      </para>
    </section>

<!-- Function is_same_month(in_date2 date, in_date1 date) -->
    <section id="lsmb13.function.is-same-month-in-date2-date-in-date1-date"
             xreflabel="lsmb13is_same_month(in_date2 date, in_date1 date)">
      <title id="lsmb13.function.is-same-month-in-date2-date-in-date1-date-title">
       is_same_month(in_date2 date, in_date1 date)
      </title>
      <titleabbrev id="lsmb13.function.is-same-month-in-date2-date-in-date1-date-titleabbrev">
       is_same_month(in_date2 date, in_date1 date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the two dates are in the same month and year. False 
otherwise.
        <programlisting>
SELECT is_same_year($1, $2) 
       and extract (&#39;MONTH&#39; from $1) = extract (&#39;MONTH&#39; from $2);
</programlisting>
      </para>
    </section>

<!-- Function is_same_year(in_date2 date, in_date1 date) -->
    <section id="lsmb13.function.is-same-year-in-date2-date-in-date1-date"
             xreflabel="lsmb13is_same_year(in_date2 date, in_date1 date)">
      <title id="lsmb13.function.is-same-year-in-date2-date-in-date1-date-title">
       is_same_year(in_date2 date, in_date1 date)
      </title>
      <titleabbrev id="lsmb13.function.is-same-year-in-date2-date-in-date1-date-titleabbrev">
       is_same_year(in_date2 date, in_date1 date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the two dates are in the same year, false otherwise.
        <programlisting>
SELECT  extract (&#39;YEAR&#39; from $1) = extract (&#39;YEAR&#39; from $2);
</programlisting>
      </para>
    </section>

<!-- Function je_get_default_lines() -->
    <section id="lsmb13.function.je-get-default-lines"
             xreflabel="lsmb13je_get_default_lines()">
      <title id="lsmb13.function.je-get-default-lines-title">
       je_get_default_lines()
      </title>
      <titleabbrev id="lsmb13.function.je-get-default-lines-titleabbrev">
       je_get_default_lines()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>character varying</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT value FROM menu_attribute where node_id = 74 and attribute = &#39;rowcount&#39;;
</programlisting>
      </para>
    </section>

<!-- Function je_set_default_lines(in_rowcount integer) -->
    <section id="lsmb13.function.je-set-default-lines-in-rowcount-integer"
             xreflabel="lsmb13je_set_default_lines(in_rowcount integer)">
      <title id="lsmb13.function.je-set-default-lines-in-rowcount-integer-title">
       je_set_default_lines(in_rowcount integer)
      </title>
      <titleabbrev id="lsmb13.function.je-set-default-lines-in-rowcount-integer-titleabbrev">
       je_set_default_lines(in_rowcount integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
    UPDATE menu_attribute set value = $1 
     where node_id = 74 and attribute=&#39;rowcount&#39;;

    IF NOT FOUND THEN
         INSERT INTO menu_attribute (node_id, attribute, value)
              values (74, &#39;rowcount&#39;, $1);
    END IF;
    RETURN $1; 
END;
</programlisting>
      </para>
    </section>

<!-- Function job__create(in_batch_id integer, in_batch_class integer) -->
    <section id="lsmb13.function.job-create-in-batch-id-integer-in-batch-class-integer"
             xreflabel="lsmb13job__create(in_batch_id integer, in_batch_class integer)">
      <title id="lsmb13.function.job-create-in-batch-id-integer-in-batch-class-integer-title">
       job__create(in_batch_id integer, in_batch_class integer)
      </title>
      <titleabbrev id="lsmb13.function.job-create-in-batch-id-integer-in-batch-class-integer-titleabbrev">
       job__create(in_batch_id integer, in_batch_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
	INSERT INTO pending_job (batch_class, batch_id)
	VALUES (coalesce(in_batch_class, 3), in_batch_id);

	RETURN currval(&#39;pending_job_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function job__status(in_job_id integer) -->
    <section id="lsmb13.function.job-status-in-job-id-integer"
             xreflabel="lsmb13job__status(in_job_id integer)">
      <title id="lsmb13.function.job-status-in-job-id-integer-title">
       job__status(in_job_id integer)
      </title>
      <titleabbrev id="lsmb13.function.job-status-in-job-id-integer-titleabbrev">
       job__status(in_job_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>job__status</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_row job__status;
BEGIN
	SELECT  (completed_at IS NULL)::INT, success::int, completed_at,
		error_condition
	INTO out_row 
	FROM pending_job
	WHERE id = in_job_id;

	RETURN out_row;
END;
</programlisting>
      </para>
    </section>

<!-- Function lastcost(integer) -->
    <section id="lsmb13.function.lastcost-integer"
             xreflabel="lsmb13lastcost(integer)">
      <title id="lsmb13.function.lastcost-integer-title">
       lastcost(integer)
      </title>
      <titleabbrev id="lsmb13.function.lastcost-integer-titleabbrev">
       lastcost(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE

v_cost float;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost sellprice FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id
  ORDER BY a.transdate desc, a.id desc
  LIMIT 1;

  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

RETURN v_cost;
END;
</programlisting>
      </para>
    </section>

<!-- Function leap_days(in_year_to integer, in_year_from integer) -->
    <section id="lsmb13.function.leap-days-in-year-to-integer-in-year-from-integer"
             xreflabel="lsmb13leap_days(in_year_to integer, in_year_from integer)">
      <title id="lsmb13.function.leap-days-in-year-to-integer-in-year-from-integer-title">
       leap_days(in_year_to integer, in_year_from integer)
      </title>
      <titleabbrev id="lsmb13.function.leap-days-in-year-to-integer-in-year-from-integer-titleabbrev">
       leap_days(in_year_to integer, in_year_from integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the number of leap years between the two year inputs, inclusive.
        <programlisting>
   SELECT count(*)::int
   FROM generate_series($1, $2)
   WHERE is_leapyear((generate_series::text || &#39;-01-01&#39;)::date);
</programlisting>
      </para>
    </section>

<!-- Function length(tsvector) -->
    <section id="lsmb13.function.length-tsvector"
             xreflabel="lsmb13length(tsvector)">
      <title id="lsmb13.function.length-tsvector-title">
       length(tsvector)
      </title>
      <titleabbrev id="lsmb13.function.length-tsvector-titleabbrev">
       length(tsvector)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsvector_length</programlisting>
      </para>
    </section>

<!-- Function lexize(oid, text) -->
    <section id="lsmb13.function.lexize-oid-text"
             xreflabel="lsmb13lexize(oid, text)">
      <title id="lsmb13.function.lexize-oid-text-title">
       lexize(oid, text)
      </title>
      <titleabbrev id="lsmb13.function.lexize-oid-text-titleabbrev">
       lexize(oid, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_lexize</programlisting>
      </para>
    </section>

<!-- Function lexize(text) -->
    <section id="lsmb13.function.lexize-text"
             xreflabel="lsmb13lexize(text)">
      <title id="lsmb13.function.lexize-text-title">
       lexize(text)
      </title>
      <titleabbrev id="lsmb13.function.lexize-text-titleabbrev">
       lexize(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_lexize_bycurrent</programlisting>
      </para>
    </section>

<!-- Function lexize(text, text) -->
    <section id="lsmb13.function.lexize-text-text"
             xreflabel="lsmb13lexize(text, text)">
      <title id="lsmb13.function.lexize-text-text-title">
       lexize(text, text)
      </title>
      <titleabbrev id="lsmb13.function.lexize-text-text-titleabbrev">
       lexize(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_lexize_byname</programlisting>
      </para>
    </section>

<!-- Function list_taxforms(in_entity_id integer) -->
    <section id="lsmb13.function.list-taxforms-in-entity-id-integer"
             xreflabel="lsmb13list_taxforms(in_entity_id integer)">
      <title id="lsmb13.function.list-taxforms-in-entity-id-integer-title">
       list_taxforms(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.list-taxforms-in-entity-id-integer-titleabbrev">
       list_taxforms(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of tax forms for the entity&apos;s country.
        <programlisting>
DECLARE t_country_tax_form country_tax_form;
BEGIN

	FOR t_country_tax_form IN 

		      SELECT * 
		            FROM country_tax_form where country_id in(SELECT country_id from entity where id=in_entity_id)
        LOOP

	RETURN NEXT t_country_tax_form;
	
	END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function location__deactivate(in_id integer) -->
    <section id="lsmb13.function.location-deactivate-in-id-integer"
             xreflabel="lsmb13location__deactivate(in_id integer)">
      <title id="lsmb13.function.location-deactivate-in-id-integer-title">
       location__deactivate(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.location-deactivate-in-id-integer-titleabbrev">
       location__deactivate(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>location</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

UPDATE location set active = false, inactive_date = now()
 WHERE id = $1;

SELECT * FROM location WHERE id = 1;

</programlisting>
      </para>
    </section>

<!-- Function location__get(in_id integer) -->
    <section id="lsmb13.function.location-get-in-id-integer"
             xreflabel="lsmb13location__get(in_id integer)">
      <title id="lsmb13.function.location-get-in-id-integer-title">
       location__get(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.location-get-in-id-integer-titleabbrev">
       location__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the location specified by in_id.
        <programlisting>
DECLARE
	out_location location%ROWTYPE;
BEGIN
	SELECT * INTO out_location FROM location WHERE id = in_id;
	RETURN out_location;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_delete(in_id integer) -->
    <section id="lsmb13.function.location-delete-in-id-integer"
             xreflabel="lsmb13location_delete(in_id integer)">
      <title id="lsmb13.function.location-delete-in-id-integer-title">
       location_delete(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.location-delete-in-id-integer-titleabbrev">
       location_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
        DELETES the location specified by in_id.  Does not return a value.
        <programlisting>
BEGIN
	DELETE FROM location WHERE id = in_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_all() -->
    <section id="lsmb13.function.location-list-all"
             xreflabel="lsmb13location_list_all()">
      <title id="lsmb13.function.location-list-all-title">
       location_list_all()
      </title>
      <titleabbrev id="lsmb13.function.location-list-all-titleabbrev">
       location_list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all locations, ordered by country, state, and city. 
        <programlisting>
DECLARE 
	out_location location%ROWTYPE;
BEGIN
	FOR out_location IN
		SELECT * FROM location 
		ORDER BY country, state, city
	LOOP
		RETURN NEXT out_location;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_class() -->
    <section id="lsmb13.function.location-list-class"
             xreflabel="lsmb13location_list_class()">
      <title id="lsmb13.function.location-list-class-title">
       location_list_class()
      </title>
      <titleabbrev id="lsmb13.function.location-list-class-titleabbrev">
       location_list_class()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists location classes, by default in order entered.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM location_class ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_country() -->
    <section id="lsmb13.function.location-list-country"
             xreflabel="lsmb13location_list_country()">
      <title id="lsmb13.function.location-list-country-title">
       location_list_country()
      </title>
      <titleabbrev id="lsmb13.function.location-list-country-titleabbrev">
       location_list_country()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF country</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists countries, by default in alphabetical order.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM country ORDER BY name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer) -->
    <section id="lsmb13.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer"
             xreflabel="lsmb13location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)">
      <title id="lsmb13.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer-title">
       location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)
      </title>
      <titleabbrev id="lsmb13.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer-titleabbrev">
       location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Note that this does NOT override the data in the database unless in_location_id is specified.
Instead we search for locations matching the desired specifications and if none 
are found, we insert one.  Either way, the return value of the location can be
used for mapping to other things.  This is necessary because locations are 
only loosly coupled with entities, etc.
        <programlisting>
DECLARE
	location_id integer;
	location_row RECORD;
BEGIN
	
	IF in_location_id IS NULL THEN
	    SELECT id INTO location_id FROM location
	    WHERE line_one = in_address1 AND line_two = in_address2
	          AND line_three = in_address3 AND in_city = city 
	          AND in_state = state AND in_zipcode = mail_code
	          AND in_country = country_id 
	    LIMIT 1;

	    IF NOT FOUND THEN
	    -- Straight insert.
	    location_id = nextval(&#39;location_id_seq&#39;);
	    INSERT INTO location (
	        id, 
	        line_one, 
	        line_two,
	        line_three,
	        city,
	        state,
	        mail_code,
	        country_id)
	    VALUES (
	        location_id,
	        in_address1,
	        in_address2,
	        in_address3,
	        in_city,
	        in_state,
	        in_zipcode,
	        in_country
	        );
	    END IF;
	    return location_id;
	ELSE
	    RAISE NOTICE &#39;Overwriting location id %&#39;, in_location_id;
	    -- Test it.
	    SELECT * INTO location_row FROM location WHERE id = in_location_id;
	    IF NOT FOUND THEN
	        -- Tricky users are lying to us.
	        RAISE EXCEPTION &#39;location_save called with nonexistant location ID %&#39;, in_location_id;
	    ELSE
	        -- Okay, we&#39;re good.
	        
	        UPDATE location SET
	            line_one = in_address1,
	            line_two = in_address2,
	            line_three = in_address3,
	            city = in_city, 
	            state = in_state,
	            mail_code = in_zipcode,
	            country_id = in_country
	        WHERE id = in_location_id;
	        return in_location_id;
	    END IF;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying) -->
    <section id="lsmb13.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying"
             xreflabel="lsmb13location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)">
      <title id="lsmb13.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying-title">
       location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)
      </title>
      <titleabbrev id="lsmb13.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying-titleabbrev">
       location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns matching locations.  All matches may be partial.
        <programlisting>
DECLARE
	out_location location%ROWTYPE;
BEGIN
	FOR out_location IN
		SELECT * FROM location 
		WHERE address1 ilike &#39;%&#39; || in_address1 || &#39;%&#39;
			AND address2 ilike &#39;%&#39; || in_address2 || &#39;%&#39;
			AND in_city ilike &#39;%&#39; || in_city || &#39;%&#39;
			AND in_state ilike &#39;%&#39; || in_state || &#39;%&#39;
			AND in_zipcode ilike &#39;%&#39; || in_zipcode || &#39;%&#39;
			AND in_country ilike &#39;%&#39; || in_country || &#39;%&#39;
	LOOP
		RETURN NEXT out_location;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function lock_record(in_session_id integer, in_id integer) -->
    <section id="lsmb13.function.lock-record-in-session-id-integer-in-id-integer"
             xreflabel="lsmb13lock_record(in_session_id integer, in_id integer)">
      <title id="lsmb13.function.lock-record-in-session-id-integer-in-id-integer-title">
       lock_record(in_session_id integer, in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.lock-record-in-session-id-integer-in-id-integer-titleabbrev">
       lock_record(in_session_id integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function seeks to lock a record with an id of in_id to a session with an
id of in_session_id.  If possible, it returns true.  If it is already locked,
false.  These are not hard locks and the application is free to disregard or 
not even ask.  They time out when the session is destroyed.

        <programlisting>
declare
   locked int;
begin
   SELECT locked_by into locked from transactions where id = $1;
   IF NOT FOUND THEN
	RETURN FALSE;
   ELSEIF locked is not null AND locked &lt;&gt; $2 THEN
        RETURN FALSE;
   END IF;
   UPDATE transactions set locked_by = $2 where id = $1;
   RETURN TRUE;
end;
</programlisting>
      </para>
    </section>

<!-- Function menu_children(in_parent_id integer) -->
    <section id="lsmb13.function.menu-children-in-parent-id-integer"
             xreflabel="lsmb13menu_children(in_parent_id integer)">
      <title id="lsmb13.function.menu-children-in-parent-id-integer-title">
       menu_children(in_parent_id integer)
      </title>
      <titleabbrev id="lsmb13.function.menu-children-in-parent-id-integer-titleabbrev">
       menu_children(in_parent_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF menu_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns all menu  items which are children of in_parent_id 
(the only input parameter). 

It is thus similar to menu_generate() but it only returns the menu items 
associated with nodes directly descendant from the parent.  It is used for
menues for frameless browsers.
        <programlisting>
SELECT * FROM menu_generate() where parent = $1;
</programlisting>
      </para>
    </section>

<!-- Function menu_generate() -->
    <section id="lsmb13.function.menu-generate"
             xreflabel="lsmb13menu_generate()">
      <title id="lsmb13.function.menu-generate-title">
       menu_generate()
      </title>
      <titleabbrev id="lsmb13.function.menu-generate-titleabbrev">
       menu_generate()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF menu_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function returns the complete menu tree.  It is used to generate nested
menus for the web interface.

        <programlisting>
DECLARE 
	item menu_item;
	arg menu_attribute%ROWTYPE;
BEGIN
	FOR item IN 
               WITH RECURSIVE tree (path, id, parent, level, positions)
                               AS (select id::text as path, id, parent, 
                                           0 as level, position::text
                                      FROM menu_node where parent is null
                                     UNION 
                                    select path || &#39;,&#39; || n.id::text, n.id, 
                                           n.parent,
                                           t.level + 1, 
                                           t.positions || &#39;,&#39; || n.position
                                      FROM menu_node n
                                      JOIN tree t ON t.id = n.parent) 
		SELECT n.position, n.id, c.level, n.label, c.path, n.parent,
                       to_args(array[ma.attribute, ma.value])
		FROM tree c
		JOIN menu_node n USING(id)
                JOIN menu_attribute ma ON (n.id = ma.node_id)
               WHERE n.id IN (select node_id 
                                FROM menu_acl acl
                          LEFT JOIN pg_roles pr on pr.rolname = acl.role_name
                               WHERE CASE WHEN role_name 
                                                           ilike &#39;public&#39;
                                                      THEN true
                                                      WHEN rolname IS NULL
                                                      THEN FALSE
                                                      ELSE pg_has_role(rolname,
                                                                       &#39;USAGE&#39;)
                                      END
                            GROUP BY node_id
                              HAVING bool_and(CASE WHEN acl_type ilike &#39;DENY&#39;
                                                   THEN FALSE
                                                   WHEN acl_type ilike &#39;ALLOW&#39;
                                                   THEN TRUE
                                                END))
                    or exists (select cn.id, cc.path
                                 FROM tree cc
                                 JOIN menu_node cn USING(id)
                                WHERE cn.id IN 
                                      (select node_id 
                                         FROM menu_acl acl
                                    LEFT JOIN pg_roles pr 
                                              on pr.rolname = acl.role_name
                                        WHERE CASE WHEN rolname 
                                                           ilike &#39;public&#39;
                                                      THEN true
                                                      WHEN rolname IS NULL
                                                      THEN FALSE
                                                      ELSE pg_has_role(rolname,
                                                                       &#39;USAGE&#39;)
                                                END
                                     GROUP BY node_id
                                       HAVING bool_and(CASE WHEN acl_type 
                                                                 ilike &#39;DENY&#39;
                                                            THEN false
                                                            WHEN acl_type 
                                                                 ilike &#39;ALLOW&#39;
                                                            THEN TRUE
                                                         END))
                                       and cc.path::text 
                                           like c.path::text || &#39;,%&#39;)
            GROUP BY n.position, n.id, c.level, n.label, c.path, c.positions,
                     n.parent
            ORDER BY string_to_array(c.positions, &#39;,&#39;)::int[]
	LOOP
		RETURN NEXT item;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function menu_insert(in_label integer, in_position integer, in_parent_id text) -->
    <section id="lsmb13.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text"
             xreflabel="lsmb13menu_insert(in_label integer, in_position integer, in_parent_id text)">
      <title id="lsmb13.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text-title">
       menu_insert(in_label integer, in_position integer, in_parent_id text)
      </title>
      <titleabbrev id="lsmb13.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text-titleabbrev">
       menu_insert(in_label integer, in_position integer, in_parent_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function inserts menu items at arbitrary positions.  The arguments are, in
order:  parent, position, label.  The return value is the id number of the menu
item created. 
        <programlisting>
DECLARE
	new_id int;
BEGIN
	UPDATE menu_node 
	SET position = position * -1
	WHERE parent = in_parent_id
		AND position &gt;= in_position;

	INSERT INTO menu_node (parent, position, label)
	VALUES (in_parent_id, in_position, in_label);

	SELECT INTO new_id currval(&#39;menu_node_id_seq&#39;);

	UPDATE menu_node 
	SET position = (position * -1) + 1
	WHERE parent = in_parent_id
		AND position &lt; 0;

	RETURN new_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function months_passed(in_end timestamp without time zone, in_start timestamp without time zone) -->
    <section id="lsmb13.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone"
             xreflabel="lsmb13months_passed(in_end timestamp without time zone, in_start timestamp without time zone)">
      <title id="lsmb13.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone-title">
       months_passed(in_end timestamp without time zone, in_start timestamp without time zone)
      </title>
      <titleabbrev id="lsmb13.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone-titleabbrev">
       months_passed(in_end timestamp without time zone, in_start timestamp without time zone)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of months between in_start and in_end.
        <programlisting>

-- The addition of one day is so that it will return &#39;1&#39; when run on the end
-- day of consecutive months.

select (extract (months from age($2 + &#39;1 day&#39;, $1 + &#39;1 day&#39;))
       + extract (years from age($2, $1)) * 12)::int;
</programlisting>
      </para>
    </section>

<!-- Function next_leap_year_calc(is_end date, in_date boolean) -->
    <section id="lsmb13.function.next-leap-year-calc-is-end-date-in-date-boolean"
             xreflabel="lsmb13next_leap_year_calc(is_end date, in_date boolean)">
      <title id="lsmb13.function.next-leap-year-calc-is-end-date-in-date-boolean-title">
       next_leap_year_calc(is_end date, in_date boolean)
      </title>
      <titleabbrev id="lsmb13.function.next-leap-year-calc-is-end-date-in-date-boolean-titleabbrev">
       next_leap_year_calc(is_end date, in_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Next relevant leap year calculation for a daily depreciation calculation
        <programlisting>
SELECT 
          (CASE WHEN extract(&#39;doy&#39; FROM $1) &lt; 59
          THEN extract(&#39;year&#39; FROM $1)
          ELSE extract(&#39;year&#39; FROM $1) + 1
          END)::int
          -
          CASE WHEN $2 THEN 1 ELSE 0 END;
</programlisting>
      </para>
    </section>

<!-- Function normal_rand(integer, double precision, double precision) -->
    <section id="lsmb13.function.normal-rand-integer-double-precision-double-precision"
             xreflabel="lsmb13normal_rand(integer, double precision, double precision)">
      <title id="lsmb13.function.normal-rand-integer-double-precision-double-precision-title">
       normal_rand(integer, double precision, double precision)
      </title>
      <titleabbrev id="lsmb13.function.normal-rand-integer-double-precision-double-precision-titleabbrev">
       normal_rand(integer, double precision, double precision)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>normal_rand</programlisting>
      </para>
    </section>

<!-- Function numnode(tsquery) -->
    <section id="lsmb13.function.numnode-tsquery"
             xreflabel="lsmb13numnode(tsquery)">
      <title id="lsmb13.function.numnode-tsquery-title">
       numnode(tsquery)
      </title>
      <titleabbrev id="lsmb13.function.numnode-tsquery-titleabbrev">
       numnode(tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquery_numnode</programlisting>
      </para>
    </section>

<!-- Function parse(oid, text) -->
    <section id="lsmb13.function.parse-oid-text"
             xreflabel="lsmb13parse(oid, text)">
      <title id="lsmb13.function.parse-oid-text-title">
       parse(oid, text)
      </title>
      <titleabbrev id="lsmb13.function.parse-oid-text-titleabbrev">
       parse(oid, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>SET OF tokenout</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_parse_byid</programlisting>
      </para>
    </section>

<!-- Function parse(text) -->
    <section id="lsmb13.function.parse-text"
             xreflabel="lsmb13parse(text)">
      <title id="lsmb13.function.parse-text-title">
       parse(text)
      </title>
      <titleabbrev id="lsmb13.function.parse-text-titleabbrev">
       parse(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF tokenout</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_parse_current</programlisting>
      </para>
    </section>

<!-- Function parse(text, text) -->
    <section id="lsmb13.function.parse-text-text"
             xreflabel="lsmb13parse(text, text)">
      <title id="lsmb13.function.parse-text-text-title">
       parse(text, text)
      </title>
      <titleabbrev id="lsmb13.function.parse-text-text-titleabbrev">
       parse(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>SET OF tokenout</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_parse_byname</programlisting>
      </para>
    </section>

<!-- Function parse_date(in_date date) -->
    <section id="lsmb13.function.parse-date-in-date-date"
             xreflabel="lsmb13parse_date(in_date date)">
      <title id="lsmb13.function.parse-date-in-date-date-title">
       parse_date(in_date date)
      </title>
      <titleabbrev id="lsmb13.function.parse-date-in-date-date-titleabbrev">
       parse_date(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
        Simple way to cast a Perl string to a
date format of known type. 
        <programlisting> select $1; </programlisting>
      </para>
    </section>

<!-- Function parts__get_by_id(in_id integer) -->
    <section id="lsmb13.function.parts-get-by-id-in-id-integer"
             xreflabel="lsmb13parts__get_by_id(in_id integer)">
      <title id="lsmb13.function.parts-get-by-id-in-id-integer-title">
       parts__get_by_id(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.parts-get-by-id-in-id-integer-titleabbrev">
       parts__get_by_id(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM parts WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function parts__get_by_partnumber(in_partnumber text) -->
    <section id="lsmb13.function.parts-get-by-partnumber-in-partnumber-text"
             xreflabel="lsmb13parts__get_by_partnumber(in_partnumber text)">
      <title id="lsmb13.function.parts-get-by-partnumber-in-partnumber-text-title">
       parts__get_by_partnumber(in_partnumber text)
      </title>
      <titleabbrev id="lsmb13.function.parts-get-by-partnumber-in-partnumber-text-titleabbrev">
       parts__get_by_partnumber(in_partnumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM PARTS WHERE partnumber = $1 and obsolete is not true; 
</programlisting>
      </para>
    </section>

<!-- Function parts__search_lite(in_description text, in_partnumber text) -->
    <section id="lsmb13.function.parts-search-lite-in-description-text-in-partnumber-text"
             xreflabel="lsmb13parts__search_lite(in_description text, in_partnumber text)">
      <title id="lsmb13.function.parts-search-lite-in-description-text-in-partnumber-text-title">
       parts__search_lite(in_description text, in_partnumber text)
      </title>
      <titleabbrev id="lsmb13.function.parts-search-lite-in-description-text-in-partnumber-text-titleabbrev">
       parts__search_lite(in_description text, in_partnumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * 
  FROM parts 
 WHERE ($1 IS NULL OR (partnumber like $1 || &#39;%&#39;))
       AND ($2 IS NULL 
            OR (description
                @@
                plainto_tsquery(get_default_lang()::regconfig, $2)))
       AND not obsolete
ORDER BY partnumber;
</programlisting>
      </para>
    </section>

<!-- Function payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar) -->
    <section id="lsmb13.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar"
             xreflabel="lsmb13payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)">
      <title id="lsmb13.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar-title">
       payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)
      </title>
      <titleabbrev id="lsmb13.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar-titleabbrev">
       payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
Reverses a payment.  All fields are mandatory except batch_id and voucher_id
because they determine the identity of the payment to be reversed.

        <programlisting>
DECLARE
	pay_row record;
        t_voucher_id int;
        t_voucher_inserted bool;
        t_currs text[];
        t_rev_fx numeric;
        t_fxgain_id int;
        t_fxloss_id int;
        t_paid_fx numeric;
BEGIN
        SELECT * INTO t_rev_fx FROM currency_get_exchangerate(
              in_currency, in_date_reversed, in_account_class);

        SELECT * INTO t_paid_fx FROM currency_get_exchangerate(
              in_currency, in_date_paid, in_account_class);

       select value::int INTO t_fxgain_id FROM setting_get(&#39;fxgain_accno_id&#39;);
       select value::int INTO t_fxloss_id FROM setting_get(&#39;fxloss_accno_id&#39;);

       SELECT string_to_array(value, &#39;:&#39;) into t_currs
          from defaults
         where setting_key = &#39;curr&#39;;

        IF in_currency IS NULL OR in_currency = t_currs[1] THEN
                t_rev_fx := 1;
                t_paid_fx := 1;
        ELSIF t_rev_fx IS NULL THEN
                t_rev_fx := in_exchangerate;
                PERFORM payments_set_exchangerate(in_account_class,
                                                  in_exchangerate,
                                                  in_currency,
                                                  in_date_reversed);
        ELSIF t_rev_fx &lt;&gt; in_exchangerate THEN
                RAISE EXCEPTION &#39;Exchange rate different than on file&#39;;
        END IF;
        IF t_rev_fx IS NULL THEN
            RAISE EXCEPTION &#39;No exchangerate provided and not default currency&#39;;
        END IF;


        IF in_batch_id IS NOT NULL THEN
		t_voucher_id := nextval(&#39;voucher_id_seq&#39;);
		t_voucher_inserted := FALSE;
	END IF;
	FOR pay_row IN 
		SELECT a.*, c.ar_ap_account_id, arap.curr, arap.fxrate
		FROM acc_trans a
		JOIN (select id, curr, entity_credit_account, 
                             CASE WHEN curr = t_currs[1] THEN 1
                                   ELSE buy END as fxrate
			FROM ar 
                   LEFT JOIN exchangerate USING (transdate, curr)
                       WHERE in_account_class = 2
			UNION
			SELECT id, curr, entity_credit_account, 
                               CASE WHEN curr = t_currs[1] THEN 1
                                    ELSE sell END as fxrate
			FROM ap
                   LEFT JOIN exchangerate USING (transdate, curr)
                       WHERE in_account_class = 1
		) arap ON (a.trans_id = arap.id)
		JOIN entity_credit_account c 
			ON (arap.entity_credit_account = c.id)
		JOIN account ch ON (a.chart_id = ch.id)
		WHERE a.source IS NOT DISTINCT FROM in_source
			AND a.transdate = in_date_paid
			AND in_credit_id = arap.entity_credit_account
			AND in_cash_accno = ch.accno
                        and in_voucher_id IS NOT DISTINCT FROM voucher_id
	LOOP
                IF pay_row.curr = t_currs[1] THEN
                   pay_row.fxrate = 1;
                END IF;

		IF in_batch_id IS NOT NULL 
			AND t_voucher_inserted IS NOT TRUE
		THEN
			INSERT INTO voucher 
			(id, trans_id, batch_id, batch_class)
			VALUES
			(t_voucher_id, pay_row.trans_id, in_batch_id,
				CASE WHEN in_account_class = 1 THEN 4
				     WHEN in_account_class = 2 THEN 7
				END);

			t_voucher_inserted := TRUE;
		END IF;

		INSERT INTO acc_trans
		(trans_id, chart_id, amount, transdate, source, memo, approved,
			voucher_id) 
		VALUES 
		(pay_row.trans_id, pay_row.chart_id, 
                        pay_row.amount / t_paid_fx * -1 * t_rev_fx, 
			in_date_reversed, in_source, &#39;Reversing &#39; || 
			COALESCE(in_source, &#39;&#39;), 
			case when in_batch_id is not null then false 
			else true end, t_voucher_id),
                 (pay_row.trans_id, pay_row.ar_ap_account_id, 
                        pay_row.amount / t_paid_fx * pay_row.fxrate,
			in_date_reversed, in_source, &#39;Reversing &#39; ||
			COALESCE(in_source, &#39;&#39;), 
			case when in_batch_id is not null then false 
			else true end, t_voucher_id),
                 (pay_row.trans_id, 
                  case when pay_row.fxrate &gt; t_rev_fx 
                       THEN t_fxloss_id ELSE t_fxgain_id END, 
                  pay_row.amount / t_paid_fx * (t_rev_fx - pay_row.fxrate),
                  in_date_reversed, in_source, &#39;Reversing &#39; ||  
                                                COALESCE(in_source, &#39;&#39;),
                   case when in_batch_id is not null then false
                        else true end, t_voucher_id);

                   
	END LOOP;
	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar) -->
    <section id="lsmb13.function.payment-search-in-currency-text-in-account-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar"
             xreflabel="lsmb13payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)">
      <title id="lsmb13.function.payment-search-in-currency-text-in-account-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar-title">
       payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)
      </title>
      <titleabbrev id="lsmb13.function.payment-search-in-currency-text-in-account-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar-titleabbrev">
       payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_record</seg>
        </seglistitem>
       </segmentedlist>
 
       This searches for payments.  in_date_to and _date_from specify the acceptable
date range.  All other matches are exact except that null matches all values.

Currently (and to support earlier data) we define a payment as a collection of
acc_trans records against the same credit account and cash account, on the same
day with the same source number, and optionally the same voucher id.
        <programlisting>
DECLARE 
	out_row payment_record;
BEGIN
	FOR out_row IN 
		select sum(CASE WHEN c.entity_class = 1 then a.amount
				ELSE a.amount * -1 END), c.meta_number, 
			c.id, co.legal_name,
			compound_array(ARRAY[ARRAY[ch.id::text, ch.accno, 
				ch.description]]), a.source, 
			b.control_code, b.description, a.voucher_id, a.transdate
		FROM entity_credit_account c
		JOIN ( select entity_credit_account, id, curr
			FROM ar WHERE in_account_class = 2
			UNION
			SELECT entity_credit_account, id, curr
			FROM ap WHERE in_account_class = 1
			) arap ON (arap.entity_credit_account = c.id)
		JOIN acc_trans a ON (arap.id = a.trans_id)
		JOIN chart ch ON (ch.id = a.chart_id)
		JOIN company co ON (c.entity_id = co.entity_id)
		LEFT JOIN voucher v ON (v.id = a.voucher_id)
		LEFT JOIN batch b ON (b.id = v.batch_id)
		WHERE (ch.accno = in_cash_accno)
                        AND (in_currency IS NULL OR in_currency = arap.curr)
			AND (c.id = in_credit_id OR in_credit_id IS NULL)
			AND (a.transdate &gt;= in_date_from 
				OR in_date_from IS NULL)
			AND (a.transdate &lt;= in_date_to OR in_date_to IS NULL)
			AND (source = in_source OR in_source IS NULL)
		GROUP BY c.meta_number, c.id, co.legal_name, a.transdate, 
			a.source, a.memo, b.id, b.control_code, b.description, 
                        voucher_id
		ORDER BY a.transdate, c.meta_number, a.source
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_bulk_post(in_curr numeric[], in_exchangerate integer, in_payment_type text, in_account_class numeric, in_payment_date text, in_cash_accno text, in_ar_ap_accno date, in_total integer, in_source integer, in_batch_id numeric, in_transactions text) -->
    <section id="lsmb13.function.payment-bulk-post-in-curr-numericARRAY-in-exchangerate-integer-in-payment-type-text-in-account-class-numeric-in-payment-date-text-in-cash-accno-text-in-ar-ap-accno-date-in-total-integer-in-source-integer-in-batch-id-numeric-in-transactions-text"
             xreflabel="lsmb13payment_bulk_post(in_curr numeric[], in_exchangerate integer, in_payment_type text, in_account_class numeric, in_payment_date text, in_cash_accno text, in_ar_ap_accno date, in_total integer, in_source integer, in_batch_id numeric, in_transactions text)">
      <title id="lsmb13.function.payment-bulk-post-in-curr-numericARRAY-in-exchangerate-integer-in-payment-type-text-in-account-class-numeric-in-payment-date-text-in-cash-accno-text-in-ar-ap-accno-date-in-total-integer-in-source-integer-in-batch-id-numeric-in-transactions-text-title">
       payment_bulk_post(in_curr numeric[], in_exchangerate integer, in_payment_type text, in_account_class numeric, in_payment_date text, in_cash_accno text, in_ar_ap_accno date, in_total integer, in_source integer, in_batch_id numeric, in_transactions text)
      </title>
      <titleabbrev id="lsmb13.function.payment-bulk-post-in-curr-numericARRAY-in-exchangerate-integer-in-payment-type-text-in-account-class-numeric-in-payment-date-text-in-cash-accno-text-in-ar-ap-accno-date-in-total-integer-in-source-integer-in-batch-id-numeric-in-transactions-text-titleabbrev">
       payment_bulk_post(in_curr numeric[], in_exchangerate integer, in_payment_type text, in_account_class numeric, in_payment_date text, in_cash_accno text, in_ar_ap_accno date, in_total integer, in_source integer, in_batch_id numeric, in_transactions text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This posts the payments for large batch workflows.

Note that in_transactions is a two-dimensional numeric array.  Of each 
sub-array, the first element is the (integer) transaction id, and the second
is the amount for that transaction.  
        <programlisting>
DECLARE 
	out_count int;
	t_voucher_id int;
	t_trans_id int;
	t_amount numeric;
        t_ar_ap_id int;
	t_cash_id int;
        t_currs text[];
        t_exchangerate numeric;
BEGIN
	IF in_batch_id IS NULL THEN
		-- t_voucher_id := NULL;
		RAISE EXCEPTION &#39;Bulk Post Must be from Batch!&#39;;
	ELSE
		INSERT INTO voucher (batch_id, batch_class, trans_id)
		values (in_batch_id,
                (SELECT batch_class_id FROM batch WHERE id = in_batch_id),
                in_transactions[1][1]);

		t_voucher_id := currval(&#39;voucher_id_seq&#39;);
	END IF;

	SELECT string_to_array(value, &#39;:&#39;) into t_currs 
          from defaults 
         where setting_key = &#39;curr&#39;;

        IF (in_curr IS NULL OR in_curr = t_currs[0]) THEN
                t_exchangerate := 1;
        ELSE 
                t_exchangerate := in_exchangerate;
        END IF;

	CREATE TEMPORARY TABLE bulk_payments_in (id int, amount numeric);

	select id into t_ar_ap_id from chart where accno = in_ar_ap_accno;
	select id into t_cash_id from chart where accno = in_cash_accno;

	FOR out_count IN 
			array_lower(in_transactions, 1) ..
			array_upper(in_transactions, 1)
	LOOP
		EXECUTE $E$
			INSERT INTO bulk_payments_in(id, amount)
			VALUES ($E$ || quote_literal(in_transactions[out_count][1])
				|| $E$, $E$ ||
				quote_literal(in_transactions[out_count][2])
				|| $E$)$E$;
	END LOOP;
	EXECUTE $E$ 
		INSERT INTO acc_trans 
			(trans_id, chart_id, amount, approved, voucher_id, transdate, 
			source, payment_type)
		SELECT id, 
		case when $E$ || quote_literal(in_account_class) || $E$ = 1
			THEN $E$ || t_cash_id || $E$
			WHEN $E$ || quote_literal(in_account_class) || $E$ = 2 
			THEN $E$ || t_ar_ap_id || $E$
			ELSE -1 END, 
		amount * $E$|| quote_literal(t_exchangerate) || $E$,
		CASE 
			WHEN $E$|| t_voucher_id || $E$ IS NULL THEN true
			ELSE false END,
		$E$ || t_voucher_id || $E$, $E$|| quote_literal(in_payment_date) 
		||$E$ , $E$ ||COALESCE(quote_literal(in_source), &#39;NULL&#39;) || 
		$E$ , $E$ || coalesce(quote_literal(in_payment_type), &#39;NULL&#39;) || $E$
		FROM bulk_payments_in  where amount &lt;&gt; 0 $E$;

	EXECUTE $E$ 
		INSERT INTO acc_trans 
			(trans_id, chart_id, amount, approved, voucher_id, transdate, 
			source, payment_type)
		SELECT id, 
		case when $E$ || quote_literal(in_account_class) || $E$ = 1 
			THEN $E$ || t_ar_ap_id || $E$
			WHEN $E$ || quote_literal(in_account_class) || $E$ = 2 
			THEN $E$ || t_cash_id || $E$
			ELSE -1 END, 
		amount * -1 * $E$|| quote_literal(t_exchangerate) || $E$,
		CASE 
			WHEN $E$|| t_voucher_id || $E$ IS NULL THEN true
			ELSE false END,
		$E$ || t_voucher_id || $E$, $E$|| quote_literal(in_payment_date) 
		||$E$ , $E$ ||COALESCE(quote_literal(in_source), &#39;null&#39;) 
		||$E$ , $E$ || coalesce(quote_literal(in_payment_type), &#39;NULL&#39;) || $E$ 
		FROM bulk_payments_in where amount &lt;&gt; 0 $E$;

        IF in_account_class = 1 THEN
        	EXECUTE $E$
	        	UPDATE ap 
		        set paid = paid + (select amount from bulk_payments_in b 
		         	where b.id = ap.id)
		         where id in (select id from bulk_payments_in) $E$;
        ELSE
        	EXECUTE $E$
	        	UPDATE ar 
		        set paid = paid + (select amount from bulk_payments_in b 
		         	where b.id = ar.id)
		         where id in (select id from bulk_payments_in) $E$;
        END IF;
	EXECUTE $E$ DROP TABLE bulk_payments_in $E$;
	perform unlock_all();
	return out_count;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text) -->
    <section id="lsmb13.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text"
             xreflabel="lsmb13payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)">
      <title id="lsmb13.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text-title">
       payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)
      </title>
      <titleabbrev id="lsmb13.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text-titleabbrev">
       payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This posts the payments for large batch workflows.

Note that in_transactions is a two-dimensional numeric array.  Of each 
sub-array, the first element is the (integer) transaction id, and the second
is the amount for that transaction.  
        <programlisting>
DECLARE 
        out_count int;
        t_voucher_id int;
        t_trans_id int;
        t_amount numeric;
        t_ar_ap_id int;
        t_cash_id int;
        t_currs text[];
        t_exchangerate numeric;
        t_cash_sign int;
BEGIN

        SELECT * INTO t_exchangerate FROM currency_get_exchangerate(
              in_currency, in_payment_date, in_account_class);

        IF in_batch_id IS NULL THEN
                -- t_voucher_id := NULL;
                RAISE EXCEPTION &#39;Bulk Post Must be from Batch!&#39;;
        ELSE
                INSERT INTO voucher (batch_id, batch_class, trans_id)
                values (in_batch_id,
                (SELECT batch_class_id FROM batch WHERE id = in_batch_id),
                in_transactions[1][1]);

                t_voucher_id := currval(&#39;voucher_id_seq&#39;);
        END IF;

        SELECT string_to_array(value, &#39;:&#39;) into t_currs 
          from defaults 
         where setting_key = &#39;curr&#39;;

        IF (in_currency IS NULL OR in_currency = t_currs[1]) THEN
                t_exchangerate := 1;
        ELSIF t_exchangerate IS NULL THEN
                t_exchangerate := in_exchangerate;
                PERFORM payments_set_exchangerate(in_account_class,
                                                  in_exchangerate, 
                                                  in_currency,
                                                  in_payment_date);
        ELSIF t_exchangerate &lt;&gt; in_exchangerate THEN
                RAISE EXCEPTION &#39;Exchange rate different than on file&#39;;
        END IF;
        IF t_exchangerate IS NULL THEN
            RAISE EXCEPTION &#39;No exchangerate provided and not default currency&#39;;
        END IF;

        CREATE TEMPORARY TABLE bulk_payments_in
           (id int, amount numeric, fxrate numeric, gain_loss_accno int);

        select id into t_ar_ap_id from chart where accno = in_ar_ap_accno;
        select id into t_cash_id from chart where accno = in_cash_accno;

        FOR out_count IN 
                        array_lower(in_transactions, 1) ..
                        array_upper(in_transactions, 1)
        LOOP
            -- Fill the bulk payments table
            INSERT INTO bulk_payments_in(id, amount)
            VALUES (in_transactions[out_count][1],
                    in_transactions[out_count][2]);
        END LOOP;

        IF in_account_class = 1 THEN
            t_cash_sign := 1;
        ELSE
            t_cash_sign := -1;
        END IF;

        IF (in_currency IS NULL OR in_currency = t_currs[1]) THEN
            UPDATE bulk_payments_in
               SET fxrate = 1;
        ELSE
            UPDATE bulk_payments_in
               SET fxrate =
                (SELECT CASE WHEN in_account_class = 1 THEN sell
                             ELSE buy
                        END
                   FROM exchangerate e
                   JOIN (SELECT transdate, id, curr FROM ar
                         UNION
                         SELECT transdate, id, curr FROM ap) a
                     ON (e.transdate = a.transdate
                         AND e.curr = a.curr)
                   WHERE a.id = bulk_payments_in.id);
            UPDATE bulk_payments_in
               SET gain_loss_accno =
                (SELECT value::int FROM defaults
                  WHERE setting_key = &#39;fxgain_accno_id&#39;)
             WHERE ((t_exchangerate - bulk_payments_in.fxrate) * t_cash_sign) &lt; 0;
            UPDATE bulk_payments_in
               SET gain_loss_accno = (SELECT value::int FROM defaults
                  WHERE setting_key = &#39;fxloss_accno_id&#39;)
             WHERE ((t_exchangerate - bulk_payments_in.fxrate) * t_cash_sign) &gt; 0;
            -- explicitly leave zero gain/loss accno_id entries at NULL
            -- so we have an easy check for which 
        END IF;

        -- Insert cash side
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, t_cash_id, amount * t_cash_sign * t_exchangerate/fxrate,
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in  where amount &lt;&gt; 0;

        -- early payment discounts
        INSERT INTO acc_trans
               (trans_id, chart_id, amount, approved,
               voucher_id, transdate, source)
        SELECT bpi.id, eca.discount_account_id, 
               amount * t_cash_sign * t_exchangerate/fxrate 
               / (1 - discount::numeric/100) 
               * (discount::numeric/100),
               CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
               t_voucher_id, in_payment_date, in_source
          FROM bulk_payments_in bpi
          JOIN (select entity_credit_account, id, transdate FROM ar 
                 WHERE in_account_class = 2
                 UNION
                SELECT entity_credit_account, id, transdate FROM ap
                 WHERE in_account_class = 1) gl ON gl.id = bpi.id
          JOIN entity_credit_account eca ON gl.entity_credit_account = eca.id
         WHERE bpi.amount &lt;&gt; 0 
               AND extract(&#39;days&#39; from age(gl.transdate)) &lt; eca.discount_terms;

        INSERT INTO acc_trans
               (trans_id, chart_id, amount, approved,
               voucher_id, transdate, source)
        SELECT bpi.id, t_ar_ap_id, 
               amount * t_cash_sign * -1 * t_exchangerate/fxrate 
               / (1 - discount::numeric/100) 
               * (discount::numeric/100),
               CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
               t_voucher_id, in_payment_date, in_source
          FROM bulk_payments_in bpi
          JOIN (select entity_credit_account, id, transdate FROM ar 
                 WHERE in_account_class = 2
                 UNION
                SELECT entity_credit_account, id, transdate FROM ap
                 WHERE in_account_class = 1) gl ON gl.id = bpi.id
          JOIN entity_credit_account eca ON gl.entity_credit_account = eca.id
         WHERE bpi.amount &lt;&gt; 0 
               AND extract(&#39;days&#39; from age(gl.transdate)) &lt; eca.discount_terms;

        -- Insert ar/ap side
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, t_ar_ap_id,
                  amount * -1 * t_cash_sign,
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in where amount &lt;&gt; 0;

        -- Insert fx gain/loss effects, if applicable
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, gain_loss_accno,
                  amount * t_cash_sign * (1 - t_exchangerate/fxrate),
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in
            WHERE amount &lt;&gt; 0 AND gain_loss_accno IS NOT NULL;

        DROP TABLE bulk_payments_in;
        perform unlock_all();
        return out_count;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_bulk_queue(in_account_class numeric[], in_payment_date integer, in_cash_accno text, in_ar_ap_accno numeric, in_total text, in_source text, in_batch_id date, in_transactions integer) -->
    <section id="lsmb13.function.payment-bulk-queue-in-account-class-numericARRAY-in-payment-date-integer-in-cash-accno-text-in-ar-ap-accno-numeric-in-total-text-in-source-text-in-batch-id-date-in-transactions-integer"
             xreflabel="lsmb13payment_bulk_queue(in_account_class numeric[], in_payment_date integer, in_cash_accno text, in_ar_ap_accno numeric, in_total text, in_source text, in_batch_id date, in_transactions integer)">
      <title id="lsmb13.function.payment-bulk-queue-in-account-class-numericARRAY-in-payment-date-integer-in-cash-accno-text-in-ar-ap-accno-numeric-in-total-text-in-source-text-in-batch-id-date-in-transactions-integer-title">
       payment_bulk_queue(in_account_class numeric[], in_payment_date integer, in_cash_accno text, in_ar_ap_accno numeric, in_total text, in_source text, in_batch_id date, in_transactions integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-bulk-queue-in-account-class-numericARRAY-in-payment-date-integer-in-cash-accno-text-in-ar-ap-accno-numeric-in-total-text-in-source-text-in-batch-id-date-in-transactions-integer-titleabbrev">
       payment_bulk_queue(in_account_class numeric[], in_payment_date integer, in_cash_accno text, in_ar_ap_accno numeric, in_total text, in_source text, in_batch_id date, in_transactions integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
	INSERT INTO payments_queue
	(transactions, batch_id, source, total, ar_ap_accno, cash_accno,
		payment_date, account_class)
	VALUES 
	(in_transactions, in_batch_id, in_source, in_total, in_ar_ap_accno,
		in_cash_accno, in_payment_date, in_account_class);

	RETURN array_upper(in_transactions, 1) - 
		array_lower(in_transactions, 1);
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_gather_header_info(in_payment_id integer, in_account_class integer) -->
    <section id="lsmb13.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer"
             xreflabel="lsmb13payment_gather_header_info(in_payment_id integer, in_account_class integer)">
      <title id="lsmb13.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer-title">
       payment_gather_header_info(in_payment_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer-titleabbrev">
       payment_gather_header_info(in_payment_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_header_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function finds a payment based on the id and retrieves the record, 
it is usefull for printing payments :) 
        <programlisting>
 DECLARE out_payment payment_header_item;
 BEGIN
 FOR out_payment IN 
   SELECT p.id as payment_id, p.reference as payment_reference, p.payment_date,  
          c.legal_name as legal_name, am.amount as amount, em.first_name, em.last_name, p.currency, p.notes
   FROM payment p
   JOIN entity_employee ent_em ON (ent_em.entity_id = p.employee_id)
   JOIN person em ON (ent_em.entity_id = em.entity_id)
   JOIN entity_credit_account eca ON (eca.id = p.entity_credit_id)
   JOIN company c ON   (c.entity_id  = eca.entity_id)
   JOIN payment_links pl ON (p.id = pl.payment_id)
   LEFT JOIN (  SELECT sum(a.amount) as amount
 		FROM acc_trans a
 		JOIN account acc ON (a.chart_id = acc.id)
                JOIN account_link al ON (acc.id =al.account_id)
 		JOIN payment_links pl ON (pl.entry_id=a.entry_id)
 		WHERE al.description in  
                       (&#39;AP_paid&#39;, &#39;AP_discount&#39;, &#39;AR_paid&#39;, &#39;AR_discount&#39;) 
                       and ((in_account_class = 1 AND al.description like &#39;AP%&#39;)
                       or (in_account_class = 2 AND al.description like &#39;AR%&#39;))
             ) am ON (true)
   WHERE p.id = in_payment_id
 LOOP
     RETURN NEXT out_payment;
 END LOOP;

 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_gather_line_info(in_payment_id integer, in_account_class integer) -->
    <section id="lsmb13.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer"
             xreflabel="lsmb13payment_gather_line_info(in_payment_id integer, in_account_class integer)">
      <title id="lsmb13.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer-title">
       payment_gather_line_info(in_payment_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer-titleabbrev">
       payment_gather_line_info(in_payment_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_line_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function finds a payment based on the id and retrieves all the line records, 
it is usefull for printing payments and build reports :) 
        <programlisting>
 DECLARE out_payment_line payment_line_item;
 BEGIN
   FOR out_payment_line IN 
     SELECT pl.payment_id, ac.entry_id, pl.type as link_type, ac.trans_id, a.invnumber as invoice_number,
     ac.chart_id, ch.accno as chart_accno, ch.description as chart_description, ch.link as chart_link,
     ac.amount,  ac.transdate as trans_date, ac.source, ac.cleared_on, ac.fx_transaction, ac.project_id,
     ac.memo, ac.invoice_id, ac.approved, ac.cleared_on, ac.reconciled_on
     FROM acc_trans ac
     JOIN payment_links pl ON (pl.entry_id = ac.entry_id )
     JOIN chart         ch ON (ch.id = ac.chart_id)
     LEFT JOIN (SELECT id,invnumber
                 FROM ar WHERE in_account_class = 2
                 UNION
                 SELECT id,invnumber
                 FROM ap WHERE in_account_class = 1
                ) a ON (ac.trans_id = a.id)
     WHERE pl.payment_id = in_payment_id
   LOOP
      RETURN NEXT out_payment_line;
   END LOOP;  
 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_get_all_accounts(in_account_class integer) -->
    <section id="lsmb13.function.payment-get-all-accounts-in-account-class-integer"
             xreflabel="lsmb13payment_get_all_accounts(in_account_class integer)">
      <title id="lsmb13.function.payment-get-all-accounts-in-account-class-integer-title">
       payment_get_all_accounts(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-all-accounts-in-account-class-integer-titleabbrev">
       payment_get_all_accounts(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        This function takes a single argument (1 for vendor, 2 for customer as 
always) and returns all entities with accounts of the appropriate type. 
        <programlisting>
DECLARE out_entity entity%ROWTYPE;
BEGIN
	FOR out_entity IN
		SELECT  ec.id, 
			e.name, e.entity_class, e.created 
		FROM entity e
		JOIN entity_credit_account ec ON (ec.entity_id = e.id)
				WHERE e.entity_class = in_account_class
	LOOP
		RETURN NEXT out_entity;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text) -->
    <section id="lsmb13.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text"
             xreflabel="lsmb13payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)">
      <title id="lsmb13.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text-title">
       payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text-titleabbrev">
       payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_contact_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes the following arguments (all prefaced with in_ in the db):
account_class: 1 for vendor, 2 for customer
business_type: integer of business.id.
currency: char(3) of currency (for example &apos;USD&apos;)
date_from, date_to:  These dates are inclusive.
batch_id:  For payment batches, where fees are concerned.
ar_ap_accno:  The AR/AP account number.

This then returns a set of contact information with a 2 dimensional array 
cnsisting of outstanding invoices.

Note that the payment selection logic is that this returns all invoices which are
either approved or in the batch_id specified.  It also locks the invoices using 
the LedgerSMB discretionary locking framework, and if not possible, returns the 
username of the individual who has the lock.

        <programlisting>
DECLARE payment_item payment_contact_invoice;
BEGIN
        FOR payment_item IN
                  SELECT c.id AS contact_id, e.control_code as econtrol_code, 
                        c.description as eca_description, 
                        e.name AS contact_name,
                         c.meta_number AS account_number,
                         sum( case when u.username IS NULL or 
                                       u.username = SESSION_USER 
                             THEN 
                              coalesce(p.due::numeric, 0) -
                              CASE WHEN c.discount_terms 
                                        &gt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due::numeric, 0)) * 
                                        coalesce(c.discount::numeric, 0) / 100
                              END
                             ELSE 0::numeric
                             END) AS total_due,
                         compound_array(ARRAY[[
                              a.id::text, a.invnumber, a.transdate::text, 
                              a.amount::text, (a.amount - p.due)::text,
                              (CASE WHEN c.discount_terms 
                                        &lt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due, 0) * coalesce(c.discount, 0) / 100)
                              END)::text, 
                              (coalesce(p.due, 0) -
                              (CASE WHEN c.discount_terms 
                                        &lt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due, 0)) * coalesce(c.discount, 0) / 100
                              END))::text,
                                case when u.username IS NOT NULL 
                                          and u.username &lt;&gt; SESSION_USER 
                                     THEN 0::text
                                     ELSE 1::text
                                END,
                                COALESCE(u.username, 0::text)
                                ]]),
                              sum(case when a.batch_id = in_batch_id then 1
                                  else 0 END),
                              bool_and(lock_record(a.id, (select max(session_id)
                                FROM &quot;session&quot; where users_id = (
                                        select id from users WHERE username =
                                        SESSION_USER))))
                           
                    FROM entity e
                    JOIN entity_credit_account c ON (e.id = c.entity_id)
                    JOIN (SELECT ap.id, invnumber, transdate, amount, entity_id, 
                                 curr, 1 as invoice_class,
                                 entity_credit_account, on_hold, v.batch_id,
                                 approved, paid
                            FROM ap
                       LEFT JOIN (select * from voucher where batch_class = 1) v 
                                 ON (ap.id = v.trans_id)
                           WHERE in_account_class = 1
                                 AND (v.batch_class = 1 or v.batch_id IS NULL)
                           UNION
                          SELECT ar.id, invnumber, transdate, amount, entity_id,
                                 curr, 2 as invoice_class,
                                 entity_credit_account, on_hold, v.batch_id,
                                 approved, paid
                            FROM ar
                       LEFT JOIN (select * from voucher where batch_class = 2) v 
                                 ON (ar.id = v.trans_id)
                           WHERE in_account_class = 2
                                 AND (v.batch_class = 2 or v.batch_id IS NULL)
                        ORDER BY transdate
                         ) a ON (a.entity_credit_account = c.id)
                    JOIN transactions t ON (a.id = t.id)
                    JOIN (SELECT acc_trans.trans_id, 
                                 sum(CASE WHEN in_account_class = 1 THEN amount
                                          WHEN in_account_class = 2 
                                          THEN amount * -1
                                     END) AS due 
                            FROM acc_trans 
                            JOIN account coa ON (coa.id = acc_trans.chart_id)
                            JOIN account_link al ON (al.account_id = coa.id)
                       LEFT JOIN voucher v ON (acc_trans.voucher_id = v.id)
                           WHERE ((al.description = &#39;AP&#39; AND in_account_class = 1)
                                 OR (al.description = &#39;AR&#39; AND in_account_class = 2))
                           AND (approved IS TRUE or v.batch_class IN (3, 6))
                        GROUP BY acc_trans.trans_id) p ON (a.id = p.trans_id)
                LEFT JOIN &quot;session&quot; s ON (s.&quot;session_id&quot; = t.locked_by)
                LEFT JOIN users u ON (u.id = s.users_id)
                   WHERE (a.batch_id = in_batch_id
                          OR (a.invoice_class = in_account_class
                             AND a.approved
                         AND due &lt;&gt; 0
                         AND NOT a.on_hold
                         AND a.curr = in_currency
                         AND EXISTS (select trans_id FROM acc_trans
                                      WHERE trans_id = a.id AND
                                            chart_id = (SELECT id from account
                                                         WHERE accno
                                                               = in_ar_ap_accno)
                                    )))
                         AND (in_meta_number IS NULL OR 
                             in_meta_number = c.meta_number)
                GROUP BY c.id, e.name, c.meta_number, c.threshold, 
                        e.control_code, c.description
                  HAVING  (sum(p.due) &gt;= c.threshold
                        OR sum(case when a.batch_id = in_batch_id then 1
                                  else 0 END) &gt; 0)
        ORDER BY c.meta_number ASC
        LOOP
                RETURN NEXT payment_item;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer) -->
    <section id="lsmb13.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer"
             xreflabel="lsmb13payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)">
      <title id="lsmb13.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer-title">
       payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer-titleabbrev">
       payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_overpayments_available_amount</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_overpayment payment_overpayments_available_amount;
BEGIN
      FOR out_overpayment IN
              SELECT chart_id, accno,   chart_description, abs(sum(available))
              FROM overpayments
              WHERE payment_class  = in_account_class 
              AND entity_credit_id = in_entity_credit_id 
              AND available &lt;&gt; 0
              GROUP BY chart_id, accno, chart_description
      LOOP
           RETURN NEXT out_overpayment;
      END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_entity_account_payment_info(in_entity_credit_id integer) -->
    <section id="lsmb13.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer"
             xreflabel="lsmb13payment_get_entity_account_payment_info(in_entity_credit_id integer)">
      <title id="lsmb13.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer-title">
       payment_get_entity_account_payment_info(in_entity_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer-titleabbrev">
       payment_get_entity_account_payment_info(in_entity_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns payment information on the entity credit account as
  required to for discount calculations and payment processing. 
        <programlisting>
 SELECT ec.id, cp.legal_name ||
        coalesce(&#39;:&#39; || ec.description,&#39;&#39;) as name,
        e.entity_class, ec.discount_account_id, ec.meta_number
 FROM entity_credit_account ec
 JOIN entity e ON (ec.entity_id = e.id)
 JOIN company cp ON (cp.entity_id = e.id)
 WHERE ec.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text) -->
    <section id="lsmb13.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text"
             xreflabel="lsmb13payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)">
      <title id="lsmb13.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text-title">
       payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text-titleabbrev">
       payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a minimal set of information about customer or vendor accounts
as needed for discount calculations and the like.
        <programlisting>
 DECLARE out_entity payment_vc_info;
 

 BEGIN
 	FOR out_entity IN
              SELECT ec.id, cp.legal_name || 
                     coalesce(&#39;:&#39; || ec.description,&#39;&#39;) as name, 
                     e.entity_class, ec.discount_account_id, ec.meta_number
 		FROM entity_credit_account ec
 		JOIN entity e ON (ec.entity_id = e.id)
 		JOIN company cp ON (cp.entity_id = e.id)
		WHERE ec.entity_class = in_account_class
		AND (cp.legal_name ilike coalesce(&#39;%&#39;||in_vc_name||&#39;%&#39;,&#39;%%&#39;) OR cp.tax_id = in_vc_idn)
	LOOP
		RETURN NEXT out_entity;
	END LOOP;
 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_get_open_accounts(in_account_class integer) -->
    <section id="lsmb13.function.payment-get-open-accounts-in-account-class-integer"
             xreflabel="lsmb13payment_get_open_accounts(in_account_class integer)">
      <title id="lsmb13.function.payment-get-open-accounts-in-account-class-integer-title">
       payment_get_open_accounts(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-open-accounts-in-account-class-integer-titleabbrev">
       payment_get_open_accounts(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        This function takes a single argument (1 for vendor, 2 for customer as 
always) and returns all entities with open accounts of the appropriate type. 
        <programlisting>
DECLARE out_entity entity%ROWTYPE;
BEGIN
        FOR out_entity IN
                SELECT ec.id, cp.legal_name as name, e.entity_class, e.created
                FROM entity e
                JOIN entity_credit_account ec ON (ec.entity_id = e.id)
                JOIN company cp ON (cp.entity_id = e.id)
                        WHERE ec.entity_class = in_account_class
                        AND CASE WHEN in_account_class = 1 THEN
                                ec.id IN
                                (SELECT entity_credit_account
                                   FROM acc_trans
                                   JOIN chart ON (acc_trans.chart_id = chart.id)
                                   JOIN ap ON (acc_trans.trans_id = ap.id)
                                   WHERE link = &#39;AP&#39;
                                   GROUP BY chart_id,
                                         trans_id, entity_credit_account
                                   HAVING SUM(acc_trans.amount) &lt;&gt; 0)
                               WHEN in_account_class = 2 THEN
                                ec.id IN (SELECT entity_credit_account
                                   FROM acc_trans
                                   JOIN chart ON (acc_trans.chart_id = chart.id)
                                   JOIN ar ON (acc_trans.trans_id = ar.id)
                                   WHERE link = &#39;AR&#39;
                                   GROUP BY chart_id,
                                         trans_id, entity_credit_account
                                   HAVING SUM(acc_trans.amount) &lt;&gt; 0)
                          END
        LOOP
                RETURN NEXT out_entity;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text) -->
    <section id="lsmb13.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text"
             xreflabel="lsmb13payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)">
      <title id="lsmb13.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text-title">
       payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text-titleabbrev">
       payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
        
This function is based on payment_get_open_invoices and returns only one invoice if the in_invnumber is set. 
if no in_invnumber is passed this function behaves the same as payment_get_open_invoices

        <programlisting>
DECLARE payment_inv payment_invoice;
BEGIN
	FOR payment_inv IN
		SELECT * from payment_get_open_invoices(in_account_class, in_entity_credit_id, in_curr, in_datefrom, in_dateto, in_amountfrom,
		in_amountto, in_department_id)
		WHERE (invnumber like in_invnumber OR in_invnumber IS NULL)
	LOOP
		RETURN NEXT payment_inv;
	END LOOP;
END;

</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer) -->
    <section id="lsmb13.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer"
             xreflabel="lsmb13payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)">
      <title id="lsmb13.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer-title">
       payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer-titleabbrev">
       payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
        This function is the base for get_open_invoice and returns all open invoices for the entity_credit_id
it has a lot of options to enable filtering and use the same logic for entity_class_id and currency. 
        <programlisting>
DECLARE payment_inv payment_invoice;
BEGIN
	FOR payment_inv IN
		SELECT a.id AS invoice_id, a.invnumber AS invnumber,a.invoice AS invoice, 
		       a.transdate AS invoice_date, a.amount AS amount, 
		       a.amount/
		       (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		        ELSE
		        (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		        END) as amount_fx, 
		       (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END) AS discount,
		        (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END)/
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		        ELSE
		        (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		        END) as discount_fx,		        
		        ac.due - (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END) AS due,
		        (ac.due - (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0 
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END))/
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		         ELSE
		         (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		         END) AS due_fx,
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
		         THEN 1
		         ELSE
		        (CASE WHEN in_account_class = 2
		         THEN ex.buy
		         ELSE ex.sell END)
		         END) AS exchangerate
                 --TODO HV prepare drop entity_id from ap,ar
                 --FROM  (SELECT id, invnumber, transdate, amount, entity_id,
                 FROM  (SELECT id, invnumber, invoice, transdate, amount,
		               1 as invoice_class, curr,
		               entity_credit_account, department_id, approved
		          FROM ap
                         UNION
		         --SELECT id, invnumber, transdate, amount, entity_id,
		         SELECT id, invnumber, invoice, transdate, amount,
		               2 AS invoice_class, curr,
		               entity_credit_account, department_id, approved
		         FROM ar
		         ) a 
		JOIN (SELECT trans_id, chart_id, sum(CASE WHEN in_account_class = 1 THEN amount
		                                  WHEN in_account_class = 2 
		                             THEN amount * -1
		                             END) as due
		        FROM acc_trans 
		        GROUP BY trans_id, chart_id) ac ON (ac.trans_id = a.id)
		        JOIN chart ON (chart.id = ac.chart_id)
		        LEFT JOIN exchangerate ex ON ( ex.transdate = a.transdate AND ex.curr = a.curr )         
		        JOIN entity_credit_account c ON (c.id = a.entity_credit_account)
                --        OR (a.entity_credit_account IS NULL and a.entity_id = c.entity_id))
	 	        WHERE ((chart.link = &#39;AP&#39; AND in_account_class = 1)
		              OR (chart.link = &#39;AR&#39; AND in_account_class = 2))
              	        AND a.invoice_class = in_account_class
		        AND c.entity_class = in_account_class
		        AND c.id = in_entity_credit_id
                        --### short term: ignore fractional cent differences
		        AND a.curr = in_curr
		        AND (a.transdate &gt;= in_datefrom 
		             OR in_datefrom IS NULL)
		        AND (a.transdate &lt;= in_dateto
		             OR in_dateto IS NULL)
		        AND (a.amount &gt;= in_amountfrom 
		             OR in_amountfrom IS NULL)
		        AND (a.amount &lt;= in_amountto
		             OR in_amountto IS NULL)
		        AND (a.department_id = in_department_id
		             OR in_department_id IS NULL)
		        AND due &lt;&gt; 0 
		        AND a.approved = true         
		        GROUP BY a.invnumber, a.transdate, a.amount, amount_fx, discount, discount_fx, ac.due, a.id, c.discount_terms, ex.buy, ex.sell, a.curr, a.invoice
	LOOP
		RETURN NEXT payment_inv;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_overpayment_entities(in_account_class integer) -->
    <section id="lsmb13.function.payment-get-open-overpayment-entities-in-account-class-integer"
             xreflabel="lsmb13payment_get_open_overpayment_entities(in_account_class integer)">
      <title id="lsmb13.function.payment-get-open-overpayment-entities-in-account-class-integer-title">
       payment_get_open_overpayment_entities(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-open-overpayment-entities-in-account-class-integer-titleabbrev">
       payment_get_open_overpayment_entities(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
 DECLARE out_entity payment_vc_info;
 BEGIN
	FOR out_entity IN
    		SELECT DISTINCT entity_credit_id, legal_name, e.entity_class, discount, o.meta_number
    		FROM overpayments o
    		JOIN entity e ON (e.id=o.entity_id)
    		WHERE available &lt;&gt; 0 AND in_account_class = payment_class
        LOOP
                RETURN NEXT out_entity;
        END LOOP;
 END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer) -->
    <section id="lsmb13.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer"
             xreflabel="lsmb13payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)">
      <title id="lsmb13.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer-title">
       payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer-titleabbrev">
       payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF overpayments</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of available overpayments
        <programlisting>
DECLARE out_overpayment overpayments%ROWTYPE;
BEGIN
      FOR out_overpayment IN
              SELECT DISTINCT * 
              FROM overpayments
              WHERE payment_class  = in_account_class 
              AND entity_credit_id = in_entity_credit_id 
              AND available &lt;&gt; 0
              AND (in_chart_id IS NULL OR chart_id = in_chart_id )
              ORDER BY payment_date
            
      LOOP
           RETURN NEXT out_overpayment;
      END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer) -->
    <section id="lsmb13.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer"
             xreflabel="lsmb13payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)">
      <title id="lsmb13.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer-title">
       payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer-titleabbrev">
       payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns vendor or customer info 
        <programlisting>
DECLARE out_row payment_location_result;
	BEGIN
		FOR out_row IN
                SELECT l.id, l.line_one, l.line_two, l.line_three, l.city,
                       l.state, l.mail_code, c.name, lc.class
                FROM location l
                JOIN entity_to_location ctl ON (ctl.location_id = l.id)
                JOIN entity cp ON (ctl.entity_id = cp.id)
                JOIN location_class lc ON (ctl.location_class = lc.id)
                JOIN country c ON (c.id = l.country_id)
                JOIN entity_credit_account ec ON (ec.entity_id = cp.entity_id)
                WHERE ec.id = in_entity_credit_id AND
                      lc.id = in_location_class_id
                ORDER BY lc.id, l.id, c.name
                LOOP
                	RETURN NEXT out_row;
		END LOOP;
	END;
</programlisting>
      </para>
    </section>

<!-- Function payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean) -->
    <section id="lsmb13.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean"
             xreflabel="lsmb13payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)">
      <title id="lsmb13.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean-title">
       payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)
      </title>
      <titleabbrev id="lsmb13.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean-titleabbrev">
       payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts a payment.  in_op_* arrays are cross-indexed with eachother.
Other arrays are cross-indexed with eachother.

This API will probably change in 1.4 as we start looking at using more custom
complex types and arrays of those (requires Pg 8.4 or higher).

        <programlisting>
DECLARE var_payment_id int;
DECLARE var_gl_id int;
DECLARE var_entry record;
DECLARE var_entry_id int[];
DECLARE out_count int;
DECLARE coa_id record;
DECLARE var_employee int;
DECLARE var_account_id int;
DECLARE default_currency char(3);
DECLARE current_exchangerate numeric;
DECLARE old_exchangerate numeric;
DECLARE fx_gain_loss_amount numeric;
BEGIN
      IF array_upper(in_amount, 1) &lt;&gt; array_upper(in_cash_account_id, 1) THEN
          RAISE EXCEPTION &#39;Wrong number of accounts&#39;;
      END IF;
        
        SELECT * INTO default_currency  FROM defaults_get_defaultcurrency(); 
        SELECT * INTO current_exchangerate FROM currency_get_exchangerate(in_curr, in_datepaid, in_account_class);


        SELECT INTO var_employee p.id 
        FROM users u
        JOIN person p ON (u.entity_id=p.entity_id)
        WHERE username = SESSION_USER LIMIT 1;
        -- 
        -- WE HAVE TO INSERT THE PAYMENT, USING THE GL INFORMATION
        -- THE ID IS GENERATED BY payment_id_seq
        --
   	INSERT INTO payment (reference, payment_class, payment_date,
	                      employee_id, currency, notes, department_id, entity_credit_id) 
	VALUES ((CASE WHEN in_account_class = 1 THEN
	                                setting_increment(&#39;rcptnumber&#39;) -- I FOUND THIS ON sql/modules/Settings.sql 
			             ELSE 						-- and it is very usefull				
			                setting_increment(&#39;paynumber&#39;) 
			             END),
	         in_account_class, in_datepaid, var_employee,
                 in_curr, in_notes, in_department_id, in_entity_credit_id);
        SELECT currval(&#39;payment_id_seq&#39;) INTO var_payment_id; -- WE&#39;LL NEED THIS VALUE TO USE payment_link table
        -- WE&#39;LL NEED THIS VALUE TO JOIN WITH PAYMENT
        -- NOW COMES THE HEAVY PART, STORING ALL THE POSSIBLE TRANSACTIONS... 
        --
        -- FIRST WE SHOULD INSERT THE CASH ACCOUNTS
        --
        -- WE SHOULD HAVE THE DATA STORED AS (ACCNO, AMOUNT), SO
     IF (array_upper(in_cash_account_id, 1) &gt; 0) THEN
	FOR out_count IN 
			array_lower(in_cash_account_id, 1) ..
			array_upper(in_cash_account_id, 1)
	LOOP
	        INSERT INTO acc_trans (chart_id, amount,
		                       trans_id, transdate, approved, source, memo)
		VALUES (in_cash_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_amount[out_count]*current_exchangerate  
		        ELSE (in_amount[out_count]*current_exchangerate)* - 1
		        END,
		        in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true), 
		        in_source[out_count], in_memo[out_count]);
                INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 1);
		IF (in_ovp_payment_id IS NOT NULL AND in_ovp_payment_id[out_count] IS NOT NULL) THEN
                	INSERT INTO payment_links
                	VALUES (in_ovp_payment_id[out_count], currval(&#39;acc_trans_entry_id_seq&#39;), 0);
		END IF;
		
	END LOOP;
	-- NOW LETS HANDLE THE AR/AP ACCOUNTS
	-- WE RECEIVED THE TRANSACTIONS_ID AND WE CAN OBTAIN THE ACCOUNT FROM THERE
	FOR out_count IN
		     array_lower(in_transaction_id, 1) ..
		     array_upper(in_transaction_id, 1)
       LOOP
               SELECT INTO var_account_id chart_id FROM acc_trans as ac
	        JOIN chart as c ON (c.id = ac.chart_id) 
       	        WHERE 
       	        trans_id = in_transaction_id[out_count] AND
       	        ( c.link = &#39;AP&#39; OR c.link = &#39;AR&#39; );
        -- We need to know the exchangerate of this transaction
	-- ### BUG: we don&#39;t have a guarantee that the transaction is
	--          the same currency as in_curr, so, we can&#39;t use
	--          current_exchangerate as the basis for fx gain/loss
	--          calculations
        IF (in_curr = default_currency) THEN 
           old_exchangerate := 1;
        ELSIF (in_account_class = 2) THEN
           SELECT buy INTO old_exchangerate 
           FROM exchangerate e
           JOIN ar a ON (a.transdate = e.transdate)
                        AND (a.curr = e.curr)
           WHERE a.id = in_transaction_id[out_count];
        ELSE 
           SELECT sell INTO old_exchangerate 
           FROM exchangerate e
           JOIN ap a ON (a.transdate = e.transdate)
                        AND (a.curr = e.curr)
           WHERE a.id = in_transaction_id[out_count];
        END IF;
        -- Now we post the AP/AR transaction
        INSERT INTO acc_trans (chart_id, amount,
                                trans_id, transdate, approved, source, memo)
		VALUES (var_account_id, 
		        CASE WHEN in_account_class = 1 THEN 
		        
		        (in_amount[out_count]*old_exchangerate) * -1 
		        ELSE in_amount[out_count]*old_exchangerate
		        END,
		        in_transaction_id[out_count], in_datepaid,  coalesce(in_approved, true), 
		        in_source[out_count], in_memo[out_count]);
        -- Lets set the gain/loss, if  fx_gain_loss_amount equals zero then we dont need to post
        -- any transaction
       fx_gain_loss_amount := in_amount[out_count]*current_exchangerate - in_amount[out_count]*old_exchangerate;
       IF (in_account_class = 1) THEN
         -- in case of vendor invoices, the invoice amounts have been negated, do the same with the diff
         fx_gain_loss_amount := fx_gain_loss_amount * -1;
       END IF;

       IF (fx_gain_loss_amount &lt; 0) THEN
           INSERT INTO acc_trans (chart_id, amount, trans_id, transdate, approved, source)
            VALUES ((select value::int from defaults WHERE setting_key = &#39;fxgain_accno_id&#39;),
                    fx_gain_loss_amount, in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true),
                    in_source[out_count]);
        ELSIF (fx_gain_loss_amount &gt; 0) THEN
            INSERT INTO acc_trans (chart_id, amount, trans_id, transdate, approved, source)
            VALUES ((select value::int from defaults WHERE setting_key = &#39;fxloss_accno_id&#39;),
                    fx_gain_loss_amount, in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true),
                    in_source[out_count]);
        END IF; 
        -- Now we set the links
         INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 1);
      END LOOP;
     END IF; -- END IF 
--
-- WE NEED TO HANDLE THE OVERPAYMENTS NOW
--
       --
       -- FIRST WE HAVE TO MAKE THE GL TO HOLD THE OVERPAYMENT TRANSACTIONS
       -- THE ID IS GENERATED BY gl_id_seq
       --
       
  IF (array_upper(in_op_cash_account_id, 1) &gt; 0) THEN
       INSERT INTO gl (reference, description, transdate,
                       person_id, notes, approved, department_id) 
              VALUES (setting_increment(&#39;glnumber&#39;),
	              in_gl_description, in_datepaid, var_employee,
	              in_notes, in_approved, in_department_id);
       SELECT currval(&#39;id&#39;) INTO var_gl_id;   
--
-- WE NEED TO SET THE GL_ID FIELD ON PAYMENT&#39;S TABLE
--
       UPDATE payment SET gl_id = var_gl_id 
       WHERE id = var_payment_id;
       -- NOW COMES THE HEAVY PART, STORING ALL THE POSSIBLE TRANSACTIONS... 
       --
       -- FIRST WE SHOULD INSERT THE OVERPAYMENT CASH ACCOUNTS
       --
	FOR out_count IN 
			array_lower(in_op_cash_account_id, 1) ..
			array_upper(in_op_cash_account_id, 1)
	LOOP
	        INSERT INTO acc_trans (chart_id, amount,
		                       trans_id, transdate, approved, source, memo)
		VALUES (in_op_cash_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_op_amount[out_count]  
		        ELSE in_op_amount[out_count] * - 1
		        END,
		        var_gl_id, in_datepaid, coalesce(in_approved, true), 
		        in_op_source[out_count], in_op_memo[out_count]);
	        INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 2);
		
	END LOOP;
	-- NOW LETS HANDLE THE OVERPAYMENT ACCOUNTS
	FOR out_count IN
		     array_lower(in_op_account_id, 1) ..
		     array_upper(in_op_account_id, 1)
	LOOP
         INSERT INTO acc_trans (chart_id, amount,
                                trans_id, transdate, approved, source, memo)
		VALUES (in_op_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_op_amount[out_count] * -1 
		        ELSE in_op_amount[out_count]
		        END,
		        var_gl_id, in_datepaid,  coalesce(in_approved, true), 
		        in_op_source[out_count], in_op_memo[out_count]);
		INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 2);
	END LOOP;	        
 END IF;  
 return var_payment_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_type__get_label(in_payment_type_id integer) -->
    <section id="lsmb13.function.payment-type-get-label-in-payment-type-id-integer"
             xreflabel="lsmb13payment_type__get_label(in_payment_type_id integer)">
      <title id="lsmb13.function.payment-type-get-label-in-payment-type-id-integer-title">
       payment_type__get_label(in_payment_type_id integer)
      </title>
      <titleabbrev id="lsmb13.function.payment-type-get-label-in-payment-type-id-integer-titleabbrev">
       payment_type__get_label(in_payment_type_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_type</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all information on a payment type by the id.  This should be renamed
to account for its behavior in future versions.
        <programlisting>
DECLARE out_row payment_type%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM payment_type where id=in_payment_type_id LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_type__list() -->
    <section id="lsmb13.function.payment-type-list"
             xreflabel="lsmb13payment_type__list()">
      <title id="lsmb13.function.payment-type-list-title">
       payment_type__list()
      </title>
      <titleabbrev id="lsmb13.function.payment-type-list-titleabbrev">
       payment_type__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_row payment_type%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM payment_type LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payments_get_open_currencies(in_account_class integer) -->
    <section id="lsmb13.function.payments-get-open-currencies-in-account-class-integer"
             xreflabel="lsmb13payments_get_open_currencies(in_account_class integer)">
      <title id="lsmb13.function.payments-get-open-currencies-in-account-class-integer-title">
       payments_get_open_currencies(in_account_class integer)
      </title>
      <titleabbrev id="lsmb13.function.payments-get-open-currencies-in-account-class-integer-titleabbrev">
       payments_get_open_currencies(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF bpchar</seg>
        </seglistitem>
       </segmentedlist>
 
        This does a sparse scan to find currencies attached to open invoices.

It should scale per the number of currencies used rather than the size of the 
ar or ap tables.

        <programlisting>
DECLARE result char(3);
BEGIN
select min(curr) into result from ar WHERE in_account_class = 2
union 
select min(curr) from ap WHERE in_account_class = 1;


LOOP
   EXIT WHEN result IS NULL;
   return next result;

   SELECT min(curr) INTO result from ar 
    where in_account_class = 2 and curr &gt; result
            union 
   select min(curr) from ap 
    WHERE in_account_class = 1 and curr &gt; result
    LIMIT 1;

END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date) -->
    <section id="lsmb13.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date"
             xreflabel="lsmb13payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)">
      <title id="lsmb13.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date-title">
       payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)
      </title>
      <titleabbrev id="lsmb13.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date-titleabbrev">
       payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        1.3 only.  This will be replaced by a more generic function in 1.4.

This sets the exchange rate for a class of transactions (payable, receivable) 
to a certain rate for a specific date.
        <programlisting>
DECLARE current_exrate  exchangerate%ROWTYPE;
BEGIN
select  * INTO current_exrate
        FROM  exchangerate 
        WHERE transdate = in_datepaid
              AND curr = in_curr;
IF current_exrate.transdate = in_datepaid THEN
   IF in_account_class = 2 THEN 
      UPDATE exchangerate set buy = in_exchangerate  where transdate = in_datepaid;
   ELSE
      UPDATE exchangerate set sell = in_exchangerate where transdate = in_datepaid;
   END IF;
   RETURN 0; 
ELSE
    IF in_account_class = 2 THEN
     INSERT INTO exchangerate (curr, transdate, buy) values (in_curr, in_datepaid, in_exchangerate);
  ELSE   
     INSERT INTO exchangerate (curr, transdate, sell) values (in_curr, in_datepaid, in_exchangerate);
  END IF;                                       
RETURN 0;
END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function periods_get() -->
    <section id="lsmb13.function.periods-get"
             xreflabel="lsmb13periods_get()">
      <title id="lsmb13.function.periods-get-title">
       periods_get()
      </title>
      <titleabbrev id="lsmb13.function.periods-get-titleabbrev">
       periods_get()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF periods</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns dates for year to date, and last year.
        <programlisting>
SELECT * FROM periods ORDER BY id
</programlisting>
      </para>
    </section>

<!-- Function person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text) -->
    <section id="lsmb13.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text"
             xreflabel="lsmb13person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)">
      <title id="lsmb13.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text-title">
       person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)
      </title>
      <titleabbrev id="lsmb13.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text-titleabbrev">
       person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes a contact record specified for the person.  Returns true if a record
was found and deleted, false if not.
        <programlisting>
BEGIN

DELETE FROM person_to_contact
 WHERE person_id = in_person_id and contact_class_id = in_contact_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer) -->
    <section id="lsmb13.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer"
             xreflabel="lsmb13person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)">
      <title id="lsmb13.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer-title">
       person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer-titleabbrev">
       person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Deletes a location mapping to a person.  Returns true if found, false if no
data deleted.
        <programlisting>
BEGIN

DELETE FROM person_to_location
 WHERE person_id = in_person_id AND location_id = in_location_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function person__get_my_entity_id() -->
    <section id="lsmb13.function.person-get-my-entity-id"
             xreflabel="lsmb13person__get_my_entity_id()">
      <title id="lsmb13.function.person-get-my-entity-id-title">
       person__get_my_entity_id()
      </title>
      <titleabbrev id="lsmb13.function.person-get-my-entity-id-titleabbrev">
       person__get_my_entity_id()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity_id of the current, logged in user.
        <programlisting>
	SELECT entity_id from users where username = SESSION_USER;
</programlisting>
      </para>
    </section>

<!-- Function person__list_bank_account(in_entity_id integer) -->
    <section id="lsmb13.function.person-list-bank-account-in-entity-id-integer"
             xreflabel="lsmb13person__list_bank_account(in_entity_id integer)">
      <title id="lsmb13.function.person-list-bank-account-in-entity-id-integer-title">
       person__list_bank_account(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-list-bank-account-in-entity-id-integer-titleabbrev">
       person__list_bank_account(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_bank_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists bank accounts for a person
        <programlisting>
DECLARE out_row entity_bank_account%ROWTYPE;
BEGIN
	FOR out_row IN
		SELECT * from entity_bank_account where entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_contacts(in_entity_id integer) -->
    <section id="lsmb13.function.person-list-contacts-in-entity-id-integer"
             xreflabel="lsmb13person__list_contacts(in_entity_id integer)">
      <title id="lsmb13.function.person-list-contacts-in-entity-id-integer-title">
       person__list_contacts(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-list-contacts-in-entity-id-integer-titleabbrev">
       person__list_contacts(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contacts attached to the function.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN 
		SELECT cc.class, cc.id, c.description, c.contact
		FROM person_to_contact c
		JOIN contact_class cc ON (c.contact_class_id = cc.id)
		JOIN person p ON (c.person_id = p.id)
		WHERE p.entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_languages() -->
    <section id="lsmb13.function.person-list-languages"
             xreflabel="lsmb13person__list_languages()">
      <title id="lsmb13.function.person-list-languages-title">
       person__list_languages()
      </title>
      <titleabbrev id="lsmb13.function.person-list-languages-titleabbrev">
       person__list_languages()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF language</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of languages ordered by code
        <programlisting> SELECT * FROM language ORDER BY code ASC </programlisting>
      </para>
    </section>

<!-- Function person__list_notes(in_entity_id integer) -->
    <section id="lsmb13.function.person-list-notes-in-entity-id-integer"
             xreflabel="lsmb13person__list_notes(in_entity_id integer)">
      <title id="lsmb13.function.person-list-notes-in-entity-id-integer-title">
       person__list_notes(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-list-notes-in-entity-id-integer-titleabbrev">
       person__list_notes(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of notes attached to a person.
        <programlisting>
DECLARE out_row record;
BEGIN
	FOR out_row IN
		SELECT *
		FROM entity_note
		WHERE ref_key = in_entity_id
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_salutations() -->
    <section id="lsmb13.function.person-list-salutations"
             xreflabel="lsmb13person__list_salutations()">
      <title id="lsmb13.function.person-list-salutations-title">
       person__list_salutations()
      </title>
      <titleabbrev id="lsmb13.function.person-list-salutations-titleabbrev">
       person__list_salutations()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF salutation</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of salutations ordered by id.
        <programlisting> SELECT * FROM salutation ORDER BY id ASC </programlisting>
      </para>
    </section>

<!-- Function person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer) -->
    <section id="lsmb13.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer"
             xreflabel="lsmb13person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)">
      <title id="lsmb13.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer-title">
       person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer-titleabbrev">
       person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the person with the information specified.  Returns the entity_id
of the record saved.
        <programlisting>

    DECLARE
        e_id int;
        e entity;
        loc location;
        l_id int;
        p_id int;
    BEGIN
    
    select * into e from entity where id = in_entity_id and entity_class = 3;
    e_id := in_entity_id; 
    
    IF FOUND THEN
        UPDATE entity 
           SET name = in_first_name || &#39; &#39; || in_last_name,
               country_id = in_country_id
         WHERE id = in_entity_id; 
    ELSE
        INSERT INTO entity (name, entity_class, country_id) 
	values (in_first_name || &#39; &#39; || in_last_name, 3, in_country_id);
	e_id := currval(&#39;entity_id_seq&#39;);
       
    END IF;
    
      
    UPDATE person SET
            salutation_id = in_salutation_id,
            first_name = in_first_name,
            last_name = in_last_name,
            middle_name = in_middle_name
    WHERE
            entity_id = in_entity_id;
    IF FOUND THEN
	RETURN in_entity_id;
    ELSE 
        -- Do an insert
        
        INSERT INTO person (salutation_id, first_name, last_name, entity_id)
	VALUES (in_salutation_id, in_first_name, in_last_name, e_id);

        RETURN e_id;
    
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer) -->
    <section id="lsmb13.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer"
             xreflabel="lsmb13person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)">
      <title id="lsmb13.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer-title">
       person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer-titleabbrev">
       person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves saves contact info.  Returns 1 if a row was inserted, 0 if it was 
updated. 
        <programlisting>
DECLARE 
    out_id int;
    v_orig person_to_contact;
BEGIN
    
    SELECT cc.* into v_orig 
    FROM person_to_contact cc, person p
    WHERE p.entity_id = in_entity_id 
    and cc.contact_class_id = in_old_contact_class
    AND cc.contact = in_old_contact
    AND cc.person_id = p.id;
    
    IF NOT FOUND THEN
    
        -- create
        INSERT INTO person_to_contact(person_id, contact_class_id, contact, description)
        VALUES (
            (SELECT id FROM person WHERE entity_id = in_entity_id),
            in_contact_class,
            in_contact_new,
            in_description
        );
        return 1;
    ELSE
        -- edit.
        UPDATE person_to_contact
           SET contact = in_contact_new, description = in_description
         WHERE contact = in_old_contact
               AND person_id = v_orig.person_id
               AND contact_class_id = in_old_contact_class;
        return 0;
    END IF;
    
END;
</programlisting>
      </para>
    </section>

<!-- Function person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer) -->
    <section id="lsmb13.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer"
             xreflabel="lsmb13person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)">
      <title id="lsmb13.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer-title">
       person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb13.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer-titleabbrev">
       person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location mapped to the person with the specified information.
Returns the location id saved.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
	    t_person_id int;
    BEGIN
	SELECT id INTO t_person_id
	FROM person WHERE entity_id = in_entity_id;

    UPDATE person_to_location
       SET location_class = in_location_class
     WHERE person_id = t_person_id 
           AND location_class = in_old_location_class
           AND location_id = in_location_id;
    
    
    IF NOT FOUND THEN
        -- Create a new one.
        l_id := location_save(
            in_location_id, 
    	    in_line_one, 
    	    in_line_two, 
    	    in_line_three, 
    	    in_city,
    		in_state, 
    		in_mail_code, 
    		in_country_code);
    	
        INSERT INTO person_to_location 
    		(person_id, location_id, location_class)
    	VALUES  (t_person_id, l_id, in_location_class);
    ELSE
        l_id := location_save(
            in_location_id, 
    	    in_line_one, 
    	    in_line_two, 
    	    in_line_three, 
    	    in_city,
    		in_state, 
    		in_mail_code, 
    		in_country_code);
        -- Update the old one.
    END IF;
    return l_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function plainto_tsquery(oid, text) -->
    <section id="lsmb13.function.plainto-tsquery-oid-text"
             xreflabel="lsmb13plainto_tsquery(oid, text)">
      <title id="lsmb13.function.plainto-tsquery-oid-text-title">
       plainto_tsquery(oid, text)
      </title>
      <titleabbrev id="lsmb13.function.plainto-tsquery-oid-text-titleabbrev">
       plainto_tsquery(oid, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>plainto_tsquery_byid</programlisting>
      </para>
    </section>

<!-- Function plainto_tsquery(text) -->
    <section id="lsmb13.function.plainto-tsquery-text"
             xreflabel="lsmb13plainto_tsquery(text)">
      <title id="lsmb13.function.plainto-tsquery-text-title">
       plainto_tsquery(text)
      </title>
      <titleabbrev id="lsmb13.function.plainto-tsquery-text-titleabbrev">
       plainto_tsquery(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>plainto_tsquery</programlisting>
      </para>
    </section>

<!-- Function plainto_tsquery(text, text) -->
    <section id="lsmb13.function.plainto-tsquery-text-text"
             xreflabel="lsmb13plainto_tsquery(text, text)">
      <title id="lsmb13.function.plainto-tsquery-text-text-title">
       plainto_tsquery(text, text)
      </title>
      <titleabbrev id="lsmb13.function.plainto-tsquery-text-text-titleabbrev">
       plainto_tsquery(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_plainto_tsquery_name</programlisting>
      </para>
    </section>

<!-- Function pricegroup__list() -->
    <section id="lsmb13.function.pricegroup-list"
             xreflabel="lsmb13pricegroup__list()">
      <title id="lsmb13.function.pricegroup-list-title">
       pricegroup__list()
      </title>
      <titleabbrev id="lsmb13.function.pricegroup-list-titleabbrev">
       pricegroup__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pricegroup</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an alphabetically ordered pricegroup list.
        <programlisting>
SELECT * FROM pricegroup ORDER BY pricegroup;
</programlisting>
      </para>
    </section>

<!-- Function pricegroups__list() -->
    <section id="lsmb13.function.pricegroups-list"
             xreflabel="lsmb13pricegroups__list()">
      <title id="lsmb13.function.pricegroups-list-title">
       pricegroups__list()
      </title>
      <titleabbrev id="lsmb13.function.pricegroups-list-titleabbrev">
       pricegroups__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pricegroup</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM pricegroup;
</programlisting>
      </para>
    </section>

<!-- Function pricelist__delete(credit_id integer, entry_id integer) -->
    <section id="lsmb13.function.pricelist-delete-credit-id-integer-entry-id-integer"
             xreflabel="lsmb13pricelist__delete(credit_id integer, entry_id integer)">
      <title id="lsmb13.function.pricelist-delete-credit-id-integer-entry-id-integer-title">
       pricelist__delete(credit_id integer, entry_id integer)
      </title>
      <titleabbrev id="lsmb13.function.pricelist-delete-credit-id-integer-entry-id-integer-titleabbrev">
       pricelist__delete(credit_id integer, entry_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
delete from partscustomer where entry_id = $1 and credit_id = $2;
delete from partsvendor where entry_id = $1 and credit_id = $2;
select true;
</programlisting>
      </para>
    </section>

<!-- Function pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer) -->
    <section id="lsmb13.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer"
             xreflabel="lsmb13pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)">
      <title id="lsmb13.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-title">
       pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </title>
      <titleabbrev id="lsmb13.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-titleabbrev">
       pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   retval eca__pricematrix;
   t_insert bool;
   t_entity_class int;

BEGIN

t_insert := false;

SELECT entity_class INTO t_entity_class FROM entity_credit_account 
  WHERE id = in_credit_id;

IF t_entity_class = 1 THEN -- VENDOR
    UPDATE partsvendor
       SET lastcost = in_price,
           leadtime = in_lead_time,
           partnumber = in_partnumber,
           curr = in_curr
     WHERE credit_id = in_credit_id AND entry_id = in_entry_id;

    IF NOT FOUND THEN
        INSERT INTO partsvendor
               (parts_id, credit_id, lastcost, leadtime, partnumber, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_leadtime::int2, 
               in_partnumber, in_curr);
    END IF;

    SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
           pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
           pv.entry_id
      INTO retval
      FROM partsvendor pv
      JOIN parts p ON p.id = pv.parts_id
     WHERE parts_id = in_parts_id and credit_id = in_credit_id;

    RETURN retval;

ELSIF t_entity_class = 2 THEN -- CUSTOMER
    UPDATE partscustomer
       SET pricebreak = in_pricebreak,
           sellprice  = in_price,
           validfrom  = in_validfrom,
           validto    = in_validto,
           curr       = in_curr
     WHERE entry_id = in_entry_id and credit_id = in_credit_id;

    IF NOT FOUND THEN
        INSERT INTO partscustomer
               (parts_id, credit_id, sellprice, validfrom, validto, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_validfrom, in_validto, 
                in_curr);

        t_insert := true;
    END IF;

    SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, 
           pc.pricebreak, pc.sellprice, NULL, NULL, NULL, pc.validfrom, 
           pc.validto, pc.curr, pc.entry_id
      INTO retval
      FROM partscustomer pc
      JOIN parts p on pc.parts_id = p.id
     WHERE entry_id = CASE WHEN t_insert 
                           THEN currval(&#39;partscustomer_entry_id_seq&#39;) 
                           ELSE in_entry_id 
                      END;
                           
    RETURN retval;

ELSE

RAISE EXCEPTION &#39;No valid entity credit account found&#39;;

END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function project_list_open(in_date date) -->
    <section id="lsmb13.function.project-list-open-in-date-date"
             xreflabel="lsmb13project_list_open(in_date date)">
      <title id="lsmb13.function.project-list-open-in-date-date-title">
       project_list_open(in_date date)
      </title>
      <titleabbrev id="lsmb13.function.project-list-open-in-date-date-titleabbrev">
       project_list_open(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF project</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns all projects that were open as on the date provided as
the argument.
        <programlisting>
DECLARE out_project project%ROWTYPE;
BEGIN
	FOR out_project IN
		SELECT * from project
		WHERE startdate &lt;= in_date AND enddate &gt;= in_date
		      AND completed = 0
	LOOP
		return next out_project;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function prsd_end(internal) -->
    <section id="lsmb13.function.prsd-end-internal"
             xreflabel="lsmb13prsd_end(internal)">
      <title id="lsmb13.function.prsd-end-internal-title">
       prsd_end(internal)
      </title>
      <titleabbrev id="lsmb13.function.prsd-end-internal-titleabbrev">
       prsd_end(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_prsd_end</programlisting>
      </para>
    </section>

<!-- Function prsd_getlexeme(internal, internal, internal) -->
    <section id="lsmb13.function.prsd-getlexeme-internal-internal-internal"
             xreflabel="lsmb13prsd_getlexeme(internal, internal, internal)">
      <title id="lsmb13.function.prsd-getlexeme-internal-internal-internal-title">
       prsd_getlexeme(internal, internal, internal)
      </title>
      <titleabbrev id="lsmb13.function.prsd-getlexeme-internal-internal-internal-titleabbrev">
       prsd_getlexeme(internal, internal, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_prsd_getlexeme</programlisting>
      </para>
    </section>

<!-- Function prsd_headline(internal, internal, internal) -->
    <section id="lsmb13.function.prsd-headline-internal-internal-internal"
             xreflabel="lsmb13prsd_headline(internal, internal, internal)">
      <title id="lsmb13.function.prsd-headline-internal-internal-internal-title">
       prsd_headline(internal, internal, internal)
      </title>
      <titleabbrev id="lsmb13.function.prsd-headline-internal-internal-internal-titleabbrev">
       prsd_headline(internal, internal, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_prsd_headline</programlisting>
      </para>
    </section>

<!-- Function prsd_lextype(internal) -->
    <section id="lsmb13.function.prsd-lextype-internal"
             xreflabel="lsmb13prsd_lextype(internal)">
      <title id="lsmb13.function.prsd-lextype-internal-title">
       prsd_lextype(internal)
      </title>
      <titleabbrev id="lsmb13.function.prsd-lextype-internal-titleabbrev">
       prsd_lextype(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_prsd_lextype</programlisting>
      </para>
    </section>

<!-- Function prsd_start(internal, integer) -->
    <section id="lsmb13.function.prsd-start-internal-integer"
             xreflabel="lsmb13prsd_start(internal, integer)">
      <title id="lsmb13.function.prsd-start-internal-integer-title">
       prsd_start(internal, integer)
      </title>
      <titleabbrev id="lsmb13.function.prsd-start-internal-integer-titleabbrev">
       prsd_start(internal, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_prsd_start</programlisting>
      </para>
    </section>

<!-- Function querytree(tsquery) -->
    <section id="lsmb13.function.querytree-tsquery"
             xreflabel="lsmb13querytree(tsquery)">
      <title id="lsmb13.function.querytree-tsquery-title">
       querytree(tsquery)
      </title>
      <titleabbrev id="lsmb13.function.querytree-tsquery-titleabbrev">
       querytree(tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquerytree</programlisting>
      </para>
    </section>

<!-- Function rank(real[], tsvector, tsquery) -->
    <section id="lsmb13.function.rank-realARRAY-tsvector-tsquery"
             xreflabel="lsmb13rank(real[], tsvector, tsquery)">
      <title id="lsmb13.function.rank-realARRAY-tsvector-tsquery-title">
       rank(real[], tsvector, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.rank-realARRAY-tsvector-tsquery-titleabbrev">
       rank(real[], tsvector, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rank_wtt</programlisting>
      </para>
    </section>

<!-- Function rank(real[], tsvector, tsquery, integer) -->
    <section id="lsmb13.function.rank-realARRAY-tsvector-tsquery-integer"
             xreflabel="lsmb13rank(real[], tsvector, tsquery, integer)">
      <title id="lsmb13.function.rank-realARRAY-tsvector-tsquery-integer-title">
       rank(real[], tsvector, tsquery, integer)
      </title>
      <titleabbrev id="lsmb13.function.rank-realARRAY-tsvector-tsquery-integer-titleabbrev">
       rank(real[], tsvector, tsquery, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rank_wttf</programlisting>
      </para>
    </section>

<!-- Function rank(tsvector, tsquery) -->
    <section id="lsmb13.function.rank-tsvector-tsquery"
             xreflabel="lsmb13rank(tsvector, tsquery)">
      <title id="lsmb13.function.rank-tsvector-tsquery-title">
       rank(tsvector, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.rank-tsvector-tsquery-titleabbrev">
       rank(tsvector, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rank_tt</programlisting>
      </para>
    </section>

<!-- Function rank(tsvector, tsquery, integer) -->
    <section id="lsmb13.function.rank-tsvector-tsquery-integer"
             xreflabel="lsmb13rank(tsvector, tsquery, integer)">
      <title id="lsmb13.function.rank-tsvector-tsquery-integer-title">
       rank(tsvector, tsquery, integer)
      </title>
      <titleabbrev id="lsmb13.function.rank-tsvector-tsquery-integer-titleabbrev">
       rank(tsvector, tsquery, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rank_ttf</programlisting>
      </para>
    </section>

<!-- Function rank_cd(real[], tsvector, tsquery) -->
    <section id="lsmb13.function.rank-cd-realARRAY-tsvector-tsquery"
             xreflabel="lsmb13rank_cd(real[], tsvector, tsquery)">
      <title id="lsmb13.function.rank-cd-realARRAY-tsvector-tsquery-title">
       rank_cd(real[], tsvector, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.rank-cd-realARRAY-tsvector-tsquery-titleabbrev">
       rank_cd(real[], tsvector, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rankcd_wtt</programlisting>
      </para>
    </section>

<!-- Function rank_cd(real[], tsvector, tsquery, integer) -->
    <section id="lsmb13.function.rank-cd-realARRAY-tsvector-tsquery-integer"
             xreflabel="lsmb13rank_cd(real[], tsvector, tsquery, integer)">
      <title id="lsmb13.function.rank-cd-realARRAY-tsvector-tsquery-integer-title">
       rank_cd(real[], tsvector, tsquery, integer)
      </title>
      <titleabbrev id="lsmb13.function.rank-cd-realARRAY-tsvector-tsquery-integer-titleabbrev">
       rank_cd(real[], tsvector, tsquery, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rankcd_wttf</programlisting>
      </para>
    </section>

<!-- Function rank_cd(tsvector, tsquery) -->
    <section id="lsmb13.function.rank-cd-tsvector-tsquery"
             xreflabel="lsmb13rank_cd(tsvector, tsquery)">
      <title id="lsmb13.function.rank-cd-tsvector-tsquery-title">
       rank_cd(tsvector, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.rank-cd-tsvector-tsquery-titleabbrev">
       rank_cd(tsvector, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rankcd_tt</programlisting>
      </para>
    </section>

<!-- Function rank_cd(tsvector, tsquery, integer) -->
    <section id="lsmb13.function.rank-cd-tsvector-tsquery-integer"
             xreflabel="lsmb13rank_cd(tsvector, tsquery, integer)">
      <title id="lsmb13.function.rank-cd-tsvector-tsquery-integer-title">
       rank_cd(tsvector, tsquery, integer)
      </title>
      <titleabbrev id="lsmb13.function.rank-cd-tsvector-tsquery-integer-titleabbrev">
       rank_cd(tsvector, tsquery, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_rankcd_ttf</programlisting>
      </para>
    </section>

<!-- Function reconciliation__account_list() -->
    <section id="lsmb13.function.reconciliation-account-list"
             xreflabel="lsmb13reconciliation__account_list()">
      <title id="lsmb13.function.reconciliation-account-list-title">
       reconciliation__account_list()
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-account-list-titleabbrev">
       reconciliation__account_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF recon_accounts</seg>
        </seglistitem>
       </segmentedlist>
 
        returns set of accounts set up for reconciliation.  Currently we pull the 
account number and description from the account table.
        <programlisting>
    SELECT
        coa.accno || &#39; &#39; || coa.description as name,
        coa.accno, coa.id as id
    FROM account coa
         JOIN cr_coa_to_account cta ON cta.chart_id = coa.id
    ORDER BY coa.accno;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric) -->
    <section id="lsmb13.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric"
             xreflabel="lsmb13reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)">
      <title id="lsmb13.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric-title">
       reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric-titleabbrev">
       reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        
This function is used for automatically matching entries from an external source
like a bank-produced csv file.

This function is very sensitive to ordering of inputs.  NULL or empty in_scn values MUST be submitted after meaningful scns.  It is also highly recommended 
that within each category, one submits in order of amount.  We should therefore
wrap it in another function which can operate on a set, perhaps in 1.4....
        <programlisting>
    
    DECLARE
	in_account int;
        la RECORD;
        t_errorcode INT;
        our_value NUMERIC;
        lid INT;
	in_count int;
	t_scn TEXT;
	t_uid int;
	t_prefix text;
        t_amount numeric;
    BEGIN
        SELECT CASE WHEN a.category in (&#39;A&#39;, &#39;E&#39;) THEN in_amount * -1
                    ELSE in_amount
               END into t_amount
          FROM cr_report r JOIN account a ON r.chart_id = a.id
         WHERE r.id = in_report_id; 

	SELECT value into t_prefix FROM defaults WHERE setting_key = &#39;check_prefix&#39;;

	t_uid := person__get_my_entity_id();
	IF in_scn = &#39;&#39; THEN 
		t_scn := NULL;
	ELSE 
		t_scn := t_prefix || in_scn;
	END IF;
	IF t_scn IS NOT NULL THEN
                -- could this be changed to update, if not found insert?
		SELECT count(*) INTO in_count FROM cr_report_line
		WHERE scn ilike t_scn AND report_id = in_report_id 
			AND their_balance = 0;

		IF in_count = 0 THEN
			INSERT INTO cr_report_line
			(report_id, scn, their_balance, our_balance, clear_time,
				&quot;user&quot;, trans_type)
			VALUES 
			(in_report_id, t_scn, t_amount, 0, in_date, t_uid,
				in_type);
		ELSIF in_count = 1 THEN
			UPDATE cr_report_line
			SET their_balance = t_amount, clear_time = in_date,
				cleared = true
			WHERE t_scn = scn AND report_id = in_report_id
				AND their_balance = 0;
		ELSE 
			SELECT count(*) INTO in_count FROM cr_report_line
			WHERE t_scn ilike scn AND report_id = in_report_id
				AND our_value = t_amount and their_balance = 0;

			IF in_count = 0 THEN -- no match among many of values
				SELECT id INTO lid FROM cr_report_line
                        	WHERE t_scn ilike scn AND report_id = in_report_id
				ORDER BY our_balance ASC limit 1;

				UPDATE cr_report_line
                                SET their_balance = t_amount, 
					clear_time = in_date,
					trans_type = in_type,
					cleared = true
                                WHERE id = lid;

			ELSIF in_count = 1 THEN -- EXECT MATCH
				UPDATE cr_report_line
				SET their_balance = t_amount, 
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
				WHERE t_scn = scn AND report_id = in_report_id
                                	AND our_value = t_amount 
					AND their_balance = 0;
			ELSE -- More than one match
				SELECT id INTO lid FROM cr_report_line
                        	WHERE t_scn ilike scn AND report_id = in_report_id
                                	AND our_value = t_amount
				ORDER BY id ASC limit 1;

				UPDATE cr_report_line
                                SET their_balance = t_amount,
					trans_type = in_type,
					cleared = true,
					clear_time = in_date
                                WHERE id = lid;
				
			END IF;
		END IF;
	ELSE -- scn IS NULL, check on amount instead
		SELECT count(*) INTO in_count FROM cr_report_line
		WHERE report_id = in_report_id AND our_balance = t_amount
			AND their_balance = 0 and post_date = in_date
			and scn NOT LIKE t_prefix || &#39;%&#39;;

		IF in_count = 0 THEN -- no match
			INSERT INTO cr_report_line
			(report_id, scn, their_balance, our_balance, clear_time,
			&quot;user&quot;, trans_type)
			VALUES 
			(in_report_id, t_scn, t_amount, 0, in_date, t_uid,
			in_type);
		ELSIF in_count = 1 THEN -- perfect match
			UPDATE cr_report_line SET their_balance = t_amount,
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
			WHERE report_id = in_report_id AND our_balance = t_amount
                        	AND their_balance = 0 and
				in_scn NOT LIKE t_prefix || &#39;%&#39;;
		ELSE -- more than one match
			SELECT min(id) INTO lid FROM cr_report_line
			WHERE report_id = in_report_id AND our_balance = t_amount
                        	AND their_balance = 0 and post_date = in_date
				AND scn NOT LIKE t_prefix || &#39;%&#39;
			LIMIT 1;

			UPDATE cr_report_line SET their_balance = t_amount,
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
			WHERE id = lid;
			
		END IF;
	END IF;
        return 1; 
        
    END;    
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_my_report(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-delete-my-report-in-report-id-integer"
             xreflabel="lsmb13reconciliation__delete_my_report(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-delete-my-report-in-report-id-integer-title">
       reconciliation__delete_my_report(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-delete-my-report-in-report-id-integer-titleabbrev">
       reconciliation__delete_my_report(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       This function allows a user to delete his or her own unsubmitted, unapproved
reconciliation reports only.  This is designed to allow a user to back out of
the reconciliation process without cluttering up the search results for others.

        <programlisting>
BEGIN
    DELETE FROM cr_report_line
     WHERE report_id = in_report_id
           AND report_id IN (SELECT id FROM cr_report
                              WHERE entered_username = SESSION_USER
                                    AND submitted IS NOT TRUE
                                    and approved IS NOT TRUE);
    DELETE FROM cr_report
     WHERE id = in_report_id AND entered_username = SESSION_USER
           AND submitted IS NOT TRUE AND approved IS NOT TRUE;
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_report(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-delete-report-in-report-id-integer"
             xreflabel="lsmb13reconciliation__delete_report(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-delete-report-in-report-id-integer-title">
       reconciliation__delete_report(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-delete-report-in-report-id-integer-titleabbrev">
       reconciliation__delete_report(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Deletes the report if the report exists and is unapproved.

Note this does not actually delete anything from the database.  Deleted reports
are kept around in case they need to be investigated.  It only marks them as 
deleted so that they can never be approved.
        <programlisting>
    DECLARE
    BEGIN
        PERFORM id FROM cr_report WHERE id = in_report_id;
        
        IF NOT FOUND THEN
            RAISE NOTICE &#39;reconciliation__delete_report(): Cannot find specified report.&#39;;
            return FOUND;
        END IF;
        
        -- We found the entry. Update it.
        
        PERFORM id FROM cr_report WHERE id = in_report_id AND approved = TRUE;
        
        IF FOUND THEN --changing the verbose message to a notice and adding a
                      --program-helpful exception --CT
            RAISE NOTICE &#39;reconcilation__delete_report(): report % is approved; cannot delete.&#39;, in_report_id;
            RAISE EXCEPTION &#39;Cannot delete approved&#39;;
        END IF;
        
        PERFORM id 
           FROM cr_report 
          WHERE id = in_report_id 
            AND submitted = TRUE
            AND entered_by = person__get_my_entity_id();
        
        -- IF FOUND THEN
            -- Creators cannot delete their own reports if they&#39;ve been submitted. -AS
            -- Why not?  If it hasn&#39;t been approved.....  
            -- Also concerned about single-user setups here so commenting out
            -- this block --CT
            -- RAISE EXCEPTION &#39;reconciliation__delete_report(): creators cannot delete their own report after submission. %&#39;, in_report_id;
        -- END IF;
        
        UPDATE cr_report
           SET deleted = TRUE,
               deleted_by = person__get_my_entity_id()
         WHERE id = in_report_id;
         
        return TRUE;
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_unapproved(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-delete-unapproved-in-report-id-integer"
             xreflabel="lsmb13reconciliation__delete_unapproved(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-delete-unapproved-in-report-id-integer-title">
       reconciliation__delete_unapproved(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-delete-unapproved-in-report-id-integer-titleabbrev">
       reconciliation__delete_unapproved(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       This function deletes any specified unapproved transaction.
        <programlisting>
BEGIN
    DELETE FROM cr_report_line
     WHERE report_id = in_report_id
           AND report_id IN (SELECT id FROM cr_report
                              WHERE approved IS NOT TRUE);
    DELETE FROM cr_report
     WHERE id = in_report_id AND approved IS NOT TRUE;
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_cleared_balance(in_chart_id integer) -->
    <section id="lsmb13.function.reconciliation-get-cleared-balance-in-chart-id-integer"
             xreflabel="lsmb13reconciliation__get_cleared_balance(in_chart_id integer)">
      <title id="lsmb13.function.reconciliation-get-cleared-balance-in-chart-id-integer-title">
       reconciliation__get_cleared_balance(in_chart_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-get-cleared-balance-in-chart-id-integer-titleabbrev">
       reconciliation__get_cleared_balance(in_chart_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets the cleared balance of the account specified by chart_id.
This is specified in normal format (i.e. positive numbers for debits for asset
and espense accounts, and positive numbers for credits in other accounts 

Note that currently contra accounts will show negative balances.
        <programlisting>
	select CASE WHEN c.category in(&#39;A&#39;, &#39;E&#39;) THEN sum(ac.amount) * -1 ELSE
		sum(ac.amount) END
	FROM account c
	JOIN acc_trans ac ON (ac.chart_id = c.id)
	JOIN (select id from ar where approved
		union
		select id from ap where approved
		union
		select id from gl where approved) g on (g.id = ac.trans_id)
	WHERE c.id = $1 AND ac.cleared is true and ac.approved is true
		GROUP BY c.id, c.category;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_current_balance(in_date integer, in_account_id date) -->
    <section id="lsmb13.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date"
             xreflabel="lsmb13reconciliation__get_current_balance(in_date integer, in_account_id date)">
      <title id="lsmb13.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date-title">
       reconciliation__get_current_balance(in_date integer, in_account_id date)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date-titleabbrev">
       reconciliation__get_current_balance(in_date integer, in_account_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets the current balance of all approved transactions against a specific 
account.  For asset and expense accounts this is the debit balance, for others
this is the credit balance.
        <programlisting>
DECLARE outval NUMERIC;
BEGIN
	SELECT CASE WHEN (select category FROM account WHERE id = in_account_id)
			IN (&#39;A&#39;, &#39;E&#39;) THEN sum(a.amount) * -1
		ELSE sum(a.amount) END
	FROM acc_trans a
	JOIN (
		SELECT id FROM ar
		WHERE approved is true
		UNION
		SELECT id FROM ap
		WHERE approved is true
		UNION
		SELECT id FROM gl
		WHERE approved is true
	) gl ON a.trans_id = gl.id
	WHERE a.approved IS TRUE 
		AND a.chart_id = in_account_id
		AND a.transdate &lt;= in_date;

	RETURN outval;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_total(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-get-total-in-report-id-integer"
             xreflabel="lsmb13reconciliation__get_total(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-get-total-in-report-id-integer-title">
       reconciliation__get_total(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-get-total-in-report-id-integer-titleabbrev">
       reconciliation__get_total(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves all header info from the reconciliation report.
        <programlisting>

    DECLARE
        row cr_report;
    BEGIN
    
        SELECT * INTO row FROM cr_report 
        where id = in_report_id 
        AND scn = -1;
        
        IF NOT FOUND THEN -- I think this is a fairly major error condition
            RAISE EXCEPTION &#39;Bad report id.&#39;;
        ELSE
            return next row;
        END IF;
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__new_report_id(in_end_date integer, in_total numeric, in_chart_id date) -->
    <section id="lsmb13.function.reconciliation-new-report-id-in-end-date-integer-in-total-numeric-in-chart-id-date"
             xreflabel="lsmb13reconciliation__new_report_id(in_end_date integer, in_total numeric, in_chart_id date)">
      <title id="lsmb13.function.reconciliation-new-report-id-in-end-date-integer-in-total-numeric-in-chart-id-date-title">
       reconciliation__new_report_id(in_end_date integer, in_total numeric, in_chart_id date)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-new-report-id-in-end-date-integer-in-total-numeric-in-chart-id-date-titleabbrev">
       reconciliation__new_report_id(in_end_date integer, in_total numeric, in_chart_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts creates a new report and returns the id.
        <programlisting>

    INSERT INTO cr_report(chart_id, their_total, end_date) values ($1, $2, $3);
    SELECT currval(&#39;cr_report_id_seq&#39;)::int;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean) -->
    <section id="lsmb13.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean"
             xreflabel="lsmb13reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)">
      <title id="lsmb13.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean-title">
       reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean-titleabbrev">
       reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts creates a new report and returns the id.
        <programlisting>

    INSERT INTO cr_report(chart_id, their_total, end_date, recon_fx) 
    values ($1, $2, $3, $4);
    SELECT currval(&#39;cr_report_id_seq&#39;)::int;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__pending_transactions(in_recon_fx date, in_their_total integer, in_report_id integer, in_chart_id numeric, in_end_date boolean) -->
    <section id="lsmb13.function.reconciliation-pending-transactions-in-recon-fx-date-in-their-total-integer-in-report-id-integer-in-chart-id-numeric-in-end-date-boolean"
             xreflabel="lsmb13reconciliation__pending_transactions(in_recon_fx date, in_their_total integer, in_report_id integer, in_chart_id numeric, in_end_date boolean)">
      <title id="lsmb13.function.reconciliation-pending-transactions-in-recon-fx-date-in-their-total-integer-in-report-id-integer-in-chart-id-numeric-in-end-date-boolean-title">
       reconciliation__pending_transactions(in_recon_fx date, in_their_total integer, in_report_id integer, in_chart_id numeric, in_end_date boolean)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-pending-transactions-in-recon-fx-date-in-their-total-integer-in-report-id-integer-in-chart-id-numeric-in-end-date-boolean-titleabbrev">
       reconciliation__pending_transactions(in_recon_fx date, in_their_total integer, in_report_id integer, in_chart_id numeric, in_end_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Ensures that the list of pending transactions in the report is up to date. 
        <programlisting>
    
    DECLARE
        gl_row RECORD;
    BEGIN
		INSERT INTO cr_report_line (report_id, scn, their_balance, 
			our_balance, &quot;user&quot;, voucher_id, ledger_id, post_date)
		SELECT in_report_id, 
		       COALESCE(ac.source, gl.ref),
		       0, 
		       sum(amount / CASE WHEN gl.table = &#39;gl&#39; THEN 1
                                         WHEN gl.table = &#39;ap&#39; THEN ex.sell
                                         WHEN gl.table = &#39;ar&#39; THEN ex.buy
                                    END) AS amount,
				(select entity_id from users 
				where username = CURRENT_USER),
			ac.voucher_id, min(ac.entry_id), ac.transdate
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, curr, 
                             transdate, &#39;ar&#39; as table 
                        FROM ar where approved
			UNION
		      select id, entity_credit_account::text, curr, 
                             transdate, &#39;ap&#39; as table 
                        FROM ap WHERE approved
			UNION
		      select id, reference, &#39;&#39;, 
                             transdate, &#39;gl&#39; as table 
                        FROM gl WHERE approved) gl 
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)))
                LEFT JOIN exchangerate ex ON gl.transdate = ex.transdate
		WHERE ac.cleared IS FALSE
			AND ac.approved IS TRUE
			AND ac.chart_id = in_chart_id
			AND ac.transdate &lt;= in_end_date
                        AND ((in_recon_fx is not true 
                                and ac.fx_transaction is not true) 
                            OR (in_recon_fx is true 
                                AND (gl.table &lt;&gt; &#39;gl&#39; OR ac.fx_transaction
                                                      IS TRUE))) 
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table
		HAVING count(rl.id) = 0;

		UPDATE cr_report set updated = now(),
			their_total = coalesce(in_their_total, their_total)
		where id = in_report_id;
    RETURN in_report_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric) -->
    <section id="lsmb13.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric"
             xreflabel="lsmb13reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)">
      <title id="lsmb13.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric-title">
       reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric-titleabbrev">
       reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Ensures that the list of pending transactions in the report is up to date. 
        <programlisting>
    
    DECLARE
        gl_row RECORD;
        t_recon_fx BOOL;
    BEGIN
                SELECT recon_fx INTO t_recon_fx FROM cr_report WHERE id = in_report_id;
 
		INSERT INTO cr_report_line (report_id, scn, their_balance, 
			our_balance, &quot;user&quot;, voucher_id, ledger_id, post_date)
		SELECT in_report_id, 
		       CASE WHEN ac.source IS NULL OR ac.source = &#39;&#39; 
                            THEN gl.ref
                            ELSE ac.source END,
		       0, 
		       sum(amount / CASE WHEN t_recon_fx IS NOT TRUE OR gl.table = &#39;gl&#39;
                                         THEN 1
                                         WHEN t_recon_fx and gl.table = &#39;ap&#39; 
                                         THEN ex.sell
                                         WHEN t_recon_fx and gl.table = &#39;ar&#39; 
                                         THEN ex.buy
                                    END) AS amount,
				(select entity_id from users 
				where username = CURRENT_USER),
			ac.voucher_id, min(ac.entry_id), ac.transdate
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, curr, 
                             transdate, &#39;ar&#39; as table 
                        FROM ar where approved
			UNION
		      select id, entity_credit_account::text, curr, 
                             transdate, &#39;ap&#39; as table 
                        FROM ap WHERE approved
			UNION
		      select id, reference, &#39;&#39;, 
                             transdate, &#39;gl&#39; as table 
                        FROM gl WHERE approved) gl 
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)))
                LEFT JOIN exchangerate ex ON gl.transdate = ex.transdate
		WHERE ac.cleared IS FALSE
			AND ac.approved IS TRUE
			AND ac.chart_id = in_chart_id
			AND ac.transdate &lt;= in_end_date
                        AND ((t_recon_fx is not true 
                                and ac.fx_transaction is not true) 
                            OR (t_recon_fx is true 
                                AND (gl.table &lt;&gt; &#39;gl&#39; OR ac.fx_transaction
                                                      IS TRUE))) 
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table, 
                        case when gl.table = &#39;gl&#39; then gl.id else 1 end
		HAVING count(rl.id) = 0;

		UPDATE cr_report set updated = now(),
			their_total = coalesce(in_their_total, their_total)
		where id = in_report_id;
    RETURN in_report_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_approve(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-report-approve-in-report-id-integer"
             xreflabel="lsmb13reconciliation__report_approve(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-report-approve-in-report-id-integer-title">
       reconciliation__report_approve(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-report-approve-in-report-id-integer-titleabbrev">
       reconciliation__report_approve(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Marks the report approved and marks all cleared transactions in it cleared.
        <programlisting>
    
    -- Does some basic checks before allowing the approval to go through; 
    -- moves the approval to &quot;cr_report_line&quot;, I guess, or some other &quot;final&quot; table.
    --
    -- Pending may just be a single flag in the database to mark that it is
    -- not finalized. Will need to discuss with Chris.
    
    DECLARE
        current_row RECORD;
        completed cr_report_line;
        total_errors INT;
        in_user TEXT;
	ac_entries int[];
    BEGIN
        in_user := current_user;
        
        -- so far, so good. Different user, and no errors remain. Therefore, 
        -- we can move it to completed reports.
        --
        -- User may not be necessary - I would think it better to use the 
        -- in_user, to note who approved the report, than the user who
        -- filed it. This may require clunkier syntax..
        
        -- 
	ac_entries := &#39;{}&#39;;
        update cr_report set approved = &#39;t&#39;,
		approved_by = person__get_my_entity_id(),
		approved_username = SESSION_USER
	where id = in_report_id;

	FOR current_row IN 
		SELECT compound_array(entries) AS entries FROM (
			select as_array(ac.entry_id) as entries
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, &#39;ar&#39; as table FROM ar
			UNION
		      select id, entity_credit_account::text, &#39;ap&#39; as table FROM ap
			UNION
		      select id, reference, &#39;gl&#39; as table FROM gl) gl
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)) and rl.cleared is true)
		WHERE ac.cleared IS FALSE
			AND ac.chart_id = (select chart_id from cr_report where id = in_report_id)
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table
		HAVING count(rl.report_id) &gt; 0) a
	LOOP
		ac_entries := ac_entries || current_row.entries;
	END LOOP;

	UPDATE acc_trans SET cleared = TRUE 
	where entry_id = any(ac_entries);
        
        return 1;        
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_details(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-report-details-in-report-id-integer"
             xreflabel="lsmb13reconciliation__report_details(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-report-details-in-report-id-integer-title">
       reconciliation__report_details(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-report-details-in-report-id-integer-titleabbrev">
       reconciliation__report_details(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the details of the report. 
        <programlisting>

    DECLARE
        row cr_report_line;
    BEGIN    
        FOR row IN 
		select * from cr_report_line where report_id = in_report_id 
		order by scn, post_date
	LOOP
        
            RETURN NEXT row;
        
        END LOOP;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_details_payee(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-report-details-payee-in-report-id-integer"
             xreflabel="lsmb13reconciliation__report_details_payee(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-report-details-payee-in-report-id-integer-title">
       reconciliation__report_details_payee(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-report-details-payee-in-report-id-integer-titleabbrev">
       reconciliation__report_details_payee(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF recon_payee</seg>
        </seglistitem>
       </segmentedlist>
 
        Pulls the payee information for the reconciliation report.
        <programlisting>
   DECLARE
        row recon_payee;
    BEGIN    
        FOR row IN 
        	select * from recon_payee where report_id = in_report_id 
        	order by scn, post_date
        LOOP
          RETURN NEXT row;
        END LOOP;    
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_summary(in_report_id integer) -->
    <section id="lsmb13.function.reconciliation-report-summary-in-report-id-integer"
             xreflabel="lsmb13reconciliation__report_summary(in_report_id integer)">
      <title id="lsmb13.function.reconciliation-report-summary-in-report-id-integer-title">
       reconciliation__report_summary(in_report_id integer)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-report-summary-in-report-id-integer-titleabbrev">
       reconciliation__report_summary(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

    DECLARE
        row cr_report;
    BEGIN    
        select * into row from cr_report where id = in_report_id;
        
        RETURN row;
        
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__save_set(in_line_ids integer, in_report_id integer[]) -->
    <section id="lsmb13.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY"
             xreflabel="lsmb13reconciliation__save_set(in_line_ids integer, in_report_id integer[])">
      <title id="lsmb13.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY-title">
       reconciliation__save_set(in_line_ids integer, in_report_id integer[])
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY-titleabbrev">
       reconciliation__save_set(in_line_ids integer, in_report_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Sets which lines of the report are cleared.
        <programlisting>
BEGIN
	UPDATE cr_report_line SET cleared = false
	WHERE report_id = in_report_id;

	UPDATE cr_report_line SET cleared = true
	WHERE report_id = in_report_id AND id = ANY(in_line_ids);
	RETURN found;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean) -->
    <section id="lsmb13.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean"
             xreflabel="lsmb13reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)">
      <title id="lsmb13.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean-title">
       reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean-titleabbrev">
       reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for reconciliation reports.
NULLs match all values.
in_date_to and in_date_from give a range of reports.  All other inputs are
exact matches.

        <programlisting>
DECLARE report cr_report;
BEGIN
	FOR report IN
		SELECT r.* FROM cr_report r
		JOIN account c ON (r.chart_id = c.id)
		WHERE 
			(in_date_from IS NULL OR in_date_from &lt;= end_date) and
			(in_date_to IS NULL OR in_date_to &gt;= end_date) AND
			(in_balance_from IS NULL 
				or in_balance_from &lt;= their_total ) AND
			(in_balance_to IS NULL 
				OR in_balance_to &gt;= their_total) AND
			(in_chart_id IS NULL OR in_chart_id = chart_id) AND
			(in_submitted IS NULL or in_submitted = submitted) AND
			(in_approved IS NULL OR in_approved = approved) AND
			(r.deleted IS FALSE)
		ORDER BY c.accno, end_date, their_total
	LOOP
		RETURN NEXT report;
	END LOOP; 
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__submit_set(in_line_ids integer, in_report_id integer[]) -->
    <section id="lsmb13.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY"
             xreflabel="lsmb13reconciliation__submit_set(in_line_ids integer, in_report_id integer[])">
      <title id="lsmb13.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY-title">
       reconciliation__submit_set(in_line_ids integer, in_report_id integer[])
      </title>
      <titleabbrev id="lsmb13.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY-titleabbrev">
       reconciliation__submit_set(in_line_ids integer, in_report_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Submits a reconciliation report for approval. 
in_line_ids is used to specify which report lines are cleared, finalizing the
report.
        <programlisting>
BEGIN
	UPDATE cr_report set submitted = true where id = in_report_id;
	PERFORM reconciliation__save_set(in_report_id, in_line_ids);

	RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text) -->
    <section id="lsmb13.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text"
             xreflabel="lsmb13report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)">
      <title id="lsmb13.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text-title">
       report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)
      </title>
      <titleabbrev id="lsmb13.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text-titleabbrev">
       report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF cash_summary_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT a.id, a.accno, a.is_heading, a.description, t.label, 
       sum(CASE WHEN ac.amount &lt; 0 THEN ac.amount * -1 ELSE NULL END),
       sum(CASE WHEN ac.amount &gt; 0 THEN ac.amount ELSE NULL END)
  FROM (select id, accno, false as is_heading, description FROM account
       UNION
        SELECT id, accno, true, description FROM account_heading) a
  LEFT
  JOIN acc_trans ac ON ac.chart_id = a.id 
  LEFT
  JOIN (select id, case when table_name ilike &#39;ar&#39; THEN &#39;rcpt&#39;
                        when table_name ilike &#39;ap&#39; THEN &#39;pmt&#39;
                        when table_name ilike &#39;gl&#39; THEN &#39;xfer&#39;
                    END AS label
          FROM transactions) t ON t.id = ac.trans_id
 WHERE accno BETWEEN $3 AND $4
        and ac.transdate BETWEEN $1 AND $2
GROUP BY a.id, a.accno, a.is_heading, a.description, t.label
ORDER BY accno;

</programlisting>
      </para>
    </section>

<!-- Function report__coa() -->
    <section id="lsmb13.function.report-coa"
             xreflabel="lsmb13report__coa()">
      <title id="lsmb13.function.report-coa-title">
       report__coa()
      </title>
      <titleabbrev id="lsmb13.function.report-coa-titleabbrev">
       report__coa()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF coa_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

WITH ac (chart_id, amount) AS (
     SELECT chart_id, CASE WHEN acc_trans.approved and gl.approved THEN amount
                           ELSE 0 
                       END
       FROM acc_trans
       JOIN (select id, approved from ar union all
             select id, approved from ap union all
             select id, approved from gl) gl ON gl.id = acc_trans.trans_id
),
l(account_id, link) AS (
     SELECT account_id, array_to_string(array_agg(description), &#39;:&#39;)
       FROM account_link
   GROUP BY account_id
)
SELECT a.id, a.is_heading, a.accno, a.description, a.gifi_accno, 
       CASE WHEN sum(ac.amount) &lt; 0 THEN sum(amount) * -1 ELSE null::numeric
        END,
       CASE WHEN sum(ac.amount) &gt; 0 THEN sum(amount) ELSE null::numeric END,
       count(ac.*), l.link
  FROM (SELECT id,false as is_heading, accno, description, gifi_accno
          FROM account
         UNION
        SELECT id, true, accno, description, null::text 
          FROM account_heading) a

 LEFT JOIN ac ON ac.chart_id = a.id AND not a.is_heading
 LEFT JOIN l ON l.account_id = a.id AND NOT a.is_heading
  GROUP BY a.id, a.is_heading, a.accno, a.description, a.gifi_accno, l.link
  ORDER BY a.accno;

</programlisting>
      </para>
    </section>

<!-- Function report__general_balance(in_date_to date, in_date_from date) -->
    <section id="lsmb13.function.report-general-balance-in-date-to-date-in-date-from-date"
             xreflabel="lsmb13report__general_balance(in_date_to date, in_date_from date)">
      <title id="lsmb13.function.report-general-balance-in-date-to-date-in-date-from-date-title">
       report__general_balance(in_date_to date, in_date_from date)
      </title>
      <titleabbrev id="lsmb13.function.report-general-balance-in-date-to-date-in-date-from-date-titleabbrev">
       report__general_balance(in_date_to date, in_date_from date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF general_balance_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

SELECT a.id, a.accno, a.description,
      sum(CASE WHEN ac.transdate &lt; $1 THEN abs(amount) ELSE null END),
      sum(CASE WHEN ac.transdate &gt;= $1 AND ac.amount &lt; 0 
               THEN ac.amount * -1 ELSE null END),
      SUM(CASE WHEN ac.transdate &gt;= $1 AND ac.amount &gt; 0
               THEN ac.amount ELSE null END),
      SUM(ABS(ac.amount))
 FROM account a 
 LEFT
 JOIN acc_trans ac ON ac.chart_id = a.id
 LEFT 
 JOIN (select id, approved from ar UNION
       SELECT id, approved from ap UNION
       SELECT id, approved FROM gl) gl ON ac.trans_id = gl.id
WHERE gl.approved and ac.approved
      and ac.transdate &lt;= $2 
GROUP BY a.id, a.accno, a.description
ORDER BY a.accno;

</programlisting>
      </para>
    </section>

<!-- Function report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[]) -->
    <section id="lsmb13.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY"
             xreflabel="lsmb13report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])">
      <title id="lsmb13.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY-title">
       report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])
      </title>
      <titleabbrev id="lsmb13.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY-titleabbrev">
       report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF gl_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
         retval gl_report_item;
         t_balance numeric;
         t_chart_id int;
BEGIN

IF in_from_date IS NULL THEN
   t_balance := 0;
ELSIF in_accno IS NOT NULL THEN
   SELECT id INTO t_chart_id FROM account WHERE accno  = in_accno;
   t_balance := account__obtain_balance(in_from_date , 
                                       (select id from account 
                                         where accno = in_accno));
ELSE
   t_balance := null;
END IF;

FOR retval IN
       WITH RECURSIVE bu_tree (id, path) AS (
            SELECT id, id::text AS path
              FROM business_unit
             WHERE parent_id is null
            UNION
            SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id
              FROM business_unit bu
              JOIN bu_tree ON bu_tree.id = bu.parent_id
            )
       SELECT g.id, g.type, g.invoice, g.reference, g.description, ac.transdate,
              ac.source, ac.amount, c.accno, c.gifi_accno, 
              g.till, ac.cleared, ac.memo, c.description AS accname, 
              ac.chart_id, ac.entry_id, 
              sum(ac.amount) over (rows unbounded preceding) + t_balance 
                as running_balance,
              compound_array(ARRAY[ARRAY[bac.class_id, bac.bu_id]])
         FROM (select id, &#39;gl&#39; as type, false as invoice, reference, 
                      description, approved,
                      null::text as till 
                 FROM gl
               UNION
               SELECT ar.id, &#39;ar&#39;, invoice, invnumber, e.name, approved, till
                 FROM ar
                 JOIN entity_credit_account eca ON ar.entity_credit_account
                      = eca.id
                 JOIN entity e ON e.id = eca.entity_id
               UNION
               SELECT ap.id, &#39;ap&#39;, invoice, invnumber, e.name, approved,
                      null as till
                 FROM ap
                 JOIN entity_credit_account eca ON ap.entity_credit_account 
                      = eca.id
                 JOIN entity e ON e.id = eca.entity_id) g
         JOIN acc_trans ac ON ac.trans_id = g.id
         JOIN account c ON ac.chart_id = c.id
    LEFT JOIN business_unit_ac bac ON ac.entry_id = bac.entry_id 
    LEFT JOIN bu_tree ON bac.bu_id = bu_tree.id
        WHERE (g.reference ilike in_reference || &#39;%&#39; or in_reference is null)
              AND (c.accno = in_accno OR in_accno IS NULL)
              AND (ac.source ilike &#39;%&#39; || in_source || &#39;%&#39; 
                   OR in_source is null)
              AND (ac.memo ilike &#39;%&#39; || in_memo || &#39;%&#39; OR in_memo is null)
             AND (in_description IS NULL OR
                  g.description
                  @@
                  plainto_tsquery(get_default_lang()::regconfig, in_description))
              AND (transdate BETWEEN in_from_date AND in_to_date
                   OR (transdate &gt;= in_from_date AND  in_to_date IS NULL)
                   OR (transdate &lt;= in_to_date AND in_from_date IS NULL)
                   OR (in_to_date IS NULL AND in_from_date IS NULL))
              AND (in_approved is false OR (g.approved AND ac.approved))
              AND (in_from_amount IS NULL OR ac.amount &gt;= in_from_amount)
              AND (in_to_amount IS NULL OR ac.amount &lt;= in_to_amount)
              AND (in_category = c.category OR in_category IS NULL)
     GROUP BY g.id, g.type, g.invoice, g.reference, g.description, ac.transdate,
              ac.source, ac.amount, c.accno, c.gifi_accno,
              g.till, ac.cleared, ac.memo, c.description,
              ac.chart_id, ac.entry_id, ac.trans_id
       HAVING in_business_units is null or in_business_units 
                &lt;@ compound_array(string_to_array(bu_tree.path, &#39;,&#39;)::int[])
     ORDER BY ac.transdate, ac.trans_id, c.accno
LOOP
   RETURN NEXT retval;
END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean) -->
    <section id="lsmb13.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean"
             xreflabel="lsmb13report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)">
      <title id="lsmb13.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-title">
       report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-titleabbrev">
       report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF report_aging_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	item report_aging_item;
BEGIN
	FOR item IN
                  WITH RECURSIVE bu_tree (id, path) AS (
                SELECT id, id::text AS path
                  FROM business_unit
                 WHERE id = any(in_business_units)
                 UNION
                SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id
                  FROM business_unit bu
                  JOIN bu_tree ON bu_tree.id = bu.parent_id
                       )
		SELECT c.entity_id, c.meta_number, e.name,
		       e.name as contact_name, 
	               a.invnumber, a.transdate, a.till, a.ordnumber, 
		       a.ponumber, a.notes, 
		       CASE WHEN a.age/30 = 0
		                 THEN (a.sign * sum(ac.amount)) 
                            ELSE 0 END
		            as c0, 
		       CASE WHEN a.age/30 = 1
		                 THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c30, 
		       CASE WHEN a.age/30 = 2
		            THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c60, 
		       CASE WHEN a.age/30 &gt; 2
		            THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c90, 
		       a.duedate, a.id, a.curr,
		       COALESCE((SELECT sell FROM exchangerate ex
		         WHERE a.curr = ex.curr
		              AND ex.transdate = a.transdate), 1)
		       AS exchangerate,
			(SELECT compound_array(ARRAY[[p.partnumber,
					i.description, i.qty::text]])
				FROM parts p 
				JOIN invoice i ON (i.parts_id = p.id)
				WHERE i.trans_id = a.id) AS line_items,
                   (coalesce(in_to_date, now())::date - a.transdate) as age
		  FROM (select id, invnumber, till, ordnumber, amount, duedate,
                               curr, ponumber, notes, entity_credit_account,
                               -1 AS sign, transdate,
                               CASE WHEN in_use_duedate 
                                    THEN coalesce(in_to_date, now())::date
                                         - duedate
                                    ELSE coalesce(in_to_date, now())::date
                                         - transdate 
                               END as age
                          FROM ar
                         WHERE in_entity_class = 2
                         UNION 
                        SELECT id, invnumber, null, ordnumber, amount, duedate,
                               curr, ponumber, notes, entity_credit_account,
                               1 as sign, transdate,
                               CASE WHEN in_use_duedate 
                                    THEN coalesce(in_to_date, now())::date
                                         - duedate
                                    ELSE coalesce(in_to_date, now())::date
                                         - transdate 
                               END as age
                          FROM ap
                         WHERE in_entity_class = 1) a
                  JOIN acc_trans ac ON ac.trans_id = a.id
                  JOIN account acc ON ac.chart_id = acc.id
                  JOIN account_link acl ON acl.account_id = acc.id
                       AND ((in_entity_class = 1 
                              AND acl.description = &#39;AP&#39;)
                           OR (in_entity_class = 2
                              AND acl.description = &#39;AR&#39;))
		  JOIN entity_credit_account c 
                       ON a.entity_credit_account = c.id
		  JOIN entity e ON (e.id = c.entity_id)
             LEFT JOIN business_unit_ac buac ON ac.entry_id = buac.entry_id
             LEFT JOIN bu_tree ON buac.bu_id = bu_tree.id
	     LEFT JOIN entity_to_location e2l 
                       ON e.id = e2l.entity_id 
                       AND e2l.location_class = 3
             LEFT JOIN location l ON l.id = e2l.location_id
	     LEFT JOIN country ON (country.id = l.country_id)
                 WHERE (e.id = in_entity_id OR in_entity_id IS NULL)
                       AND (in_accno IS NULL or acc.accno = in_accno)
              GROUP BY c.entity_id, c.meta_number, e.name,
                       l.line_one, l.line_two, l.line_three,
                       l.city, l.state, l.mail_code, country.name,
                       a.invnumber, a.transdate, a.till, a.ordnumber,
                       a.ponumber, a.notes, a.amount, a.sign,
                       a.duedate, a.id, a.curr, a.age
                HAVING in_business_units is null or in_business_units 
                       &lt;@ compound_array(string_to_array(bu_tree.path, 
                                         &#39;,&#39;)::int[])
	      ORDER BY entity_id, curr, transdate, invnumber
	LOOP
		return next item;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean) -->
    <section id="lsmb13.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean"
             xreflabel="lsmb13report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)">
      <title id="lsmb13.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-title">
       report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-titleabbrev">
       report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF report_aging_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT entity_id, account_number, name, contact_name, null::text, null::date, 
       null::text, null::text, null::text, null::text, 
       sum(c0), sum(c30), sum(c60), sum(c90), null::date, null::int, curr,
       null::numeric, null::text[], null::int
  FROM report__invoice_aging_detail($1, $2, $3, $4, $5, $6)
 GROUP BY entity_id, account_number, name, contact_name, curr
 ORDER BY account_number
</programlisting>
      </para>
    </section>

<!-- Function report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean) -->
    <section id="lsmb13.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean"
             xreflabel="lsmb13report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)">
      <title id="lsmb13.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean-title">
       report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)
      </title>
      <titleabbrev id="lsmb13.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean-titleabbrev">
       report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF trial_balance_line</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a simple routine to generate trial balances for the full
company, for a project, or for a department.
        <programlisting>
DECLARE out_row trial_balance_line;
BEGIN
	IF in_department_id IS NULL THEN
		FOR out_row IN
			SELECT c.id, c.accno, c.description, 
				SUM(CASE WHEN ac.transdate &lt; in_datefrom 
				              AND c.category IN (&#39;I&#39;, &#39;L&#39;, &#39;Q&#39;)
				    THEN ac.amount
				    ELSE ac.amount * -1
				    END), 
			        SUM(CASE WHEN ac.transdate &gt;= in_date_from 
				              AND ac.amount &gt; 0 
			            THEN ac.amount
			            ELSE 0 END),
			        SUM(CASE WHEN ac.transdate &gt;= in_date_from 
				              AND ac.amount &lt; 0
			            THEN ac.amount
			            ELSE 0 END) * -1,
				SUM(CASE WHEN ac.transdate &gt;= in_date_from
					AND c.charttype IN (&#39;I&#39;)
				    THEN ac.amount
				    WHEN ac.transdate &gt;= in_date_from
				              AND c.category IN (&#39;I&#39;, &#39;L&#39;, &#39;Q&#39;)
				    THEN ac.amount
				    ELSE ac.amount * -1
				    END)
				FROM acc_trans ac
				JOIN (select id, approved FROM ap
					UNION ALL 
					select id, approved FROM gl
					UNION ALL
					select id, approved FROM ar) g
					ON (g.id = ac.trans_id)
				JOIN chart c ON (c.id = ac.chart_id)
				WHERE ac.transdate &lt;= in_date_to
					AND ac.approved AND g.approved
					AND (in_project_id IS NULL 
						OR in_project_id = ac.project_id)
				GROUP BY c.id, c.accno, c.description
				ORDER BY c.accno
				
		LOOP
			RETURN NEXT out_row;
		END LOOP;
	ELSE 
		FOR out_row IN
			SELECT 1
		LOOP
			RETURN NEXT out_row;
		END LOOP;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function reset_tsearch() -->
    <section id="lsmb13.function.reset-tsearch"
             xreflabel="lsmb13reset_tsearch()">
      <title id="lsmb13.function.reset-tsearch-title">
       reset_tsearch()
      </title>
      <titleabbrev id="lsmb13.function.reset-tsearch-titleabbrev">
       reset_tsearch()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_reset_tsearch</programlisting>
      </para>
    </section>

<!-- Function rewrite(tsquery, text) -->
    <section id="lsmb13.function.rewrite-tsquery-text"
             xreflabel="lsmb13rewrite(tsquery, text)">
      <title id="lsmb13.function.rewrite-tsquery-text-title">
       rewrite(tsquery, text)
      </title>
      <titleabbrev id="lsmb13.function.rewrite-tsquery-text-titleabbrev">
       rewrite(tsquery, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquery_rewrite_query</programlisting>
      </para>
    </section>

<!-- Function rewrite(tsquery, tsquery, tsquery) -->
    <section id="lsmb13.function.rewrite-tsquery-tsquery-tsquery"
             xreflabel="lsmb13rewrite(tsquery, tsquery, tsquery)">
      <title id="lsmb13.function.rewrite-tsquery-tsquery-tsquery-title">
       rewrite(tsquery, tsquery, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.rewrite-tsquery-tsquery-tsquery-titleabbrev">
       rewrite(tsquery, tsquery, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquery_rewrite</programlisting>
      </para>
    </section>

<!-- Function rewrite(tsquery[]) -->
    <section id="lsmb13.function.rewrite-tsqueryARRAY"
             xreflabel="lsmb13rewrite(tsquery[])">
      <title id="lsmb13.function.rewrite-tsqueryARRAY-title">
       rewrite(tsquery[])
      </title>
      <titleabbrev id="lsmb13.function.rewrite-tsqueryARRAY-titleabbrev">
       rewrite(tsquery[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function rewrite_accum(tsquery, tsquery[]) -->
    <section id="lsmb13.function.rewrite-accum-tsquery-tsqueryARRAY"
             xreflabel="lsmb13rewrite_accum(tsquery, tsquery[])">
      <title id="lsmb13.function.rewrite-accum-tsquery-tsqueryARRAY-title">
       rewrite_accum(tsquery, tsquery[])
      </title>
      <titleabbrev id="lsmb13.function.rewrite-accum-tsquery-tsqueryARRAY-titleabbrev">
       rewrite_accum(tsquery, tsquery[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_rewrite_accum</programlisting>
      </para>
    </section>

<!-- Function rewrite_finish(tsquery) -->
    <section id="lsmb13.function.rewrite-finish-tsquery"
             xreflabel="lsmb13rewrite_finish(tsquery)">
      <title id="lsmb13.function.rewrite-finish-tsquery-title">
       rewrite_finish(tsquery)
      </title>
      <titleabbrev id="lsmb13.function.rewrite-finish-tsquery-titleabbrev">
       rewrite_finish(tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_rewrite_finish</programlisting>
      </para>
    </section>

<!-- Function save_taxform(in_taxform_name integer, in_country_code text) -->
    <section id="lsmb13.function.save-taxform-in-taxform-name-integer-in-country-code-text"
             xreflabel="lsmb13save_taxform(in_taxform_name integer, in_country_code text)">
      <title id="lsmb13.function.save-taxform-in-taxform-name-integer-in-country-code-text-title">
       save_taxform(in_taxform_name integer, in_country_code text)
      </title>
      <titleabbrev id="lsmb13.function.save-taxform-in-taxform-name-integer-in-country-code-text-titleabbrev">
       save_taxform(in_taxform_name integer, in_country_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves tax form information. Returns true or raises exception.
        <programlisting>
BEGIN
	INSERT INTO country_tax_form(country_id, form_name) 
	values (in_country_code, in_taxform_name);

	RETURN true;
END;
</programlisting>
      </para>
    </section>

<!-- Function session_check(in_token integer, in_session_id text) -->
    <section id="lsmb13.function.session-check-in-token-integer-in-session-id-text"
             xreflabel="lsmb13session_check(in_token integer, in_session_id text)">
      <title id="lsmb13.function.session-check-in-token-integer-in-session-id-text-title">
       session_check(in_token integer, in_session_id text)
      </title>
      <titleabbrev id="lsmb13.function.session-check-in-token-integer-in-session-id-text-titleabbrev">
       session_check(in_token integer, in_session_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>session</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a session row.  If no session exists, it returns null
        <programlisting>
DECLARE out_row session%ROWTYPE;
BEGIN
	DELETE FROM session
	 WHERE last_used &lt; now() - coalesce((SELECT value FROM defaults
                                    WHERE setting_key = &#39;session_timeout&#39;)::interval,
	                            &#39;90 minutes&#39;::interval);
        UPDATE session 
           SET last_used = now()
         WHERE session_id = in_session_id
               AND token = in_token
	       AND users_id = (select id from users 
			where username = SESSION_USER);
	IF FOUND THEN
		SELECT * INTO out_row FROM session WHERE session_id = in_session_id;
	ELSE
		DELETE FROM SESSION 
		WHERE users_id IN (select id from users
                        where username = SESSION_USER); 
		-- the above query also releases all discretionary locks by the
                -- session

               PERFORM * 
                  FROM defaults
                 WHERE setting_key = &#39;auto_logout&#39; and value = &#39;1&#39;;

                IF FOUND THEN
                    RAISE NOTICE &#39;auto logout&#39;;
                    RETURN NULL;
                ELSE
                    INSERT INTO session (users_id, token)
                    SELECT id, md5(random()::text)
                      FROM users 
                     WHERE username = SESSION_USER;

                    SELECT * INTO out_row FROM SESSION 
                     WHERE users_id = (select id from users
                                             where username = SESSION_USER);
                    RETURN out_row;
               END IF;
	END IF;
	RETURN out_row;
END;
</programlisting>
      </para>
    </section>

<!-- Function set_curcfg(integer) -->
    <section id="lsmb13.function.set-curcfg-integer"
             xreflabel="lsmb13set_curcfg(integer)">
      <title id="lsmb13.function.set-curcfg-integer-title">
       set_curcfg(integer)
      </title>
      <titleabbrev id="lsmb13.function.set-curcfg-integer-titleabbrev">
       set_curcfg(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_set_curcfg</programlisting>
      </para>
    </section>

<!-- Function set_curcfg(text) -->
    <section id="lsmb13.function.set-curcfg-text"
             xreflabel="lsmb13set_curcfg(text)">
      <title id="lsmb13.function.set-curcfg-text-title">
       set_curcfg(text)
      </title>
      <titleabbrev id="lsmb13.function.set-curcfg-text-titleabbrev">
       set_curcfg(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_set_curcfg_byname</programlisting>
      </para>
    </section>

<!-- Function set_curdict(integer) -->
    <section id="lsmb13.function.set-curdict-integer"
             xreflabel="lsmb13set_curdict(integer)">
      <title id="lsmb13.function.set-curdict-integer-title">
       set_curdict(integer)
      </title>
      <titleabbrev id="lsmb13.function.set-curdict-integer-titleabbrev">
       set_curdict(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_set_curdict</programlisting>
      </para>
    </section>

<!-- Function set_curdict(text) -->
    <section id="lsmb13.function.set-curdict-text"
             xreflabel="lsmb13set_curdict(text)">
      <title id="lsmb13.function.set-curdict-text-title">
       set_curdict(text)
      </title>
      <titleabbrev id="lsmb13.function.set-curdict-text-titleabbrev">
       set_curdict(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_set_curdict_byname</programlisting>
      </para>
    </section>

<!-- Function set_curprs(integer) -->
    <section id="lsmb13.function.set-curprs-integer"
             xreflabel="lsmb13set_curprs(integer)">
      <title id="lsmb13.function.set-curprs-integer-title">
       set_curprs(integer)
      </title>
      <titleabbrev id="lsmb13.function.set-curprs-integer-titleabbrev">
       set_curprs(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_set_curprs</programlisting>
      </para>
    </section>

<!-- Function set_curprs(text) -->
    <section id="lsmb13.function.set-curprs-text"
             xreflabel="lsmb13set_curprs(text)">
      <title id="lsmb13.function.set-curprs-text-title">
       set_curprs(text)
      </title>
      <titleabbrev id="lsmb13.function.set-curprs-text-titleabbrev">
       set_curprs(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_set_curprs_byname</programlisting>
      </para>
    </section>

<!-- Function set_limit(real) -->
    <section id="lsmb13.function.set-limit-real"
             xreflabel="lsmb13set_limit(real)">
      <title id="lsmb13.function.set-limit-real-title">
       set_limit(real)
      </title>
      <titleabbrev id="lsmb13.function.set-limit-real-titleabbrev">
       set_limit(real)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>set_limit</programlisting>
      </para>
    </section>

<!-- Function setting__get_currencies() -->
    <section id="lsmb13.function.setting-get-currencies"
             xreflabel="lsmb13setting__get_currencies()">
      <title id="lsmb13.function.setting-get-currencies-title">
       setting__get_currencies()
      </title>
      <titleabbrev id="lsmb13.function.setting-get-currencies-titleabbrev">
       setting__get_currencies()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an array of currencies from the defaults table.
        <programlisting>
SELECT string_to_array(value, &#39;:&#39;) from defaults where setting_key = &#39;curr&#39;;
</programlisting>
      </para>
    </section>

<!-- Function setting__set(in_value character varying, in_setting_key character varying) -->
    <section id="lsmb13.function.setting-set-in-value-character-varying-in-setting-key-character-varying"
             xreflabel="lsmb13setting__set(in_value character varying, in_setting_key character varying)">
      <title id="lsmb13.function.setting-set-in-value-character-varying-in-setting-key-character-varying-title">
       setting__set(in_value character varying, in_setting_key character varying)
      </title>
      <titleabbrev id="lsmb13.function.setting-set-in-value-character-varying-in-setting-key-character-varying-titleabbrev">
       setting__set(in_value character varying, in_setting_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        sets a value in the defaults thable and returns true if successful.
        <programlisting>
BEGIN
	UPDATE defaults SET value = in_value WHERE setting_key = in_setting_key;
        IF NOT FOUND THEN
             INSERT INTO defaults (setting_key, value) 
                  VALUES (in_setting_key, in_value);
        END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_get(in_key character varying) -->
    <section id="lsmb13.function.setting-get-in-key-character-varying"
             xreflabel="lsmb13setting_get(in_key character varying)">
      <title id="lsmb13.function.setting-get-in-key-character-varying-title">
       setting_get(in_key character varying)
      </title>
      <titleabbrev id="lsmb13.function.setting-get-in-key-character-varying-titleabbrev">
       setting_get(in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>defaults</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the value of the setting in the defaults table.
        <programlisting>
SELECT * FROM defaults WHERE setting_key = $1;
</programlisting>
      </para>
    </section>

<!-- Function setting_get_default_accounts() -->
    <section id="lsmb13.function.setting-get-default-accounts"
             xreflabel="lsmb13setting_get_default_accounts()">
      <title id="lsmb13.function.setting-get-default-accounts-title">
       setting_get_default_accounts()
      </title>
      <titleabbrev id="lsmb13.function.setting-get-default-accounts-titleabbrev">
       setting_get_default_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF defaults</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of settings for default accounts.
        <programlisting>
DECLARE
	account defaults%ROWTYPE;
BEGIN
	FOR account IN 
		SELECT * FROM defaults 
		WHERE setting_key like &#39;%accno_id&#39;
                ORDER BY setting_key
	LOOP
		RETURN NEXT account;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_increment(in_key character varying) -->
    <section id="lsmb13.function.setting-increment-in-key-character-varying"
             xreflabel="lsmb13setting_increment(in_key character varying)">
      <title id="lsmb13.function.setting-increment-in-key-character-varying-title">
       setting_increment(in_key character varying)
      </title>
      <titleabbrev id="lsmb13.function.setting-increment-in-key-character-varying-titleabbrev">
       setting_increment(in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>character varying</seg>
        </seglistitem>
       </segmentedlist>
 
       This function takes a value for a sequence in the defaults table and increments
it.  Leading zeroes and spaces are preserved as placeholders.  Currently &lt;?lsmb
parsing is not supported in this routine though it may be added at a later date.

        <programlisting>
DECLARE
	base_value VARCHAR;
	raw_value VARCHAR;
	increment INTEGER;
	inc_length INTEGER;
	new_value VARCHAR;
BEGIN
	SELECT value INTO raw_value FROM defaults 
	WHERE setting_key = in_key
	FOR UPDATE;

	SELECT substring(raw_value from  &#39;(&#39; || E&#39;\\&#39; || &#39;d*)(&#39; || E&#39;\\&#39; || &#39;D*|&lt;&#39; || E&#39;\\&#39; || &#39;?lsmb [^&lt;&gt;] &#39; || E&#39;\\&#39; || &#39;?&gt;)*$&#39;)
	INTO base_value;

	IF base_value like &#39;0%&#39; THEN
		increment := base_value::integer + 1;
		SELECT char_length(increment::text) INTO inc_length;

		SELECT overlay(base_value placing increment::varchar
			from (select char_length(base_value) 
				- inc_length + 1) for inc_length)
		INTO new_value;
	ELSE
		new_value := base_value::integer + 1;
	END IF;
	SELECT regexp_replace(raw_value, base_value, new_value) INTO new_value;
	UPDATE defaults SET value = new_value WHERE setting_key = in_key;

	return new_value;	
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_set(in_value character varying, in_key character varying) -->
    <section id="lsmb13.function.setting-set-in-value-character-varying-in-key-character-varying"
             xreflabel="lsmb13setting_set(in_value character varying, in_key character varying)">
      <title id="lsmb13.function.setting-set-in-value-character-varying-in-key-character-varying-title">
       setting_set(in_value character varying, in_key character varying)
      </title>
      <titleabbrev id="lsmb13.function.setting-set-in-value-character-varying-in-key-character-varying-titleabbrev">
       setting_set(in_value character varying, in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        sets a value in the defaults thable and returns true if successful.
        <programlisting>
BEGIN
	UPDATE defaults SET value = in_value WHERE setting_key = in_key;
        IF NOT FOUND THEN
             INSERT INTO defaults (setting_key, value) 
                  VALUES (in_setting_key, in_value);
        END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function setweight(tsvector, "char") -->
    <section id="lsmb13.function.setweight-tsvector-char"
             xreflabel="lsmb13setweight(tsvector, &quot;char&quot;)">
      <title id="lsmb13.function.setweight-tsvector-char-title">
       setweight(tsvector, &quot;char&quot;)
      </title>
      <titleabbrev id="lsmb13.function.setweight-tsvector-char-titleabbrev">
       setweight(tsvector, &quot;char&quot;)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsvector</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsvector_setweight</programlisting>
      </para>
    </section>

<!-- Function show_curcfg() -->
    <section id="lsmb13.function.show-curcfg"
             xreflabel="lsmb13show_curcfg()">
      <title id="lsmb13.function.show-curcfg-title">
       show_curcfg()
      </title>
      <titleabbrev id="lsmb13.function.show-curcfg-titleabbrev">
       show_curcfg()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>oid</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>get_current_ts_config</programlisting>
      </para>
    </section>

<!-- Function show_limit() -->
    <section id="lsmb13.function.show-limit"
             xreflabel="lsmb13show_limit()">
      <title id="lsmb13.function.show-limit-title">
       show_limit()
      </title>
      <titleabbrev id="lsmb13.function.show-limit-titleabbrev">
       show_limit()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>show_limit</programlisting>
      </para>
    </section>

<!-- Function show_trgm(text) -->
    <section id="lsmb13.function.show-trgm-text"
             xreflabel="lsmb13show_trgm(text)">
      <title id="lsmb13.function.show-trgm-text-title">
       show_trgm(text)
      </title>
      <titleabbrev id="lsmb13.function.show-trgm-text-titleabbrev">
       show_trgm(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>show_trgm</programlisting>
      </para>
    </section>

<!-- Function similarity(text, text) -->
    <section id="lsmb13.function.similarity-text-text"
             xreflabel="lsmb13similarity(text, text)">
      <title id="lsmb13.function.similarity-text-text-title">
       similarity(text, text)
      </title>
      <titleabbrev id="lsmb13.function.similarity-text-text-titleabbrev">
       similarity(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>real</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>similarity</programlisting>
      </para>
    </section>

<!-- Function similarity_op(text, text) -->
    <section id="lsmb13.function.similarity-op-text-text"
             xreflabel="lsmb13similarity_op(text, text)">
      <title id="lsmb13.function.similarity-op-text-text-title">
       similarity_op(text, text)
      </title>
      <titleabbrev id="lsmb13.function.similarity-op-text-text-titleabbrev">
       similarity_op(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>similarity_op</programlisting>
      </para>
    </section>

<!-- Function snb_en_init(internal) -->
    <section id="lsmb13.function.snb-en-init-internal"
             xreflabel="lsmb13snb_en_init(internal)">
      <title id="lsmb13.function.snb-en-init-internal-title">
       snb_en_init(internal)
      </title>
      <titleabbrev id="lsmb13.function.snb-en-init-internal-titleabbrev">
       snb_en_init(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_snb_en_init</programlisting>
      </para>
    </section>

<!-- Function snb_lexize(internal, internal, integer) -->
    <section id="lsmb13.function.snb-lexize-internal-internal-integer"
             xreflabel="lsmb13snb_lexize(internal, internal, integer)">
      <title id="lsmb13.function.snb-lexize-internal-internal-integer-title">
       snb_lexize(internal, internal, integer)
      </title>
      <titleabbrev id="lsmb13.function.snb-lexize-internal-internal-integer-titleabbrev">
       snb_lexize(internal, internal, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_snb_lexize</programlisting>
      </para>
    </section>

<!-- Function snb_ru_init(internal) -->
    <section id="lsmb13.function.snb-ru-init-internal"
             xreflabel="lsmb13snb_ru_init(internal)">
      <title id="lsmb13.function.snb-ru-init-internal-title">
       snb_ru_init(internal)
      </title>
      <titleabbrev id="lsmb13.function.snb-ru-init-internal-titleabbrev">
       snb_ru_init(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_snb_ru_init</programlisting>
      </para>
    </section>

<!-- Function snb_ru_init_koi8(internal) -->
    <section id="lsmb13.function.snb-ru-init-koi8-internal"
             xreflabel="lsmb13snb_ru_init_koi8(internal)">
      <title id="lsmb13.function.snb-ru-init-koi8-internal-title">
       snb_ru_init_koi8(internal)
      </title>
      <titleabbrev id="lsmb13.function.snb-ru-init-koi8-internal-titleabbrev">
       snb_ru_init_koi8(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_snb_ru_init_koi8</programlisting>
      </para>
    </section>

<!-- Function snb_ru_init_utf8(internal) -->
    <section id="lsmb13.function.snb-ru-init-utf8-internal"
             xreflabel="lsmb13snb_ru_init_utf8(internal)">
      <title id="lsmb13.function.snb-ru-init-utf8-internal-title">
       snb_ru_init_utf8(internal)
      </title>
      <titleabbrev id="lsmb13.function.snb-ru-init-utf8-internal-titleabbrev">
       snb_ru_init_utf8(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_snb_ru_init_utf8</programlisting>
      </para>
    </section>

<!-- Function spell_init(internal) -->
    <section id="lsmb13.function.spell-init-internal"
             xreflabel="lsmb13spell_init(internal)">
      <title id="lsmb13.function.spell-init-internal-title">
       spell_init(internal)
      </title>
      <titleabbrev id="lsmb13.function.spell-init-internal-titleabbrev">
       spell_init(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_spell_init</programlisting>
      </para>
    </section>

<!-- Function spell_lexize(internal, internal, integer) -->
    <section id="lsmb13.function.spell-lexize-internal-internal-integer"
             xreflabel="lsmb13spell_lexize(internal, internal, integer)">
      <title id="lsmb13.function.spell-lexize-internal-internal-integer-title">
       spell_lexize(internal, internal, integer)
      </title>
      <titleabbrev id="lsmb13.function.spell-lexize-internal-internal-integer-titleabbrev">
       spell_lexize(internal, internal, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_spell_lexize</programlisting>
      </para>
    </section>

<!-- Function stat(text) -->
    <section id="lsmb13.function.stat-text"
             xreflabel="lsmb13stat(text)">
      <title id="lsmb13.function.stat-text-title">
       stat(text)
      </title>
      <titleabbrev id="lsmb13.function.stat-text-titleabbrev">
       stat(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>SET OF statinfo</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_stat1</programlisting>
      </para>
    </section>

<!-- Function stat(text, text) -->
    <section id="lsmb13.function.stat-text-text"
             xreflabel="lsmb13stat(text, text)">
      <title id="lsmb13.function.stat-text-text-title">
       stat(text, text)
      </title>
      <titleabbrev id="lsmb13.function.stat-text-text-titleabbrev">
       stat(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>SET OF statinfo</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_stat2</programlisting>
      </para>
    </section>

<!-- Function strip(tsvector) -->
    <section id="lsmb13.function.strip-tsvector"
             xreflabel="lsmb13strip(tsvector)">
      <title id="lsmb13.function.strip-tsvector-title">
       strip(tsvector)
      </title>
      <titleabbrev id="lsmb13.function.strip-tsvector-titleabbrev">
       strip(tsvector)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsvector</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsvector_strip</programlisting>
      </para>
    </section>

<!-- Function syn_init(internal) -->
    <section id="lsmb13.function.syn-init-internal"
             xreflabel="lsmb13syn_init(internal)">
      <title id="lsmb13.function.syn-init-internal-title">
       syn_init(internal)
      </title>
      <titleabbrev id="lsmb13.function.syn-init-internal-titleabbrev">
       syn_init(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_syn_init</programlisting>
      </para>
    </section>

<!-- Function syn_lexize(internal, internal, integer) -->
    <section id="lsmb13.function.syn-lexize-internal-internal-integer"
             xreflabel="lsmb13syn_lexize(internal, internal, integer)">
      <title id="lsmb13.function.syn-lexize-internal-internal-integer-title">
       syn_lexize(internal, internal, integer)
      </title>
      <titleabbrev id="lsmb13.function.syn-lexize-internal-internal-integer-titleabbrev">
       syn_lexize(internal, internal, integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_syn_lexize</programlisting>
      </para>
    </section>

<!-- Function tax_form__get(in_form_id integer) -->
    <section id="lsmb13.function.tax-form-get-in-form-id-integer"
             xreflabel="lsmb13tax_form__get(in_form_id integer)">
      <title id="lsmb13.function.tax-form-get-in-form-id-integer-title">
       tax_form__get(in_form_id integer)
      </title>
      <titleabbrev id="lsmb13.function.tax-form-get-in-form-id-integer-titleabbrev">
       tax_form__get(in_form_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves specified tax form information from the database.
        <programlisting>
SELECT * FROM country_tax_form where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__list_all() -->
    <section id="lsmb13.function.tax-form-list-all"
             xreflabel="lsmb13tax_form__list_all()">
      <title id="lsmb13.function.tax-form-list-all-title">
       tax_form__list_all()
      </title>
      <titleabbrev id="lsmb13.function.tax-form-list-all-titleabbrev">
       tax_form__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of all tax forms, ordered by country_id and id
        <programlisting>
SELECT * FROM country_tax_form ORDER BY country_id, id;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__list_ext() -->
    <section id="lsmb13.function.tax-form-list-ext"
             xreflabel="lsmb13tax_form__list_ext()">
      <title id="lsmb13.function.tax-form-list-ext-title">
       tax_form__list_ext()
      </title>
      <titleabbrev id="lsmb13.function.tax-form-list-ext-titleabbrev">
       tax_form__list_ext()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF taxform_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of tax forms with an added field, country_name, to specify the
name of the country.
        <programlisting>
SELECT t.id, t.form_name, t.country_id, c.name, t.default_reportable
  FROM country_tax_form t
  JOIN country c ON c.id = t.country_id
 ORDER BY c.name, t.form_name;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean) -->
    <section id="lsmb13.function.tax-form-save-in-default-reportable-integer-in-form-name-integer-in-country-id-text-in-id-boolean"
             xreflabel="lsmb13tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean)">
      <title id="lsmb13.function.tax-form-save-in-default-reportable-integer-in-form-name-integer-in-country-id-text-in-id-boolean-title">
       tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean)
      </title>
      <titleabbrev id="lsmb13.function.tax-form-save-in-default-reportable-integer-in-form-name-integer-in-country-id-text-in-id-boolean-titleabbrev">
       tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves tax form information to the database.
        <programlisting>
BEGIN
        UPDATE country_tax_form 
           SET country_id = in_country_id,
               form_name =in_form_name,
               default_reportable = coalesce(in_default_reportable,false)
         WHERE id = in_id;

        IF FOUND THEN
           RETURN in_id;
        END IF;

	insert into country_tax_form(country_id,form_name, default_reportable) 
	values (in_country_id, in_form_name, 
                coalesce(in_default_reportable, false));

	RETURN currval(&#39;country_tax_form_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text) -->
    <section id="lsmb13.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text"
             xreflabel="lsmb13tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)">
      <title id="lsmb13.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-title">
       tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </title>
      <titleabbrev id="lsmb13.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-titleabbrev">
       tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_detail_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides a list of invoices and transactions that a report hits.  This 
is intended to allow an organization to adjust what is reported on the 1099 
before printing them.
        <programlisting>
DECLARE
	out_row tax_form_report_detail_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 then 0 
                              when relation = &#39;acc_trans&#39;
                          THEN ac.reportable_amount * pmt.amount
                                / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 then 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount * pmt.amount
                               / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     SUM(CASE WHEN gl.amount = 0 THEN 0 
                              ELSE ac.reportable_amount * pmt.amount
                               / gl.amount 
                              END
                         * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end 
                         * CASE WHEN relation = &#39;invoice&#39; THEN -1 ELSE 1 END),
                     gl.invnumber, gl.duedate::text, gl.id
                FROM (select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ar&#39; as class
                        FROM ar 
                       UNION 
                      select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ap&#39; as class
                        FROM ap
                     ) gl 
                JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                   LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                   LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id)
		JOIN entity_credit_account ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
                JOIN (SELECT ac.trans_id, sum(ac.amount) as amount,
                             as_array(entry_id) as entry_ids, 
                             as_array(chart_id) as chart_ids,
                             count(*) as num
                        FROM acc_trans ac
                       where chart_id in (select account_id
                                            from account_link
                                           where description like &#39;%paid&#39;)
                          AND transdate BETWEEN in_begin AND in_end
                     group by ac.trans_id
                     ) pmt ON  (pmt.trans_id = gl.id)
		WHERE country_tax_form.id = in_tax_form_id AND meta_number = in_meta_number
		GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, gl.invnumber, gl.duedate, gl.id, entity_credit_account.id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date) -->
    <section id="lsmb13.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date"
             xreflabel="lsmb13tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)">
      <title id="lsmb13.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date-title">
       tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)
      </title>
      <titleabbrev id="lsmb13.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date-titleabbrev">
       tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       This provides the total reportable value per vendor.  As per 1099 forms, these
are cash-basis documents and show amounts paid.
        <programlisting>
DECLARE
	out_row tax_form_report_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;acc_trans&#39; 
                          THEN ac.reportable_amount * pmt.amount
                                / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount * pmt.amount
                               / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                          ELSE ac.reportable_amount * pmt.amount
                                / gl.amount
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end
                      * CASE WHEN ac.relation = &#39;invoice&#39; then -1 else 1 end)
                         
		FROM (select id, transdate, entity_credit_account, invoice, 
                             amount, &#39;ar&#39; as class FROM ar 
                       UNION 
                      select id, transdate, entity_credit_account, invoice, 
                              amount, &#39;ap&#39; as class from ap
                     ) gl
               JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                    LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                    LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id 
                             AND ((gl.invoice is true and ac.relation=&#39;invoice&#39;)
                                  OR (gl.invoice is false 
                                     and ac.relation=&#39;acc_trans&#39;)))
                JOIN (SELECT ac.trans_id, sum(ac.amount) as amount,
                             as_array(entry_id) as entry_ids, 
                             as_array(chart_id) as chart_ids,
                             count(*) as num
                        FROM acc_trans ac
                       where chart_id in (select account_id
                                            from account_link
                                           where description like &#39;%paid&#39;)
                          AND transdate BETWEEN in_begin AND in_end
                     group by ac.trans_id
                     ) pmt ON  (pmt.trans_id = gl.id)
		JOIN entity_credit_account 
                  ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
               WHERE country_tax_form.id = in_tax_form_id
             GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, entity_credit_account.id
    LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tg_enforce_perms_eclass() -->
    <section id="lsmb13.function.tg-enforce-perms-eclass"
             xreflabel="lsmb13tg_enforce_perms_eclass()">
      <title id="lsmb13.function.tg-enforce-perms-eclass-title">
       tg_enforce_perms_eclass()
      </title>
      <titleabbrev id="lsmb13.function.tg-enforce-perms-eclass-titleabbrev">
       tg_enforce_perms_eclass()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
   r_eclass entity_class;
   roll_pfx text;
BEGIN
IF TG_OP = &#39;DELETE&#39; THEN
   RETURN OLD;
ELSE 
   SELECT value INTO roll_pfx FROM defaults WHERE setting_key = &#39;roll_prefix&#39;;
   SELECT * INTO r_eclass from entity_class WHERE id = NEW.entity_class;
   IF pg_has_role(SESSION_USER, coalesce(roll_pfx, 
                                         &#39;lsmb_&#39; || current_database() || &#39;__&#39;)
                                || &#39;contact_class_&#39; || lower(regexp_replace(
                                                        r_eclass.class, 
                                                        &#39; &#39;, 
                                                        &#39;_&#39;)), &#39;USAGE&#39;)
   THEN
      RETURN NEW;
   ELSE
      RAISE EXCEPTION &#39;Access Denied for class&#39;;
   END IF;
END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function thesaurus_init(internal) -->
    <section id="lsmb13.function.thesaurus-init-internal"
             xreflabel="lsmb13thesaurus_init(internal)">
      <title id="lsmb13.function.thesaurus-init-internal-title">
       thesaurus_init(internal)
      </title>
      <titleabbrev id="lsmb13.function.thesaurus-init-internal-titleabbrev">
       thesaurus_init(internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_thesaurus_init</programlisting>
      </para>
    </section>

<!-- Function thesaurus_lexize(internal, internal, integer, internal) -->
    <section id="lsmb13.function.thesaurus-lexize-internal-internal-integer-internal"
             xreflabel="lsmb13thesaurus_lexize(internal, internal, integer, internal)">
      <title id="lsmb13.function.thesaurus-lexize-internal-internal-integer-internal-title">
       thesaurus_lexize(internal, internal, integer, internal)
      </title>
      <titleabbrev id="lsmb13.function.thesaurus-lexize-internal-internal-integer-internal-titleabbrev">
       thesaurus_lexize(internal, internal, integer, internal)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>internal</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_thesaurus_lexize</programlisting>
      </para>
    </section>

<!-- Function to_args(in_args text[], in_base text[]) -->
    <section id="lsmb13.function.to-args-in-args-textARRAY-in-base-textARRAY"
             xreflabel="lsmb13to_args(in_args text[], in_base text[])">
      <title id="lsmb13.function.to-args-in-args-textARRAY-in-base-textARRAY-title">
       to_args(in_args text[], in_base text[])
      </title>
      <titleabbrev id="lsmb13.function.to-args-in-args-textARRAY-in-base-textARRAY-titleabbrev">
       to_args(in_args text[], in_base text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes two arguments.  The first is a one-dimensional array 
representing the  base state of the argument array.  The second is a two 
element array of {key, value}.

If either of the args is null, it returns the first argument.  Otherwise it 
returns the first initial array, concatenated with key || &apos;=&apos; || value.

It primarily exists for the to_args aggregate.

        <programlisting>
SELECT CASE WHEN $2[1] IS NULL OR $2[2] IS NULL THEN $1 
            ELSE $1 || ($2[1]::text || &#39;=&#39; || $2[2]::text)
       END;
</programlisting>
      </para>
    </section>

<!-- Function to_args(text[]) -->
    <section id="lsmb13.function.to-args-textARRAY"
             xreflabel="lsmb13to_args(text[])">
      <title id="lsmb13.function.to-args-textARRAY-title">
       to_args(text[])
      </title>
      <titleabbrev id="lsmb13.function.to-args-textARRAY-titleabbrev">
       to_args(text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
        Turns a setof ARRAY[key,value] into an 
ARRAY[key||&apos;=&apos;||value, key||&apos;=&apos;||value,...]

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function to_tsquery(oid, text) -->
    <section id="lsmb13.function.to-tsquery-oid-text"
             xreflabel="lsmb13to_tsquery(oid, text)">
      <title id="lsmb13.function.to-tsquery-oid-text-title">
       to_tsquery(oid, text)
      </title>
      <titleabbrev id="lsmb13.function.to-tsquery-oid-text-titleabbrev">
       to_tsquery(oid, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>to_tsquery_byid</programlisting>
      </para>
    </section>

<!-- Function to_tsquery(text) -->
    <section id="lsmb13.function.to-tsquery-text"
             xreflabel="lsmb13to_tsquery(text)">
      <title id="lsmb13.function.to-tsquery-text-title">
       to_tsquery(text)
      </title>
      <titleabbrev id="lsmb13.function.to-tsquery-text-titleabbrev">
       to_tsquery(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>to_tsquery</programlisting>
      </para>
    </section>

<!-- Function to_tsquery(text, text) -->
    <section id="lsmb13.function.to-tsquery-text-text"
             xreflabel="lsmb13to_tsquery(text, text)">
      <title id="lsmb13.function.to-tsquery-text-text-title">
       to_tsquery(text, text)
      </title>
      <titleabbrev id="lsmb13.function.to-tsquery-text-text-titleabbrev">
       to_tsquery(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_to_tsquery_name</programlisting>
      </para>
    </section>

<!-- Function to_tsvector(oid, text) -->
    <section id="lsmb13.function.to-tsvector-oid-text"
             xreflabel="lsmb13to_tsvector(oid, text)">
      <title id="lsmb13.function.to-tsvector-oid-text-title">
       to_tsvector(oid, text)
      </title>
      <titleabbrev id="lsmb13.function.to-tsvector-oid-text-titleabbrev">
       to_tsvector(oid, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsvector</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>to_tsvector_byid</programlisting>
      </para>
    </section>

<!-- Function to_tsvector(text) -->
    <section id="lsmb13.function.to-tsvector-text"
             xreflabel="lsmb13to_tsvector(text)">
      <title id="lsmb13.function.to-tsvector-text-title">
       to_tsvector(text)
      </title>
      <titleabbrev id="lsmb13.function.to-tsvector-text-titleabbrev">
       to_tsvector(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsvector</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>to_tsvector</programlisting>
      </para>
    </section>

<!-- Function to_tsvector(text, text) -->
    <section id="lsmb13.function.to-tsvector-text-text"
             xreflabel="lsmb13to_tsvector(text, text)">
      <title id="lsmb13.function.to-tsvector-text-text-title">
       to_tsvector(text, text)
      </title>
      <titleabbrev id="lsmb13.function.to-tsvector-text-text-titleabbrev">
       to_tsvector(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>tsvector</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_to_tsvector_name</programlisting>
      </para>
    </section>

<!-- Function token_type() -->
    <section id="lsmb13.function.token-type"
             xreflabel="lsmb13token_type()">
      <title id="lsmb13.function.token-type-title">
       token_type()
      </title>
      <titleabbrev id="lsmb13.function.token-type-titleabbrev">
       token_type()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>SET OF tokentype</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_token_type_current</programlisting>
      </para>
    </section>

<!-- Function token_type(integer) -->
    <section id="lsmb13.function.token-type-integer"
             xreflabel="lsmb13token_type(integer)">
      <title id="lsmb13.function.token-type-integer-title">
       token_type(integer)
      </title>
      <titleabbrev id="lsmb13.function.token-type-integer-titleabbrev">
       token_type(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>SET OF tokentype</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_token_type_byid</programlisting>
      </para>
    </section>

<!-- Function token_type(text) -->
    <section id="lsmb13.function.token-type-text"
             xreflabel="lsmb13token_type(text)">
      <title id="lsmb13.function.token-type-text-title">
       token_type(text)
      </title>
      <titleabbrev id="lsmb13.function.token-type-text-titleabbrev">
       token_type(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>SET OF tokentype</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>ts_token_type_byname</programlisting>
      </para>
    </section>

<!-- Function track_global_sequence() -->
    <section id="lsmb13.function.track-global-sequence"
             xreflabel="lsmb13track_global_sequence()">
      <title id="lsmb13.function.track-global-sequence-title">
       track_global_sequence()
      </title>
      <titleabbrev id="lsmb13.function.track-global-sequence-titleabbrev">
       track_global_sequence()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This trigger is used to track the id sequence entries across the 
transactions table, and with the ar, ap, and gl tables.  This is necessary 
because these have not been properly refactored yet.

        <programlisting>
BEGIN
	IF tg_op = &#39;INSERT&#39; THEN
		INSERT INTO transactions (id, table_name) 
		VALUES (new.id, TG_RELNAME);
	ELSEIF tg_op = &#39;UPDATE&#39; THEN
		IF new.id = old.id THEN
			return new;
		ELSE
			UPDATE transactions SET id = new.id WHERE id = old.id;
		END IF;
	ELSE 
		DELETE FROM transactions WHERE id = old.id;
	END IF;
	RETURN new;
END;
</programlisting>
      </para>
    </section>

<!-- Function trigger_parts_short() -->
    <section id="lsmb13.function.trigger-parts-short"
             xreflabel="lsmb13trigger_parts_short()">
      <title id="lsmb13.function.trigger-parts-short-title">
       trigger_parts_short()
      </title>
      <titleabbrev id="lsmb13.function.trigger-parts-short-titleabbrev">
       trigger_parts_short()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  IF NEW.onhand &gt;= NEW.rop THEN
    NOTIFY parts_short;
  END IF;
  RETURN NEW;
END;
</programlisting>
      </para>
    </section>

<!-- Function trigger_pending_job() -->
    <section id="lsmb13.function.trigger-pending-job"
             xreflabel="lsmb13trigger_pending_job()">
      <title id="lsmb13.function.trigger-pending-job-title">
       trigger_pending_job()
      </title>
      <titleabbrev id="lsmb13.function.trigger-pending-job-titleabbrev">
       trigger_pending_job()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  IF NEW.success IS NULL THEN
    NOTIFY job_entered;
  END IF;
  RETURN NEW;
END;
</programlisting>
      </para>
    </section>

<!-- Function ts_debug(text) -->
    <section id="lsmb13.function.ts-debug-text"
             xreflabel="lsmb13ts_debug(text)">
      <title id="lsmb13.function.ts-debug-text-title">
       ts_debug(text)
      </title>
      <titleabbrev id="lsmb13.function.ts-debug-text-titleabbrev">
       ts_debug(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF tsdebug</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
select
        (select c.cfgname::text from pg_catalog.pg_ts_config as c
         where c.oid = show_curcfg()),
        t.alias as tok_type,
        t.descr as description,
        p.token,
        ARRAY ( SELECT m.mapdict::pg_catalog.regdictionary::pg_catalog.text
                FROM pg_catalog.pg_ts_config_map AS m
                WHERE m.mapcfg = show_curcfg() AND m.maptokentype = p.tokid
                ORDER BY m.mapseqno )
        AS dict_name,
        strip(to_tsvector(p.token)) as tsvector
from
        parse( _get_parser_from_curcfg(), $1 ) as p,
        token_type() as t
where
        t.tokid = p.tokid
</programlisting>
      </para>
    </section>

<!-- Function tsearch2() -->
    <section id="lsmb13.function.tsearch2"
             xreflabel="lsmb13tsearch2()">
      <title id="lsmb13.function.tsearch2-title">
       tsearch2()
      </title>
      <titleabbrev id="lsmb13.function.tsearch2-titleabbrev">
       tsearch2()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>C</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsa_tsearch2</programlisting>
      </para>
    </section>

<!-- Function tsq_mcontained(tsquery, tsquery) -->
    <section id="lsmb13.function.tsq-mcontained-tsquery-tsquery"
             xreflabel="lsmb13tsq_mcontained(tsquery, tsquery)">
      <title id="lsmb13.function.tsq-mcontained-tsquery-tsquery-title">
       tsq_mcontained(tsquery, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.tsq-mcontained-tsquery-tsquery-titleabbrev">
       tsq_mcontained(tsquery, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsq_mcontained</programlisting>
      </para>
    </section>

<!-- Function tsq_mcontains(tsquery, tsquery) -->
    <section id="lsmb13.function.tsq-mcontains-tsquery-tsquery"
             xreflabel="lsmb13tsq_mcontains(tsquery, tsquery)">
      <title id="lsmb13.function.tsq-mcontains-tsquery-tsquery-title">
       tsq_mcontains(tsquery, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.tsq-mcontains-tsquery-tsquery-titleabbrev">
       tsq_mcontains(tsquery, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsq_mcontains</programlisting>
      </para>
    </section>

<!-- Function tsquery_and(tsquery, tsquery) -->
    <section id="lsmb13.function.tsquery-and-tsquery-tsquery"
             xreflabel="lsmb13tsquery_and(tsquery, tsquery)">
      <title id="lsmb13.function.tsquery-and-tsquery-tsquery-title">
       tsquery_and(tsquery, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.tsquery-and-tsquery-tsquery-titleabbrev">
       tsquery_and(tsquery, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquery_and</programlisting>
      </para>
    </section>

<!-- Function tsquery_not(tsquery) -->
    <section id="lsmb13.function.tsquery-not-tsquery"
             xreflabel="lsmb13tsquery_not(tsquery)">
      <title id="lsmb13.function.tsquery-not-tsquery-title">
       tsquery_not(tsquery)
      </title>
      <titleabbrev id="lsmb13.function.tsquery-not-tsquery-titleabbrev">
       tsquery_not(tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquery_not</programlisting>
      </para>
    </section>

<!-- Function tsquery_or(tsquery, tsquery) -->
    <section id="lsmb13.function.tsquery-or-tsquery-tsquery"
             xreflabel="lsmb13tsquery_or(tsquery, tsquery)">
      <title id="lsmb13.function.tsquery-or-tsquery-tsquery-title">
       tsquery_or(tsquery, tsquery)
      </title>
      <titleabbrev id="lsmb13.function.tsquery-or-tsquery-tsquery-titleabbrev">
       tsquery_or(tsquery, tsquery)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>tsquery</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>tsquery_or</programlisting>
      </para>
    </section>

<!-- Function unlock(in_id integer) -->
    <section id="lsmb13.function.unlock-in-id-integer"
             xreflabel="lsmb13unlock(in_id integer)">
      <title id="lsmb13.function.unlock-in-id-integer-title">
       unlock(in_id integer)
      </title>
      <titleabbrev id="lsmb13.function.unlock-in-id-integer-titleabbrev">
       unlock(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Releases a pessimistic locks against a transaction, if that transaciton, as 
identified by in_id exists, and if  it is locked by the current session. 
These locks are again only advisory, and the application may choose to handle 
them or not.

Returns true if the transaction was unlocked by this routine, false 
otherwise.
        <programlisting>
BEGIN
    UPDATE transactions SET locked_by = NULL WHERE id = in_id 
           AND locked_by IN (SELECT session_id FROM session WHERE users_id =
		(SELECT id FROM users WHERE username = SESSION_USER));
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function unlock_all() -->
    <section id="lsmb13.function.unlock-all"
             xreflabel="lsmb13unlock_all()">
      <title id="lsmb13.function.unlock-all-title">
       unlock_all()
      </title>
      <titleabbrev id="lsmb13.function.unlock-all-titleabbrev">
       unlock_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Releases all pessimistic locks against transactions.  These locks are again
only advisory, and the application may choose to handle them or not.

Returns true if any transactions were unlocked, false otherwise.
        <programlisting>
BEGIN
    UPDATE transactions SET locked_by = NULL 
    where locked_by IN 
          (select session_id from session WHERE users_id = 
                  (SELECT id FROM users WHERE username = SESSION_USER));

    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__change_password(in_new_password text) -->
    <section id="lsmb13.function.user-change-password-in-new-password-text"
             xreflabel="lsmb13user__change_password(in_new_password text)">
      <title id="lsmb13.function.user-change-password-in-new-password-text-title">
       user__change_password(in_new_password text)
      </title>
      <titleabbrev id="lsmb13.function.user-change-password-in-new-password-text-titleabbrev">
       user__change_password(in_new_password text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Alloes a user to change his or her own password.  The password is set to 
expire setting_get(&apos;password_duration&apos;) days after the password change.
        <programlisting>
DECLARE
	t_expires timestamp;
        t_password_duration text;
BEGIN
    SELECT value INTO t_password_duration FROM defaults 
     WHERE setting_key = &#39;password_duration&#39;;
    IF t_password_duration IS NULL or t_password_duration=&#39;&#39; THEN
        t_expires := &#39;infinity&#39;;
    ELSE
        t_expires := now() 
                     + (t_password_duration::numeric::text || &#39; days&#39;)::interval;
    END IF;


    UPDATE users SET notify_password = DEFAULT where username = SESSION_USER;

    EXECUTE &#39;ALTER USER &#39; || quote_ident(SESSION_USER) || 
            &#39; with ENCRYPTED password &#39; || quote_literal(in_new_password) ||
                 &#39; VALID UNTIL &#39;|| quote_literal(t_expires);
    return 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__check_my_expiration() -->
    <section id="lsmb13.function.user-check-my-expiration"
             xreflabel="lsmb13user__check_my_expiration()">
      <title id="lsmb13.function.user-check-my-expiration-title">
       user__check_my_expiration()
      </title>
      <titleabbrev id="lsmb13.function.user-check-my-expiration-titleabbrev">
       user__check_my_expiration()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>interval</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the time when password of the current logged in user is set to 
expire.
        <programlisting>
DECLARE
    outval interval;
BEGIN
    SELECT CASE WHEN isfinite(rolvaliduntil) is not true THEN &#39;1 year&#39;::interval
                ELSE rolvaliduntil - now() END AS expiration INTO outval 
    FROM pg_roles WHERE rolname = SESSION_USER;
    RETURN outval;
end;
</programlisting>
      </para>
    </section>

<!-- Function user__expires_soon() -->
    <section id="lsmb13.function.user-expires-soon"
             xreflabel="lsmb13user__expires_soon()">
      <title id="lsmb13.function.user-expires-soon-title">
       user__expires_soon()
      </title>
      <titleabbrev id="lsmb13.function.user-expires-soon-titleabbrev">
       user__expires_soon()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the password of the current logged in user is set to expire 
within on week.
        <programlisting>
   SELECT user__check_my_expiration() &lt; &#39;1 week&#39;;
</programlisting>
      </para>
    </section>

<!-- Function user__get_all_users() -->
    <section id="lsmb13.function.user-get-all-users"
             xreflabel="lsmb13user__get_all_users()">
      <title id="lsmb13.function.user-get-all-users-title">
       user__get_all_users()
      </title>
      <titleabbrev id="lsmb13.function.user-get-all-users-titleabbrev">
       user__get_all_users()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF user_listable</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    select * from user_listable;
    
</programlisting>
      </para>
    </section>

<!-- Function user__get_preferences(in_user_id integer) -->
    <section id="lsmb13.function.user-get-preferences-in-user-id-integer"
             xreflabel="lsmb13user__get_preferences(in_user_id integer)">
      <title id="lsmb13.function.user-get-preferences-in-user-id-integer-title">
       user__get_preferences(in_user_id integer)
      </title>
      <titleabbrev id="lsmb13.function.user-get-preferences-in-user-id-integer-titleabbrev">
       user__get_preferences(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF user_preference</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the preferences row for the user.
        <programlisting>
    
declare
    v_row user_preference;
BEGIN
    select * into v_row from user_preference where id = in_user_id;
    
    IF NOT FOUND THEN
    
        RAISE EXCEPTION &#39;Could not find user preferences for id %&#39;, in_user_id;
    ELSE
        return next v_row;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text) -->
    <section id="lsmb13.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text"
             xreflabel="lsmb13user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)">
      <title id="lsmb13.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text-title">
       user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)
      </title>
      <titleabbrev id="lsmb13.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text-titleabbrev">
       user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves user preferences.  Returns true if successful, false if no preferences
were found to update.
        <programlisting>
BEGIN
    UPDATE user_preference
    SET dateformat = in_dateformat,
        numberformat = in_numberformat,
        language = in_language,
        stylesheet = in_stylesheet,
        printer = in_printer
    WHERE id = (select id from users where username = SESSION_USER);
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher__delete(in_voucher_id integer) -->
    <section id="lsmb13.function.voucher-delete-in-voucher-id-integer"
             xreflabel="lsmb13voucher__delete(in_voucher_id integer)">
      <title id="lsmb13.function.voucher-delete-in-voucher-id-integer-title">
       voucher__delete(in_voucher_id integer)
      </title>
      <titleabbrev id="lsmb13.function.voucher-delete-in-voucher-id-integer-titleabbrev">
       voucher__delete(in_voucher_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the specified voucher from the batch.
        <programlisting>
DECLARE 
	voucher_row RECORD;
BEGIN
	SELECT * INTO voucher_row FROM voucher WHERE id = in_voucher_id;
	IF voucher_row.batch_class IN (1, 2, 5) THEN
        DELETE FROM ac_tax_form WHERE entry_id IN (
               SELECT entry_id
                 FROM acc_trans
               WHERE trans_id = voucher_row.trans_id);
 
		DELETE FROM acc_trans WHERE trans_id = voucher_row.trans_id;
		DELETE FROM ar WHERE id = voucher_row.trans_id;
		DELETE FROM ap WHERE id = voucher_row.trans_id;
		DELETE FROM gl WHERE id = voucher_row.trans_id;
		DELETE FROM voucher WHERE id = voucher_row.id;
		-- DELETE FROM transactions WHERE id = voucher_row.trans_id;
	ELSE 
		update ar set paid = amount + 
			(select sum(amount) from acc_trans 
			join chart ON (acc_trans.chart_id = chart.id)
			where link = &#39;AR&#39; AND trans_id = ar.id
				AND (voucher_id IS NULL 
				OR voucher_id &lt;&gt; voucher_row.id))
		where id in (select trans_id from acc_trans 
				where voucher_id = voucher_row.id);

		update ap set paid = amount - (select sum(amount) from acc_trans 
			join chart ON (acc_trans.chart_id = chart.id)
			where link = &#39;AP&#39; AND trans_id = ap.id
				AND (voucher_id IS NULL 
				OR voucher_id &lt;&gt; voucher_row.id))
		where id in (select trans_id from acc_trans 
				where voucher_id = voucher_row.id);
                DELETE FROM ac_tax_form WHERE entry_id IN
                       (select entry_id from acc_trans 
                         where voucher_id = voucher_row.id);

		DELETE FROM acc_trans where voucher_id = voucher_row.id;
	END IF;
	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher__list(in_batch_id integer) -->
    <section id="lsmb13.function.voucher-list-in-batch-id-integer"
             xreflabel="lsmb13voucher__list(in_batch_id integer)">
      <title id="lsmb13.function.voucher-list-in-batch-id-integer-title">
       voucher__list(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb13.function.voucher-list-in-batch-id-integer-titleabbrev">
       voucher__list(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF voucher_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a list of vouchers and amounts attached to the batch.
        <programlisting>
declare voucher_item record;
BEGIN
    	FOR voucher_item IN
		SELECT v.id, a.invoice, a.invnumber, e.name, 
			v.batch_id, v.trans_id, 
			a.amount, a.transdate, &#39;Payable&#39;
		FROM voucher v
		JOIN ap a ON (v.trans_id = a.id)
		JOIN entity_credit_account eca 
			ON (eca.id = a.entity_credit_account)
		JOIN entity e ON (eca.entity_id = e.id)
		WHERE v.batch_id = in_batch_id 
			AND v.batch_class = (select id from batch_class 
					WHERE class = &#39;ap&#39;)
		UNION
		SELECT v.id, a.invoice, a.invnumber, e.name, 
			v.batch_id, v.trans_id, 
			a.amount, a.transdate, &#39;Receivable&#39;
		FROM voucher v
		JOIN ar a ON (v.trans_id = a.id)
		JOIN entity_credit_account eca 
			ON (eca.id = a.entity_credit_account)
		JOIN entity e ON (eca.entity_id = e.id)
		WHERE v.batch_id = in_batch_id 
			AND v.batch_class = (select id from batch_class 
					WHERE class = &#39;ar&#39;)
		UNION ALL
		-- TODO:  Add the class labels to the class table.
		SELECT v.id, false, a.source, 
			cr.meta_number || &#39;--&#39;  || co.legal_name , 
			v.batch_id, v.trans_id, 
			sum(CASE WHEN bc.class LIKE &#39;payment%&#39; THEN a.amount * -1
			     ELSE a.amount  END), a.transdate, 
			CASE WHEN bc.class = &#39;payment&#39; THEN &#39;Payment&#39;
			     WHEN bc.class = &#39;payment_reversal&#39; 
			     THEN &#39;Payment Reversal&#39;
			END
		FROM voucher v
		JOIN acc_trans a ON (v.id = a.voucher_id)
                JOIN batch_class bc ON (bc.id = v.batch_class)
		JOIN chart c ON (a.chart_id = c.id)
		JOIN ap ON (ap.id = a.trans_id)
		JOIN entity_credit_account cr 
			ON (ap.entity_credit_account = cr.id)
		JOIN company co ON (cr.entity_id = co.entity_id)
		WHERE v.batch_id = in_batch_id 
			AND a.voucher_id = v.id
			AND (bc.class like &#39;payment%&#39; AND c.link = &#39;AP&#39;)
		GROUP BY v.id, a.source, cr.meta_number, co.legal_name ,
                        v.batch_id, v.trans_id, a.transdate, bc.class

		UNION ALL
		SELECT v.id, false, a.source, a.memo, 
			v.batch_id, v.trans_id, 
			CASE WHEN bc.class LIKE &#39;receipt%&#39; THEN sum(a.amount) * -1
			     ELSE sum(a.amount)  END, a.transdate, 
			CASE WHEN bc.class = &#39;receipt&#39; THEN &#39;Receipt&#39;
			     WHEN bc.class = &#39;receipt_reversal&#39; 
			     THEN &#39;Receipt Reversal&#39;
			END
		FROM voucher v
		JOIN acc_trans a ON (v.id = a.voucher_id)
                JOIN batch_class bc ON (bc.id = v.batch_class)
		JOIN chart c ON (a.chart_id = c.id)
		JOIN ar ON (ar.id = a.trans_id)
		JOIN entity_credit_account cr 
			ON (ar.entity_credit_account = cr.id)
		JOIN company co ON (cr.entity_id = co.entity_id)
		WHERE v.batch_id = in_batch_id 
			AND a.voucher_id = v.id
			AND (bc.class like &#39;receipt%&#39; AND c.link = &#39;AR&#39;)
		GROUP BY v.id, a.source, cr.meta_number, co.legal_name ,
                        a.memo, v.batch_id, v.trans_id, a.transdate, bc.class
		UNION ALL
		SELECT v.id, false, g.reference, g.description, 
			v.batch_id, v.trans_id,
			sum(a.amount), g.transdate, &#39;GL&#39;
		FROM voucher v
		JOIN gl g ON (g.id = v.trans_id)
		JOIN acc_trans a ON (v.trans_id = a.trans_id)
		WHERE a.amount &gt; 0
			AND v.batch_id = in_batch_id
			AND v.batch_class IN (select id from batch_class 
					where class = &#39;gl&#39;)
		GROUP BY v.id, g.reference, g.description, v.batch_id, 
			v.trans_id, g.transdate
		ORDER BY 7, 1
	LOOP
		RETURN NEXT voucher_item;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher_get_batch(in_batch_id integer) -->
    <section id="lsmb13.function.voucher-get-batch-in-batch-id-integer"
             xreflabel="lsmb13voucher_get_batch(in_batch_id integer)">
      <title id="lsmb13.function.voucher-get-batch-in-batch-id-integer-title">
       voucher_get_batch(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb13.function.voucher-get-batch-in-batch-id-integer-titleabbrev">
       voucher_get_batch(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>batch</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves basic batch information based on batch_id.
        <programlisting>
DECLARE
	batch_out batch%ROWTYPE;
BEGIN
	SELECT * INTO batch_out FROM batch b WHERE b.id = in_batch_id;
	RETURN batch_out;
END;
</programlisting>
      </para>
    </section>

<!-- Function warehouse__list_all() -->
    <section id="lsmb13.function.warehouse-list-all"
             xreflabel="lsmb13warehouse__list_all()">
      <title id="lsmb13.function.warehouse-list-all-title">
       warehouse__list_all()
      </title>
      <titleabbrev id="lsmb13.function.warehouse-list-all-titleabbrev">
       warehouse__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF warehouse</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM warehouse order by description;
</programlisting>
      </para>
    </section>

  </chapter>

  <chapter id="lsmb14.schema"
           xreflabel="lsmb14">
    <title>Schema lsmb14</title>
    <para></para>


      <section id="lsmb14.table.ac-tax-form"
               xreflabel="lsmb14.ac_tax_form">
        <title id="lsmb14.table.ac-tax-form-title">
         Table:
         
         <structname>ac_tax_form</structname>
        </title>
 

        <para>
           Mapping journal_line to country_tax_form for reporting purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ac_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.acc-trans"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.acc-trans"
               xreflabel="lsmb14.acc_trans">
        <title id="lsmb14.table.acc-trans-title">
         Table:
         
         <structname>acc_trans</structname>
        </title>
 

        <para>
          This table stores line items for financial transactions.  Please note that
payments in 1.3 are not full-fledged transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>acc_trans</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Document Source identifier for individual line items, usually used 
for payments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fx_transaction</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>memo</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reconciled_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.voucher"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on acc_trans</title>

          <varlistentry>
            <term>ac_transdate_year_idx</term>
            <listitem><para>date_part(&apos;YEAR&apos;::text, transdate)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_voucher_id_idx</term>
            <listitem><para>voucher_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.ac_tax_form via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.ac-tax-form"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-ac"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment-links"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.account"
               xreflabel="lsmb14.account">
        <title id="lsmb14.table.account-title">
         Table:
         
         <structname>account</structname>
        </title>
 

        <para>
           This table stores the main account info.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_temp</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 Only affects equity accounts.  If set, close at end of year. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>category</structfield></term>
              <listitem><para>
                <type>character(1)</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gifi_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>heading</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contra</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.account-checkpoint"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.account-link"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.cr-coa-to-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.cr-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.parts"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.partstax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-deduction-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-income-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.trial-balance-account-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.account-checkpoint"
               xreflabel="lsmb14.account_checkpoint">
        <title id="lsmb14.table.account-checkpoint-title">
         Table:
         
         <structname>account_checkpoint</structname>
        </title>
 

        <para>
           This table holds account balances at various dates.  Transactions MUST NOT
be posted prior to the latest end_date in this table, and no unapproved 
transactions (vouchers or drafts) can remain in the closed period.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_checkpoint</structname>
            </title>


            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>debits</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credits</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.account-heading"
               xreflabel="lsmb14.account_heading">
        <title id="lsmb14.table.account-heading-title">
         Table:
         
         <structname>account_heading</structname>
        </title>
 

        <para>
          
This table holds the account headings in the system.  Each account must belong 
to a heading, and a heading can belong to another heading.  In this way it is 
possible to nest accounts for reporting purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_heading</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.account-heading"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.trial-balance-heading-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.account-link"
               xreflabel="lsmb14.account_link">
        <title id="lsmb14.table.account-link-title">
         Table:
         
         <structname>account_link</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_link</structname>
            </title>


            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account-link-description"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.account-link-description"
               xreflabel="lsmb14.account_link_description">
        <title id="lsmb14.table.account-link-description-title">
         Table:
         
         <structname>account_link_description</structname>
        </title>
 

        <para>
           This is a lookup table which provide basic information as to categories and
dropdowns of accounts.  In general summary accounts cannot belong to more than 
one category (an AR summary account cannot appear in other dropdowns for 
example).  Custom fields are not overwritten when the account is edited from
the front-end.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_link_description</structname>
            </title>


            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>summary</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>custom</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.account_link via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.account-link"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.ap"
               xreflabel="lsmb14.ap">
        <title id="lsmb14.table.ap-title">
         Table:
         
         <structname>ap</structname>
        </title>
 

        <para>
           Summary/header information for AP transactions and vendor invoices.
Note that some constraints here are hard to enforce because we haven not gotten 
to rewriting the relevant code here.
HV TODO drop entity_id

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ap</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Text identifier for the invoice.  Must be unique.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 This stores the total amount (including taxes) for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 Total amount excluding taxes for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>paid</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>datepaid</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>duedate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 True if the transaction tracks goods/services purchase using the invoice
table.  False otherwise.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

              <para>
                 3 letters to identify the currency.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are displayed on the invoice when printed or emailed
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

              <para>
                Person who created the transaction
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>till</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Quotation Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are not displayed when the invoice is printed or emailed and
may be updated without reposting hte invocie.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Purchase Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

              <para>
                Only show in financial reports if true.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                If true numbers are displayed after multiplying by -1
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

              <para>
                 Not exposed to the UI, but can be set to prevent an invoice from showing up
for payment or in outstanding reports.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

              <para>
                 reference for the vendor account used.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on ap</title>

          <varlistentry>
            <term>ap_check</term>
            <listitem><para>CHECK ((((amount IS NULL) AND (curr IS NULL)) OR ((amount IS NOT NULL) AND (curr IS NOT NULL))))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.ar"
               xreflabel="lsmb14.ar">
        <title id="lsmb14.table.ar-title">
         Table:
         
         <structname>ar</structname>
        </title>
 

        <para>
           Summary/header information for AR transactions and sales invoices.
Note that some constraints here are hard to enforce because we haven not gotten 
to rewriting the relevant code here.
HV TODO drop entity_id

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ar</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invnumber</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>










              </para>

              <para>
                 Text identifier for the invoice.  Must be unique.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 This stores the total amount (including taxes) for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 Total amount excluding taxes for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>paid</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>datepaid</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>duedate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 True if the transaction tracks goods/services purchase using the invoice
table.  False otherwise.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are displayed on the invoice when printed or emailed
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

              <para>
                 3 letters to identify the currency.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

              <para>
                Person who created the transaction
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>till</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Quotation Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are not displayed when the invoice is printed or emailed and
may be updated without reposting hte invocie.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Purchase Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                If true numbers are displayed after multiplying by -1
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

              <para>
                Only show in financial reports if true.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

              <para>
                 reference for the customer account used.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

              <para>
                 Not exposed to the UI, but can be set to prevent an invoice from showing up
for payment or in outstanding reports.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_return</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on ar</title>

          <varlistentry>
            <term>ar_check</term>
            <listitem><para>CHECK ((((amount IS NULL) AND (curr IS NULL)) OR ((amount IS NOT NULL) AND (curr IS NOT NULL))))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.assembly"
               xreflabel="lsmb14.assembly">
        <title id="lsmb14.table.assembly-title">
         Table:
         
         <structname>assembly</structname>
        </title>
 

        <para>
          Holds mapping for parts that are members of assemblies.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>assembly</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>




              </para>

              <para>
                This is the id of the assembly the part is being mapped to.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>




              </para>

              <para>
                ID of part that is a member of the assembly.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bom</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>adj</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on assembly</title>

          <varlistentry>
            <term>assembly_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.asset-class"
               xreflabel="lsmb14.asset_class">
        <title id="lsmb14.table.asset-class-title">
         Table:
         
         <structname>asset_class</structname>
        </title>
 

        <para>
          
The account fields here set the defaults for the individual asset items.  They
are non-authoritative.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dep_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>method</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-dep-method"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.asset-dep-method"
               xreflabel="lsmb14.asset_dep_method">
        <title id="lsmb14.table.asset-dep-method-title">
         Table:
         
         <structname>asset_dep_method</structname>
        </title>
 

        <para>
           Stores asset depreciation methods, and their relevant stored procedures.

The fixed asset system is such depreciation methods can be plugged in via this
table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_dep_method</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>method</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 These are keyed to specific stored procedures.  Currently only &quot;straight_line&quot; is supported
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sproc</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                The sproc mentioned here is a stored procedure which must have the following
arguments: (in_asset_ids int[],  in_report_date date, in_report_id int).

Here in_asset_ids are the assets to be depreciated, in_report_date is the date
of the report, and in_report_id is the id of the report.  The sproc MUST
insert the relevant lines into asset_report_line. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit_label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_name</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-unit-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_class via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-class"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.asset-disposal-method"
               xreflabel="lsmb14.asset_disposal_method">
        <title id="lsmb14.table.asset-disposal-method-title">
         Table:
         
         <structname>asset_disposal_method</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_disposal_method</structname>
            </title>


            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>multiple</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_label</structfield></term>
              <listitem><para>
                <type>character(1)</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on asset_disposal_method</title>

          <varlistentry>
            <term>asset_disposal_method_multiple_check</term>
            <listitem><para>CHECK ((multiple = ANY (ARRAY[1, 0, (-1)])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_rl_to_disposal_method via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.asset-item"
               xreflabel="lsmb14.asset_item">
        <title id="lsmb14.table.asset-item-title">
         Table:
         
         <structname>asset_item</structname>
        </title>
 

        <para>
           Stores details of asset items.  The account fields here are authoritative,
while the ones in the asset_class table are defaults.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_item</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tag</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                 This can be plugged into other routines to generate it automatically via ALTER TABLE .... SET DEFAULT.....
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>purchase_value</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salvage_value</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>usable_life</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>purchase_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_depreciation</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.warehouse"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.eca-invoice"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dep_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>exp_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_by</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>









                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.asset-note"
               xreflabel="lsmb14.asset_note">
        <title id="lsmb14.table.asset-note-title">
         Table:
         
         <structname>asset_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 4</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-item"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on asset_note</title>

          <varlistentry>
            <term>asset_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 4))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.asset-report"
               xreflabel="lsmb14.asset_report">
        <title id="lsmb14.table.asset-report-title">
         Table:
         
         <structname>asset_report</structname>
        </title>
 

        <para>
           Asset reports are discrete sets of depreciation or disposal transctions,
and each one may be turned into no more than one GL transaction.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gl_id</structfield></term>
              <listitem><para>
                <type>bigint</type>








                      <literal>UNIQUE</literal>









                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_class</structfield></term>
              <listitem><para>
                <type>bigint</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_class</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-report-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>bigint</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>bigint</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>depreciated_qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dont_approve</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>submitted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.asset-report-class"
               xreflabel="lsmb14.asset_report_class">
        <title id="lsmb14.table.asset-report-class-title">
         Table:
         
         <structname>asset_report_class</structname>
        </title>
 

        <para>
            By default only four types of asset reports are supported.  In the future
others may be added.  Please correspond on the list before adding more types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.asset-report-line"
               xreflabel="lsmb14.asset_report_line">
        <title id="lsmb14.table.asset-report-line-title">
         Table:
         
         <structname>asset_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>asset_id</structfield></term>
              <listitem><para>
                <type>bigint</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>bigint</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

              <para>
                 In case assets are moved between departments, we have to store this here.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>warehouse_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.warehouse"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.asset-rl-to-disposal-method"
               xreflabel="lsmb14.asset_rl_to_disposal_method">
        <title id="lsmb14.table.asset-rl-to-disposal-method-title">
         Table:
         
         <structname>asset_rl_to_disposal_method</structname>
        </title>
 

        <para>
           Maps disposal method to line items in the asset disposal report.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_rl_to_disposal_method</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>disposal_method_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.asset-disposal-method"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>percent_disposed</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.asset-unit-class"
               xreflabel="lsmb14.asset_unit_class">
        <title id="lsmb14.table.asset-unit-class-title">
         Table:
         
         <structname>asset_unit_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_unit_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_dep_method via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-dep-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.audittrail"
               xreflabel="lsmb14.audittrail">
        <title id="lsmb14.table.audittrail-title">
         Table:
         
         <structname>audittrail</structname>
        </title>
 

        <para>
           This stores information on who entered or updated rows in the ar, ap, or gl
tables.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>audittrail</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tablename</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>action</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on audittrail</title>

          <varlistentry>
            <term>audittrail_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.batch"
               xreflabel="lsmb14.batch">
        <title id="lsmb14.table.batch-title">
         Table:
         
         <structname>batch</structname>
        </title>
 

        <para>
           Stores batch header info.  Batches are groups of vouchers that are posted
together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>batch</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.batch-class"/>


              </para>

              <para>
                 Note that this field is largely used for sorting the vouchers.  A given batch is NOT restricted to this type.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.session"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_on</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on batch</title>

          <varlistentry>
            <term>batch_control_code_check</term>
            <listitem><para>CHECK ((length(control_code) &gt; 0))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.voucher via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.batch-class"
               xreflabel="lsmb14.batch_class">
        <title id="lsmb14.table.batch-class-title">
         Table:
         
         <structname>batch_class</structname>
        </title>
 

        <para>
           These values are hard-coded.  Please coordinate before adding standard
values. Values from 900 to 999 are reserved for local use.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>batch_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.batch via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.bu-class-to-module"
               xreflabel="lsmb14.bu_class_to_module">
        <title id="lsmb14.table.bu-class-to-module-title">
         Table:
         
         <structname>bu_class_to_module</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>bu_class_to_module</structname>
            </title>


            <varlistentry>
              <term><structfield>bu_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>module_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.lsmb-module"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.budget-info"
               xreflabel="lsmb14.budget_info">
        <title id="lsmb14.table.budget-info-title">
         Table:
         
         <structname>budget_info</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_info</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on budget_info</title>

          <varlistentry>
            <term>budget_info_check</term>
            <listitem><para>CHECK ((start_date &lt; end_date))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.budget_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-to-business-unit"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.budget-line"
               xreflabel="lsmb14.budget_line">
        <title id="lsmb14.table.budget-line-title">
         Table:
         
         <structname>budget_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_line</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.budget-info"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.budget-note"
               xreflabel="lsmb14.budget_note">
        <title id="lsmb14.table.budget-note-title">
         Table:
         
         <structname>budget_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 6</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.budget-info"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on budget_note</title>

          <varlistentry>
            <term>budget_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 6))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.budget-to-business-unit"
               xreflabel="lsmb14.budget_to_business_unit">
        <title id="lsmb14.table.budget-to-business-unit-title">
         Table:
         
         <structname>budget_to_business_unit</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_to_business_unit</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE</literal>



                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.budget-info"/>






              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.business"
               xreflabel="lsmb14.business">
        <title id="lsmb14.table.business-title">
         Table:
         
         <structname>business</structname>
        </title>
 

        <para>
          Groups of Customers assigned joint discounts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.business-unit"
               xreflabel="lsmb14.business_unit">
        <title id="lsmb14.table.business-unit-title">
         Table:
         
         <structname>business_unit</structname>
        </title>
 

        <para>
           Tracks Projects, Departments, Funds, Etc.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE#1</literal>



                <literal>PRIMARY KEY</literal>















              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#2</literal>









                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>








                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE#2</literal>










              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-to-business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-ac"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-inv"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-jl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-oitem"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-translation"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.jcitems"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.job"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.business-unit-ac"
               xreflabel="lsmb14.business_unit_ac">
        <title id="lsmb14.table.business-unit-ac-title">
         Table:
         
         <structname>business_unit_ac</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_ac</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.acc-trans"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.business-unit-class"
               xreflabel="lsmb14.business_unit_class">
        <title id="lsmb14.table.business-unit-class-title">
         Table:
         
         <structname>business_unit_class</structname>
        </title>
 

        <para>
           Consolidates projects and departments, and allows this to be extended for
funds accounting and other purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordering</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.bu_class_to_module via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.bu-class-to-module"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-to-business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-ac"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-inv"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-jl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-oitem"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.business-unit-inv"
               xreflabel="lsmb14.business_unit_inv">
        <title id="lsmb14.table.business-unit-inv-title">
         Table:
         
         <structname>business_unit_inv</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_inv</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.invoice"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.business-unit-jl"
               xreflabel="lsmb14.business_unit_jl">
        <title id="lsmb14.table.business-unit-jl-title">
         Table:
         
         <structname>business_unit_jl</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_jl</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-line"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.business-unit-oitem"
               xreflabel="lsmb14.business_unit_oitem">
        <title id="lsmb14.table.business-unit-oitem-title">
         Table:
         
         <structname>business_unit_oitem</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_oitem</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.orderitems"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit-class"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.business-unit-translation"
               xreflabel="lsmb14.business_unit_translation">
        <title id="lsmb14.table.business-unit-translation-title">
         Table:
         
         <structname>business_unit_translation</structname>
        </title>
 

        <para>
           Translation information for projects, departments, etc.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.view.cash-impact"
               xreflabel="lsmb14.cash_impact">
        <title id="lsmb14.view.cash-impact-title">
         View:
         
         <structname>cash_impact</structname>
        </title>
 

        <para>
           This view is used by cash basis reports to determine the fraction of a
transaction to be counted.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cash_impact</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>portion</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rel</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view cash_impact</title>
         <programlisting>
(
SELECT gl.id
     , 1::numeric AS portion
     ,&apos;gl&apos;::text AS rel 
  FROM lsmb14.gl 
UNION ALLSELECT gl.id
     , CASE WHEN 
     (
           (gl.amount - sum
                 (ac.amount)
           ) = 
           (0)::numeric
     ) THEN 
     (0)::numeric ELSE 
     (gl.amount / 
           (gl.amount - sum
                 (ac.amount)
           )
     ) END AS portion
     ,&apos;ar&apos;::text AS rel 
  FROM (
           (lsmb14.ar gl 
              JOIN lsmb14.acc_trans ac 
                ON (
                       (ac.trans_id = gl.id)
                 )
           )
        JOIN lsmb14.account_link al 
          ON (
                 (
                       (ac.chart_id = al.account_id)
                     AND (al.description = &apos;AR&apos;::text)
                 )
           )
     )
GROUP BY gl.id
     , gl.amount
)
UNION ALLSELECT gl.id
, CASE WHEN 
(
     (gl.amount - sum
           (ac.amount)
     ) = 
     (0)::numeric
) THEN 
(0)::numeric ELSE 
(gl.amount / 
     (gl.amount - sum
           (ac.amount)
     )
) END AS portion
,&apos;ap&apos;::text AS rel 
FROM (
     (lsmb14.ap gl 
        JOIN lsmb14.acc_trans ac 
          ON (
                 (ac.trans_id = gl.id)
           )
     )
  JOIN lsmb14.account_link al 
    ON (
           (
                 (ac.chart_id = al.account_id)
               AND (al.description = &apos;AP&apos;::text)
           )
     )
)
GROUP BY gl.id
, gl.amount;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.view.chart"
               xreflabel="lsmb14.chart">
        <title id="lsmb14.view.chart-title">
         View:
         
         <structname>chart</structname>
        </title>
 

        <para>
          Compatibility chart for 1.2 and earlier.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>chart</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>charttype</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>category</structfield></term>
              <listitem><para>
                <type>bpchar</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>link</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_heading</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gifi_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contra</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view chart</title>
         <programlisting>
SELECT account_heading.id
, account_heading.accno
, account_heading.description
,&apos;H&apos;::text AS charttype
, NULL::bpchar AS category
, NULL::text AS link
, NULL::integer AS account_heading
, NULL::text AS gifi_accno
, false AS contra
, false AS tax 
FROM lsmb14.account_heading 
UNIONSELECT c.id
, c.accno
, c.description
,&apos;A&apos;::text AS charttype
, c.category
, lsmb14.concat_colon
(l.description) AS link
, c.heading AS account_heading
, c.gifi_accno
, c.contra
, c.tax 
FROM (lsmb14.account c 
LEFT JOIN lsmb14.account_link l 
    ON (
           (c.id = l.account_id)
     )
)
GROUP BY c.id
, c.accno
, c.description
, c.category
, c.heading
, c.gifi_accno
, c.contra
, c.tax;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.company"
               xreflabel="lsmb14.company">
        <title id="lsmb14.table.company-title">
         Table:
         
         <structname>company</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>company</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>legal_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax_id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 In the US this would be a EIN. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales_tax_id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>license_number</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sic_code</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on company</title>

          <varlistentry>
            <term>company_legal_name_check</term>
            <listitem><para>CHECK ((legal_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.person_to_company via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.contact-class"
               xreflabel="lsmb14.contact_class">
        <title id="lsmb14.table.contact-class-title">
         Table:
         
         <structname>contact_class</structname>
        </title>
 

        <para>
           Stores type of contact information attached to companies and persons.
Please coordinate with others before adding new types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>contact_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on contact_class</title>

          <varlistentry>
            <term>contact_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.eca_to_contact via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-to-contact"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.country"
               xreflabel="lsmb14.country">
        <title id="lsmb14.table.country-title">
         Table:
         
         <structname>country</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>country</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>itu</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 The ITU Telecommunication Standardization Sector code for calling internationally. For example, the US is 1, Great Britain is 44 
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on country</title>

          <varlistentry>
            <term>country_name_check</term>
            <listitem><para>CHECK ((name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>country_short_name_check</term>
            <listitem><para>CHECK ((short_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.country_tax_form via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.country-tax-form"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-deduction-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-income-class"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.country-tax-form"
               xreflabel="lsmb14.country_tax_form">
        <title id="lsmb14.table.country-tax-form-title">
         Table:
         
         <structname>country_tax_form</structname>
        </title>
 

        <para>
           This table was designed for holding information relating to reportable
sales or purchases, such as IRS 1099 forms and international equivalents.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>country_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>form_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.cr-coa-to-account"
               xreflabel="lsmb14.cr_coa_to_account">
        <title id="lsmb14.table.cr-coa-to-account-title">
         Table:
         
         <structname>cr_coa_to_account</structname>
        </title>
 

        <para>
           Provides name mapping for the cash reconciliation screen.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_coa_to_account</structname>
            </title>


            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.cr-report"
               xreflabel="lsmb14.cr_report">
        <title id="lsmb14.table.cr-report-title">
         Table:
         
         <structname>cr_report</structname>
        </title>
 

        <para>
          This table holds header data for cash reports.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_total</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>submitted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>updated</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_username</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deleted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deleted_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_username</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>recon_fx</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on cr_report</title>

          <varlistentry>
            <term>cr_report_check</term>
            <listitem><para>CHECK (((deleted IS NOT TRUE) OR (approved IS NOT TRUE)))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.cr_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.cr-report-line"
               xreflabel="lsmb14.cr_report_line">
        <title id="lsmb14.table.cr-report-line-title">
         Table:
         
         <structname>cr_report_line</structname>
        </title>
 

        <para>
           This stores line item data on transaction lines and whether they are 
cleared.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.cr-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>scn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the check number.  Maps to journal_entry.reference 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>our_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>errorcode</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>user</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>clear_time</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>insert_time</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ledger_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.acc-trans"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>overlook</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.custom-field-catalog"
               xreflabel="lsmb14.custom_field_catalog">
        <title id="lsmb14.table.custom-field-catalog-title">
         Table:
         
         <structname>custom_field_catalog</structname>
        </title>
 

        <para>
           Deprecated, use only with old code.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>custom_field_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>field_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.custom-table-catalog"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>field_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.custom-table-catalog"
               xreflabel="lsmb14.custom_table_catalog">
        <title id="lsmb14.table.custom-table-catalog-title">
         Table:
         
         <structname>custom_table_catalog</structname>
        </title>
 

        <para>
           Deprecated, use only with old code.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>custom_table_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>table_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>extends</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.custom_field_catalog via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.custom-field-catalog"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.defaults"
               xreflabel="lsmb14.defaults">
        <title id="lsmb14.table.defaults-title">
         Table:
         
         <structname>defaults</structname>
        </title>
 

        <para>
            This is a free-form table for managing application settings per company
database.  We use key-value modelling here because this most accurately maps 
the actual semantics of the data.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>defaults</structname>
            </title>


            <varlistentry>
              <term><structfield>setting_key</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>value</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.eca-invoice"
               xreflabel="lsmb14.eca_invoice">
        <title id="lsmb14.table.eca-invoice-title">
         Table:
         
         <structname>eca_invoice</structname>
        </title>
 

        <para>
           Replaces the rest of the ar and ap tables.
Also tracks payments and receipts. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_invoice</structname>
            </title>


            <varlistentry>
              <term><structfield>order_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                 Link to order it was created from
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>journal_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 On hold invoices can not be paid, and overpayments that are on hold cannot 
be used to pay invoices.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 When this is set to true, the invoice is shown with opposite normal numbers,
i.e. negatives appear as positives, and positives appear as negatives.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>due</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character(6)</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 When this is set to true, the invoice does not show up on outstanding reports
and cannot be paid.  Overpayments where this is set to true do not appear on 
outstanding reports and cannot be paid.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>order_number</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the order number of the other party.  So for a sales invoice, this 
would be a purchase order, and for a vendor invoice, this would be a sales 
order.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment-map"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.eca-note"
               xreflabel="lsmb14.eca_note">
        <title id="lsmb14.table.eca-note-title">
         Table:
         
         <structname>eca_note</structname>
        </title>
 

        <para>
           Notes for entity_credit_account entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

              <para>
                 references entity_credit_account.id
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on eca_note</title>

          <varlistentry>
            <term>eca_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 3))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.eca-tax"
               xreflabel="lsmb14.eca_tax">
        <title id="lsmb14.table.eca-tax-title">
         Table:
         
         <structname>eca_tax</structname>
        </title>
 

        <para>
           Mapping customers and vendors to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_tax</structname>
            </title>


            <varlistentry>
              <term><structfield>eca_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.eca-to-contact"
               xreflabel="lsmb14.eca_to_contact">
        <title id="lsmb14.table.eca-to-contact-title">
         Table:
         
         <structname>eca_to_contact</structname>
        </title>
 

        <para>
           To keep track of the relationship between multiple contact methods and a single vendor or customer account. For generic 
contacts, use entity_to_contact instead.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on eca_to_contact</title>

          <varlistentry>
            <term>eca_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.eca-to-location"
               xreflabel="lsmb14.eca_to_location">
        <title id="lsmb14.table.eca-to-location-title">
         Table:
         
         <structname>eca_to_location</structname>
        </title>
 

        <para>
           This table is used for locations bound to contracts.  For generic contact
addresses, use entity_to_location instead 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.location-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.employee-class"
               xreflabel="lsmb14.employee_class">
        <title id="lsmb14.table.employee-class-title">
         Table:
         
         <structname>employee_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_class</structname>
            </title>


            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.employee_to_ec via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.employee-to-ec"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.view.employee-search"
               xreflabel="lsmb14.employee_search">
        <title id="lsmb14.view.employee-search-title">
         View:
         
         <structname>employee_search</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_search</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view employee_search</title>
         <programlisting>
SELECT e.entity_id
, e.startdate
, e.enddate
, e.role
, e.ssn
, e.sales
, e.manager_id
, e.employeenumber
, e.dob
, em.name AS manager
, emn.note
, en.name 
FROM (
     (
           (
                 (lsmb14.entity_employee e 
               LEFT JOIN lsmb14.entity en 
                      ON (
                             (e.entity_id = en.id)
                       )
                 )
         LEFT JOIN lsmb14.entity_employee m 
                ON (
                       (e.manager_id = m.entity_id)
                 )
           )
   LEFT JOIN lsmb14.entity em 
          ON (
                 (em.id = m.entity_id)
           )
     )
LEFT JOIN lsmb14.entity_note emn 
    ON (
           (emn.ref_key = em.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.employee-to-ec"
               xreflabel="lsmb14.employee_to_ec">
        <title id="lsmb14.table.employee-to-ec-title">
         Table:
         
         <structname>employee_to_ec</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_to_ec</structname>
            </title>


            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ec_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.employee-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.view.employees"
               xreflabel="lsmb14.employees">
        <title id="lsmb14.view.employees-title">
         View:
         
         <structname>employees</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employees</structname>
            </title>


            <varlistentry>
              <term><structfield>salutation</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>first_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view employees</title>
         <programlisting>
SELECT s.salutation
, p.first_name
, p.last_name
, ee.entity_id
, ee.startdate
, ee.enddate
, ee.role
, ee.ssn
, ee.sales
, ee.manager_id
, ee.employeenumber
, ee.dob 
FROM (
     (lsmb14.person p 
        JOIN lsmb14.entity_employee ee 
       USING (entity_id)
     )
LEFT JOIN lsmb14.salutation s 
    ON (
           (p.salutation_id = s.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.entity"
               xreflabel="lsmb14.entity">
        <title id="lsmb14.table.entity-title">
         Table:
         
         <structname>entity</structname>
        </title>
 

        <para>
           The primary entity table to map to all contacts 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the common name of an entity. If it was a person it may be Joshua Drake, a company Acme Corp. You may also choose to use a domain such as commandprompt.com 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_class</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-class"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>



                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT setting_increment(&apos;entity_control&apos;::character varying)</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity</title>

          <varlistentry>
            <term>entity_name_check</term>
            <listitem><para>CHECK ((name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.budget-info"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.company"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.cr-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-bank-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-employee"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-other-name"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-base"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-secondary-attachment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-entry"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-deduction"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-paid-timeoff"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-wage"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.person"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.transactions"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.users"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.entity-bank-account"
               xreflabel="lsmb14.entity_bank_account">
        <title id="lsmb14.table.entity-bank-account-title">
         Table:
         
         <structname>entity_bank_account</structname>
        </title>
 

        <para>
          This stores bank account information for both companies and persons.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_bank_account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bic</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 Banking Institution Code, such as routing number of SWIFT code.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>iban</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 International Bank Account Number.  used to store the actual account number
for the banking institution.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.entity-class"
               xreflabel="lsmb14.entity_class">
        <title id="lsmb14.table.entity-class-title">
         Table:
         
         <structname>entity_class</structname>
        </title>
 

        <para>
           Defines the class type such as vendor, customer, contact, employee 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 The first 7 values are reserved and 
permanent.  Individuals who create new classes, however, should coordinate 
with others for ranges to use.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_class</title>

          <varlistentry>
            <term>entity_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity_class</title>

          <varlistentry>
            <term>entity_class_idx</term>
            <listitem><para>lower(class)</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.entity via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.entity-credit-account"
               xreflabel="lsmb14.entity_credit_account">
        <title id="lsmb14.table.entity-credit-account-title">
         Table:
         
         <structname>entity_credit_account</structname>
        </title>
 

        <para>
          This table stores information relating to general relationships regarding 
moneys owed on invoice.  Invoices, whether AR or AP, must be attached to 
a record in this table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_credit_account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pay_to_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount_terms</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>creditlimit</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>meta_number</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 This stores the human readable control code for the customer/vendor record.
This is typically called the customer/vendor &quot;account&quot; in the application.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>business_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>









                <literal>DEFAULT &apos;en&apos;::character varying</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.pricegroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>threshold</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>primary_contact</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ar_ap_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cash_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bank_account</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-bank-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxform_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country-tax-form"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_credit_account</title>

          <varlistentry>
            <term>entity_credit_account_check</term>
            <listitem><para>CHECK (((ar_ap_account_id IS NOT NULL) OR (entity_id = 0)))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>entity_credit_account_entity_class_check</term>
            <listitem><para>CHECK ((entity_class = ANY (ARRAY[1, 2])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-eca"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.partscustomer"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.partsvendor"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.entity-employee"
               xreflabel="lsmb14.entity_employee">
        <title id="lsmb14.table.entity-employee-title">
         Table:
         
         <structname>entity_employee</structname>
        </title>
 

        <para>
           This contains employee-specific extensions to person/entity. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_employee</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.employee-to-ec"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.inventory"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.entity-note"
               xreflabel="lsmb14.entity_note">
        <title id="lsmb14.table.entity-note-title">
         Table:
         
         <structname>entity_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_note</title>

          <varlistentry>
            <term>entity_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity_note</title>

          <varlistentry>
            <term>entity_note_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>entity_note_vectors_idx</term>
            <listitem><para>vector</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.entity-other-name"
               xreflabel="lsmb14.entity_other_name">
        <title id="lsmb14.table.entity-other-name-title">
         Table:
         
         <structname>entity_other_name</structname>
        </title>
 

        <para>
           Similar to company_other_name, a person
may be jd, Joshua Drake, linuxpoet... all are the same person.  Currently
unused in the front-end but will likely be added in future versions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_other_name</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>other_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_other_name</title>

          <varlistentry>
            <term>entity_other_name_other_name_check</term>
            <listitem><para>CHECK ((other_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.entity-to-contact"
               xreflabel="lsmb14.entity_to_contact">
        <title id="lsmb14.table.entity-to-contact-title">
         Table:
         
         <structname>entity_to_contact</structname>
        </title>
 

        <para>
           This table stores contact information for entities
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_to_contact</title>

          <varlistentry>
            <term>entity_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.entity-to-location"
               xreflabel="lsmb14.entity_to_location">
        <title id="lsmb14.table.entity-to-location-title">
         Table:
         
         <structname>entity_to_location</structname>
        </title>
 

        <para>
           This table is used for locations generic to companies.  For contract-bound
addresses, use eca_to_location instead 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.location-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.exchangerate"
               xreflabel="lsmb14.exchangerate">
        <title id="lsmb14.table.exchangerate-title">
         Table:
         
         <structname>exchangerate</structname>
        </title>
 

        <para>
           When you receive money in a foreign currency, it is worth to you in your local currency
whatever you can get for it when you sell the acquired currency (sell rate).
When you have to pay someone in a foreign currency, the equivalent amount is the amount
you have to spend to acquire the foreign currency (buy rate).
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>exchangerate</structname>
            </title>


            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>buy</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sell</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on exchangerate</title>

          <varlistentry>
            <term>exchangerate_ct_key</term>
            <listitem><para>curr, transdate</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.file-base"
               xreflabel="lsmb14.file_base">
        <title id="lsmb14.table.file-base-title">
         Table:
         
         <structname>file_base</structname>
        </title>
 

        <para>
          Abstract table, holds no records.  Inheriting table store actual file
attachment data. Can be queried however to retrieve lists of all files. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_base</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.mime-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                This column inheriting tables is used to reference the database row for the
attachment.  Inheriting tables MUST set the foreign key here appropriately.

This can also be used to create classifications of other documents, such as by
source of automatic import (where the file is not yet attached) or
even standard,
long-lived documents.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-class"
               xreflabel="lsmb14.file_class">
        <title id="lsmb14.table.file-class-title">
         Table:
         
         <structname>file_class</structname>
        </title>
 

        <para>
           File classes are collections of files attached against rows in specific 
tables in the database.  They can be used in the future to implement other form 
of file attachment. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.file_base via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-base"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-secondary-attachment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-view-catalog"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.file-eca"
               xreflabel="lsmb14.file_eca">
        <title id="lsmb14.table.file-eca-title">
         Table:
         
         <structname>file_eca</structname>
        </title>
 

        <para>
           File attachments primarily attached to customer and vendor agreements.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_eca</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_eca</title>

          <varlistentry>
            <term>file_eca_file_class_check</term>
            <listitem><para>CHECK ((file_class = 5))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-entity"
               xreflabel="lsmb14.file_entity">
        <title id="lsmb14.table.file-entity-title">
         Table:
         
         <structname>file_entity</structname>
        </title>
 

        <para>
           File attachments primarily attached to entities.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_entity</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_entity</title>

          <varlistentry>
            <term>file_entity_file_class_check</term>
            <listitem><para>CHECK ((file_class = 4))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.view.file-links"
               xreflabel="lsmb14.file_links">
        <title id="lsmb14.view.file-links-title">
         View:
         
         <structname>file_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_links</title>
         <programlisting>
SELECT file_tx_links.file_id
, file_tx_links.ref_key
, file_tx_links.reference
, file_tx_links.type
, file_tx_links.dest_class
, file_tx_links.source_class
, file_tx_links.dest_ref 
FROM lsmb14.file_tx_links 
UNIONSELECT file_order_links.file_id
, file_order_links.ref_key
, file_order_links.reference
, file_order_links.oe_class AS type
, file_order_links.dest_class
, file_order_links.source_class
, file_order_links.dest_ref 
FROM lsmb14.file_order_links;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.file-order"
               xreflabel="lsmb14.file_order">
        <title id="lsmb14.table.file-order-title">
         Table:
         
         <structname>file_order</structname>
        </title>
 

        <para>
           File attachments primarily attached to orders and quotations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order</title>

          <varlistentry>
            <term>file_order_file_class_check</term>
            <listitem><para>CHECK ((file_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.file_order_to_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-order-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-order-to-tx"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.view.file-order-links"
               xreflabel="lsmb14.file_order_links">
        <title id="lsmb14.view.file-order-links-title">
         View:
         
         <structname>file_order_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_order_links</title>
         <programlisting>
SELECT sl.file_id
, sl.ref_key
, oe.ordnumber AS reference
, oc.oe_class
, sl.dest_class
, sl.source_class
, sl.ref_key AS dest_ref 
FROM (
     (lsmb14.file_secondary_attachment sl 
        JOIN lsmb14.oe 
          ON (
                 (sl.ref_key = oe.id)
           )
     )
  JOIN lsmb14.oe_class oc 
    ON (
           (oe.oe_class_id = oc.id)
     )
)
WHERE (sl.source_class = 2);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.file-order-to-order"
               xreflabel="lsmb14.file_order_to_order">
        <title id="lsmb14.table.file-order-to-order-title">
         Table:
         
         <structname>file_order_to_order</structname>
        </title>
 

        <para>
           Secondary links from one order to another, for example to support order
consolidation.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_to_order</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-order"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order_to_order</title>

          <varlistentry>
            <term>file_order_to_order_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 2))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_order_to_order_source_class_check</term>
            <listitem><para>CHECK ((source_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-order-to-tx"
               xreflabel="lsmb14.file_order_to_tx">
        <title id="lsmb14.table.file-order-to-tx-title">
         Table:
         
         <structname>file_order_to_tx</structname>
        </title>
 

        <para>
           Secondary links from orders to transactions, for example to track files when
invoices are generated from orders.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_to_tx</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-order"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order_to_tx</title>

          <varlistentry>
            <term>file_order_to_tx_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 1))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_order_to_tx_source_class_check</term>
            <listitem><para>CHECK ((source_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-part"
               xreflabel="lsmb14.file_part">
        <title id="lsmb14.table.file-part-title">
         Table:
         
         <structname>file_part</structname>
        </title>
 

        <para>
           File attachments primarily attached to goods and services.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_part</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_part</title>

          <varlistentry>
            <term>file_part_file_class_check</term>
            <listitem><para>CHECK ((file_class = 3))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-secondary-attachment"
               xreflabel="lsmb14.file_secondary_attachment">
        <title id="lsmb14.table.file-secondary-attachment-title">
         Table:
         
         <structname>file_secondary_attachment</structname>
        </title>
 

        <para>
          Another abstract table.  This one will use rewrite rules to make inserts safe
because of the difficulty in managing inserts otherwise. Inheriting tables 
provide secondary links between the file and other database objects.

Due to the nature of database inheritance and unique constraints
in PostgreSQL, this must be partitioned in a star format.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_secondary_attachment</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-transaction"
               xreflabel="lsmb14.file_transaction">
        <title id="lsmb14.table.file-transaction-title">
         Table:
         
         <structname>file_transaction</structname>
        </title>
 

        <para>
           File attachments primarily attached to AR/AP/GL.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_transaction</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_transaction</title>

          <varlistentry>
            <term>file_transaction_file_class_check</term>
            <listitem><para>CHECK ((file_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.file_tx_to_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-tx-to-order"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.view.file-tx-links"
               xreflabel="lsmb14.file_tx_links">
        <title id="lsmb14.view.file-tx-links-title">
         View:
         
         <structname>file_tx_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_tx_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_tx_links</title>
         <programlisting>
SELECT sl.file_id
, sl.ref_key
, gl.reference
, gl.type
, sl.dest_class
, sl.source_class
, sl.ref_key AS dest_ref 
FROM (lsmb14.file_secondary_attachment sl 
  JOIN (
           (
            SELECT gl.id
                 , gl.reference
                 ,&apos;gl&apos;::text AS type 
              FROM lsmb14.gl 
             UNIONSELECT ar.id
                 , ar.invnumber
                 , CASE WHEN ar.invoice THEN &apos;is&apos;::text ELSE &apos;ar&apos;::text END AS type 
              FROM lsmb14.ar
           )
       UNIONSELECT ap.id
           , ap.invnumber
           , CASE WHEN ap.invoice THEN &apos;ir&apos;::text ELSE &apos;ap&apos;::text END AS type 
        FROM lsmb14.ap
     ) gl 
    ON (
           (
                 (sl.ref_key = gl.id)
               AND (sl.source_class = 1)
           )
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.file-tx-to-order"
               xreflabel="lsmb14.file_tx_to_order">
        <title id="lsmb14.table.file-tx-to-order-title">
         Table:
         
         <structname>file_tx_to_order</structname>
        </title>
 

        <para>
           Secondary links from journal entries to orders.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_tx_to_order</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-transaction"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_tx_to_order</title>

          <varlistentry>
            <term>file_tx_to_order_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 2))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_tx_to_order_source_class_check</term>
            <listitem><para>CHECK ((source_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.file-view-catalog"
               xreflabel="lsmb14.file_view_catalog">
        <title id="lsmb14.table.file-view-catalog-title">
         Table:
         
         <structname>file_view_catalog</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_view_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>view_name</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.gifi"
               xreflabel="lsmb14.gifi">
        <title id="lsmb14.table.gifi-title">
         Table:
         
         <structname>gifi</structname>
        </title>
 

        <para>
           GIFI labels for accounts, used in Canada and some EU countries for tax 
reporting
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>gifi</structname>
            </title>


            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.gl"
               xreflabel="lsmb14.gl">
        <title id="lsmb14.table.gl-title">
         Table:
         
         <structname>gl</structname>
        </title>
 

        <para>
           This table holds summary information for entries in the general journal.
Does not hold summary information in 1.3 for AR or AP entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>gl</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>


              </para>

              <para>
                 the person_id of the employee who created
the entry.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payment via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.yearend"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.inventory"
               xreflabel="lsmb14.inventory">
        <title id="lsmb14.table.inventory-title">
         Table:
         
         <structname>inventory</structname>
        </title>
 

        <para>
           This table contains inventory mappings to warehouses, not general inventory
management data.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>warehouse_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>orderitems_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.inventory-report"
               xreflabel="lsmb14.inventory_report">
        <title id="lsmb14.table.inventory-report-title">
         Table:
         
         <structname>inventory_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ar_trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ap_trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.inventory_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.inventory-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.inventory-report-line"
               xreflabel="lsmb14.inventory_report_line">
        <title id="lsmb14.table.inventory-report-line-title">
         Table:
         
         <structname>inventory_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.inventory-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>counted</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>expected</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.invoice"
               xreflabel="lsmb14.invoice">
        <title id="lsmb14.table.invoice-title">
         Table:
         
         <structname>invoice</structname>
        </title>
 

        <para>
          Line items of invoices with goods/services attached.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                Positive is normal for sales invoices, negative for vendor invoices.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>allocated</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                Number of allocated items, negative relative to qty.
When qty + allocated = 0, then the item is fully used for purposes of COGS 
calculations.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>precision</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fxsellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>assemblyitem</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deliverydate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on invoice</title>

          <varlistentry>
            <term>invoice_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>invoice_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.business_unit_inv via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-inv"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.invoice-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.invoice-tax-form"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.invoice-note"
               xreflabel="lsmb14.invoice_note">
        <title id="lsmb14.table.invoice-note-title">
         Table:
         
         <structname>invoice_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.invoice"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on invoice_note</title>

          <varlistentry>
            <term>invoice_note_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>invoice_note_vectors_idx</term>
            <listitem><para>vector</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.invoice-tax-form"
               xreflabel="lsmb14.invoice_tax_form">
        <title id="lsmb14.table.invoice-tax-form-title">
         Table:
         
         <structname>invoice_tax_form</structname>
        </title>
 

        <para>
           Maping invoice to country_tax_form.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.invoice"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.jcitems"
               xreflabel="lsmb14.jcitems">
        <title id="lsmb14.table.jcitems-title">
         Table:
         
         <structname>jcitems</structname>
        </title>
 

        <para>
           Time and materials cards. 
Materials cards not implemented.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>jcitems</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>business_unit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>allocated</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fxsellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>checkedin</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>checkedout</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>total</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>non_billable</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on jcitems</title>

          <varlistentry>
            <term>jcitems_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.job"
               xreflabel="lsmb14.job">
        <title id="lsmb14.table.job-title">
         Table:
         
         <structname>job</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>job</structname>
            </title>


            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                 Job costing/manufacturing here not implemented.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>production</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>completed</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.journal-entry"
               xreflabel="lsmb14.journal_entry">
        <title id="lsmb14.table.journal-entry-title">
         Table:
         
         <structname>journal_entry</structname>
        </title>
 

        <para>
          
This tale records the header information for each transaction.  It replaces 
parts of the following tables:  acc_trans, ar, ap, gl, transactions.

Note now all ar/ap transactions are also journal entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_entry</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 Invoice number or journal entry number.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.session"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>journal</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>effective_start</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 For transactions whose effects are spread out over a period of time, this is
the effective start date for the transaction.  To be used by add-ons for 
automating adjustments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>effective_end</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 For transactions whose effects are spread out over a period of time, this is
the effective end date for the transaction.  To be used by add-ons for 
automating adjustments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>currency</structfield></term>
              <listitem><para>
                <type>character(3)</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_template</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 Set true for template transactions.  Templates can never be approved but can
be copied into new transactions and are useful for recurrances. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on journal_entry</title>

          <varlistentry>
            <term>journal_entry_check</term>
            <listitem><para>CHECK (((is_template IS FALSE) OR (approved IS FALSE)))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-order-to-tx"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-transaction"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.new-shipto"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.journal-line"
               xreflabel="lsmb14.journal_line">
        <title id="lsmb14.table.journal-line-title">
         Table:
         
         <structname>journal_line</structname>
        </title>
 

        <para>
           Replaces acc_trans as the main account transaction line table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>journal_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 Still needed both for legacy data and in case reconciliation data must 
eventually be purged.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reconciliation_report</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.cr-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_type</structfield></term>
              <listitem><para>
                <type>text</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account-link-description"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on journal_line</title>

          <varlistentry>
            <term>journal_line_amount_check</term>
            <listitem><para>CHECK ((amount &lt;&gt; &apos;NaN&apos;::numeric))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.business_unit_jl via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-jl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment-map"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.tax-extended"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.journal-note"
               xreflabel="lsmb14.journal_note">
        <title id="lsmb14.table.journal-note-title">
         Table:
         
         <structname>journal_note</structname>
        </title>
 

        <para>
           This stores notes attached to journal entries, including payments and
invoices.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>internal_only</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 When set to true, does not show up in notes list for invoice templates
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on journal_note</title>

          <varlistentry>
            <term>journal_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 5))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.journal-type"
               xreflabel="lsmb14.journal_type">
        <title id="lsmb14.table.journal-type-title">
         Table:
         
         <structname>journal_type</structname>
        </title>
 

        <para>
           This table describes the journal entry type of the transaction.  The 
following values are hard coded by default:
1:  General journal
2:  Sales (AR)
3:  Purchases (AP)
4:  Receipts
5:  Payments


        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.journal_entry via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-entry"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.language"
               xreflabel="lsmb14.language">
        <title id="lsmb14.table.language-title">
         Table:
         
         <structname>language</structname>
        </title>
 

        <para>
           Languages for manual translations and so forth.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>language</structname>
            </title>


            <varlistentry>
              <term><structfield>code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.eca_invoice via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.user-preference"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.location"
               xreflabel="lsmb14.location">
        <title id="lsmb14.table.location-title">
         Table:
         
         <structname>location</structname>
        </title>
 

        <para>
          
This table stores addresses, such as shipto and bill to addresses.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>location</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_one</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_two</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_three</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>city</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>state</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mail_code</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>inactive_date</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on location</title>

          <varlistentry>
            <term>location_city_check</term>
            <listitem><para>CHECK ((city ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_line_one_check</term>
            <listitem><para>CHECK ((line_one ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_mail_code_check</term>
            <listitem><para>CHECK ((mail_code ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_state_check</term>
            <listitem><para>CHECK ((state ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.eca_to_location via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.new-shipto"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.location-class"
               xreflabel="lsmb14.location_class">
        <title id="lsmb14.table.location-class-title">
         Table:
         
         <structname>location_class</structname>
        </title>
 

        <para>
          
Individuals seeking to add new location classes should coordinate with others.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>location_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>authoritative</structfield></term>
              <listitem><para>
                <type>boolean</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on location_class</title>

          <varlistentry>
            <term>location_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.eca_to_location via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-to-location"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.lsmb-group"
               xreflabel="lsmb14.lsmb_group">
        <title id="lsmb14.table.lsmb-group-title">
         Table:
         
         <structname>lsmb_group</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_group</structname>
            </title>


            <varlistentry>
              <term><structfield>role_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.lsmb_group_grants via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.lsmb-group-grants"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.lsmb-group-grants"
               xreflabel="lsmb14.lsmb_group_grants">
        <title id="lsmb14.table.lsmb-group-grants-title">
         Table:
         
         <structname>lsmb_group_grants</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_group_grants</structname>
            </title>


            <varlistentry>
              <term><structfield>group_name</structfield></term>
              <listitem><para>
                <type>text</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.lsmb-group"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>granted_role</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.lsmb-module"
               xreflabel="lsmb14.lsmb_module">
        <title id="lsmb14.table.lsmb-module-title">
         Table:
         
         <structname>lsmb_module</structname>
        </title>
 

        <para>
           This stores categories functionality into modules.  Addons may add rows here, but 
the id should be hardcoded.  As always 900-1000 will be reserved for internal use, 
and negative numbers will be reserved for testing.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_module</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.bu_class_to_module via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.bu-class-to-module"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.lsmb-roles"
               xreflabel="lsmb14.lsmb_roles">
        <title id="lsmb14.table.lsmb-roles-title">
         Table:
         
         <structname>lsmb_roles</structname>
        </title>
 

        <para>
           Tracks role assignments in the front end.  Not sure why we need this.  Will
rethink for 1.4.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_roles</structname>
            </title>


            <varlistentry>
              <term><structfield>user_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.makemodel"
               xreflabel="lsmb14.makemodel">
        <title id="lsmb14.table.makemodel-title">
         Table:
         
         <structname>makemodel</structname>
        </title>
 

        <para>
           A single parts entry can have multiple make/model entries.  These
store manufacturer/model number info.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>makemodel</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>barcode</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>make</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>model</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on makemodel</title>

          <varlistentry>
            <term>makemodel_make_key</term>
            <listitem><para>lower(make)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>makemodel_model_key</term>
            <listitem><para>lower(model)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>makemodel_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.menu-acl"
               xreflabel="lsmb14.menu_acl">
        <title id="lsmb14.table.menu-acl-title">
         Table:
         
         <structname>menu_acl</structname>
        </title>
 

        <para>
          Provides access control list entries for menu nodes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_acl</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role_name</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>acl_type</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

              <para>
                 Nodes are hidden unless a role is found of which the user is a member, and
where the acl_type for that role type and node is set to &apos;allow&apos; and no acl is 
found for any role of which the user is a member, where the acl_type is set to
&apos;deny&apos;.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>node_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on menu_acl</title>

          <varlistentry>
            <term>menu_acl_acl_type_check</term>
            <listitem><para>CHECK ((((acl_type)::text = &apos;allow&apos;::text) OR ((acl_type)::text = &apos;deny&apos;::text)))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.menu-attribute"
               xreflabel="lsmb14.menu_attribute">
        <title id="lsmb14.table.menu-attribute-title">
         Table:
         
         <structname>menu_attribute</structname>
        </title>
 

        <para>
           This table stores the callback information for each menu item.  The 
attributes are stored in key/value modelling because of the fact that this
best matches the semantic structure of the information.

Each node should have EITHER a menu or a module attribute, menu for a menu with 
sub-items, module for an executiable script.  The module attribute identifies
the perl script to be run.  The action attribute identifies the entry point.

Beyond this, any other attributes that should be passed in can be done as other
attributes.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_attribute</structname>
            </title>


            <varlistentry>
              <term><structfield>node_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attribute</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>value</structfield></term>
              <listitem><para>
                <type>character varying</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.view.menu-friendly"
               xreflabel="lsmb14.menu_friendly">
        <title id="lsmb14.view.menu-friendly-title">
         View:
         
         <structname>menu_friendly</structname>
        </title>
 

        <para>
           A nice human-readable view for investigating the menu tree.  Does not
show menu attributes or acls.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_friendly</structname>
            </title>


            <varlistentry>
              <term><structfield>level</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>path</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>position</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view menu_friendly</title>
         <programlisting>WITH RECURSIVE tree
(path
     , id
     , parent
     , level
     , positions
) AS 
(
SELECT (menu_node.id)::text AS path
     , menu_node.id
     , menu_node.parent
     , 0 AS level
     , (menu_node.&quot;position&quot;)::text AS &quot;position&quot;
  FROM lsmb14.menu_node 
 WHERE (menu_node.parent IS NULL)
 UNIONSELECT (
           (t.path || 
               &apos;,&apos;::text
           ) || 
           (n.id)::text
     )
     , n.id
     , n.parent
     , (t.level + 1)
     , (
           (t.positions || 
               &apos;,&apos;::text
           ) || n.&quot;position&quot;
     )
  FROM (lsmb14.menu_node n 
        JOIN tree t 
          ON (
                 (t.id = n.parent)
           )
     )
)
SELECT t.level
, t.path
, (repeat
     (&apos; &apos;::text
           , (2 * t.level)
     ) || 
     (n.label)::text
) AS label
, n.id
, n.&quot;position&quot;
FROM (tree t 
  JOIN lsmb14.menu_node n 
 USING (id)
)
ORDER BY (string_to_array
     (t.positions
           ,&apos;,&apos;::text
     )
)::integer[];</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.menu-node"
               xreflabel="lsmb14.menu_node">
        <title id="lsmb14.table.menu-node-title">
         Table:
         
         <structname>menu_node</structname>
        </title>
 

        <para>
          This table stores the tree structure of the menu.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_node</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>character varying</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>









                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>position</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.menu_acl via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.menu-acl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.menu-attribute"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.menu-node"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.mime-type"
               xreflabel="lsmb14.mime_type">
        <title id="lsmb14.table.mime-type-title">
         Table:
         
         <structname>mime_type</structname>
        </title>
 

        <para>
           This is a lookup table for storing MIME types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>mime_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_include</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.file_base via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-base"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.new-shipto"
               xreflabel="lsmb14.new_shipto">
        <title id="lsmb14.table.new-shipto-title">
         Table:
         
         <structname>new_shipto</structname>
        </title>
 

        <para>
           Tracks ship_to information for orders and invoices.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>new_shipto</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.location"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.note"
               xreflabel="lsmb14.note">
        <title id="lsmb14.table.note-title">
         Table:
         
         <structname>note</structname>
        </title>
 

        <para>
           This is an abstract table which should have zero rows.  It is inherited by
other tables for specific notes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.note-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                Body of note.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

              <para>
                tsvector for full text indexing, requires 
both setting up tsearch dictionaries and adding triggers to use at present.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 Subclassed tables use this column as a foreign key against the table storing
the record a note is attached to.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.note-class"
               xreflabel="lsmb14.note_class">
        <title id="lsmb14.table.note-class-title">
         Table:
         
         <structname>note_class</structname>
        </title>
 

        <para>
           Coordinate with others before adding entries. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>note_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on note_class</title>

          <varlistentry>
            <term>note_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.note via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.note"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.oe"
               xreflabel="lsmb14.oe">
        <title id="lsmb14.table.oe-title">
         Table:
         
         <structname>oe</structname>
        </title>
 

        <para>
           Header information for:
* Sales orders
* Purchase Orders
* Quotations
* Requests for Quotation

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>oe</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reqdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>closed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quotation</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.oe-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on oe</title>

          <varlistentry>
            <term>oe_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>oe_ordnumber_key</term>
            <listitem><para>ordnumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>oe_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.file_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-order-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-tx-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.new-shipto"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.oe-class"
               xreflabel="lsmb14.oe_class">
        <title id="lsmb14.table.oe-class-title">
         Table:
         
         <structname>oe_class</structname>
        </title>
 

        <para>
           Hardwired classifications for orders and quotations. 
Coordinate before adding.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>oe_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>smallint</type>




                      <literal>UNIQUE</literal>










              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on oe_class</title>

          <varlistentry>
            <term>oe_class_id_check</term>
            <listitem><para>CHECK ((id = ANY (ARRAY[1, 2, 3, 4])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.oe via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.oe"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.open-forms"
               xreflabel="lsmb14.open_forms">
        <title id="lsmb14.table.open-forms-title">
         Table:
         
         <structname>open_forms</structname>
        </title>
 

        <para>
           This is our primary anti-xsrf measure, as this allows us to require a full
round trip to the web server in order to save data.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>open_forms</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>session_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.session"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.orderitems"
               xreflabel="lsmb14.orderitems">
        <title id="lsmb14.table.orderitems-title">
         Table:
         
         <structname>orderitems</structname>
        </title>
 

        <para>
           Line items for sales/purchase orders and quotations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>orderitems</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>precision</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reqdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ship</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on orderitems</title>

          <varlistentry>
            <term>orderitems_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>orderitems_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.business_unit_oitem via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.business-unit-oitem"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.view.overpayments"
               xreflabel="lsmb14.overpayments">
        <title id="lsmb14.view.overpayments-title">
         View:
         
         <structname>overpayments</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>overpayments</structname>
            </title>


            <varlistentry>
              <term><structfield>payment_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>available</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>legal_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>meta_number</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view overpayments</title>
         <programlisting>
SELECT p.id AS payment_id
, p.reference AS payment_reference
, p.payment_class
, p.closed AS payment_closed
, p.payment_date
, ac.chart_id
, c.accno
, c.description AS chart_description
, abs
(sum
     (ac.amount)
) AS available
, cmp.legal_name
, eca.id AS entity_credit_id
, eca.entity_id
, eca.discount
, eca.meta_number 
FROM (
     (
           (
                 (
                       (lsmb14.payment p 
                          JOIN lsmb14.payment_links pl 
                            ON (
                                   (pl.payment_id = p.id)
                             )
                       )
                    JOIN lsmb14.acc_trans ac 
                      ON (
                             (ac.entry_id = pl.entry_id)
                       )
                 )
              JOIN lsmb14.chart c 
                ON (
                       (c.id = ac.chart_id)
                 )
           )
        JOIN lsmb14.entity_credit_account eca 
          ON (
                 (eca.id = p.entity_credit_id)
           )
     )
  JOIN lsmb14.company cmp 
    ON (
           (cmp.entity_id = eca.entity_id)
     )
)
WHERE (
     (
           (p.gl_id IS NOT NULL)
         AND (
                 (pl.type = 2)
                OR (pl.type = 0)
           )
     )
   AND (c.link ~~ &apos;%overpayment%&apos;::text)
)
GROUP BY p.id
, c.accno
, p.reference
, p.payment_class
, p.closed
, p.payment_date
, ac.chart_id
, c.description
, cmp.legal_name
, eca.id
, eca.entity_id
, eca.discount
, eca.meta_number;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.parts"
               xreflabel="lsmb14.parts">
        <title id="lsmb14.table.parts-title">
         Table:
         
         <structname>parts</structname>
        </title>
 

        <para>
          This stores detail information about goods and services.  The type of part
is currently defined according to the following rules:
* If assembly is true, then an assembly
* If inventory_accno_id, income_accno_id, and expense_accno_id are not null then
  a part.
* If inventory_accno_id is null but the other two are not, then a service.
* Otherwise, a labor/overhead entry.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>parts</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>listprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>lastcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>priceupdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>weight</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>onhand</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>makemodel</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>assembly</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>alternate</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rop</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                Re-order point.  Used to select parts for short inventory report.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>inventory_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>income_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>expense_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>returns_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bin</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Text identifier for where a part is stored.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bom</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                Show on Bill of Materials.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>image</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Hyperlink to product image.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>drawing</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>microfiche</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partsgroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>avgcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on parts</title>

          <varlistentry>
            <term>parts_description_key</term>
            <listitem><para>lower(description)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>parts_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>parts_partnumber_key</term>
            <listitem><para>lower(partnumber)</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.assembly via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.assembly"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.file-part"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.inventory-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.parts-translation"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.partstax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.parts-translation"
               xreflabel="lsmb14.parts_translation">
        <title id="lsmb14.table.parts-translation-title">
         Table:
         
         <structname>parts_translation</structname>
        </title>
 

        <para>
           Translation information for parts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>parts_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.partscustomer"
               xreflabel="lsmb14.partscustomer">
        <title id="lsmb14.table.partscustomer-title">
         Table:
         
         <structname>partscustomer</structname>
        </title>
 

        <para>
           Tracks per-customer pricing.  Discounts can be offered for periods of time
and for pricegroups as well as per customer
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partscustomer</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.pricegroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricebreak</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validfrom</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validto</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.partsgroup"
               xreflabel="lsmb14.partsgroup">
        <title id="lsmb14.table.partsgroup-title">
         Table:
         
         <structname>partsgroup</structname>
        </title>
 

        <para>
           Groups of parts for Point of Sale screen.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsgroup</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partsgroup</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.partsgroup"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partsgroup</title>

          <varlistentry>
            <term>partsgroup_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.partsgroup via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.partsgroup"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.partsgroup-translation"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.partsgroup-translation"
               xreflabel="lsmb14.partsgroup_translation">
        <title id="lsmb14.table.partsgroup-translation-title">
         Table:
         
         <structname>partsgroup_translation</structname>
        </title>
 

        <para>
           Translation information for partsgroups.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsgroup_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.partsgroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.partstax"
               xreflabel="lsmb14.partstax">
        <title id="lsmb14.table.partstax-title">
         Table:
         
         <structname>partstax</structname>
        </title>
 

        <para>
           Mapping of parts to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partstax</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.parts"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxcategory_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.taxcategory"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partstax</title>

          <varlistentry>
            <term>partstax_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.partsvendor"
               xreflabel="lsmb14.partsvendor">
        <title id="lsmb14.table.partsvendor-title">
         Table:
         
         <structname>partsvendor</structname>
        </title>
 

        <para>
           Tracks vendor&apos;s pricing, as well as vendor&apos;s part number, lead time 
required and currency.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsvendor</structname>
            </title>


            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>leadtime</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>lastcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partsvendor</title>

          <varlistentry>
            <term>partsvendor_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.payment"
               xreflabel="lsmb14.payment">
        <title id="lsmb14.table.payment-title">
         Table:
         
         <structname>payment</structname>
        </title>
 

        <para>
           This table will store the main data on a payment, prepayment, overpayment, et
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 This field will store the code for both receipts and payment order  
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gl_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.gl"/>


              </para>

              <para>
                 A payment should always be linked to a GL movement 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>closed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 This will store the current state of a payment/receipt order 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>currency</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on payment</title>

          <varlistentry>
            <term>payment_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.payment_links via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment-links"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payment-links"
               xreflabel="lsmb14.payment_links">
        <title id="lsmb14.table.payment-links-title">
         Table:
         
         <structname>payment_links</structname>
        </title>
 

        <para>
            
 An explanation to the type field.
 * A type 0 means the link is referencing an ar/ap  and was created
   using an overpayment movement after the receipt was created 
 * A type 1 means the link is referencing an ar/ap and  was made 
   on the payment creation, its not the product of an overpayment movement 
 * A type 2 means the link is not referencing an ar/ap and its the product
   of the overpayment logic 

 With this ideas in order we can do the following

 To get the payment amount we will sum the entries with type &gt; 0.
 To get the linked amount we will sum the entries with type &lt; 2.
 The overpayment account can be obtained from the entries with type = 2.

 This reasoning is hacky and i hope it can dissapear when we get to 1.4 - D.M.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_links</structname>
            </title>


            <varlistentry>
              <term><structfield>payment_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payment"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.acc-trans"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payment-map"
               xreflabel="lsmb14.payment_map">
        <title id="lsmb14.table.payment-map-title">
         Table:
         
         <structname>payment_map</structname>
        </title>
 

        <para>
           This maps the payment journal entry to the
invoices it pays.  A couple notes here:
1)  There is no requirement tht the payment &quot;invoice&quot; be linked to the same
entity_credit_account as the paid invoice.  People can pay eachothers invoices
if LedgerSMB supports this at an app level.
2)  This now means that payments are first class transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_map</structname>
            </title>


            <varlistentry>
              <term><structfield>line_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-line"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pays</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.eca-invoice"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payment-type"
               xreflabel="lsmb14.payment_type">
        <title id="lsmb14.table.payment-type-title">
         Table:
         
         <structname>payment_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payroll-deduction"
               xreflabel="lsmb14.payroll_deduction">
        <title id="lsmb14.table.payroll-deduction-title">
         Table:
         
         <structname>payroll_deduction</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_deduction</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-deduction-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payroll-deduction-class"
               xreflabel="lsmb14.payroll_deduction_class">
        <title id="lsmb14.table.payroll-deduction-class-title">
         Table:
         
         <structname>payroll_deduction_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_deduction_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>



                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country"/>






              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_deduction_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-deduction-type"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-deduction-type"
               xreflabel="lsmb14.payroll_deduction_type">
        <title id="lsmb14.table.payroll-deduction-type-title">
         Table:
         
         <structname>payroll_deduction_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_deduction_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pdc_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-deduction-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-deduction-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>calc_percent</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_deduction via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-deduction"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-employee-class"
               xreflabel="lsmb14.payroll_employee_class">
        <title id="lsmb14.table.payroll-employee-class-title">
         Table:
         
         <structname>payroll_employee_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_employee_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_employee_class_to_income_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-employee-class-to-income-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-employee-class-to-income-type"
               xreflabel="lsmb14.payroll_employee_class_to_income_type">
        <title id="lsmb14.table.payroll-employee-class-to-income-type-title">
         Table:
         
         <structname>payroll_employee_class_to_income_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_employee_class_to_income_type</structname>
            </title>


            <varlistentry>
              <term><structfield>ec_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-employee-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>it_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-income-type"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payroll-income-category"
               xreflabel="lsmb14.payroll_income_category">
        <title id="lsmb14.table.payroll-income-category-title">
         Table:
         
         <structname>payroll_income_category</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_income_category</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payroll-income-class"
               xreflabel="lsmb14.payroll_income_class">
        <title id="lsmb14.table.payroll-income-class-title">
         Table:
         
         <structname>payroll_income_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_income_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>



                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.country"/>






              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_income_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-income-type"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-income-type"
               xreflabel="lsmb14.payroll_income_type">
        <title id="lsmb14.table.payroll-income-type-title">
         Table:
         
         <structname>payroll_income_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_income_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pic_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-income-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-income-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_employee_class_to_income_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-employee-class-to-income-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-wage"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-paid-timeoff"
               xreflabel="lsmb14.payroll_paid_timeoff">
        <title id="lsmb14.table.payroll-paid-timeoff-title">
         Table:
         
         <structname>payroll_paid_timeoff</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_paid_timeoff</structname>
            </title>


            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pto_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-pto-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payroll-pto-class"
               xreflabel="lsmb14.payroll_pto_class">
        <title id="lsmb14.table.payroll-pto-class-title">
         Table:
         
         <structname>payroll_pto_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_pto_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_paid_timeoff via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-paid-timeoff"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-report"
               xreflabel="lsmb14.payroll_report">
        <title id="lsmb14.table.payroll-report-title">
         Table:
         
         <structname>payroll_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ec_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-employee-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.payroll_paid_timeoff via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-paid-timeoff"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payroll-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.payroll-report-line"
               xreflabel="lsmb14.payroll_report_line">
        <title id="lsmb14.table.payroll-report-line-title">
         Table:
         
         <structname>payroll_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>it_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-income-type"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.payroll-wage"
               xreflabel="lsmb14.payroll_wage">
        <title id="lsmb14.table.payroll-wage-title">
         Table:
         
         <structname>payroll_wage</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_wage</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.payroll-income-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.view.periods"
               xreflabel="lsmb14.periods">
        <title id="lsmb14.view.periods-title">
         View:
         
         <structname>periods</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>periods</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_to</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_from</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view periods</title>
         <programlisting>
SELECT&apos;ytd&apos;::text AS id
,&apos;Year to Date&apos;::text AS label
, (now
     ()
)::date AS date_to
, (
     (
           (date_part
                 (&apos;year&apos;::text
                       , now
                       ()
                 )
           )::text || &apos;-01-01&apos;::text
     )
)::date AS date_from 
UNIONSELECT&apos;last_year&apos;::text AS id
,&apos;Last Year&apos;::text AS label
, (
     (
           (
                 (date_part
                       (&apos;YEAR&apos;::text
                             , now
                             ()
                       ) - 
                       (1)::double precision
                 )
           )::text || &apos;-12-31&apos;::text
     )
)::date AS date_to
, (
     (
           (
                 (date_part
                       (&apos;YEAR&apos;::text
                             , now
                             ()
                       ) - 
                       (1)::double precision
                 )
           )::text || &apos;-01-01&apos;::text
     )
)::date AS date_from;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.person"
               xreflabel="lsmb14.person">
        <title id="lsmb14.table.person-title">
         Table:
         
         <structname>person</structname>
        </title>
 

        <para>
           Every person, must have an entity to derive a common or display name. The correct way to get class information on a person would be person.entity_id-&gt;entity_class_to_entity.entity_id. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salutation_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.salutation"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>first_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>middle_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on person</title>

          <varlistentry>
            <term>person_first_name_check</term>
            <listitem><para>CHECK ((first_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>person_last_name_check</term>
            <listitem><para>CHECK ((last_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.audittrail via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.audittrail"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.gl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.jcitems"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.person-to-company"
               xreflabel="lsmb14.person_to_company">
        <title id="lsmb14.table.person-to-company-title">
         Table:
         
         <structname>person_to_company</structname>
        </title>
 

        <para>
           currently unused in the front-end, but can be used to map persons
to companies.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person_to_company</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.person"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>company_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.company"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.pricegroup"
               xreflabel="lsmb14.pricegroup">
        <title id="lsmb14.table.pricegroup-title">
         Table:
         
         <structname>pricegroup</structname>
        </title>
 

        <para>
           Pricegroups are groups of customers who are assigned prices and discounts
together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>pricegroup</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on pricegroup</title>

          <varlistentry>
            <term>pricegroup_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>pricegroup_pricegroup_key</term>
            <listitem><para>pricegroup</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.partscustomer"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.view.recon-payee"
               xreflabel="lsmb14.recon_payee">
        <title id="lsmb14.view.recon-payee-title">
         View:
         
         <structname>recon_payee</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>recon_payee</structname>
            </title>


            <varlistentry>
              <term><structfield>payee</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>scn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>our_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>errorcode</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>user</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>clear_time</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>insert_time</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ledger_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>overlook</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view recon_payee</title>
         <programlisting>
SELECT n.name AS payee
, rr.id
, rr.report_id
, rr.scn
, rr.their_balance
, rr.our_balance
, rr.errorcode
, rr.&quot;user&quot;
, rr.clear_time
, rr.insert_time
, rr.trans_type
, rr.post_date
, rr.ledger_id
, ac.voucher_id
, rr.overlook
, rr.cleared 
FROM (
     (
           (lsmb14.cr_report_line rr 
         LEFT JOIN lsmb14.acc_trans ac 
                ON (
                       (rr.ledger_id = ac.entry_id)
                 )
           )
   LEFT JOIN lsmb14.gl 
          ON (
                 (ac.trans_id = gl.id)
           )
     )
LEFT JOIN (
           (
            SELECT ap.id
                 , e.name 
              FROM (
                       (lsmb14.ap 
                          JOIN lsmb14.entity_credit_account eca 
                            ON (
                                   (ap.entity_credit_account = eca.id)
                             )
                       )
                    JOIN lsmb14.entity e 
                      ON (
                             (eca.entity_id = e.id)
                       )
                 )
             UNIONSELECT ar.id
                 , e.name 
              FROM (
                       (lsmb14.ar 
                          JOIN lsmb14.entity_credit_account eca 
                            ON (
                                   (ar.entity_credit_account = eca.id)
                             )
                       )
                    JOIN lsmb14.entity e 
                      ON (
                             (eca.entity_id = e.id)
                       )
                 )
           )
       UNIONSELECT gl.id
           , gl.description 
        FROM lsmb14.gl
     ) n 
    ON (
           (n.id = ac.trans_id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.recurring"
               xreflabel="lsmb14.recurring">
        <title id="lsmb14.table.recurring-title">
         Table:
         
         <structname>recurring</structname>
        </title>
 

        <para>
           Stores recurring information on transactions which will recur in the future.
Note that this means that only fully posted transactions can recur. 
I would highly recommend depricating this table and working instead on extending
the template transaction addon to handle recurring information.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurring</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>nextdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>repeat</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>howmany</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.recurringemail"
               xreflabel="lsmb14.recurringemail">
        <title id="lsmb14.table.recurringemail-title">
         Table:
         
         <structname>recurringemail</structname>
        </title>
 

        <para>
          Email  to be sent out when recurring transaction is posted.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurringemail</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>format</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>message</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.recurringprint"
               xreflabel="lsmb14.recurringprint">
        <title id="lsmb14.table.recurringprint-title">
         Table:
         
         <structname>recurringprint</structname>
        </title>
 

        <para>
           Template, printer etc. to print to when recurring transaction posts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurringprint</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>format</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printer</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.view.role-view"
               xreflabel="lsmb14.role_view">
        <title id="lsmb14.view.role-view-title">
         View:
         
         <structname>role_view</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>role_view</structname>
            </title>


            <varlistentry>
              <term><structfield>roleid</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>member</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>grantor</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>admin_option</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolname</structfield></term>
              <listitem><para>
                <type>name</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolsuper</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolinherit</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcreaterole</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcreatedb</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcatupdate</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcanlogin</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolreplication</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolconnlimit</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolpassword</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolvaliduntil</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolconfig</structfield></term>
              <listitem><para>
                <type>text[]</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oid</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view role_view</title>
         <programlisting>
SELECT m.roleid
, m.member
, m.grantor
, m.admin_option
, a.rolname
, a.rolsuper
, a.rolinherit
, a.rolcreaterole
, a.rolcreatedb
, a.rolcatupdate
, a.rolcanlogin
, a.rolreplication
, a.rolconnlimit
, a.rolpassword
, a.rolvaliduntil
, a.rolconfig
, a.oid 
FROM (pg_auth_members m 
  JOIN pg_roles a 
    ON (
           (m.roleid = a.oid)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.salutation"
               xreflabel="lsmb14.salutation">
        <title id="lsmb14.table.salutation-title">
         Table:
         
         <structname>salutation</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>salutation</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salutation</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.person via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.person"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.session"
               xreflabel="lsmb14.session">
        <title id="lsmb14.table.session-title">
         Table:
         
         <structname>session</structname>
        </title>
 

        <para>
           This table is used to track sessions on a database level across page 
requests (discretionary locks,open forms for anti-xsrf measures).
Because of the way LedgerSMB authentication works currently we do 
not time out authentication when the session times out.  We do time out 
highly pessimistic locks used for large batch payment workflows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>session</structname>
            </title>


            <varlistentry>
              <term><structfield>session_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>token</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_used</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ttl</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 3600</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>users_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notify_pasword</structfield></term>
              <listitem><para>
                <type>interval</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;7 days&apos;::interval</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on session</title>

          <varlistentry>
            <term>session_token_check</term>
            <listitem><para>CHECK ((length((token)::text) = 32))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.batch via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.journal-entry"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.open-forms"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.transactions"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.sic"
               xreflabel="lsmb14.sic">
        <title id="lsmb14.table.sic-title">
         Table:
         
         <structname>sic</structname>
        </title>
 

        <para>
          
This can be used SIC codes or any equivalent, such as ISIC, NAICS, etc.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>sic</structname>
            </title>


            <varlistentry>
              <term><structfield>code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sictype</structfield></term>
              <listitem><para>
                <type>character(1)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.status"
               xreflabel="lsmb14.status">
        <title id="lsmb14.table.status-title">
         Table:
         
         <structname>status</structname>
        </title>
 

        <para>
           Whether AR/AP transactions and invoices have been emailed and/or printed 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>status</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>emailed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>spoolfile</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on status</title>

          <varlistentry>
            <term>status_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.tax"
               xreflabel="lsmb14.tax">
        <title id="lsmb14.table.tax-title">
         Table:
         
         <structname>tax</structname>
        </title>
 

        <para>
          Information on tax rates.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tax</structname>
            </title>


            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>



                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>minvalue</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>maxvalue</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validto</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT &apos;infinity&apos;::timestamp without time zone</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pass</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                This is an integer indicating the pass of the tax. This is to support 
cumultative sales tax rules (for example, Quebec charging taxes on the federal
taxes collected).
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT 1</literal>




                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.taxmodule"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.tax-extended"
               xreflabel="lsmb14.tax_extended">
        <title id="lsmb14.table.tax-extended-title">
         Table:
         
         <structname>tax_extended</structname>
        </title>
 

        <para>
           This stores extended information for manual tax calculations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tax_extended</structname>
            </title>


            <varlistentry>
              <term><structfield>tax_basis</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.journal-line"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.taxcategory"
               xreflabel="lsmb14.taxcategory">
        <title id="lsmb14.table.taxcategory-title">
         Table:
         
         <structname>taxcategory</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>taxcategory</structname>
            </title>


            <varlistentry>
              <term><structfield>taxcategory_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxcategoryname</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.taxmodule"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.partstax via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.partstax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.taxmodule"
               xreflabel="lsmb14.taxmodule">
        <title id="lsmb14.table.taxmodule-title">
         Table:
         
         <structname>taxmodule</structname>
        </title>
 

        <para>
          This is used to store information on tax modules.  the module name is used
to determine the Perl class for the taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>taxmodule</structname>
            </title>


            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodulename</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.tax via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.taxcategory"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.transactions"
               xreflabel="lsmb14.transactions">
        <title id="lsmb14.table.transactions-title">
         Table:
         
         <structname>transactions</structname>
        </title>
 

        <para>
           This table provides referential integrity between AR, AP, GL tables on one
hand and acc_trans on the other, pending the refactoring of those tables.  It
also is used to provide discretionary locking of financial transactions across 
database connections, for example in batch payment workflows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>transactions</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.session"/>


              </para>

              <para>
                 This should only be used in pessimistic locking measures as required by large
batch work flows. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on transactions</title>

          <varlistentry>
            <term>transactions_locked_by_i</term>
            <listitem><para>locked_by</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing lsmb14.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.gl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.translation"
               xreflabel="lsmb14.translation">
        <title id="lsmb14.table.translation-title">
         Table:
         
         <structname>translation</structname>
        </title>
 

        <para>
          abstract table for manual translation data. Should have zero rows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on translation</title>

          <varlistentry>
            <term>translation_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="lsmb14.table.trial-balance"
               xreflabel="lsmb14.trial_balance">
        <title id="lsmb14.table.trial-balance-title">
         Table:
         
         <structname>trial_balance</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_from</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_to</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>yearend</structfield></term>
              <listitem><para>
                <type>text</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.trial-balance-yearend-types"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.trial_balance__account_to_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.trial-balance-account-to-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.trial-balance-heading-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.trial-balance-account-to-report"
               xreflabel="lsmb14.trial_balance__account_to_report">
        <title id="lsmb14.table.trial-balance-account-to-report-title">
         Table:
         
         <structname>trial_balance__account_to_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__account_to_report</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.trial-balance"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.trial-balance-heading-to-report"
               xreflabel="lsmb14.trial_balance__heading_to_report">
        <title id="lsmb14.table.trial-balance-heading-to-report-title">
         Table:
         
         <structname>trial_balance__heading_to_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__heading_to_report</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.trial-balance"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>heading_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.trial-balance-yearend-types"
               xreflabel="lsmb14.trial_balance__yearend_types">
        <title id="lsmb14.table.trial-balance-yearend-types-title">
         Table:
         
         <structname>trial_balance__yearend_types</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__yearend_types</structname>
            </title>


            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.trial_balance via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.trial-balance"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.view.tx-report"
               xreflabel="lsmb14.tx_report">
        <title id="lsmb14.view.tx-report-title">
         View:
         
         <structname>tx_report</structname>
        </title>
 

        <para>
           This view provides join and approval information for transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tx_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view tx_report</title>
         <programlisting>
(
SELECT gl.id
     , gl.reference
     , NULL::integer AS entity_credit_account
     ,&apos;gl&apos;::text AS &quot;table&quot;
     , gl.approved 
  FROM lsmb14.gl 
UNION ALLSELECT ap.id
     , ap.invnumber AS reference
     , ap.entity_credit_account
     ,&apos;ap&apos;::text AS &quot;table&quot;
     , ap.approved 
  FROM lsmb14.ap
)
UNION ALLSELECT ar.id
, ar.invnumber AS reference
, ar.entity_credit_account
,&apos;ar&apos;::text AS &quot;table&quot;
, ar.approved 
FROM lsmb14.ar;</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.view.user-listable"
               xreflabel="lsmb14.user_listable">
        <title id="lsmb14.view.user-listable-title">
         View:
         
         <structname>user_listable</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>user_listable</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>username</structfield></term>
              <listitem><para>
                <type>character varying(30)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view user_listable</title>
         <programlisting>
SELECT u.id
, u.username
, e.created 
FROM (lsmb14.entity e 
  JOIN lsmb14.users u 
    ON (
           (u.entity_id = e.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="lsmb14.table.user-preference"
               xreflabel="lsmb14.user_preference">
        <title id="lsmb14.table.user-preference-title">
         Table:
         
         <structname>user_preference</structname>
        </title>
 

        <para>
           This table sets the basic preferences for formats, languages, printers, and user-selected stylesheets.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>user_preference</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.users"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>












                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>stylesheet</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;ledgersmb.css&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printer</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dateformat</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;yyyy-mm-dd&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>numberformat</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;1000.00&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="lsmb14.table.users"
               xreflabel="lsmb14.users">
        <title id="lsmb14.table.users-title">
         Table:
         
         <structname>users</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>users</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>username</structfield></term>
              <listitem><para>
                <type>character varying(30)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notify_password</structfield></term>
              <listitem><para>
                <type>interval</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;7 days&apos;::interval</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.lsmb_roles via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.lsmb-roles"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.session"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.user-preference"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.voucher"
               xreflabel="lsmb14.voucher">
        <title id="lsmb14.table.voucher-title">
         Table:
         
         <structname>voucher</structname>
        </title>
 

        <para>
          Mapping transactions to batches for batch approval.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>voucher</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.batch"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 This is simply a surrogate key for easy reference.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.batch-class"/>


              </para>

              <para>
                 This is the authoritative class of the 
voucher. 
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.acc-trans"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.warehouse"
               xreflabel="lsmb14.warehouse">
        <title id="lsmb14.table.warehouse-title">
         Table:
         
         <structname>warehouse</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>warehouse</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing lsmb14.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="lsmb14.table.asset-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="lsmb14.table.yearend"
               xreflabel="lsmb14.yearend">
        <title id="lsmb14.table.yearend-title">
         Table:
         
         <structname>yearend</structname>
        </title>
 

        <para>
           An extension to the journal_entry table to track transactionsactions which close out 
the books at yearend.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>yearend</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="lsmb14.table.gl"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reversed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>



<!-- Function _entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer) -->
    <section id="lsmb14.function.-entity-location-save-in-country-id-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer"
             xreflabel="lsmb14_entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)">
      <title id="lsmb14.function.-entity-location-save-in-country-id-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer-title">
       _entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.-entity-location-save-in-country-id-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer-titleabbrev">
       _entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Private method for storing locations to an entity.  Do not call directly.
Returns the location id that was inserted or updated.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
	t_company_id int;
    BEGIN
	SELECT id INTO t_company_id
	FROM company WHERE entity_id = in_entity_id;

	DELETE FROM entity_to_location
	WHERE entity_id = in_entity_id
		AND location_class = in_location_class
		AND location_id = in_location_id;

	SELECT location_save(NULL, in_line_one, in_line_two, in_line_three, in_city,
		in_state, in_mail_code, in_country_id) 
	INTO l_id;

	INSERT INTO entity_to_location
		(entity_id, location_class, location_id)
	VALUES  (in_entity_id, in_location_class, l_id);

	RETURN l_id;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function account__delete(in_id integer) -->
    <section id="lsmb14.function.account-delete-in-id-integer"
             xreflabel="lsmb14account__delete(in_id integer)">
      <title id="lsmb14.function.account-delete-in-id-integer-title">
       account__delete(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.account-delete-in-id-integer-titleabbrev">
       account__delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes an account with the id specified.  If the account has 
transactions associated with it, it will fail and raise a foreign key constraint.

        <programlisting>
BEGIN
DELETE FROM account_link WHERE account_id = in_id;
DELETE FROM account WHERE id = in_id;
RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__get_by_link_desc(in_description text) -->
    <section id="lsmb14.function.account-get-by-link-desc-in-description-text"
             xreflabel="lsmb14account__get_by_link_desc(in_description text)">
      <title id="lsmb14.function.account-get-by-link-desc-in-description-text-title">
       account__get_by_link_desc(in_description text)
      </title>
      <titleabbrev id="lsmb14.function.account-get-by-link-desc-in-description-text-titleabbrev">
       account__get_by_link_desc(in_description text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets a list of accounts with a specific link description set.  For example,
for a dropdown list.
        <programlisting>
SELECT * FROM account
WHERE id IN (SELECT account_id FROM account_link WHERE description = $1);
</programlisting>
      </para>
    </section>

<!-- Function account__get_from_accno(in_accno text) -->
    <section id="lsmb14.function.account-get-from-accno-in-accno-text"
             xreflabel="lsmb14account__get_from_accno(in_accno text)">
      <title id="lsmb14.function.account-get-from-accno-in-accno-text-title">
       account__get_from_accno(in_accno text)
      </title>
      <titleabbrev id="lsmb14.function.account-get-from-accno-in-accno-text-titleabbrev">
       account__get_from_accno(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the account where the accno field matches (excatly) the 
in_accno provided.
        <programlisting>
     select * from account where accno = $1;
</programlisting>
      </para>
    </section>

<!-- Function account__get_taxes() -->
    <section id="lsmb14.function.account-get-taxes"
             xreflabel="lsmb14account__get_taxes()">
      <title id="lsmb14.function.account-get-taxes-title">
       account__get_taxes()
      </title>
      <titleabbrev id="lsmb14.function.account-get-taxes-titleabbrev">
       account__get_taxes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns set of accounts where the tax attribute is true.
        <programlisting>
SELECT * FROM account 
 WHERE tax is true
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function account__is_recon(in_accno text) -->
    <section id="lsmb14.function.account-is-recon-in-accno-text"
             xreflabel="lsmb14account__is_recon(in_accno text)">
      <title id="lsmb14.function.account-is-recon-in-accno-text-title">
       account__is_recon(in_accno text)
      </title>
      <titleabbrev id="lsmb14.function.account-is-recon-in-accno-text-titleabbrev">
       account__is_recon(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if account is set up for reconciliation, false otherwise.
Note that returns false on invalid account number too
        <programlisting> SELECT count(*) &gt; 0 
     FROM cr_coa_to_account c2a
     JOIN account ON account.id = c2a.chart_id 
    WHERE accno = $1; </programlisting>
      </para>
    </section>

<!-- Function account__list_by_heading() -->
    <section id="lsmb14.function.account-list-by-heading"
             xreflabel="lsmb14account__list_by_heading()">
      <title id="lsmb14.function.account-list-by-heading-title">
       account__list_by_heading()
      </title>
      <titleabbrev id="lsmb14.function.account-list-by-heading-titleabbrev">
       account__list_by_heading()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM account ORDER BY heading;
</programlisting>
      </para>
    </section>

<!-- Function account__obtain_balance(in_account_id date, in_transdate integer) -->
    <section id="lsmb14.function.account-obtain-balance-in-account-id-date-in-transdate-integer"
             xreflabel="lsmb14account__obtain_balance(in_account_id date, in_transdate integer)">
      <title id="lsmb14.function.account-obtain-balance-in-account-id-date-in-transdate-integer-title">
       account__obtain_balance(in_account_id date, in_transdate integer)
      </title>
      <titleabbrev id="lsmb14.function.account-obtain-balance-in-account-id-date-in-transdate-integer-titleabbrev">
       account__obtain_balance(in_account_id date, in_transdate integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the account balance at a given point in time, calculating forward 
from most recent check point.
        <programlisting>
DECLARE balance numeric;
BEGIN
	SELECT coalesce(sum(ac.amount) + cp.amount, sum(ac.amount))
	INTO balance
	FROM acc_trans ac
	JOIN (select id, approved from ar union
		select id, approved from ap union
		select id, approved from gl) a ON (a.id = ac.trans_id)
	LEFT JOIN (select account_id, end_date, amount from account_checkpoint
		WHERE account_id = in_account_id AND end_date &lt; in_transdate
		ORDER BY end_date desc limit 1
	) cp ON (cp.account_id = ac.chart_id)
	WHERE ac.chart_id = in_account_id 
		AND ac.transdate &gt; coalesce(cp.end_date, ac.transdate - &#39;1 day&#39;::interval)
		and ac.approved and a.approved
		and ac.transdate &lt;= in_transdate
	GROUP BY cp.amount, ac.chart_id;

	RETURN balance;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean) -->
    <section id="lsmb14.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean"
             xreflabel="lsmb14account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)">
      <title id="lsmb14.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean-title">
       account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean-titleabbrev">
       account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes existing account_link entries, where the 
account_link.description is not designated as a custom one in the 
account_link_description table.

If no account heading is provided, the account heading which has an accno field
closest to but prior (by collation order) is used.

Then it saves the account information, and rebuilds the account_link records 
based on the in_link array.

        <programlisting>
DECLARE 
	t_heading_id int;
	t_link record;
	t_id int;
        t_tax bool;
BEGIN

    SELECT count(*) &gt; 0 INTO t_tax FROM tax WHERE in_id = chart_id;
    t_tax := t_tax OR in_tax;
	-- check to ensure summary accounts are exclusive
        -- necessary for proper handling by legacy code
    FOR t_link IN SELECT description FROM account_link_description 
    WHERE summary=&#39;t&#39;
	LOOP
		IF t_link.description = ANY (in_link) and array_upper(in_link, 1) &gt; 1 THEN
			RAISE EXCEPTION &#39;Invalid link settings:  Summary&#39;;
		END IF;
	END LOOP;
	-- heading settings
	IF in_heading IS NULL THEN
		SELECT id INTO t_heading_id FROM account_heading 
		WHERE accno &lt; in_accno order by accno desc limit 1;
	ELSE
		t_heading_id := in_heading;
	END IF;

    -- don&#39;t remove custom links.
	DELETE FROM account_link 
	WHERE account_id = in_id 
              and description in ( select description 
                                    from  account_link_description
                                    where custom = &#39;f&#39;);

	UPDATE account 
	SET accno = in_accno,
		description = in_description,
		category = in_category,
		gifi_accno = in_gifi_accno,
		heading = t_heading_id,
		contra = in_contra,
                obsolete = in_obsolete,
                tax = t_tax,
                is_temp = in_is_temp
	WHERE id = in_id;

	IF FOUND THEN
		t_id := in_id;
	ELSE
                -- can&#39;t obsolete on insert, but this can be changed if users
                -- request it --CT
		INSERT INTO account (accno, description, category, gifi_accno,
			heading, contra, tax, is_temp)
		VALUES (in_accno, in_description, in_category, in_gifi_accno,
			t_heading_id, in_contra, in_tax, in_is_temp);

		t_id := currval(&#39;account_id_seq&#39;);
	END IF;

	FOR t_link IN 
		select in_link[generate_series] AS val
		FROM generate_series(array_lower(in_link, 1), 
			array_upper(in_link, 1))
	LOOP
		INSERT INTO account_link (account_id, description)
		VALUES (t_id, t_link.val);
	END LOOP;

	
	RETURN t_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date) -->
    <section id="lsmb14.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date"
             xreflabel="lsmb14account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)">
      <title id="lsmb14.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date-title">
       account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)
      </title>
      <titleabbrev id="lsmb14.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date-titleabbrev">
       account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This saves tax rates.
        <programlisting>
BEGIN
	UPDATE tax SET validto = in_validto,
               rate = in_rate,
               minvalue = in_minvalue,
               maxvalue = in_maxvalue,
               taxnumber = in_taxnumber,
               pass = in_pass,
               taxmodule_id = in_taxmodule_id
         WHERE chart_id = in_chart_id and validto = in_old_validto;

         IF FOUND THEN
             return true;
         END IF;

         INSERT INTO tax(chart_id, validto, rate, minvalue, maxvalue, taxnumber,
                        pass, taxmodule_id)
         VALUES (in_chart_id, in_validto, in_rate, in_minvalue, in_maxvalue, 
                in_taxnumber, in_pass, in_taxmodule_id);

         RETURN TRUE;

END;
</programlisting>
      </para>
    </section>

<!-- Function account_get(in_id integer) -->
    <section id="lsmb14.function.account-get-in-id-integer"
             xreflabel="lsmb14account_get(in_id integer)">
      <title id="lsmb14.function.account-get-in-id-integer-title">
       account_get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.account-get-in-id-integer-titleabbrev">
       account_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns an entry from the chart view which matches the id requested, and which
is an account, not a heading.
        <programlisting>
SELECT * from chart where id = $1 and charttype = &#39;A&#39;;
</programlisting>
      </para>
    </section>

<!-- Function account_has_transactions(in_id integer) -->
    <section id="lsmb14.function.account-has-transactions-in-id-integer"
             xreflabel="lsmb14account_has_transactions(in_id integer)">
      <title id="lsmb14.function.account-has-transactions-in-id-integer-title">
       account_has_transactions(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.account-has-transactions-in-id-integer-titleabbrev">
       account_has_transactions(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Checks to see if any transactions use this account.  If so, returns true.
If not, returns false.
        <programlisting>
BEGIN
	PERFORM trans_id FROM acc_trans WHERE chart_id = in_id LIMIT 1;
	IF FOUND THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function account_heading__list() -->
    <section id="lsmb14.function.account-heading-list"
             xreflabel="lsmb14account_heading__list()">
      <title id="lsmb14.function.account-heading-list-title">
       account_heading__list()
      </title>
      <titleabbrev id="lsmb14.function.account-heading-list-titleabbrev">
       account_heading__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_heading</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all account headings, currently ordered by account number.

        <programlisting> SELECT * FROM account_heading order by accno; </programlisting>
      </para>
    </section>

<!-- Function account_heading_get(in_id integer) -->
    <section id="lsmb14.function.account-heading-get-in-id-integer"
             xreflabel="lsmb14account_heading_get(in_id integer)">
      <title id="lsmb14.function.account-heading-get-in-id-integer-title">
       account_heading_get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.account-heading-get-in-id-integer-titleabbrev">
       account_heading_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>chart</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns an entry from the chart view which matches the id requested, and which
is a heading, not an account.
        <programlisting>
DECLARE
	account chart%ROWTYPE;
BEGIN
	SELECT * INTO account FROM chart WHERE id = in_id AND charttype = &#39;H&#39;;
	RETURN account;
END;
</programlisting>
      </para>
    </section>

<!-- Function account_heading_list() -->
    <section id="lsmb14.function.account-heading-list"
             xreflabel="lsmb14account_heading_list()">
      <title id="lsmb14.function.account-heading-list-title">
       account_heading_list()
      </title>
      <titleabbrev id="lsmb14.function.account-heading-list-titleabbrev">
       account_heading_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_heading</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all existing account headings.
        <programlisting>
SELECT * FROM account_heading order by accno;
</programlisting>
      </para>
    </section>

<!-- Function account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer) -->
    <section id="lsmb14.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer"
             xreflabel="lsmb14account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)">
      <title id="lsmb14.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer-title">
       account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer-titleabbrev">
       account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an account heading. 
        <programlisting>
BEGIN
	UPDATE account_heading
	SET accno = in_accno,
		description = in_description,
		parent_id = in_parent
	WHERE id = in_id;

	IF FOUND THEN
		RETURN in_id;
	END IF;
	INSERT INTO account_heading (accno, description, parent_id)
	VALUES (in_accno, in_description, in_parent);

	RETURN currval(&#39;account_heading_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying) -->
    <section id="lsmb14.function.add-custom-field-field-datatype-character-varying-new-field-name-character-varying-table-name-character-varying"
             xreflabel="lsmb14add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying)">
      <title id="lsmb14.function.add-custom-field-field-datatype-character-varying-new-field-name-character-varying-table-name-character-varying-title">
       add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying)
      </title>
      <titleabbrev id="lsmb14.function.add-custom-field-field-datatype-character-varying-new-field-name-character-varying-table-name-character-varying-titleabbrev">
       add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
	perform TABLE_ID FROM custom_table_catalog 
		WHERE extends = table_name;
	IF NOT FOUND THEN
		BEGIN
			INSERT INTO custom_table_catalog (extends) 
				VALUES (table_name);
			EXECUTE &#39;CREATE TABLE &#39; || 
                               quote_ident(&#39;custom_&#39; ||table_name) ||
				&#39; (row_id INT PRIMARY KEY)&#39;;
		EXCEPTION WHEN duplicate_table THEN
			-- do nothing
		END;
	END IF;
	INSERT INTO custom_field_catalog (field_name, table_id)
	values (new_field_name, (SELECT table_id 
                                        FROM custom_table_catalog
		WHERE extends = table_name));
	EXECUTE &#39;ALTER TABLE &#39;|| quote_ident(&#39;custom_&#39;||table_name) || 
                &#39; ADD COLUMN &#39; || quote_ident(new_field_name) || &#39; &#39; || 
                  quote_ident(field_datatype);
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__add_function_to_group(in_role text, in_func text) -->
    <section id="lsmb14.function.admin-add-function-to-group-in-role-text-in-func-text"
             xreflabel="lsmb14admin__add_function_to_group(in_role text, in_func text)">
      <title id="lsmb14.function.admin-add-function-to-group-in-role-text-in-func-text-title">
       admin__add_function_to_group(in_role text, in_func text)
      </title>
      <titleabbrev id="lsmb14.function.admin-add-function-to-group-in-role-text-in-func-text-titleabbrev">
       admin__add_function_to_group(in_role text, in_func text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions to a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;GRANT EXECUTE ON FUNCTION &#39;|| quote_ident(in_func) ||&#39; to &#39;|| quote_ident(in_role);
        
        EXECUTE stmt;
        
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__add_group_to_role(in_role_name text, in_group_name text) -->
    <section id="lsmb14.function.admin-add-group-to-role-in-role-name-text-in-group-name-text"
             xreflabel="lsmb14admin__add_group_to_role(in_role_name text, in_group_name text)">
      <title id="lsmb14.function.admin-add-group-to-role-in-role-name-text-in-group-name-text-title">
       admin__add_group_to_role(in_role_name text, in_group_name text)
      </title>
      <titleabbrev id="lsmb14.function.admin-add-group-to-role-in-role-name-text-in-group-name-text-titleabbrev">
       admin__add_group_to_role(in_role_name text, in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This function inserts the arguments into lsmb_group_grants for future
reference and issues the db-level grant.  It then returns true if there are no
exceptions.
        <programlisting> 
BEGIN
   PERFORM * FROM lsmb_group_grants 
     WHERE group_name = in_group_name AND
           granted_role = in_role_name;

 IF NOT FOUND THEN
   INSERT INTO lsmb_group_grants(group_name, granted_role) 
   VALUES (in_group_name, in_role_name);
 END IF;

   EXECUTE &#39;GRANT &#39; || quote_ident(in_role_name) || &#39; TO &#39; ||
           quote_literal(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name);
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__add_user_to_role(in_role text, in_username text) -->
    <section id="lsmb14.function.admin-add-user-to-role-in-role-text-in-username-text"
             xreflabel="lsmb14admin__add_user_to_role(in_role text, in_username text)">
      <title id="lsmb14.function.admin-add-user-to-role-in-role-text-in-username-text-title">
       admin__add_user_to_role(in_role text, in_username text)
      </title>
      <titleabbrev id="lsmb14.function.admin-add-user-to-role-in-role-text-in-username-text-titleabbrev">
       admin__add_user_to_role(in_role text, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions to a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;GRANT &#39;|| quote_ident(in_role) ||&#39; to &#39;|| quote_ident(in_username);
        
        EXECUTE stmt;
        insert into lsmb_roles (user_id, role) 
        SELECT id, in_role from users where username = in_username;
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__create_group(in_group_name text) -->
    <section id="lsmb14.function.admin-create-group-in-group-name-text"
             xreflabel="lsmb14admin__create_group(in_group_name text)">
      <title id="lsmb14.function.admin-create-group-in-group-name-text-title">
       admin__create_group(in_group_name text)
      </title>
      <titleabbrev id="lsmb14.function.admin-create-group-in-group-name-text-titleabbrev">
       admin__create_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    DECLARE
        
        stmt text;
        t_dbname text;
    BEGIN
	t_dbname := current_database();
        stmt := &#39;create role &#39;|| quote_ident(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name);
        execute stmt;
        INSERT INTO lsmb_group (role_name) 
             values (quote_literal(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name));
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__delete_group(in_group_name text) -->
    <section id="lsmb14.function.admin-delete-group-in-group-name-text"
             xreflabel="lsmb14admin__delete_group(in_group_name text)">
      <title id="lsmb14.function.admin-delete-group-in-group-name-text-title">
       admin__delete_group(in_group_name text)
      </title>
      <titleabbrev id="lsmb14.function.admin-delete-group-in-group-name-text-titleabbrev">
       admin__delete_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        
    Deletes the input group from the database. Not designed to be used to 
    remove a login-capable user.

        <programlisting>
    
    DECLARE
        stmt text;
        a_role role_view;
        t_dbname text;
    BEGIN
        t_dbname := current_database();
        

        select * into a_role from role_view where rolname = in_group_name;
        
        if not found then
            return &#39;f&#39;::bool;
        else
            stmt := &#39;drop role lsmb_&#39; || quote_ident(t_dbname || &#39;__&#39; || in_group_name);
            execute stmt;
            return &#39;t&#39;::bool;
        end if;
    END;
</programlisting>
      </para>
    </section>

<!-- Function admin__delete_user(in_drop_role text, in_username boolean) -->
    <section id="lsmb14.function.admin-delete-user-in-drop-role-text-in-username-boolean"
             xreflabel="lsmb14admin__delete_user(in_drop_role text, in_username boolean)">
      <title id="lsmb14.function.admin-delete-user-in-drop-role-text-in-username-boolean-title">
       admin__delete_user(in_drop_role text, in_username boolean)
      </title>
      <titleabbrev id="lsmb14.function.admin-delete-user-in-drop-role-text-in-username-boolean-titleabbrev">
       admin__delete_user(in_drop_role text, in_username boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        
    Drops the provided user, as well as deletes the user configuration data.
It leaves the entity and person references.

If in_drop_role is set, it drops the role too.

        <programlisting>
    
    DECLARE
        stmt text;
        a_user users;
    BEGIN
    
        select * into a_user from users where username = in_username;
        
        IF NOT FOUND THEN
        
            raise exception &#39;User not found.&#39;;
        ELSIF FOUND THEN
            IF in_drop_role IS TRUE then 
                stmt := &#39; drop user &#39; || quote_ident(a_user.username);
                execute stmt;
            END IF;    
            -- also gets user_connection
            delete from user_preference where id = (
                   select id from users where entity_id = a_user.entity_id);
            delete from users where entity_id = a_user.entity_id;
            return 1;
        END IF;   
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__drop_session(in_session_id integer) -->
    <section id="lsmb14.function.admin-drop-session-in-session-id-integer"
             xreflabel="lsmb14admin__drop_session(in_session_id integer)">
      <title id="lsmb14.function.admin-drop-session-in-session-id-integer-title">
       admin__drop_session(in_session_id integer)
      </title>
      <titleabbrev id="lsmb14.function.admin-drop-session-in-session-id-integer-titleabbrev">
       admin__drop_session(in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Drops the session identified, releasing all locks held.
        <programlisting>
BEGIN
	DELETE FROM &quot;session&quot; WHERE session_id = in_session_id;
	RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__get_roles() -->
    <section id="lsmb14.function.admin-get-roles"
             xreflabel="lsmb14admin__get_roles()">
      <title id="lsmb14.function.admin-get-roles-title">
       admin__get_roles()
      </title>
      <titleabbrev id="lsmb14.function.admin-get-roles-titleabbrev">
       admin__get_roles()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF pg_roles</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
    v_rol record;
    t_dbname text;
BEGIN
    t_dbname := current_database();
    FOR v_rol in 
        SELECT *
        from 
            pg_roles
        where 
            rolname ~ (&#39;^lsmb_&#39; || t_dbname || &#39;__&#39;) 
            and rolcanlogin is false
        order by rolname ASC
    LOOP
        RETURN NEXT v_rol;
    END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__get_roles_for_user(in_user_id integer) -->
    <section id="lsmb14.function.admin-get-roles-for-user-in-user-id-integer"
             xreflabel="lsmb14admin__get_roles_for_user(in_user_id integer)">
      <title id="lsmb14.function.admin-get-roles-for-user-in-user-id-integer-title">
       admin__get_roles_for_user(in_user_id integer)
      </title>
      <titleabbrev id="lsmb14.function.admin-get-roles-for-user-in-user-id-integer-titleabbrev">
       admin__get_roles_for_user(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF text</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of roles that  a user is a part of.
        <programlisting>
    
    declare
        u_role record;
        a_user users;
    begin
        select * into a_user from admin__get_user(in_user_id);
        
        FOR u_role IN 
        select r.rolname 
        from 
            pg_roles r,
            (select 
                m.roleid 
             from 
                pg_auth_members m, pg_roles b 
             where 
                m.member = b.oid 
             and 
                b.rolname = a_user.username
            ) as ar
         where 
            r.oid = ar.roleid
         LOOP
        
            RETURN NEXT u_role.rolname::text;
        
        END LOOP;
        RETURN;
    end;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__get_user(in_entity_id integer) -->
    <section id="lsmb14.function.admin-get-user-in-entity-id-integer"
             xreflabel="lsmb14admin__get_user(in_entity_id integer)">
      <title id="lsmb14.function.admin-get-user-in-entity-id-integer-title">
       admin__get_user(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.admin-get-user-in-entity-id-integer-titleabbrev">
       admin__get_user(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) user specified by the id.
        <programlisting>
    
    DECLARE
        a_user users;
    BEGIN
        
        select * into a_user from users where entity_id = in_entity_id;
        return next a_user;
        return;
    
    END;    
</programlisting>
      </para>
    </section>

<!-- Function admin__is_group(in_group_name text) -->
    <section id="lsmb14.function.admin-is-group-in-group-name-text"
             xreflabel="lsmb14admin__is_group(in_group_name text)">
      <title id="lsmb14.function.admin-is-group-in-group-name-text-title">
       admin__is_group(in_group_name text)
      </title>
      <titleabbrev id="lsmb14.function.admin-is-group-in-group-name-text-titleabbrev">
       admin__is_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    -- This needs some work.  CT 
    DECLARE
        
        existant_role pg_roles;
        stmt text;
        
    BEGIN
        select * into existant_role from pg_roles 
        where rolname = in_group_name AND rolcanlogin is false;
        
        if not found then
            return &#39;f&#39;::bool;
            
        else
            return &#39;t&#39;::bool;
        end if;            
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__is_user(in_user text) -->
    <section id="lsmb14.function.admin-is-user-in-user-text"
             xreflabel="lsmb14admin__is_user(in_user text)">
      <title id="lsmb14.function.admin-is-user-in-user-text-title">
       admin__is_user(in_user text)
      </title>
      <titleabbrev id="lsmb14.function.admin-is-user-in-user-text-titleabbrev">
       admin__is_user(in_user text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if user is set up in LedgerSMB.  False otherwise.
        <programlisting>
    BEGIN
    
        PERFORM * from users where username = in_user;
        RETURN found;     
    
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__list_group_grants(in_group_name text) -->
    <section id="lsmb14.function.admin-list-group-grants-in-group-name-text"
             xreflabel="lsmb14admin__list_group_grants(in_group_name text)">
      <title id="lsmb14.function.admin-list-group-grants-in-group-name-text-title">
       admin__list_group_grants(in_group_name text)
      </title>
      <titleabbrev id="lsmb14.function.admin-list-group-grants-in-group-name-text-titleabbrev">
       admin__list_group_grants(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF lsmb_group_grants</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM lsmb_group_grants WHERE group_name = $1
ORDER BY granted_role;
</programlisting>
      </para>
    </section>

<!-- Function admin__list_sessions() -->
    <section id="lsmb14.function.admin-list-sessions"
             xreflabel="lsmb14admin__list_sessions()">
      <title id="lsmb14.function.admin-list-sessions-title">
       admin__list_sessions()
      </title>
      <titleabbrev id="lsmb14.function.admin-list-sessions-titleabbrev">
       admin__list_sessions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF session_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all active sessions.
        <programlisting>
SELECT s.session_id, u.username, s.last_used, count(t.id)
FROM &quot;session&quot; s
JOIN users u ON (s.users_id = u.id)
LEFT JOIN transactions t ON (t.locked_by = s.session_id)
GROUP BY s.session_id, u.username, s.last_used
ORDER BY u.username;
</programlisting>
      </para>
    </section>

<!-- Function admin__remove_function_from_group(in_role text, in_func text) -->
    <section id="lsmb14.function.admin-remove-function-from-group-in-role-text-in-func-text"
             xreflabel="lsmb14admin__remove_function_from_group(in_role text, in_func text)">
      <title id="lsmb14.function.admin-remove-function-from-group-in-role-text-in-func-text-title">
       admin__remove_function_from_group(in_role text, in_func text)
      </title>
      <titleabbrev id="lsmb14.function.admin-remove-function-from-group-in-role-text-in-func-text-titleabbrev">
       admin__remove_function_from_group(in_role text, in_func text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions of non-existant role $.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions from a non-existant function.&#39;;
        END IF;
        
        stmt := &#39;REVOKE EXECUTE ON FUNCTION &#39;|| quote_ident(in_func) ||&#39; FROM &#39;|| quote_ident(in_role);
        
        EXECUTE stmt;
        
        return 1;    
    END;
    
    
</programlisting>
      </para>
    </section>

<!-- Function admin__remove_group_from_role(in_role_name text, in_group_name text) -->
    <section id="lsmb14.function.admin-remove-group-from-role-in-role-name-text-in-group-name-text"
             xreflabel="lsmb14admin__remove_group_from_role(in_role_name text, in_group_name text)">
      <title id="lsmb14.function.admin-remove-group-from-role-in-role-name-text-in-group-name-text-title">
       admin__remove_group_from_role(in_role_name text, in_group_name text)
      </title>
      <titleabbrev id="lsmb14.function.admin-remove-group-from-role-in-role-name-text-in-group-name-text-titleabbrev">
       admin__remove_group_from_role(in_role_name text, in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
Returns true if the grant record was found and deleted, false otherwise.
Issues db-level revoke in all cases.
        <programlisting>
BEGIN

   EXECUTE &#39;REVOKE &#39; || quote_ident(in_role_name) || &#39; FROM &#39; ||
           quote_literal(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name);

   DELETE FROM lsmb_group_grants 
    WHERE group_name = in_group_name AND granted_role = in_role_name;

   RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function admin__remove_user_from_role(in_role text, in_username text) -->
    <section id="lsmb14.function.admin-remove-user-from-role-in-role-text-in-username-text"
             xreflabel="lsmb14admin__remove_user_from_role(in_role text, in_username text)">
      <title id="lsmb14.function.admin-remove-user-from-role-in-role-text-in-username-text-title">
       admin__remove_user_from_role(in_role text, in_username text)
      </title>
      <titleabbrev id="lsmb14.function.admin-remove-user-from-role-in-role-text-in-username-text-titleabbrev">
       admin__remove_user_from_role(in_role text, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions from a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;REVOKE &#39;|| quote_ident(in_role) ||&#39; FROM &#39;|| quote_ident(in_username);
        
        EXECUTE stmt;
        
        return 1;    
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean) -->
    <section id="lsmb14.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean"
             xreflabel="lsmb14admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)">
      <title id="lsmb14.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean-title">
       admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean-titleabbrev">
       admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates a user and relevant records in LedgerSMB and PostgreSQL.
        <programlisting>
    DECLARE
    
        a_user users;
        v_user_id int;
        p_id int;
        l_id int;
        stmt text;
        t_is_role bool;
        t_is_user bool;
    BEGIN
        -- WARNING TO PROGRAMMERS:  This function runs as the definer and runs
        -- utility statements via EXECUTE.
        -- PLEASE BE VERY CAREFUL ABOUT SQL-INJECTION INSIDE THIS FUNCTION.

       PERFORM rolname FROM pg_roles WHERE rolname = in_username;
       t_is_role := found;
       t_is_user := admin__is_user(in_username);

       IF t_is_role is true and t_is_user is false and in_import is false THEN
          RAISE EXCEPTION &#39;Duplicate user&#39;;
        END IF;

        if t_is_role and in_password is not null then
                execute &#39;ALTER USER &#39; || quote_ident( in_username ) || 
                     &#39; WITH ENCRYPTED PASSWORD &#39; || quote_literal (in_password)
                     || $e$ valid until $e$ || 
                      quote_literal(now() + &#39;1 day&#39;::interval);
        elsif in_import is false AND t_is_user is false 
              AND in_password IS NULL THEN
                RAISE EXCEPTION &#39;No password&#39;;
        elsif  t_is_role is false and in_import IS FALSE THEN
            -- create an actual user
                execute &#39;CREATE USER &#39; || quote_ident( in_username ) || 
                     &#39; WITH ENCRYPTED PASSWORD &#39; || quote_literal (in_password)
                     || $e$ valid until $e$ || quote_literal(now() + &#39;1 day&#39;::interval);
       END IF;         
        
        select * into a_user from users lu where lu.id = in_id;
        IF FOUND THEN 
            return a_user.id;
        ELSE
            -- Insert cycle
            
            --- The entity is expected to already BE created. See admin.pm.
            
            
            v_user_id := nextval(&#39;users_id_seq&#39;);
            insert into users (id, username, entity_id) VALUES (
                v_user_id,
                in_username,
                in_entity_id
            );
            
            insert into user_preference (id) values (v_user_id);

            IF NOT exists(SELECT * FROM entity_employee WHERE entity_id = in_entity_id) THEN
                INSERT into entity_employee (entity_id) values (in_entity_id);
            END IF;
            -- Finally, issue the create user statement
            
            return v_user_id ;

            
        
        END IF;
    
    END;
</programlisting>
      </para>
    </section>

<!-- Function admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date) -->
    <section id="lsmb14.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date"
             xreflabel="lsmb14admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)">
      <title id="lsmb14.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date-title">
       admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)
      </title>
      <titleabbrev id="lsmb14.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date-titleabbrev">
       admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF user_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of users matching search criteria.  Nulls match all values.
only username is not an exact match.
        <programlisting>
DECLARE t_return_row user_result;
BEGIN
	FOR t_return_row IN
		SELECT u.id, u.username, p.first_name, p.last_name, e.ssn, e.dob
		FROM users u
		JOIN person p ON (u.entity_id = p.entity_id)
		JOIN entity_employee e ON (e.entity_id = p.entity_id)
		WHERE u.username LIKE &#39;%&#39; || coalesce(in_username,&#39;&#39;) || &#39;%&#39; AND
			(p.first_name = in_first_name or in_first_name is null)
			AND (p.last_name = in_last_name or in_last_name is null)
			AND (in_ssn is NULL or in_ssn = e.ssn) 
			AND (e.dob = in_dob::date or in_dob is NULL)
	LOOP
		RETURN NEXT t_return_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function as_array(anyelement) -->
    <section id="lsmb14.function.as-array-anyelement"
             xreflabel="lsmb14as_array(anyelement)">
      <title id="lsmb14.function.as-array-anyelement-title">
       as_array(anyelement)
      </title>
      <titleabbrev id="lsmb14.function.as-array-anyelement-titleabbrev">
       as_array(anyelement)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>anyarray</seg>
        </seglistitem>
       </segmentedlist>
 
        A basic array aggregate to take elements and return a one-dimensional array.

Example:  SELECT as_array(id) from entity_class;

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function asset__get(in_tag integer, in_id text) -->
    <section id="lsmb14.function.asset-get-in-tag-integer-in-id-text"
             xreflabel="lsmb14asset__get(in_tag integer, in_id text)">
      <title id="lsmb14.function.asset-get-in-tag-integer-in-id-text-title">
       asset__get(in_tag integer, in_id text)
      </title>
      <titleabbrev id="lsmb14.function.asset-get-in-tag-integer-in-id-text-titleabbrev">
       asset__get(in_tag integer, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a given asset either by id or tag.  Both are complete matches.

Note that the behavior is undefined if both id and tag are provided.
        <programlisting>
DECLARE ret_val asset_item;
BEGIN
	SELECT * into ret_val from asset_item WHERE id = in_id OR in_tag = tag
        ORDER BY id desc limit 1;
	return ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__import_from_disposal(in_id integer) -->
    <section id="lsmb14.function.asset-import-from-disposal-in-id-integer"
             xreflabel="lsmb14asset__import_from_disposal(in_id integer)">
      <title id="lsmb14.function.asset-import-from-disposal-in-id-integer-title">
       asset__import_from_disposal(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-import-from-disposal-in-id-integer-titleabbrev">
       asset__import_from_disposal(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Imports items from partial disposal reports. This function should not be
called dirctly by programmers but rather through the other disposal approval
api&apos;s.
        <programlisting>
DECLARE t_report asset_report;
        t_import asset_report;
BEGIN

    SELECT * INTO t_report from asset_report where id = in_id;

    if t_report.report_class &lt;&gt; 4 THEN RETURN FALSE;
    END IF;

    SELECT * 
      INTO t_import 
      FROM  asset_report__begin_import 
            (t_report.asset_class::int, t_report.report_date);

    PERFORM asset_report__import(
	ai.description,
	ai.tag,
	ai.purchase_value * rld.percent_disposed / 100,
	ai.salvage_value * rld.percent_disposed / 100,
	ai.usable_life,
	ai.purchase_date,
        ai.start_depreciation,
	ai.location_id,
	ai.department_id,
	ai.asset_account_id,
	ai.dep_account_id,
	ai.exp_account_id,
	ai.asset_class_id,
        ai.invoice_id,
        t_import.id,
        r.accum_depreciation * rld.percent_disposed / 100,
        TRUE)
    FROM asset_item ai
    JOIN asset_report__get_disposal(t_report.id) r  ON (ai.id = r.id)
    JOIN asset_report_line rl ON (rl.asset_id = ai.id AND rl.report_id = in_id)
    join asset_rl_to_disposal_method rld 
         ON (rl.report_id = rld.report_id and ai.id = rld.asset_id)
   where rld.percent_disposed is null or percent_disposed &lt; 100;
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer) -->
    <section id="lsmb14.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer"
             xreflabel="lsmb14asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)">
      <title id="lsmb14.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-title">
       asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-titleabbrev">
       asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the asset with the information provided.  If the id is provided, 
overwrites the record with the id.  Otherwise, or if that record is not found,
inserts.  Returns the row inserted or updated.

        <programlisting>
DECLARE ret_val asset_item;
BEGIN
	UPDATE asset_item
	SET asset_class_id = in_asset_class,
		description = in_description,
		tag = in_tag,
		purchase_date = in_purchase_date,
		purchase_value = in_purchase_value,
		usable_life = in_usable_life,
		location_id = in_warehouse_id,
		department_id = in_department_id,
		invoice_id = in_invoice_id,
		salvage_value = in_salvage_value,
                asset_account_id = in_asset_account_id,
                exp_account_id = in_exp_account_id,
                start_depreciation = 
                         coalesce(in_start_depreciation, in_purchase_date),
                dep_account_id = in_dep_account_id
	WHERE id = in_id;
	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_item WHERE id = in_id;
		return ret_val;
	END IF;

	INSERT INTO asset_item (asset_class_id, description, tag, purchase_date,
		purchase_value, usable_life, salvage_value, department_id,
		location_id, invoice_id, asset_account_id, dep_account_id,
                start_depreciation, exp_account_id)
	VALUES (in_asset_class, in_description, in_tag, in_purchase_date,
		in_purchase_value, in_usable_life, in_salvage_value,
		in_department_id, in_warehouse_id, in_invoice_id,
                in_asset_account_id, in_dep_account_id,
                coalesce(in_start_depreciation, in_purchase_date),
                in_exp_account_id);

	SELECT * INTO ret_val FROM asset_item 
	WHERE id = currval(&#39;asset_item_id_seq&#39;);
	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric) -->
    <section id="lsmb14.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric"
             xreflabel="lsmb14asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)">
      <title id="lsmb14.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric-title">
       asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)
      </title>
      <titleabbrev id="lsmb14.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric-titleabbrev">
       asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
       Searches for assets.  Nulls match all records.  Asset class is exact,
as is purchase date, purchase value, and salvage value. Tag and description
are partial matches.
        <programlisting>
DECLARE out_val asset_item;
BEGIN
	FOR out_val IN
		SELECT * FROM asset_item
		WHERE (in_asset_class is null 
			or asset_class_id = in_asset_class)
			AND (in_description is null or description 
				LIKE &#39;%&#39; || in_description || &#39;%&#39;)
			and (in_tag is not null or tag like &#39;%&#39;||in_tag||&#39;%&#39;)
			AND (in_purchase_date is null 
				or purchase_date = in_purchase_date)
			AND (in_purchase_value is null
				or in_purchase_value = purchase_value)
			AND (in_usable_life is null
				or in_usable_life = usable_life)
			AND (in_salvage_value is null
				OR in_salvage_value = salvage_value)
	LOOP
		RETURN NEXT out_val;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get(in_id integer) -->
    <section id="lsmb14.function.asset-class-get-in-id-integer"
             xreflabel="lsmb14asset_class__get(in_id integer)">
      <title id="lsmb14.function.asset-class-get-in-id-integer-title">
       asset_class__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-class-get-in-id-integer-titleabbrev">
       asset_class__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        returns the row from asset_class identified by in_id.
        <programlisting>
DECLARE ret_val asset_class;
BEGIN 
	SELECT * INTO ret_val FROM asset_class WHERE id = in_id;
	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_asset_accounts() -->
    <section id="lsmb14.function.asset-class-get-asset-accounts"
             xreflabel="lsmb14asset_class__get_asset_accounts()">
      <title id="lsmb14.function.asset-class-get-asset-accounts-title">
       asset_class__get_asset_accounts()
      </title>
      <titleabbrev id="lsmb14.function.asset-class-get-asset-accounts-titleabbrev">
       asset_class__get_asset_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of fixed asset accounts, ordered by account number
        <programlisting>
SELECT * FROM account 
WHERE id IN 
	(select account_id from account_link where description = &#39;Fixed_Asset&#39;)
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_accounts() -->
    <section id="lsmb14.function.asset-class-get-dep-accounts"
             xreflabel="lsmb14asset_class__get_dep_accounts()">
      <title id="lsmb14.function.asset-class-get-dep-accounts-title">
       asset_class__get_dep_accounts()
      </title>
      <titleabbrev id="lsmb14.function.asset-class-get-dep-accounts-titleabbrev">
       asset_class__get_dep_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of asset depreciation accounts, ordered by account number
        <programlisting>
SELECT * FROM account 
WHERE id IN 
	(select account_id from account_link where description = &#39;Asset_Dep&#39;)
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_method(in_asset_class integer) -->
    <section id="lsmb14.function.asset-class-get-dep-method-in-asset-class-integer"
             xreflabel="lsmb14asset_class__get_dep_method(in_asset_class integer)">
      <title id="lsmb14.function.asset-class-get-dep-method-in-asset-class-integer-title">
       asset_class__get_dep_method(in_asset_class integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-class-get-dep-method-in-asset-class-integer-titleabbrev">
       asset_class__get_dep_method(in_asset_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_dep_method</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the depreciation method associated with the asset class.
        <programlisting>
SELECT * from asset_dep_method 
WHERE id = (select method from asset_class where id = $1);
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_methods() -->
    <section id="lsmb14.function.asset-class-get-dep-methods"
             xreflabel="lsmb14asset_class__get_dep_methods()">
      <title id="lsmb14.function.asset-class-get-dep-methods-title">
       asset_class__get_dep_methods()
      </title>
      <titleabbrev id="lsmb14.function.asset-class-get-dep-methods-titleabbrev">
       asset_class__get_dep_methods()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_dep_method</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of asset_dep_methods ordered by the method label.
        <programlisting>
SELECT * FROM asset_dep_method ORDER BY method;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__list() -->
    <section id="lsmb14.function.asset-class-list"
             xreflabel="lsmb14asset_class__list()">
      <title id="lsmb14.function.asset-class-list-title">
       asset_class__list()
      </title>
      <titleabbrev id="lsmb14.function.asset-class-list-titleabbrev">
       asset_class__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an alphabetical list of asset classes.
        <programlisting>
SELECT * FROM asset_class ORDER BY label;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text) -->
    <section id="lsmb14.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text"
             xreflabel="lsmb14asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)">
      <title id="lsmb14.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text-title">
       asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)
      </title>
      <titleabbrev id="lsmb14.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text-titleabbrev">
       asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves this data as an asset_class record.  If in_id is NULL or is not found
in the table, inserts a new row.  Returns the row saved.
        <programlisting>
DECLARE ret_val asset_class;
BEGIN
	UPDATE asset_class 
	SET asset_account_id = in_asset_account_id,
		dep_account_id = in_dep_account_id,
		method = in_method,
		label = in_label
	WHERE id = in_id;

	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_class where id = in_id;
		RETURN ret_val;
	END IF;

	INSERT INTO asset_class (asset_account_id, dep_account_id, method,
		label)
	VALUES (in_asset_account_id, in_dep_account_id, in_method, 
		in_label);

	SELECT * INTO ret_val FROM asset_class 
	WHERE id = currval(&#39;asset_class_id_seq&#39;);

	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text) -->
    <section id="lsmb14.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text"
             xreflabel="lsmb14asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)">
      <title id="lsmb14.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-title">
       asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)
      </title>
      <titleabbrev id="lsmb14.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-titleabbrev">
       asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_class_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of matching asset classes.  The account id&apos;s are exact matches
as is the method, but the label is a partial match.  NULL&apos;s match all.
        <programlisting>
DECLARE out_var asset_class_result;
BEGIN
	FOR out_var IN
		SELECT ac.id, ac.asset_account_id, aa.accno, aa.description, 
			ad.accno, ad.description, m.method, ac.method,
			ac.label
		FROM asset_class ac
		JOIN account aa ON (aa.id = ac.asset_account_id)
		JOIN account ad ON (ad.id = ac.dep_account_id)
		JOIN asset_dep_method m ON (ac.method = m.id)
		WHERE 
			(in_asset_account_id is null 
				or in_asset_account_id = ac.asset_account_id)
			AND (in_dep_account_id is null OR
				in_dep_account_id = ac.dep_account_id)
			AND (in_method is null OR in_method = ac.method)
			AND (in_label IS NULL OR ac.label LIKE 
				&#39;%&#39; || in_label || &#39;%&#39;)
               ORDER BY label
	LOOP
		RETURN NEXT out_var;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric) -->
    <section id="lsmb14.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric"
             xreflabel="lsmb14asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)">
      <title id="lsmb14.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric-title">
       asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)
      </title>
      <titleabbrev id="lsmb14.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric-titleabbrev">
       asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This function is a basic function which does the actual calculation for 
straight line depreciation.
        <programlisting>
SELECT CASE WHEN $3/$1 * $4 &lt; $4 - $5 THEN $3/$1 * $4 
            ELSE $4 - $5
            END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric) -->
    <section id="lsmb14.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric"
             xreflabel="lsmb14asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)">
      <title id="lsmb14.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric-title">
       asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)
      </title>
      <titleabbrev id="lsmb14.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric-titleabbrev">
       asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks the interval between the two dates, and if longer than the 
usable life, returns the months in that interval.  Otherwise returns the 
usable life.
        <programlisting>
select CASE WHEN extract(&#39;MONTHS&#39; FROM (date_trunc(&#39;day&#39;, $2) - date_trunc(&#39;day&#39;, $1))) 
                 &gt; $3
            THEN $3
            ELSE extract(&#39;MONTHS&#39; FROM (date_trunc(&#39;day&#39;, $2) - date_trunc(&#39;day&#39;, $1)))::numeric
            END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date) -->
    <section id="lsmb14.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date"
             xreflabel="lsmb14asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)">
      <title id="lsmb14.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date-title">
       asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)
      </title>
      <titleabbrev id="lsmb14.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date-titleabbrev">
       asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       If the interval is less than 0 then 0.  If the interval is greater than the 
usable life, then the usable life.  Otherwise, return the interval as a 
fractional year.
        <programlisting>
   SELECT CASE WHEN $3 IS NULL or get_fractional_year($2, $3) &gt; $1 
               then $1
               WHEN get_fractional_year($2, $3) &lt; 0
               THEN 0
               ELSE get_fractional_year($2, $3)
          END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="lsmb14.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="lsmb14asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="lsmb14.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Performs straight line depreciation, selecting depreciation amounts, etc. 
into a report for further review and approval.  Usable life is in months, and
depreciation is an equal amount every month.
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life,
                  ai.usable_life --months
                  - months_passed(coalesce(start_depreciation, purchase_date),
                                  coalesce(max(report_date),
                                           start_depreciation,
                                           purchase_date)),
                  months_passed(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="lsmb14.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="lsmb14asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="lsmb14.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life, -- years
                  ai.usable_life - 
                  get_fractional_year(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                       coalesce(start_depreciation,
                                         purchase_date)),
                  get_fractional_year(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="lsmb14.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="lsmb14asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="lsmb14.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Performs straight line depreciation on a set of selected assets, selecting
the depreciation values into a report.

Assumes the usable life is measured in years, and is depreciated eavenly every
month.
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life * 12,
                  ai.usable_life * 12 --months
                  - months_passed(coalesce(start_depreciation, purchase_date),
                                  coalesce(max(report_date),
                                           start_depreciation,
                                           purchase_date)),
                  months_passed(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_depreciation__approve(in_expense_acct integer, in_report_id integer) -->
    <section id="lsmb14.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer"
             xreflabel="lsmb14asset_depreciation__approve(in_expense_acct integer, in_report_id integer)">
      <title id="lsmb14.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer-title">
       asset_depreciation__approve(in_expense_acct integer, in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer-titleabbrev">
       asset_depreciation__approve(in_expense_acct integer, in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Approves an asset depreciation report and creats the GL draft.
        <programlisting>
declare retval asset_report;
begin

retval := asset_report__record_approve(in_report_id);

INSERT INTO gl (reference, description, approved)
select &#39;Asset Report &#39; || in_id, &#39;Asset Depreciation Report for &#39; || report_date,
       false
 FROM asset_report where id = in_id;

INSERT INTO acc_trans (amount, chart_id, transdate, approved, trans_id)
SELECT l.amount, a.dep_account_id, r.report_date, true, currval(&#39;id&#39;)
  FROM asset_report r
  JOIN asset_report_line l ON (r.id = l.report_id)
  JOIN asset_item a ON (a.id = l.asset_id)
 WHERE r.id = in_id;

INSERT INTO acc_trans (amount, chart_id, transdate, approved, trans_id)
SELECT sum(l.amount) * -1, in_expense_acct, r.report_date, approved, 
       currval(&#39;id&#39;)
  FROM asset_report r
  JOIN asset_report_line l ON (r.id = l.report_id)
  JOIN asset_item a ON (a.id = l.asset_id)
 WHERE r.id = in_id
 GROUP BY r.report_date;


return retval;

end;
</programlisting>
      </para>
    </section>

<!-- Function asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer) -->
    <section id="lsmb14.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer"
             xreflabel="lsmb14asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)">
      <title id="lsmb14.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-title">
       asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-titleabbrev">
       asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        This approves the asset_report for disposals, creating relevant GL drafts.

If the report is a partial disposal report, imports remaining percentages as new
asset items.
        <programlisting>
DECLARE 
   retval asset_report;
   iter record;
   t_disposed_percent numeric;
begin
-- this code is fairly opaque and needs more documentation that would be 
-- otherwise optimal. This is mostly due to the fact that we have fairly
-- repetitive insert/select routines and the fact that the accounting 
-- requirements are not immediately intuitive.  Inserts marked functionally along
-- with typical debit/credit designations.  Note debits are always negative.


retval := asset_report__record_approve(in_id);
if retval.report_class = 2 then
     t_disposed_percent := 100;
end if;

INSERT INTO gl (reference, description, approved, transdate)
select &#39;Asset Report &#39; || in_id, &#39;Asset Disposal Report for &#39; || report_date,
       false, report_date
 FROM asset_report where id = in_id;

-- REMOVING ASSETS FROM ACCOUNT (Credit)
insert into acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), a.asset_account_id, 
       a.purchase_value 
       * (coalesce(t_disposed_percent, m.percent_disposed)/100), 
       true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 WHERE r.id = in_id;

-- REMOVING ACCUM DEP. (Debit)
INSERT into acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), a.dep_account_id, 
       sum(dl.amount) * -1 
       * (coalesce(t_disposed_percent, m.percent_disposed)/100), 
       true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_report_line dl ON (l.asset_id = dl.asset_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 JOIN  asset_report dr ON (dl.report_id = dr.id 
                           and dr.report_class = 1
                           and dr.approved_at is not null)
 WHERE r.id = in_id
group by a.dep_account_id, m.percent_disposed, r.report_date;

-- INSERT asset/proceeds (Debit, credit for negative values)
INSERT INTO acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), in_asset_acct, coalesce(l.amount, 0) * -1, true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 WHERE r.id = in_id;

-- INSERT GAIN/LOSS (Credit for gain, debit for loss)
INSERT INTO acc_trans(trans_id, chart_id, amount, approved, transdate)
select currval(&#39;id&#39;), 
            CASE WHEN sum(amount) &gt; 0 THEN in_loss_acct
            else in_gain_acct
        END,
        sum(amount) * -1 , true, 
        retval.report_date
  FROM acc_trans
  WHERE trans_id = currval(&#39;id&#39;);

IF retval.report_class = 4 then
   PERFORM asset__import_from_disposal(retval.id);
end if;

return retval;
end;
</programlisting>
      </para>
    </section>

<!-- Function asset_item__add_note(in_note integer, in_subject text, in_id text) -->
    <section id="lsmb14.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text"
             xreflabel="lsmb14asset_item__add_note(in_note integer, in_subject text, in_id text)">
      <title id="lsmb14.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text-title">
       asset_item__add_note(in_note integer, in_subject text, in_id text)
      </title>
      <titleabbrev id="lsmb14.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text-titleabbrev">
       asset_item__add_note(in_note integer, in_subject text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Adds a note to an asset item
        <programlisting>
INSERT INTO asset_note (ref_key, subject, note) values ($1, $2, $3);
SELECT * FROM asset_note WHERE id = currval(&#39;note_id_seq&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer) -->
    <section id="lsmb14.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer"
             xreflabel="lsmb14asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)">
      <title id="lsmb14.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-title">
       asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-titleabbrev">
       asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of matching asset items.  Nulls match all records.
Tag and description allow for partial match.  All other matches are exact.
        <programlisting>
DECLARE retval asset_item;
BEGIN
    FOR retval IN
         SELECT * FROM asset_item
          WHERE (id = in_id or in_id is null)
                and (asset_class_id = in_asset_class or in_asset_class is null)
                and (description like &#39;%&#39;||in_description||&#39;%&#39;
                     or in_description is null)
                and (tag like &#39;%&#39; || in_tag || &#39;%&#39; or in_tag is null)
                and (purchase_value = in_purchase_value 
                    or in_purchase_value is null)
                and (in_purchase_date = purchase_date 
                    or in_purchase_date is null)
                and (start_depreciation = in_start_depreciation
                    or in_start_depreciation is null)
                and (in_warehouse_id = location_id OR in_warehouse_id is null)
                and (department_id = in_department_id 
                    or in_department_id is null)
                and (in_invoice_id = invoice_id OR in_invoice_id IS NULL)
                and (asset_account_id = in_asset_account_id
                    or in_asset_account_id is null)
                and (dep_account_id = in_dep_account_id
                    or in_dep_account_id is null)
   LOOP
       return next retval;
   end loop;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_nbv_report() -->
    <section id="lsmb14.function.asset-nbv-report"
             xreflabel="lsmb14asset_nbv_report()">
      <title id="lsmb14.function.asset-nbv-report-title">
       asset_nbv_report()
      </title>
      <titleabbrev id="lsmb14.function.asset-nbv-report-titleabbrev">
       asset_nbv_report()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_nbv_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the current net book value report.
        <programlisting>
   SELECT ai.id, ai.tag, ai.description, coalesce(ai.start_depreciation, ai.purchase_date),
          adm.short_name, ai.usable_life 
           - months_passed(coalesce(ai.start_depreciation, ai.purchase_date),
                                  coalesce(max(r.report_date),
                                           ai.start_depreciation,
                                           ai.purchase_date))/ 12,
          ai.purchase_value - ai.salvage_value, ai.salvage_value, max(r.report_date),
          sum(rl.amount), ai.purchase_value - sum(rl.amount) 
     FROM asset_item ai
     JOIN asset_class ac ON (ai.asset_class_id = ac.id)
     JOIN asset_dep_method adm ON (adm.id = ac.method)
LEFT JOIN asset_report_line rl ON (ai.id = rl.asset_id)
LEFT JOIN asset_report r on (rl.report_id = r.id)
    WHERE r.id IS NULL OR r.approved_at IS NOT NULL
 GROUP BY ai.id, ai.tag, ai.description, ai.start_depreciation, ai.purchase_date,
          adm.short_name, ai.usable_life, ai.purchase_value, salvage_value
   HAVING (NOT 2 = ANY(as_array(r.report_class))) 
          AND (NOT 4 = ANY(as_array(r.report_class)))
          OR max(r.report_class) IS NULL
 ORDER BY ai.id, ai.tag, ai.description;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer) -->
    <section id="lsmb14.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer"
             xreflabel="lsmb14asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)">
      <title id="lsmb14.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer-title">
       asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer-titleabbrev">
       asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        This function approves an asset report (whether depreciation or disposal).
Also generates relevant GL drafts for review and posting.
        <programlisting>
DECLARE ret_val asset_report;
BEGIN
        UPDATE asset_report 
           SET approved_at = now(),
               approved_by = person__get_my_entity_id()
         where id = in_id;
	SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
        if ret_val.dont_approve is not true then 
                if ret_val.report_class = 1 THEN
                    PERFORM asset_report__generate_gl(in_id, in_expense_acct);
                ELSIF ret_val.report_class = 2 THEN
                    PERFORM asset_report__disposal_gl(
                                 in_id, in_gain_acct, in_loss_acct);
                ELSIF ret_val.report_class = 4 THEN
                    PERFORM asset_disposal__approve(in_id, in_gain_acct, in_loss_acct, (select asset_account_id from asset_class 
                                                                                         where id = ret_val.asset_class)
                                                   );
                ELSE RAISE EXCEPTION &#39;Invalid report class&#39;;
                END IF;
        end if;
	SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
	RETURN ret_val;
end;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer) -->
    <section id="lsmb14.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer"
             xreflabel="lsmb14asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)">
      <title id="lsmb14.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer-title">
       asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer-titleabbrev">
       asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates the asset report recofd for the asset disposal report.
        <programlisting>
DECLARE retval asset_report;

begin

INSERT INTO asset_report (asset_class, report_date, entered_at, entered_by, 
            report_class)
     VALUES (in_asset_class, in_report_date, now(), person__get_my_entity_id(), 
            in_report_class);

SELECT * INTO retval FROM asset_report where id = currval(&#39;asset_report_id_seq&#39;);

return retval;

end;

</programlisting>
      </para>
    </section>

<!-- Function asset_report__begin_import(in_report_date integer, in_asset_class date) -->
    <section id="lsmb14.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date"
             xreflabel="lsmb14asset_report__begin_import(in_report_date integer, in_asset_class date)">
      <title id="lsmb14.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date-title">
       asset_report__begin_import(in_report_date integer, in_asset_class date)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date-titleabbrev">
       asset_report__begin_import(in_report_date integer, in_asset_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates the outline of an asset import report
        <programlisting>
INSERT INTO asset_report (asset_class, report_date, entered_at, entered_by, 
            report_class, dont_approve)
     VALUES ($1, $2, now(), person__get_my_entity_id(), 
            3, true);

SELECT * FROM asset_report where id = currval(&#39;asset_report_id_seq&#39;);

</programlisting>
      </para>
    </section>

<!-- Function asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer) -->
    <section id="lsmb14.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer"
             xreflabel="lsmb14asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)">
      <title id="lsmb14.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-title">
       asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-titleabbrev">
       asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates GL transactions for ful disposal reports.
        <programlisting>
  INSERT 
    INTO gl (reference, description, transdate, approved)
  SELECT setting_increment(&#39;glnumber&#39;), &#39;Asset Report &#39; || asset_report.id,
		report_date, false
    FROM asset_report 
    JOIN asset_report_line ON (asset_report.id = asset_report_line.report_id)
    JOIN asset_item        ON (asset_report_line.asset_id = asset_item.id)
   WHERE asset_report.id = $1
GROUP BY asset_report.id, asset_report.report_date;

  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT a.dep_account_id, currval(&#39;id&#39;)::int, sum(r.accum_depreciation) * -1,
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item a ON (r.id = a.id)
GROUP BY a.dep_account_id, r.disposed_on;

  -- GAIN is negative since it is a debit
  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT case when sum(r.gain_loss) &gt; 0 THEN $3 else $2 end,
         currval(&#39;id&#39;)::int, sum(r.gain_loss),
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item ai ON (r.id = ai.id)
GROUP BY r.disposed_on;

  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT a.asset_account_id, currval(&#39;id&#39;)::int, sum(r.purchase_value),
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item a ON (r.id = a.id)
GROUP BY a.asset_account_id, r.disposed_on;


  SELECT TRUE;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric) -->
    <section id="lsmb14.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric"
             xreflabel="lsmb14asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)">
      <title id="lsmb14.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric-title">
       asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric-titleabbrev">
       asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Disposes of an asset.  in_dm is the disposal method id.
        <programlisting>
BEGIN
    INSERT 
      INTO asset_report_line (report_id, asset_id, amount)
    values (in_id, in_asset_id, in_amount);

    INSERT 
      INTO asset_rl_to_disposal_method 
           (report_id, asset_id, disposal_method_id, percent_disposed)
    VALUES (in_id, in_asset_id, in_dm, in_percent_disposed);

    RETURN TRUE;
    END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date) -->
    <section id="lsmb14.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date"
             xreflabel="lsmb14asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)">
      <title id="lsmb14.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date-title">
       asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date-titleabbrev">
       asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates lines to select/deselect for the asset report (depreciation or
disposal).
        <programlisting>
   SELECT ai.*
     FROM asset_item ai
     JOIN asset_class ac ON (ai.asset_class_id = ac.id)
LEFT JOIN asset_report_line arl ON (arl.asset_id = ai.id)
LEFT JOIN asset_report ar ON (arl.report_id = ar.id)
    WHERE COALESCE(ai.start_depreciation, ai.purchase_date) &lt;= $3 AND ac.id = $2
          AND obsolete_by IS NULL
 GROUP BY ai.id, ai.tag, ai.description, ai.purchase_value, ai.usable_life,
          ai.purchase_date, ai.location_id, ai.invoice_id, ai.asset_account_id,
          ai.dep_account_id, ai.asset_class_id, ai.start_depreciation,
          ai.salvage_value, ai.department_id, ai.exp_account_id, ai.obsolete_by
   HAVING (count(ar.report_class) = 0 OR    
          (2 &lt;&gt; ALL(as_array(ar.report_class)) 
          and 4 &lt;&gt; ALL(as_array(ar.report_class))))
          AND ((ai.purchase_value - coalesce(sum(arl.amount), 0) 
               &gt; ai.salvage_value) and ai.obsolete_by is null)
               OR $1 is not true;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__generate_gl(in_accum_account_id integer, in_report_id integer) -->
    <section id="lsmb14.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer"
             xreflabel="lsmb14asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)">
      <title id="lsmb14.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer-title">
       asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer-titleabbrev">
       asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates a GL transaction when the Asset report is approved.

Currently this creates GL drafts, not approved transctions

        <programlisting>
DECLARE 
	t_report_dept record;
	t_dep_amount numeric;

Begin
	INSERT INTO gl (reference, description, transdate, approved)
	SELECT setting_increment(&#39;glnumber&#39;), &#39;Asset Report &#39; || asset_report.id,
		report_date, false
	FROM asset_report 
	JOIN asset_report_line 
		ON (asset_report.id = asset_report_line.report_id)
	JOIN asset_item 
		ON (asset_report_line.asset_id = asset_item.id)
	WHERE asset_report.id = in_report_id
	GROUP BY asset_report.id, asset_report.report_date;

	INSERT INTO acc_trans (trans_id, chart_id, transdate, approved, amount)
	SELECT gl.id, a.exp_account_id, r.report_date, true, sum(amount) * -1
	FROM asset_report r
	JOIN asset_report_line l ON (r.id = l.report_id)
	JOIN asset_item a ON (l.asset_id = a.id)
	JOIN gl ON (gl.description = &#39;Asset Report &#39; || l.report_id)
	WHERE r.id = in_report_id
	GROUP BY gl.id, r.report_date, a.exp_account_id;

	INSERT INTO acc_trans (trans_id, chart_id, transdate, approved, amount)
	SELECT gl.id, a.dep_account_id, r.report_date, true, sum(amount)
	FROM asset_report r
	JOIN asset_report_line l ON (r.id = l.report_id)
	JOIN asset_item a ON (l.asset_id = a.id)
	JOIN gl ON (gl.description = &#39;Asset Report &#39; || l.report_id) 
	WHERE r.id = in_report_id
	GROUP BY gl.id, a.dep_account_id, r.report_date, a.tag, a.description;

	RETURN in_report_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get(in_id integer) -->
    <section id="lsmb14.function.asset-report-get-in-id-integer"
             xreflabel="lsmb14asset_report__get(in_id integer)">
      <title id="lsmb14.function.asset-report-get-in-id-integer-title">
       asset_report__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-in-id-integer-titleabbrev">
       asset_report__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the asset_report line identified by id.
        <programlisting>
select * from asset_report where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_disposal(in_id integer) -->
    <section id="lsmb14.function.asset-report-get-disposal-in-id-integer"
             xreflabel="lsmb14asset_report__get_disposal(in_id integer)">
      <title id="lsmb14.function.asset-report-get-disposal-in-id-integer-title">
       asset_report__get_disposal(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-disposal-in-id-integer-titleabbrev">
       asset_report__get_disposal(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_disposal_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of lines of disposed assets in a disposal report, specified
by the report id.
        <programlisting>
   SELECT ai.id, ai.tag, ai.description, ai.start_depreciation, r.report_date,
          dm.short_label, ai.purchase_value, 
          sum (CASE WHEN pr.report_class in (1,3) THEN prl.amount ELSE 0 END) 
          as accum_dep,
          l.amount, 
          ai.purchase_value - sum(CASE WHEN pr.report_class in (1,3) 
                                       THEN prl.amount 
                                       ELSE 0 
                                   END) as adjusted_basis,
          l.amount - ai.purchase_value + sum(CASE WHEN pr.report_class in (1,3)
                                                  THEN prl.amount 
                                                  ELSE 0 
                                              END) as gain_loss
     FROM asset_item ai
     JOIN asset_report_line l   ON (l.report_id = $1 AND ai.id = l.asset_id)
     JOIN asset_report r        ON (l.report_id = r.id)
LEFT JOIN asset_rl_to_disposal_method adm 
                             USING (report_id, asset_id)
     JOIN asset_disposal_method dm
                                ON (adm.disposal_method_id = dm.id)
LEFT JOIN asset_report_line prl ON (prl.report_id &lt;&gt; $1 
                                   AND ai.id = prl.asset_id)
LEFT JOIN asset_report pr       ON (prl.report_id = pr.id)
 GROUP BY ai.id, ai.tag, ai.description, ai.start_depreciation, r.report_date,
          ai.purchase_value, l.amount, dm.short_label
 ORDER BY ai.id, ai.tag;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_disposal_methods() -->
    <section id="lsmb14.function.asset-report-get-disposal-methods"
             xreflabel="lsmb14asset_report__get_disposal_methods()">
      <title id="lsmb14.function.asset-report-get-disposal-methods-title">
       asset_report__get_disposal_methods()
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-disposal-methods-titleabbrev">
       asset_report__get_disposal_methods()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_disposal_method</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of asset_disposal_method items ordered by label.
        <programlisting>
SELECT * FROM asset_disposal_method order by label;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_expense_accts() -->
    <section id="lsmb14.function.asset-report-get-expense-accts"
             xreflabel="lsmb14asset_report__get_expense_accts()">
      <title id="lsmb14.function.asset-report-get-expense-accts-title">
       asset_report__get_expense_accts()
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-expense-accts-titleabbrev">
       asset_report__get_expense_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all asset expense reports.
        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_expense&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_gain_accts() -->
    <section id="lsmb14.function.asset-report-get-gain-accts"
             xreflabel="lsmb14asset_report__get_gain_accts()">
      <title id="lsmb14.function.asset-report-get-gain-accts-title">
       asset_report__get_gain_accts()
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-gain-accts-titleabbrev">
       asset_report__get_gain_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of gain accounts for asset depreciation and disposal reports.

        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_gain&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_lines(in_id integer) -->
    <section id="lsmb14.function.asset-report-get-lines-in-id-integer"
             xreflabel="lsmb14asset_report__get_lines(in_id integer)">
      <title id="lsmb14.function.asset-report-get-lines-in-id-integer-title">
       asset_report__get_lines(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-lines-in-id-integer-titleabbrev">
       asset_report__get_lines(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_report_line_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the lines of an asset depreciation report.
        <programlisting>
   select ai.tag, coalesce(ai.start_depreciation, ai.purchase_date), ai.purchase_value, m.short_name, 
          ai.usable_life, 
          ai.purchase_value - ai.salvage_value, max(pr.report_date),
          sum(case when pr.report_date &lt; r.report_date then prl.amount
                   else 0
                end), 
          rl.amount, 
          sum (case when extract(year from pr.report_date)
                         = extract(year from r.report_date)
                         AND pr.report_date &lt; r.report_date
                    then prl.amount
                    else 0
                end), 
          sum(prl.amount), 
          ai.description, ai.purchase_date
     FROM asset_item ai
     JOIN asset_class c ON (ai.asset_class_id = c.id)
     JOIN asset_dep_method m ON (c.method = m.id)
     JOIN asset_report_line rl ON (rl.asset_id = ai.id)
     JOIN asset_report r ON (rl.report_id = r.id)
LEFT JOIN asset_report_line prl ON (prl.asset_id = ai.id)
LEFT JOIN asset_report pr ON (prl.report_id = pr.id)
    WHERE rl.report_id = $1
 GROUP BY ai.tag, ai.start_depreciation, ai.purchase_value, m.short_name,
          ai.usable_life, ai.salvage_value, r.report_date, rl.amount,
          ai.description, ai.purchase_date;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_loss_accts() -->
    <section id="lsmb14.function.asset-report-get-loss-accts"
             xreflabel="lsmb14asset_report__get_loss_accts()">
      <title id="lsmb14.function.asset-report-get-loss-accts-title">
       asset_report__get_loss_accts()
      </title>
      <titleabbrev id="lsmb14.function.asset-report-get-loss-accts-titleabbrev">
       asset_report__get_loss_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of loss accounts for asset depreciation and disposal reports.

        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_loss&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean) -->
    <section id="lsmb14.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean"
             xreflabel="lsmb14asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)">
      <title id="lsmb14.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean-title">
       asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean-titleabbrev">
       asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Imports an asset with the supplied information.  If in_obsolete_other is
false, this creates a new depreciable asset.  If it is true, it sets up the 
other asset as obsolete.  This is the way partial disposal reports are handled.

        <programlisting>

SET CONSTRAINTS asset_item_obsolete_by_fkey DEFERRED;
-- This fails a deferrable fkey constraint but avoids a partial unique index
-- so in this case, the foreign key is deferred for the duration of this 
-- specific stored proc call.

UPDATE asset_item
   SET obsolete_by = -1 
 WHERE tag = $2 and $17 is true;

INSERT 
  INTO asset_report_line 
       (report_id, asset_id, amount, department_id, warehouse_id)
select $15, id, $16, department_id, location_id
  from asset__save
       (NULL, $13, $1, $2, $6, $3, $5, coalesce($4, 0), $7, $8, $9, $14, $10, $11, $12);

UPDATE asset_item 
   SET obsolete_by = currval(&#39;asset_item_id_seq&#39;)
 WHERE obsolete_by = -1;

-- enforce fkeys now and raise exception if fail
SET CONSTRAINTS asset_item_obsolete_by_fkey IMMEDIATE;
SELECT true;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__record_approve(in_id integer) -->
    <section id="lsmb14.function.asset-report-record-approve-in-id-integer"
             xreflabel="lsmb14asset_report__record_approve(in_id integer)">
      <title id="lsmb14.function.asset-report-record-approve-in-id-integer-title">
       asset_report__record_approve(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-record-approve-in-id-integer-titleabbrev">
       asset_report__record_approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Marks the asset_report record approved.  Not generally recommended to call
directly.
        <programlisting>
UPDATE asset_report 
   set approved_by = person__get_my_entity_id(),
       approved_at = now()
 where id = $1;

select * from asset_report where id = $1;

</programlisting>
      </para>
    </section>

<!-- Function asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean) -->
    <section id="lsmb14.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean"
             xreflabel="lsmb14asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)">
      <title id="lsmb14.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean-title">
       asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean-titleabbrev">
       asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates or updates an asset report with the information presented.  Note that
approval values are not set here, and that one cannot unsubmit a report though
this function.
        <programlisting>
DECLARE 
	ret_val asset_report;
	item record;
	method_text text;
BEGIN
	UPDATE asset_report 
	set asset_class = in_asset_class,
		report_class = in_report_class,
		report_date = in_report_date,
		submitted = (in_submit or submitted)
	WHERE id = in_id;

	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
	ELSE 
		INSERT INTO asset_report(report_class, asset_class, report_date,
			submitted)
		values (in_report_class, in_asset_class, in_report_date, 
			coalesce(in_submit, true));

		SELECT * INTO ret_val FROM asset_report 
		WHERE id = currval(&#39;asset_report_id_seq&#39;);
                
	END IF;
        RETURN ret_val;

END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer) -->
    <section id="lsmb14.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer"
             xreflabel="lsmb14asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)">
      <title id="lsmb14.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer-title">
       asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer-titleabbrev">
       asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_report_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for asset reports.  Nulls match all rows.  Approved, asset class, 
and entered_by are exact matches.  Start_date and end_date define the beginning
and end of the search date. 
        <programlisting>

  SELECT r.id, r.report_date, r.gl_id, r.asset_class, r.report_class, 
         r.entered_by, r.approved_by, r.entered_at, r.approved_at, 
         r.depreciated_qty, r.dont_approve, r.submitted, sum(l.amount)
    FROM asset_report r
    JOIN asset_report_line l ON (l.report_id = r.id)
   where ($1 is null or $1 &lt;= report_date)
         and ($2 is null or $2 &gt;= report_date)
         and ($3 is null or $3 = asset_class)
         and ($4 is null 
              or ($4 is true and approved_by is not null)
              or ($4 is false and approved_by is null))
         and ($5 is null or $5 = entered_by)
GROUP BY r.id, r.report_date, r.gl_id, r.asset_class, r.report_class,
         r.entered_by, r.approved_by, r.entered_at, r.approved_at,
         r.depreciated_qty, r.dont_approve, r.submitted;
</programlisting>
      </para>
    </section>

<!-- Function asset_report_partial_disposal_details(in_id integer) -->
    <section id="lsmb14.function.asset-report-partial-disposal-details-in-id-integer"
             xreflabel="lsmb14asset_report_partial_disposal_details(in_id integer)">
      <title id="lsmb14.function.asset-report-partial-disposal-details-in-id-integer-title">
       asset_report_partial_disposal_details(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.asset-report-partial-disposal-details-in-id-integer-titleabbrev">
       asset_report_partial_disposal_details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF partial_disposal_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the partial disposal details for a partial disposal report.
        <programlisting>
SELECT ai.id, ai.tag, ai.start_depreciation, ai.purchase_value, ai.description,
       ar.report_date, arld.percent_disposed, 
       (arld.percent_disposed / 100) * ai.purchase_value, 
       100 - arld.percent_disposed,
       ((100 - arld.percent_disposed)/100) * ai.purchase_value
  FROM asset_item ai
  JOIN asset_report_line l ON (ai.id = l.asset_id)
  JOIN asset_report ar ON (ar.id = l.report_id)
  JOIN asset_rl_to_disposal_method arld
       ON  ((arld.report_id, arld.asset_id) = (l.report_id, l.asset_id))
 WHERE ar.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function avgcost(integer) -->
    <section id="lsmb14.function.avgcost-integer"
             xreflabel="lsmb14avgcost(integer)">
      <title id="lsmb14.function.avgcost-integer-title">
       avgcost(integer)
      </title>
      <titleabbrev id="lsmb14.function.avgcost-integer-titleabbrev">
       avgcost(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE

v_cost float;
v_qty float;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost, v_qty SUM(i.sellprice * i.qty), SUM(i.qty)
  FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id;
  
  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

  IF NOT v_qty IS NULL THEN
    IF v_qty = 0 THEN
      v_cost := 0;
    ELSE
      v_cost := v_cost/v_qty;
    END IF;
  END IF;

RETURN v_cost;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date) -->
    <section id="lsmb14.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date"
             xreflabel="lsmb14batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)">
      <title id="lsmb14.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date-title">
       batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)
      </title>
      <titleabbrev id="lsmb14.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date-titleabbrev">
       batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts the batch into the table.
        <programlisting>
BEGIN
	INSERT INTO 
		batch (batch_class_id, default_date, description, control_code,
			created_by)
	VALUES ((SELECT id FROM batch_class WHERE class = in_batch_class),
		in_batch_date, in_description, in_batch_number, 
			(select entity_id FROM users WHERE username = session_user));

	return currval(&#39;batch_id_seq&#39;);
END;	
</programlisting>
      </para>
    </section>

<!-- Function batch_delete(in_batch_id integer) -->
    <section id="lsmb14.function.batch-delete-in-batch-id-integer"
             xreflabel="lsmb14batch_delete(in_batch_id integer)">
      <title id="lsmb14.function.batch-delete-in-batch-id-integer-title">
       batch_delete(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb14.function.batch-delete-in-batch-id-integer-titleabbrev">
       batch_delete(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        If the batch is found and unapproved, deletes it and returns 1.
Otherwise raises an exception.
        <programlisting>
DECLARE 
	t_transaction_ids int[];
BEGIN
	-- Adjust AR/AP tables for payment and payment reversal vouchers
	-- voucher_id is only set in acc_trans on payment/receipt vouchers and
	-- their reversals. -CT
        perform * from batch where id = in_batch_id and approved_on IS NULL;
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Batch not found&#39;;
        END IF; 
	update ar set paid = amount + 
		(select sum(amount) from acc_trans 
		join chart ON (acc_trans.chart_id = chart.id)
		where link = &#39;AR&#39; AND trans_id = ar.id
			AND (voucher_id IS NULL OR voucher_id NOT IN 
				(select id from voucher 
				WHERE batch_id = in_batch_id))) 
	where id in (select trans_id from acc_trans where voucher_id IN 
		(select id from voucher where batch_id = in_batch_id));

	update ap set paid = amount - (select sum(amount) from acc_trans 
		join chart ON (acc_trans.chart_id = chart.id)
		where link = &#39;AP&#39; AND trans_id = ap.id
			AND (voucher_id IS NULL OR voucher_id NOT IN 
				(select id from voucher 
				WHERE batch_id = in_batch_id))) 
	where id in (select trans_id from acc_trans where voucher_id IN 
		(select id from voucher where batch_id = in_batch_id));

        DELETE FROM ac_tax_form WHERE entry_id IN
               (select entry_id from acc_trans where voucher_id in
                       (select id from voucher where batch_id = in_batch_id)
               );

	DELETE FROM acc_trans WHERE voucher_id IN 
		(select id FROM voucher where batch_id = in_batch_id);

	-- The rest of this function involves the deletion of actual
	-- transactions, vouchers, and batches, and jobs which are in progress.
	-- -CT
	SELECT as_array(trans_id) INTO t_transaction_ids
	FROM voucher WHERE batch_id = in_batch_id AND batch_class IN (1, 2, 5);

        DELETE FROM ac_tax_form WHERE entry_id in
               (select entry_id from acc_trans 
                 where trans_id = any(t_transaction_ids));

	DELETE FROM acc_trans WHERE trans_id = ANY(t_transaction_ids);
	DELETE FROM ap WHERE id = ANY(t_transaction_ids);
	DELETE FROM gl WHERE id = ANY(t_transaction_ids);
	DELETE FROM voucher WHERE batch_id = in_batch_id;
	DELETE FROM batch WHERE id = in_batch_id;
	DELETE FROM transactions WHERE id = ANY(t_transaction_ids);

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_get_class_id(in_type text) -->
    <section id="lsmb14.function.batch-get-class-id-in-type-text"
             xreflabel="lsmb14batch_get_class_id(in_type text)">
      <title id="lsmb14.function.batch-get-class-id-in-type-text-title">
       batch_get_class_id(in_type text)
      </title>
      <titleabbrev id="lsmb14.function.batch-get-class-id-in-type-text-titleabbrev">
       batch_get_class_id(in_type text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        returns the batch class id associated with the in_type label provided.
        <programlisting>
SELECT id FROM batch_class WHERE class = $1;
</programlisting>
      </para>
    </section>

<!-- Function batch_get_users() -->
    <section id="lsmb14.function.batch-get-users"
             xreflabel="lsmb14batch_get_users()">
      <title id="lsmb14.function.batch-get-users-title">
       batch_get_users()
      </title>
      <titleabbrev id="lsmb14.function.batch-get-users-titleabbrev">
       batch_get_users()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a sim[ple set of user objects.  This should be renamed so that 
it is more obvious it is a general purpose function.
        <programlisting>
DECLARE out_record users%ROWTYPE;
BEGIN
	FOR out_record IN
		SELECT * from users WHERE entity_id IN (select created_by from batch)
	LOOP
		RETURN NEXT out_record;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_list_classes() -->
    <section id="lsmb14.function.batch-list-classes"
             xreflabel="lsmb14batch_list_classes()">
      <title id="lsmb14.function.batch-list-classes-title">
       batch_list_classes()
      </title>
      <titleabbrev id="lsmb14.function.batch-list-classes-titleabbrev">
       batch_list_classes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all batch classes.
        <programlisting>
DECLARE out_val record;
BEGIN
	FOR out_val IN select * from batch_class order by id
 	LOOP
		return next out_val;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_post(in_batch_id integer) -->
    <section id="lsmb14.function.batch-post-in-batch-id-integer"
             xreflabel="lsmb14batch_post(in_batch_id integer)">
      <title id="lsmb14.function.batch-post-in-batch-id-integer-title">
       batch_post(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb14.function.batch-post-in-batch-id-integer-titleabbrev">
       batch_post(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts the specified batch to the books.  Only posted batches should show up
on standard financial reports.
        <programlisting>
BEGIN
	UPDATE ar SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 2);
	
	UPDATE ap SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 1);

	UPDATE gl SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 5);

	UPDATE acc_trans SET approved = true 
	WHERE voucher_id IN (select id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class IN (3, 4, 6, 7));

	UPDATE batch 
	SET approved_on = now(),
		approved_by = (select entity_id FROM users 
			WHERE username = SESSION_USER)
	WHERE id = in_batch_id;

	RETURN now()::date;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean) -->
    <section id="lsmb14.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean"
             xreflabel="lsmb14batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)">
      <title id="lsmb14.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-title">
       batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-titleabbrev">
       batch_search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of batches and amounts processed on the batch.

Nulls match all values.
in_date_from and in_date_to specify date ranges.
in_description is a partial match.
All other criteria are exact matches.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
		SELECT b.id, c.class, b.control_code, b.description, u.username,
			b.created_on, b.default_date,
			sum(
				CASE WHEN vc.id = 5 AND al.amount &lt; 0 -- GL
				     THEN al.amount 
				     WHEN vc.id  = 1
				     THEN ap.amount 
				     WHEN vc.id = 2
                                     THEN ap.amount
				     ELSE 0
                                END) AS transaction_total,
			sum(
				CASE WHEN alc.link = &#39;AR&#39; AND vc.id IN (6, 7)
				     THEN al.amount
				     WHEN alc.link = &#39;AP&#39; AND vc.id IN (3, 4)
				     THEN al.amount * -1
				     ELSE 0
				END
			   ) AS payment_total
		FROM batch b
		JOIN batch_class c ON (b.batch_class_id = c.id)
		LEFT JOIN users u ON (u.entity_id = b.created_by)
		LEFT JOIN voucher v ON (v.batch_id = b.id)
		LEFT JOIN batch_class vc ON (v.batch_class = vc.id)
		LEFT JOIN ar ON (vc.id = 2 AND v.trans_id = ar.id)
		LEFT JOIN ap ON (vc.id = 1 AND v.trans_id = ap.id)
		LEFT JOIN acc_trans al ON 
			((vc.id = 5 AND v.trans_id = al.trans_id) OR
				(vc.id IN (3, 4, 6, 7) 
					AND al.voucher_id = v.id))
		LEFT JOIN chart alc ON (al.chart_id = alc.id)
		WHERE (c.id = in_class_id OR in_class_id IS NULL) AND 
			(b.description LIKE 
				&#39;%&#39; || in_description || &#39;%&#39; OR
				in_description IS NULL) AND
			(in_created_by_eid = b.created_by OR
				in_created_by_eid IS NULL) AND
			((in_approved = false OR in_approved IS NULL AND
				approved_on IS NULL) OR
				(in_approved = true AND approved_on IS NOT NULL)
			) 
			and (in_date_from IS NULL 
				or b.default_date &gt;= in_date_from)
			and (in_date_to IS NULL
				or b.default_date &lt;= in_date_to)
		GROUP BY b.id, c.class, b.description, u.username, b.created_on,
			b.control_code, b.default_date
		HAVING  
			(in_amount_gt IS NULL OR
			sum(coalesce(ar.amount - ar.paid, ap.amount - ap.paid, 
				al.amount)) 
			&gt;= in_amount_gt) 
			AND 
			(in_amount_lt IS NULL OR
			sum(coalesce(ar.amount - ar.paid, ap.amount - ap.paid, 
				al.amount))
			&lt;= in_amount_lt)
		ORDER BY b.control_code, b.description
		
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean) -->
    <section id="lsmb14.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean"
             xreflabel="lsmb14batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)">
      <title id="lsmb14.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-title">
       batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-titleabbrev">
       batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a full search for the batches, listing them by amount processed.
in_amount_gt and in_amount_lt provide a range to search for.
in_description is a partial match field.
Other fields are exact matches.

NULLs match all values.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
               SELECT b.id, c.class, b.control_code, b.description, u.username,
                        b.created_on, b.default_date, 0, 0
                FROM batch b
                JOIN batch_class c ON (b.batch_class_id = c.id)
                JOIN users u ON (u.entity_id = b.created_by)
                LEFT JOIN voucher v ON (v.batch_id = b.id) 
               where v.id is null
                     and(u.entity_id = in_created_by_eid 
                     or in_created_by_eid is null) and
                     (in_description is null or b.description 
                     like &#39;%&#39;  || in_description || &#39;%&#39;) and
                     (in_class_id is null or c.id = in_class_id)
            GROUP BY b.id, c.class, b.description, u.username, b.created_on, 
                     b.control_code, b.default_date
            ORDER BY b.control_code, b.description

		
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean) -->
    <section id="lsmb14.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean"
             xreflabel="lsmb14batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)">
      <title id="lsmb14.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean-title">
       batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean-titleabbrev">
       batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This performs a simple search of open batches created by the entity_id
in question.  This is used to pull up batches that were currently used so that
they can be picked up and more vouchers added.

NULLs match all values.
in_description is a partial match
All other inouts are exact matches.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
		SELECT b.id, c.class, b.control_code, b.description, u.username,
			b.created_on, b.default_date, NULL
		FROM batch b
		JOIN batch_class c ON (b.batch_class_id = c.id)
		LEFT JOIN users u ON (u.entity_id = b.created_by)
		WHERE (c.id = in_class_id OR in_class_id IS NULL) AND 
			(b.description LIKE 
				&#39;%&#39; || in_description || &#39;%&#39; OR
				in_description IS NULL) AND
			(in_created_by_eid = b.created_by OR
				in_created_by_eid IS NULL) AND
			((in_approved = false OR in_approved IS NULL AND
				approved_on IS NULL) OR
				(in_approved = true AND approved_on IS NOT NULL)
			)
		GROUP BY b.id, c.class, b.description, u.username, b.created_on,
			b.control_code, b.default_date
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__approve(in_id integer) -->
    <section id="lsmb14.function.budget-approve-in-id-integer"
             xreflabel="lsmb14budget__approve(in_id integer)">
      <title id="lsmb14.function.budget-approve-in-id-integer-title">
       budget__approve(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-approve-in-id-integer-titleabbrev">
       budget__approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
UPDATE budget_info 
   set approved_at = now(), approved_by = person__get_my_entity_id()
 WHERE id = $1;

SELECT budget__get_info($1);
</programlisting>
      </para>
    </section>

<!-- Function budget__get_business_units(in_id integer) -->
    <section id="lsmb14.function.budget-get-business-units-in-id-integer"
             xreflabel="lsmb14budget__get_business_units(in_id integer)">
      <title id="lsmb14.function.budget-get-business-units-in-id-integer-title">
       budget__get_business_units(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-get-business-units-in-id-integer-titleabbrev">
       budget__get_business_units(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> select bu.*
     FROM business_unit bu
     JOIN budget_to_business_unit b2bu ON b2bu.bu_id = bu.id
     JOIN budget_info bi ON bi.id = b2bu.budget_id
    WHERE bi.id = $1
 ORDER BY bu.class_id;
</programlisting>
      </para>
    </section>

<!-- Function budget__get_details(in_id integer) -->
    <section id="lsmb14.function.budget-get-details-in-id-integer"
             xreflabel="lsmb14budget__get_details(in_id integer)">
      <title id="lsmb14.function.budget-get-details-in-id-integer-title">
       budget__get_details(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-get-details-in-id-integer-titleabbrev">
       budget__get_details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_line</seg>
        </seglistitem>
       </segmentedlist>
 
        This retrieves the budget lines associated with a budget.
        <programlisting>
  SELECT * FROM budget_line where budget_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function budget__get_info(in_id integer) -->
    <section id="lsmb14.function.budget-get-info-in-id-integer"
             xreflabel="lsmb14budget__get_info(in_id integer)">
      <title id="lsmb14.function.budget-get-info-in-id-integer-title">
       budget__get_info(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-get-info-in-id-integer-titleabbrev">
       budget__get_info(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        Selects the budget info. 
        <programlisting> 
select bi.id, bi.start_date, bi.end_date, bi.reference, bi.description, 
       bi.entered_by, bi.approved_by, bi.obsolete_by, bi.entered_at, 
       bi.approved_at, bi.obsolete_at, 
       ee.name, ae.name, oe.name
  from budget_info bi
  JOIN entity ee ON bi.entered_by = ee.id
  LEFT JOIN entity ae ON bi.approved_by = ae.id
  LEFT JOIN entity oe ON bi.obsolete_by = oe.id
 where bi.id = $1; 
</programlisting>
      </para>
    </section>

<!-- Function budget__get_notes(in_id integer) -->
    <section id="lsmb14.function.budget-get-notes-in-id-integer"
             xreflabel="lsmb14budget__get_notes(in_id integer)">
      <title id="lsmb14.function.budget-get-notes-in-id-integer-title">
       budget__get_notes(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-get-notes-in-id-integer-titleabbrev">
       budget__get_notes(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all notes associated with a budget, by default in the order they 
were created.
        <programlisting> 
SELECT * FROM budget_note WHERE ref_key = $1
 ORDER BY created;
</programlisting>
      </para>
    </section>

<!-- Function budget__mark_obsolete(in_id integer) -->
    <section id="lsmb14.function.budget-mark-obsolete-in-id-integer"
             xreflabel="lsmb14budget__mark_obsolete(in_id integer)">
      <title id="lsmb14.function.budget-mark-obsolete-in-id-integer-title">
       budget__mark_obsolete(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-mark-obsolete-in-id-integer-titleabbrev">
       budget__mark_obsolete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        Marks a budget as obsolete 
        <programlisting>
UPDATE budget_info 
   set obsolete_by = person__get_my_entity_id(), obsolete_at = now()
 WHERE id = $1 and approved_by is not null;
SELECT budget__get_info($1)
</programlisting>
      </para>
    </section>

<!-- Function budget__reject(in_id integer) -->
    <section id="lsmb14.function.budget-reject-in-id-integer"
             xreflabel="lsmb14budget__reject(in_id integer)">
      <title id="lsmb14.function.budget-reject-in-id-integer-title">
       budget__reject(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-reject-in-id-integer-titleabbrev">
       budget__reject(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes unapproved budgets only.
        <programlisting>
BEGIN

DELETE FROM budget_line 
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_to_project
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_to_department
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_info WHERE id = in_id AND approved_by IS NULL;

RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_details(in_details integer, in_id text[]) -->
    <section id="lsmb14.function.budget-save-details-in-details-integer-in-id-textARRAY"
             xreflabel="lsmb14budget__save_details(in_details integer, in_id text[])">
      <title id="lsmb14.function.budget-save-details-in-details-integer-in-id-textARRAY-title">
       budget__save_details(in_details integer, in_id text[])
      </title>
      <titleabbrev id="lsmb14.function.budget-save-details-in-details-integer-in-id-textARRAY-titleabbrev">
       budget__save_details(in_details integer, in_id text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        This saves the line items for the budget.  in_details is an array n long
where each entry is {int account_id, text description, numeric amount}.  The
in_id parameter is the budget_id.
        <programlisting>
DECLARE
   loop_count int;
   retval budget_info_ext;
BEGIN
    FOR loop_count in   
        array_lower(in_details, 1) ..
        array_upper(in_details, 1)
    LOOP
        INSERT INTO budget_line 
                    (budget_id, 
                     account_id, 
                     description, 
                     amount)
             VALUES (in_id, 
                     in_details[loop_count][1]::int, 
                     in_details[loop_count][2], 
                     in_details[loop_count][3]::numeric);
    END LOOP;
    retval := budget__get_info(in_id);
    return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[]) -->
    <section id="lsmb14.function.budget-save-info-in-business-units-integer-in-description-date-in-reference-date-in-end-date-text-in-start-date-text-in-id-integerARRAY"
             xreflabel="lsmb14budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[])">
      <title id="lsmb14.function.budget-save-info-in-business-units-integer-in-description-date-in-reference-date-in-end-date-text-in-start-date-text-in-id-integerARRAY-title">
       budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[])
      </title>
      <titleabbrev id="lsmb14.function.budget-save-info-in-business-units-integer-in-description-date-in-reference-date-in-end-date-text-in-start-date-text-in-id-integerARRAY-titleabbrev">
       budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves the extended budget info passed through to the function.  See the 
comment on type budget_info_ext for more information.
        <programlisting>
DECLARE 
   retval budget_info_ext;
   t_id int;
BEGIN

   PERFORM * FROM budget_info WHERE id = in_id and approved_by is not null;
   IF FOUND THEN
       RAISE EXCEPTION &#39;report approved&#39;;
   END IF;

  UPDATE budget_info
     SET start_date = in_start_date,
         end_date = in_end_date,
         reference = in_reference,
         description = in_description
   WHERE id = in_id and approved_by is null;
  IF FOUND THEN
      t_id := in_id;
  ELSE
       INSERT INTO budget_info (start_date, end_date, reference, description)
            VALUES (in_start_date, in_end_date, in_reference, in_description);
       t_id = currval(&#39;budget_info_id_seq&#39;);

       INSERT INTO budget_to_business_unit(budget_id, bu_id, bu_class)
       SELECT t_id, id, class_id
         FROM business_unit
        WHERE id = ANY(in_business_units);
  END IF;
  retval := budget__get_info(t_id);
  return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_note(in_note integer, in_subject text, in_id text) -->
    <section id="lsmb14.function.budget-save-note-in-note-integer-in-subject-text-in-id-text"
             xreflabel="lsmb14budget__save_note(in_note integer, in_subject text, in_id text)">
      <title id="lsmb14.function.budget-save-note-in-note-integer-in-subject-text-in-id-text-title">
       budget__save_note(in_note integer, in_subject text, in_id text)
      </title>
      <titleabbrev id="lsmb14.function.budget-save-note-in-note-integer-in-subject-text-in-id-text-titleabbrev">
       budget__save_note(in_note integer, in_subject text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a note attached to a budget.
        <programlisting>
INSERT INTO budget_note (subject, note, ref_key) 
     values ($2, $3, $1);

SELECT * FROM budget_note WHERE id = currval(&#39;note_id_seq&#39;::regclass);
</programlisting>
      </para>
    </section>

<!-- Function budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean) -->
    <section id="lsmb14.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-business-units-date-in-obsolete-by-text-in-approved-by-text-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integerARRAY-in-end-date-boolean-in-start-date-boolean"
             xreflabel="lsmb14budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean)">
      <title id="lsmb14.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-business-units-date-in-obsolete-by-text-in-approved-by-text-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integerARRAY-in-end-date-boolean-in-start-date-boolean-title">
       budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean)
      </title>
      <titleabbrev id="lsmb14.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-business-units-date-in-obsolete-by-text-in-approved-by-text-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integerARRAY-in-end-date-boolean-in-start-date-boolean-titleabbrev">
       budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a general search for budgets
        <programlisting>
select bi.id, bi.start_date, bi.end_date, bi.reference, bi.description, 
       bi.entered_by, bi.approved_by, bi.obsolete_by, bi.entered_at, 
       bi.approved_at, bi.obsolete_at, 
       ee.name, ae.name, oe.name
  from budget_info bi 
  JOIN entity ee ON bi.entered_by = ee.id
  LEFT JOIN entity ae ON bi.approved_by = ae.id
  LEFT JOIN entity oe ON bi.obsolete_by = oe.id
 WHERE (start_date = $1 or $1 is null) AND ($2 = end_date or $2 is null) 
       AND ($3 BETWEEN start_date AND end_date or $2 is null)
       AND ($4 ilike reference || &#39;%&#39; or $4 is null) 
       AND (bi.description @@ plainto_tsquery($5) or $5 is null) 
       AND ($6 = entered_by or $6 is null) 
       AND ($7 = approved_by or $7 is null) 
       AND ($8 = obsolete_by or $8 is null) 
       AND ($10 IS NULL OR ($10 = (approved_by IS NOT NULL)))
       AND ($11 IS NULL OR ($11 = (obsolete_by IS NOT NULL)))
 ORDER BY reference;
</programlisting>
      </para>
    </section>

<!-- Function budget__variance_report(in_id integer) -->
    <section id="lsmb14.function.budget-variance-report-in-id-integer"
             xreflabel="lsmb14budget__variance_report(in_id integer)">
      <title id="lsmb14.function.budget-variance-report-in-id-integer-title">
       budget__variance_report(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.budget-variance-report-in-id-integer-titleabbrev">
       budget__variance_report(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_variance_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a variance report for budget with an id of in_id.
        <programlisting>
   WITH agg_account (amount, id, transdate)
        AS ( SELECT ac.amount *
                    CASE WHEN a.contra THEN -1 ELSE 1 END *
                    CASE WHEN a.category IN (&#39;A&#39;, &#39;E&#39;) THEN -1 ELSE 1 END
                    AS amount,
                    ac.chart_id, ac.transdate
               FROM acc_trans ac
               JOIN account a ON ac.chart_id = a.id
           )
   SELECT act.accno, act.description, act.id, b.description, b.amount,
          coalesce(sum(a.amount), 0), 
          b.amount - coalesce(sum(a.amount), 0) AS variance
     FROM budget_info bi
     JOIN budget_line b ON bi.id = b.budget_id
     JOIN account act ON act.id = b.account_id
LEFT JOIN agg_account a ON a.transdate BETWEEN bi.start_date and bi.end_date
                           AND a.id = b.account_id
    WHERE bi.id = $1
 GROUP BY act.accno, act.description, act.id, b.description, b.amount
 ORDER BY act.accno;
</programlisting>
      </para>
    </section>

<!-- Function business_type__list() -->
    <section id="lsmb14.function.business-type-list"
             xreflabel="lsmb14business_type__list()">
      <title id="lsmb14.function.business-type-list-title">
       business_type__list()
      </title>
      <titleabbrev id="lsmb14.function.business-type-list-titleabbrev">
       business_type__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF business</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of all business types. Ordered by description by default.
        <programlisting>
DECLARE out_row business%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM business ORDER BY description LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function business_unit__get(in_id integer) -->
    <section id="lsmb14.function.business-unit-get-in-id-integer"
             xreflabel="lsmb14business_unit__get(in_id integer)">
      <title id="lsmb14.function.business-unit-get-in-id-integer-title">
       business_unit__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-get-in-id-integer-titleabbrev">
       business_unit__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM business_unit where id = $1; </programlisting>
      </para>
    </section>

<!-- Function business_unit__get_tree_for(in_id integer) -->
    <section id="lsmb14.function.business-unit-get-tree-for-in-id-integer"
             xreflabel="lsmb14business_unit__get_tree_for(in_id integer)">
      <title id="lsmb14.function.business-unit-get-tree-for-in-id-integer-title">
       business_unit__get_tree_for(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-get-tree-for-in-id-integer-titleabbrev">
       business_unit__get_tree_for(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF business_unit_short</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns tree-related records with the root of the tree being 
the business unit of in_id.  
        <programlisting>
WITH RECURSIVE tree  (id, control_code, description,  start_date, end_date, 
                      parent_id, path, level)
AS (
   SELECT id, control_code, description, start_date, end_date, parent_id, 
          ARRAY[parent_id] AS path, 1 as level
     FROM business_unit WHERE $1 = id
    UNION
   SELECT t.id, t.control_code, t.description, t.start_date, t.end_date, 
          t.parent_id,   
          t.path || bu.id AS path, t.level + 1 as level
     FROM business_unit bu JOIN tree t ON t.parent_id = bu.id
)
SELECT * FROM tree ORDER BY path;
</programlisting>
      </para>
    </section>

<!-- Function business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean) -->
    <section id="lsmb14.function.business-unit-list-by-class-in-strict-credit-integer-in-credit-id-date-in-active-on-integer-in-business-unit-class-id-boolean"
             xreflabel="lsmb14business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean)">
      <title id="lsmb14.function.business-unit-list-by-class-in-strict-credit-integer-in-credit-id-date-in-active-on-integer-in-business-unit-class-id-boolean-title">
       business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-list-by-class-in-strict-credit-integer-in-credit-id-date-in-active-on-integer-in-business-unit-class-id-boolean-titleabbrev">
       business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
        This function retUrns a list of all units (projects, departments, funds, etc)
active on the in_active_on date, where in_credit_id matches the credit id of the
customer or vendor requested, and where in_business_uni_class_id is the class id
of the class of business units (1 for department, 2 for project, etc).

With the exception of in_business_unit_class_id, the null matches all records.

        <programlisting>
BEGIN
RETURN QUERY SELECT * FROM business_unit 
              WHERE (in_active_on BETWEEN coalesce(start_date, in_active_on) 
                                      AND coalesce(end_date, in_active_on) 
                      OR in_active_on IS NULL)
                    AND (in_credit_id = credit_id
                        OR (credit_id IS NULL and in_strict_credit IS NOT TRUE)
                        OR (in_credit_id IS NULL))
                    AND class_id = in_business_unit_class_id
           ORDER BY control_code;
END;
</programlisting>
      </para>
    </section>

<!-- Function business_unit__list_classes(in_module boolean, in_active text) -->
    <section id="lsmb14.function.business-unit-list-classes-in-module-boolean-in-active-text"
             xreflabel="lsmb14business_unit__list_classes(in_module boolean, in_active text)">
      <title id="lsmb14.function.business-unit-list-classes-in-module-boolean-in-active-text-title">
       business_unit__list_classes(in_module boolean, in_active text)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-list-classes-in-module-boolean-in-active-text-titleabbrev">
       business_unit__list_classes(in_module boolean, in_active text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF business_unit_class</seg>
        </seglistitem>
       </segmentedlist>
 
        This function lists all business unit clases.  If in_active is true, then 
only active classes are listed.  If it is false then only inactive classes are
listed.  If it is null, then all classes are listed.
        <programlisting>

SELECT bc.* 
  FROM business_unit_class bc
 WHERE     (active = $1 OR $1 IS NULL)
       AND (id IN (select bu_class_id 
                     FROM bu_class_to_module bcm
                     JOIN lsmb_module mod ON mod.id = bcm.module_id
                    WHERE lower(label) = lower($2))
            OR $2 is null)
ORDER BY ordering;

</programlisting>
      </para>
    </section>

<!-- Function business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer) -->
    <section id="lsmb14.function.business-unit-save-in-credit-id-integer-in-parent-id-integer-in-end-date-text-in-start-date-text-in-description-date-in-control-code-date-in-class-id-integer-in-id-integer"
             xreflabel="lsmb14business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer)">
      <title id="lsmb14.function.business-unit-save-in-credit-id-integer-in-parent-id-integer-in-end-date-text-in-start-date-text-in-description-date-in-control-code-date-in-class-id-integer-in-id-integer-title">
       business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-save-in-credit-id-integer-in-parent-id-integer-in-end-date-text-in-start-date-text-in-description-date-in-control-code-date-in-class-id-integer-in-id-integer-titleabbrev">
       business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval business_unit;
        t_id int;

BEGIN

UPDATE business_unit
   SET class_id = in_class_id,
       control_code = in_control_code,
       description = in_description,
       start_date = in_start_date,
       end_date = in_end_date,
       credit_id = in_credit_id
 WHERE id = in_id;


IF FOUND THEN
   t_id := in_id;
ELSE
   INSERT INTO business_unit 
          (class_id, control_code, description, start_date, end_date, parent_id,
           credit_id)
   VALUES (in_class_id, in_control_code, in_description, in_start_date, 
           in_end_date, in_parent_id, in_credit_id);
    t_id := currval(&#39;business_unit_id_seq&#39;);
END IF;

SELECT * INTO retval FROM business_unit WHERE id = t_id;

RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function business_unit_class__get_modules(in_id integer) -->
    <section id="lsmb14.function.business-unit-class-get-modules-in-id-integer"
             xreflabel="lsmb14business_unit_class__get_modules(in_id integer)">
      <title id="lsmb14.function.business-unit-class-get-modules-in-id-integer-title">
       business_unit_class__get_modules(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-class-get-modules-in-id-integer-titleabbrev">
       business_unit_class__get_modules(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF lsmb_module</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM lsmb_module 
    WHERE id IN (select module_id from bu_class_to_module where bu_class_id = $1)
 ORDER BY id;
</programlisting>
      </para>
    </section>

<!-- Function business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer) -->
    <section id="lsmb14.function.business-unit-class-save-in-ordering-integer-in-active-text-in-label-boolean-in-id-integer"
             xreflabel="lsmb14business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer)">
      <title id="lsmb14.function.business-unit-class-save-in-ordering-integer-in-active-text-in-label-boolean-in-id-integer-title">
       business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-class-save-in-ordering-integer-in-active-text-in-label-boolean-in-id-integer-titleabbrev">
       business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>business_unit_class</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval business_unit_class;
        t_id int;
BEGIN

t_id := in_id;
UPDATE business_unit_class
   SET label = in_label,
       active = in_active,
       ordering = in_ordering
 WHERE id = in_id;

IF NOT FOUND THEN

   INSERT INTO business_unit_class (label, active, ordering)
   VALUES (in_label, in_active, in_ordering);

   t_id := currval(&#39;business_unit_class_id_seq&#39;);

END IF;

SELECT * INTO retval FROM business_unit_class WHERE id = t_id;

RETURN retval;

END;

</programlisting>
      </para>
    </section>

<!-- Function business_unit_class__save_modules(in_mod_ids integer, in_id integer[]) -->
    <section id="lsmb14.function.business-unit-class-save-modules-in-mod-ids-integer-in-id-integerARRAY"
             xreflabel="lsmb14business_unit_class__save_modules(in_mod_ids integer, in_id integer[])">
      <title id="lsmb14.function.business-unit-class-save-modules-in-mod-ids-integer-in-id-integerARRAY-title">
       business_unit_class__save_modules(in_mod_ids integer, in_id integer[])
      </title>
      <titleabbrev id="lsmb14.function.business-unit-class-save-modules-in-mod-ids-integer-in-id-integerARRAY-titleabbrev">
       business_unit_class__save_modules(in_mod_ids integer, in_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DELETE FROM bu_class_to_module WHERE bu_class_id = $1;

INSERT INTO bu_class_to_module (bu_class_id, module_id)
SELECT $1, unnest
  FROM unnest($2);

SELECT true;
</programlisting>
      </para>
    </section>

<!-- Function business_unit_get(in_id integer) -->
    <section id="lsmb14.function.business-unit-get-in-id-integer"
             xreflabel="lsmb14business_unit_get(in_id integer)">
      <title id="lsmb14.function.business-unit-get-in-id-integer-title">
       business_unit_get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.business-unit-get-in-id-integer-titleabbrev">
       business_unit_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM business_unit WHERE id = $1; </programlisting>
      </para>
    </section>

<!-- Function chart_get_ar_ap(in_account_class integer) -->
    <section id="lsmb14.function.chart-get-ar-ap-in-account-class-integer"
             xreflabel="lsmb14chart_get_ar_ap(in_account_class integer)">
      <title id="lsmb14.function.chart-get-ar-ap-in-account-class-integer-title">
       chart_get_ar_ap(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.chart-get-ar-ap-in-account-class-integer-titleabbrev">
       chart_get_ar_ap(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the cash account acording with in_account_class which 
must be 1 or 2.

If in_account_class is 1 then it returns a list of AP accounts, and if 
in_account_class is 2, then a list of AR accounts.
        <programlisting>
DECLARE out_row chart%ROWTYPE;
BEGIN
	IF in_account_class NOT IN (1, 2) THEN
		RAISE EXCEPTION &#39;Bad Account Type&#39;;
	END IF;
       FOR out_row IN
               SELECT * FROM chart 
               WHERE link = CASE WHEN in_account_class = 1 THEN &#39;AP&#39;
                               WHEN in_account_class = 2 THEN &#39;AR&#39;
                               END
               ORDER BY accno
       LOOP
               RETURN NEXT out_row;
       END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_all() -->
    <section id="lsmb14.function.chart-list-all"
             xreflabel="lsmb14chart_list_all()">
      <title id="lsmb14.function.chart-list-all-title">
       chart_list_all()
      </title>
      <titleabbrev id="lsmb14.function.chart-list-all-titleabbrev">
       chart_list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates a list of chart view entries.
        <programlisting>
DECLARE out_row chart%ROWTYPE;
BEGIN
	FOR out_row IN 
		SELECT * FROM chart ORDER BY accno
	LOOP
		RETURN next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_cash(in_account_class integer) -->
    <section id="lsmb14.function.chart-list-cash-in-account-class-integer"
             xreflabel="lsmb14chart_list_cash(in_account_class integer)">
      <title id="lsmb14.function.chart-list-cash-in-account-class-integer-title">
       chart_list_cash(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.chart-list-cash-in-account-class-integer-titleabbrev">
       chart_list_cash(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the overpayment accounts acording with 
in_account_class which must be 1 or 2.

If in_account_class is 1 it returns a list of AP cash accounts and 
if 2, AR cash accounts.
        <programlisting>
 DECLARE resultrow record;
         link_string text;
 BEGIN
         IF in_account_class = 1 THEN
            link_string := &#39;%AP_paid%&#39;;
         ELSE 
            link_string := &#39;%AR_paid%&#39;;
         END IF;
 
         FOR resultrow IN
           SELECT *  FROM chart
           WHERE link LIKE link_string
           ORDER BY accno
           LOOP
           return next resultrow;
         END LOOP;
 END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_discount(in_account_class integer) -->
    <section id="lsmb14.function.chart-list-discount-in-account-class-integer"
             xreflabel="lsmb14chart_list_discount(in_account_class integer)">
      <title id="lsmb14.function.chart-list-discount-in-account-class-integer-title">
       chart_list_discount(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.chart-list-discount-in-account-class-integer-titleabbrev">
       chart_list_discount(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the discount accounts acording with in_account_class 
which must be 1 or 2.

If in_account_class is 1, returns AP discount accounts, if 2, AR discount 
accounts.
        <programlisting>
DECLARE resultrow record;
        link_string text;
BEGIN
        IF in_account_class = 1 THEN
           link_string := &#39;%AP_discount%&#39;;
        ELSE
           link_string := &#39;%AR_discount%&#39;;
        END IF;

        FOR resultrow IN
          SELECT *  FROM chart
          WHERE link LIKE link_string
          ORDER BY accno
          LOOP
          return next resultrow;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_overpayment(in_account_class integer) -->
    <section id="lsmb14.function.chart-list-overpayment-in-account-class-integer"
             xreflabel="lsmb14chart_list_overpayment(in_account_class integer)">
      <title id="lsmb14.function.chart-list-overpayment-in-account-class-integer-title">
       chart_list_overpayment(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.chart-list-overpayment-in-account-class-integer-titleabbrev">
       chart_list_overpayment(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of AP_overpayment accounts if in_account_class is 1
Otherwise it returns a list of AR_overpayment accounts.
        <programlisting>
DECLARE resultrow record;
        link_string text;
BEGIN
        IF in_account_class = 1 THEN
           link_string := &#39;%AP_overpayment%&#39;;
        ELSE 
           link_string := &#39;%AR_overpayment%&#39;;
        END IF;

        FOR resultrow IN
          SELECT *  FROM chart
          WHERE link LIKE link_string
          ORDER BY accno
          LOOP
          return next resultrow;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_search(in_link_desc text, in_search text) -->
    <section id="lsmb14.function.chart-list-search-in-link-desc-text-in-search-text"
             xreflabel="lsmb14chart_list_search(in_link_desc text, in_search text)">
      <title id="lsmb14.function.chart-list-search-in-link-desc-text-in-search-text-title">
       chart_list_search(in_link_desc text, in_search text)
      </title>
      <titleabbrev id="lsmb14.function.chart-list-search-in-link-desc-text-in-search-text-titleabbrev">
       chart_list_search(in_link_desc text, in_search text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        This returns a list of account entries where the description or account 
number begins with in_search.

If in_link_desc is provided, the list is further filtered by which accounts are 
set to an account_link.description equal to that provided.
        <programlisting>
DECLARE out_row account%ROWTYPE;
BEGIN
	FOR out_row IN 
		SELECT * FROM account 
                 WHERE (accno ~* (&#39;^&#39;||in_search) 
                       OR description ~* (&#39;^&#39;||in_search))
                       AND (in_link_desc IS NULL 
                           or id in 
                          (select account_id from account_link 
                            where description = in_link_desc))
                       AND not obsolete
              ORDER BY accno
	LOOP
		RETURN next out_row;
	END LOOP;
END;</programlisting>
      </para>
    </section>

<!-- Function check_expiration() -->
    <section id="lsmb14.function.check-expiration"
             xreflabel="lsmb14check_expiration()">
      <title id="lsmb14.function.check-expiration-title">
       check_expiration()
      </title>
      <titleabbrev id="lsmb14.function.check-expiration-titleabbrev">
       check_expiration()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks whether the user needs to be notified of a pending expiration of 
his/her password.  Returns true if needed, false if not.

The function also records the next time when the notification will again need to
be displayed. 
        <programlisting>
DECLARE test_result BOOL;
	expires_in interval;
	notify_again interval;
BEGIN
	expires_in := user__check_my_expiration();

	SELECT expires_in &lt; notify_password INTO test_result
	FROM users WHERE username = SESSION_USER;

	IF test_result THEN 
		IF expires_in &lt; &#39;1 week&#39; THEN
			notify_again := &#39;1 hour&#39;;
		ELSE
			notify_again := &#39;1 day&#39;;
		END IF;

		UPDATE users 
		SET notify_password = expires_in - notify_again
		WHERE username = SESSION_USER;
	END IF;
	RETURN test_result;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric) -->
    <section id="lsmb14.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric"
             xreflabel="lsmb14cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)">
      <title id="lsmb14.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric-title">
       cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb14.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric-titleabbrev">
       cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_cp account_checkpoint;
        t_ar ar;
        t_avail numeric;
BEGIN


IF in_qty &gt; 0 THEN
   return cogs__reverse_ap(in_parts_id, in_qty * -1) * in_lastcost;
END IF;

SELECT * INTO t_cp FROM account_checkpoint ORDER BY end_date DESC LIMIT 1;

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN ar a ON a.id = i.trans_id
     WHERE qty + allocated &gt; 0 and parts_id  = in_parts_id
  ORDER BY a.transdate, a.id, i.id
LOOP
   t_avail := t_inv.qty + t_inv.allocated;
   SELECT * INTO t_ar FROM ar WHERE id = t_inv.trans_id;
   IF t_alloc &lt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return t_alloc;
   ELSIF (in_qty + t_alloc) * -1 &lt;=  t_avail  THEN
       UPDATE invoice SET allocated = allocated + (in_qty + t_alloc)
        WHERE id = t_inv.id;

       INSERT INTO acc_trans 
              (chart_id, transdate, amount, invoice_id, approved, trans_id)
       SELECT expense_accno_id, 
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, (in_qty + t_alloc) * in_lastcost, t_inv.id, true,
              t_inv.trans_id
         FROM parts 
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL
       UNION
       SELECT income_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, -1 * (in_qty + t_alloc) * in_lastcost, t_inv.id, true,
              t_inv.trans_id
         FROM parts 
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL;
                                    
       t_cogs := t_cogs + (in_qty + t_alloc) * in_lastcost;
       return in_qty * -1;
   ELSE
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_cogs := t_cogs + t_avail * in_lastcost;

       INSERT INTO acc_trans
              (chart_id, transdate, amount, invoice_id, approved, trans_id)
       SELECT expense_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END,  -1 * t_avail * in_lastcost, 
              t_inv.id, true, t_inv.trans_id
         FROM parts
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL
       UNION
       SELECT income_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, -t_avail * in_lastcost, t_inv.id, true, t_inv.trans_id
         FROM parts
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL;
       t_alloc := t_alloc + t_avail;
       t_cogs := t_cogs + t_avail * in_lastcost;
   END IF;


END LOOP;

RETURN t_alloc;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ap_line(in_invoice_id integer) -->
    <section id="lsmb14.function.cogs-add-for-ap-line-in-invoice-id-integer"
             xreflabel="lsmb14cogs__add_for_ap_line(in_invoice_id integer)">
      <title id="lsmb14.function.cogs-add-for-ap-line-in-invoice-id-integer-title">
       cogs__add_for_ap_line(in_invoice_id integer)
      </title>
      <titleabbrev id="lsmb14.function.cogs-add-for-ap-line-in-invoice-id-integer-titleabbrev">
       cogs__add_for_ap_line(in_invoice_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval numeric;
        r_cogs numeric[];
        t_inv invoice;
        t_adj numeric;
        t_ap  ap;
BEGIN

SELECT * INTO t_inv FROM invoice 
 WHERE id = in_invoice_id;

IF t_inv.qty + t_inv.allocated = 0 THEN
   return 0;
END IF;

SELECT * INTO t_ap FROM ap WHERE id = t_inv.trans_id;

IF t_inv.qty &lt; 0 THEN -- normal COGS

    SELECT cogs__add_for_ap(i.parts_id, i.qty + i.allocated, i.sellprice) 
      INTO retval
      FROM invoice i
      JOIN parts p ON p.id = i.parts_id
     WHERE i.id = $1;

    UPDATE invoice 
       SET allocated = allocated + retval
     WHERE id = $1;
ELSE -- reversal

   r_cogs := cogs__reverse_ap(t_inv.parts_id, t_inv.qty + t_inv.allocated);

   UPDATE invoice
      SET allocated = allocated + r_cogs[1]
    WHERE id = in_invoice_id;

   t_adj := t_inv.sellprice * r_cogs[1] + r_cogs[2];

   INSERT INTO acc_trans 
          (chart_id, trans_id, approved,  amount, transdate, invoice_id)
   SELECT p.inventory_accno_id, t_inv.trans_id, true, t_adj, t_ap.transdate, 
          in_invoice_id
     FROM parts p
    WHERE id = t_inv.parts_id
    UNION
   SELECT p.expense_accno_id, t_inv.trans_id, true, t_adj * -1, t_ap.transdate,
          in_invoice_id
     FROM parts p
    WHERE id = t_inv.parts_id;
   retval := r_cogs[1];
   raise notice &#39;cogs reversal returned %&#39;, r_cogs;

END IF;

RETURN retval;

END;

</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ar(in_qty integer, in_parts_id numeric) -->
    <section id="lsmb14.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric"
             xreflabel="lsmb14cogs__add_for_ar(in_qty integer, in_parts_id numeric)">
      <title id="lsmb14.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric-title">
       cogs__add_for_ar(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb14.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__add_for_ar(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
        This function accepts a parts_id and a quantity, and iterates through AP 
records in order, calculating COGS on a FIFO basis and returning it to the 
application to attach to the current transaction.

Return values are an array of {allocated, cogs}.

        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_avail numeric;
BEGIN


FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN (select id, approved, transdate from ap
             union
            select id, approved, transdate from gl) a ON a.id = i.trans_id
     WHERE qty + allocated &lt; 0 AND i.parts_id = in_parts_id
  ORDER BY a.transdate asc, a.id asc, i.id asc
LOOP
   t_avail := (t_inv.qty + t_inv.allocated) * -1;
   IF t_alloc &gt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty + t_alloc) &lt;= t_avail THEN
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       t_cogs := t_cogs + (in_qty - t_alloc) * t_inv.sellprice;
       t_alloc := in_qty;
       return ARRAY[t_alloc, t_cogs];
   ELSE
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_cogs := t_cogs + (t_avail * t_inv.sellprice);
       t_alloc := t_alloc + t_avail;
   END IF;
END LOOP;

RETURN ARRAY[t_alloc, t_cogs];

END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ar_line(in_invoice_id integer) -->
    <section id="lsmb14.function.cogs-add-for-ar-line-in-invoice-id-integer"
             xreflabel="lsmb14cogs__add_for_ar_line(in_invoice_id integer)">
      <title id="lsmb14.function.cogs-add-for-ar-line-in-invoice-id-integer-title">
       cogs__add_for_ar_line(in_invoice_id integer)
      </title>
      <titleabbrev id="lsmb14.function.cogs-add-for-ar-line-in-invoice-id-integer-titleabbrev">
       cogs__add_for_ar_line(in_invoice_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   t_cogs numeric[];
   t_inv invoice;
   t_part parts;
   t_ar ar;
   t_transdate date;
BEGIN

SELECT * INTO t_inv FROM invoice WHERE id = in_invoice_id;
SELECT * INTO t_part FROM parts WHERE id = t_inv.parts_id;
SELECT * INTO t_ar FROM ar WHERE id = t_inv.trans_id;

IF t_inv.qty + t_inv.allocated = 0 THEN
   return 0;
END IF;

IF t_inv.qty &gt; 0 THEN 
   t_cogs := cogs__add_for_ar(t_inv.parts_id, t_inv.qty + t_inv.allocated);
ELSE
   t_cogs := cogs__reverse_ar(t_inv.parts_id, t_inv.qty + t_inv.allocated);
END IF;


UPDATE invoice set allocated = allocated - t_cogs[1]
 WHERE id = in_invoice_id;

SELECT CASE WHEN t_ar.transdate &gt; max(end_date) THEN t_ar.transdate
            ELSE max(end_date) + &#39;1 day&#39;::interval
        END INTO t_transdate
  from account_checkpoint td; 
INSERT INTO acc_trans 
       (trans_id, chart_id, approved, amount, transdate,  invoice_id)
VALUES (t_inv.trans_id, CASE WHEN t_inv.qty &lt; 0 AND t_ar.is_return 
                           THEN t_part.returns_accno_id
                           ELSE t_part.expense_accno_id
                      END, TRUE, t_cogs[2] * -1, t_transdate, t_inv.id),
       (t_inv.trans_id, t_part.inventory_accno_id, TRUE, t_cogs[2], 
       t_transdate, t_inv.id);

RETURN t_cogs[1];

END;

</programlisting>
      </para>
    </section>

<!-- Function cogs__reverse_ap(in_qty integer, in_parts_id numeric) -->
    <section id="lsmb14.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric"
             xreflabel="lsmb14cogs__reverse_ap(in_qty integer, in_parts_id numeric)">
      <title id="lsmb14.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric-title">
       cogs__reverse_ap(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb14.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__reverse_ap(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
        This function iterates through invoice rows attached to ap transactions and 
allocates them on a first-in first-out basis.  The sort of pseudo-&quot;COGS&quot; value 
is returned to the application for further handling.
        <programlisting>
DECLARE t_alloc numeric :=0;
        t_inv invoice;
        t_cogs numeric :=0;
        retval numeric[];
BEGIN
RAISE NOTICE &#39;reversing AP: parts_id %, qty %&#39;, in_parts_id, in_qty;

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN ap a ON a.id = i.trans_id
     WHERE qty + allocated &lt; 0 AND parts_id = in_parts_id
  ORDER BY a.transdate, a.id, i.id
LOOP
   RAISE NOTICE &#39;id %, avail %, allocated %, requesting %&#39;, t_inv.id, t_inv.qty + t_inv.allocated, t_alloc, in_qty - t_alloc;
   IF t_alloc &gt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty - t_alloc) &lt;= -1 * (t_inv.qty + t_inv.allocated) THEN
       raise notice &#39;partial reversal&#39;;
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       return ARRAY[in_qty * -1, t_cogs + (in_qty - t_alloc) * t_inv.sellprice];
   ELSE
       raise notice &#39;total reversal&#39;;
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_alloc := t_alloc - (t_inv.qty + t_inv.allocated);
       t_cogs := t_cogs - (t_inv.qty + t_inv.allocated) * t_inv.sellprice;
   END IF;
END LOOP;

RETURN ARRAY[t_alloc, t_cogs];

RAISE EXCEPTION &#39;TOO FEW TO ALLOCATE&#39;;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__reverse_ar(in_qty integer, in_parts_id numeric) -->
    <section id="lsmb14.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric"
             xreflabel="lsmb14cogs__reverse_ar(in_qty integer, in_parts_id numeric)">
      <title id="lsmb14.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric-title">
       cogs__reverse_ar(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="lsmb14.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__reverse_ar(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
       This function accepts a part id and quantity to reverse.  It then iterates 
backwards over AP related records, calculating COGS.  This does not save COGS
but rather returns it to the application to save.

Return values are an array of {allocated, cogs}.

        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_avail numeric;
BEGIN

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN (select id, approved, transdate from ap 
            union
            select id, approved, transdate from gl) a ON a.id = i.trans_id
     WHERE allocated &gt; 0 and a.approved and parts_id = in_parts_id
  ORDER BY a.transdate DESC, a.id DESC, i.id DESC
LOOP
   t_avail := t_inv.allocated;
   IF t_alloc &lt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       RETURN ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty - t_alloc) * -1 &lt;=  t_inv.allocated THEN
       raise notice &#39;partial reversal&#39;;
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       t_cogs := t_cogs +  (in_qty - t_alloc) * t_inv.sellprice;
       return ARRAY[t_alloc + (in_qty - t_alloc), t_cogs];
   ELSE
       raise notice &#39;full reversal&#39;;
       UPDATE invoice SET allocated = 0
        WHERE id = t_inv.id;
       t_alloc := t_alloc + t_inv.allocated * -1;
       t_cogs := t_cogs + -1 * (t_inv.allocated) * t_inv.sellprice;
   END IF;
END LOOP;

RAISE EXCEPTION &#39;TOO FEW TO REVERSE&#39;;

END;
</programlisting>
      </para>
    </section>

<!-- Function company__get(in_entity_id integer) -->
    <section id="lsmb14.function.company-get-in-entity-id-integer"
             xreflabel="lsmb14company__get(in_entity_id integer)">
      <title id="lsmb14.function.company-get-in-entity-id-integer-title">
       company__get(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.company-get-in-entity-id-integer-titleabbrev">
       company__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>company_entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all attributes for the company attached to the entity.
        <programlisting>
	SELECT c.entity_id, e.entity_class, c.legal_name, c.tax_id, c.sales_tax_id,
               c.license_number, c.sic_code, e.control_code, e.country_id 
          FROM company c
          JOIN entity e ON e.id = c.entity_id
         WHERE entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function company__get_all_accounts(in_entity_class integer, in_entity_id integer) -->
    <section id="lsmb14.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer"
             xreflabel="lsmb14company__get_all_accounts(in_entity_class integer, in_entity_id integer)">
      <title id="lsmb14.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer-title">
       company__get_all_accounts(in_entity_class integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer-titleabbrev">
       company__get_all_accounts(in_entity_class integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all entity credit accounts attached to that entity.
        <programlisting>
    
    SELECT * 
      FROM entity_credit_account 
     WHERE entity_id = $1
       AND entity_class = $2;
    
</programlisting>
      </para>
    </section>

<!-- Function company__get_by_cc(in_control_code text) -->
    <section id="lsmb14.function.company-get-by-cc-in-control-code-text"
             xreflabel="lsmb14company__get_by_cc(in_control_code text)">
      <title id="lsmb14.function.company-get-by-cc-in-control-code-text-title">
       company__get_by_cc(in_control_code text)
      </title>
      <titleabbrev id="lsmb14.function.company-get-by-cc-in-control-code-text-titleabbrev">
       company__get_by_cc(in_control_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>company_entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity/company row attached to the control code. 
        <programlisting>
        SELECT c.entity_id, e.entity_class, c.legal_name, c.tax_id, c.sales_tax_id,
               c.license_number, c.sic_code, e.control_code, e.country_id
          FROM company c
          JOIN entity e ON e.id = c.entity_id
         WHERE e.control_code = $1;
</programlisting>
      </para>
    </section>

<!-- Function company__next_id() -->
    <section id="lsmb14.function.company-next-id"
             xreflabel="lsmb14company__next_id()">
      <title id="lsmb14.function.company-next-id-title">
       company__next_id()
      </title>
      <titleabbrev id="lsmb14.function.company-next-id-titleabbrev">
       company__next_id()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>bigint</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    select nextval(&#39;company_id_seq&#39;);
    
</programlisting>
      </para>
    </section>

<!-- Function company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text) -->
    <section id="lsmb14.function.company-save-in-license-number-integer-in-sales-tax-id-text-in-country-id-integer-in-sic-code-text-in-entity-id-text-in-tax-id-integer-in-legal-name-text-in-entity-class-integer-in-control-code-text-in-id-text"
             xreflabel="lsmb14company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text)">
      <title id="lsmb14.function.company-save-in-license-number-integer-in-sales-tax-id-text-in-country-id-integer-in-sic-code-text-in-entity-id-text-in-tax-id-integer-in-legal-name-text-in-entity-class-integer-in-control-code-text-in-id-text-title">
       company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text)
      </title>
      <titleabbrev id="lsmb14.function.company-save-in-license-number-integer-in-sales-tax-id-text-in-country-id-integer-in-sic-code-text-in-entity-id-text-in-tax-id-integer-in-legal-name-text-in-entity-class-integer-in-control-code-text-in-id-text-titleabbrev">
       company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>company</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a company.  Returns the id number of the record stored.
        <programlisting>
DECLARE t_entity_id INT;
	t_company_id INT;
	t_control_code TEXT;
        t_retval COMPANY;
BEGIN
	t_company_id := in_id;

	IF in_control_code IS NULL THEN
		t_control_code := setting_increment(&#39;company_control&#39;);
	ELSE
		t_control_code := in_control_code;
	END IF;

	UPDATE entity 
	SET name = in_legal_name, 
		entity_class = in_entity_class,
		control_code = in_control_code
	WHERE id = in_entity_id;

	IF FOUND THEN
		t_entity_id = in_entity_id;
	ELSE
		INSERT INTO entity (name, entity_class, control_code,country_id)
		VALUES (in_legal_name, in_entity_class, t_control_code,in_country_id);
		t_entity_id := currval(&#39;entity_id_seq&#39;);
	END IF;

	UPDATE company
	SET legal_name = in_legal_name,
		tax_id = in_tax_id,
		sic_code = in_sic_code,
                sales_tax_id = in_sales_tax_id,
                license_number = in_license_number
	WHERE id = t_company_id;


	IF NOT FOUND THEN
		INSERT INTO company(entity_id, legal_name, tax_id, sic_code,
                                    sales_tax_id, license_number)
		VALUES (t_entity_id, in_legal_name, in_tax_id, in_sic_code, 
                        in_sales_tax_id, in_license_number);

	END IF;
        SELECT * INTO t_retval FROM company WHERE entity_id = t_entity_id;
        RETURN t_retval;	
END;
</programlisting>
      </para>
    </section>

<!-- Function company_get_billing_info(in_id integer) -->
    <section id="lsmb14.function.company-get-billing-info-in-id-integer"
             xreflabel="lsmb14company_get_billing_info(in_id integer)">
      <title id="lsmb14.function.company-get-billing-info-in-id-integer-title">
       company_get_billing_info(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.company-get-billing-info-in-id-integer-titleabbrev">
       company_get_billing_info(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>company_billing_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns billing information (billing name and address) for a given credit 
account.
        <programlisting>
DECLARE out_var company_billing_info;
	t_id INT;
BEGIN
	select coalesce(eca.pay_to_name, c.legal_name), eca.meta_number, 
		e.control_code, c.tax_id, a.line_one, a.line_two, a.line_three, 
		a.city, a.state, a.mail_code, cc.name
	into out_var
	FROM (select legal_name, tax_id, entity_id 
                FROM company
               UNION ALL
              SELECT last_name || &#39;, &#39; || first_name, null, entity_id 
                FROM person) c
	JOIN entity e ON (c.entity_id = e.id)
	JOIN entity_credit_account eca ON (eca.entity_id = e.id)
	LEFT JOIN eca_to_location cl ON (eca.id = cl.credit_id)
	LEFT JOIN location a ON (a.id = cl.location_id)
	LEFT JOIN country cc ON (cc.id = a.country_id)
	WHERE eca.id = in_id AND (location_class = 1 or location_class is null);

	RETURN out_var;
END;
</programlisting>
      </para>
    </section>

<!-- Function compound_array(anyarray) -->
    <section id="lsmb14.function.compound-array-anyarray"
             xreflabel="lsmb14compound_array(anyarray)">
      <title id="lsmb14.function.compound-array-anyarray-title">
       compound_array(anyarray)
      </title>
      <titleabbrev id="lsmb14.function.compound-array-anyarray-titleabbrev">
       compound_array(anyarray)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>anyarray</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an n dimensional array.

Example: SELECT as_array(ARRAY[id::text, class]) from contact_class

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function concat_colon(text) -->
    <section id="lsmb14.function.concat-colon-text"
             xreflabel="lsmb14concat_colon(text)">
      <title id="lsmb14.function.concat-colon-text-title">
       concat_colon(text)
      </title>
      <titleabbrev id="lsmb14.function.concat-colon-text-titleabbrev">
       concat_colon(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a sumple aggregate to return values from the database in a 
colon-separated list.  Other programs probably should not rely on this since 
it is primarily included for the chart view.
        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function concat_colon(text, text) -->
    <section id="lsmb14.function.concat-colon-text-text"
             xreflabel="lsmb14concat_colon(text, text)">
      <title id="lsmb14.function.concat-colon-text-text-title">
       concat_colon(text, text)
      </title>
      <titleabbrev id="lsmb14.function.concat-colon-text-text-titleabbrev">
       concat_colon(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes two arguments and creates a list out  of them.  It&apos;s useful 
as an aggregate base (see aggregate concat_colon).  However this is a temporary
function only and should not be relied upon.
        <programlisting>
select CASE WHEN $1 IS NULL THEN $2 ELSE $1 || &#39;:&#39; || $2 END;
</programlisting>
      </para>
    </section>

<!-- Function contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text) -->
    <section id="lsmb14.function.contact-search-in-notes-integer-in-control-code-text-in-name-part-textARRAY-in-business-id-text-in-active-date-to-text-in-active-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-date-in-address-date-in-meta-number-integer-in-contact-info-text-in-contact-text-in-entity-class-text"
             xreflabel="lsmb14contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text)">
      <title id="lsmb14.function.contact-search-in-notes-integer-in-control-code-text-in-name-part-textARRAY-in-business-id-text-in-active-date-to-text-in-active-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-date-in-address-date-in-meta-number-integer-in-contact-info-text-in-contact-text-in-entity-class-text-title">
       contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text)
      </title>
      <titleabbrev id="lsmb14.function.contact-search-in-notes-integer-in-control-code-text-in-name-part-textARRAY-in-business-id-text-in-active-date-to-text-in-active-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-date-in-address-date-in-meta-number-integer-in-contact-info-text-in-contact-text-in-entity-class-text-titleabbrev">
       contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	out_row contact_search_result;
	loop_count int;
	t_contact_info text[];
BEGIN
	t_contact_info = in_contact_info;


	FOR out_row IN
		SELECT e.id, e.control_code, ec.id, ec.meta_number, 
			ec.description, ec.entity_class, 
			c.legal_name, c.sic_code, b.description , ec.curr::text
		FROM (select * from entity 
                       where control_code like in_control_code || &#39;%&#39;
                      union
                      select * from entity where in_control_code is null) e
		JOIN (SELECT legal_name, sic_code, entity_id 
                        FROM company 
                       WHERE legal_name @@ plainto_tsquery(in_name_part)
                      UNION ALL
                      SELECT legal_name, sic_code, entity_id
                        FROM company
                       WHERE in_name_part IS NULL
                      UNION ALL
                     SELECT coalesce(first_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(middle_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(last_name, &#39;&#39;), null, entity_id
                       FROM person
                      WHERE coalesce(first_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(middle_name, &#39;&#39;) || &#39; &#39;
                            || coalesce(last_name, &#39;&#39;) 
                             @@ plainto_tsquery(in_name_part)
                      UNION ALL
                     SELECT coalesce(first_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(middle_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(last_name, &#39;&#39;), null, entity_id
                       FROM person
                       WHERE in_name_part IS NULL) c ON (e.id = c.entity_id)
		LEFT JOIN entity_credit_account ec ON (ec.entity_id = e.id)
		LEFT JOIN business b ON (ec.business_id = b.id)
		WHERE coalesce(ec.entity_class,e.entity_class) = in_entity_class
			AND (c.entity_id IN (select entity_id 
                                               FROM entity_to_contact
                                              WHERE contact ILIKE 
                                                            ANY(t_contact_info))
				                    OR &#39;&#39; ILIKE 
                                                          ALL(t_contact_info)
                                                    OR t_contact_info IS NULL)
			
			AND ((in_address IS NULL AND in_city IS NULL 
					AND in_state IS NULL 
					AND in_country IS NULL)
				OR (c.entity_id IN 
				(select entity_id FROM entity_to_location
				WHERE location_id IN 
					(SELECT id FROM location
					WHERE (line_one @@ plainto_tsquery(
                                                              in_address)
                                               OR
					       line_two @@ plainto_tsquery(
                                                              in_address)
                                               OR
					       line_three @@ plainto_tsquery(
                                                              in_address))
						AND city ILIKE 
							&#39;%&#39; || 
							coalesce(in_city, &#39;&#39;) 
							|| &#39;%&#39;
						AND state ILIKE
							&#39;%&#39; || 
							coalesce(in_state, &#39;&#39;) 
							|| &#39;%&#39;
						AND mail_code ILIKE
							&#39;%&#39; || 
							coalesce(in_mail_code,
								&#39;&#39;)
							|| &#39;%&#39;
						AND country_id IN 
							(SELECT id FROM country
							WHERE name ilike
                                                              in_country
								OR short_name
								ilike 
								in_country)))))
			AND (ec.business_id = 
				coalesce(in_business_id, ec.business_id)
				OR (ec.business_id IS NULL 
					AND in_business_id IS NULL))
			AND (ec.startdate &lt;= coalesce(in_active_date_to, 
						ec.startdate)
				OR (ec.startdate IS NULL))
			AND (ec.enddate &gt;= coalesce(in_active_date_from, ec.enddate)
				OR (ec.enddate IS NULL))
	 		AND (ec.meta_number like in_meta_number || &#39;%&#39;
			     OR in_meta_number IS NULL)
                        AND (in_notes IS NULL OR e.id in (
                                     SELECT entity_id from entity_note
                                      WHERE note @@ plainto_tsquery(in_notes))
                                  OR ec.id IN (select ref_key FROM eca_note
                                     WHERE note @@ plainto_tsquery(in_notes)))
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function contact_class__list() -->
    <section id="lsmb14.function.contact-class-list"
             xreflabel="lsmb14contact_class__list()">
      <title id="lsmb14.function.contact-class-list-title">
       contact_class__list()
      </title>
      <titleabbrev id="lsmb14.function.contact-class-list-titleabbrev">
       contact_class__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contact classes ordered by ID.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM contact_class ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function cr_coa_to_account_save(in_description text, in_accno text) -->
    <section id="lsmb14.function.cr-coa-to-account-save-in-description-text-in-accno-text"
             xreflabel="lsmb14cr_coa_to_account_save(in_description text, in_accno text)">
      <title id="lsmb14.function.cr-coa-to-account-save-in-description-text-in-accno-text-title">
       cr_coa_to_account_save(in_description text, in_accno text)
      </title>
      <titleabbrev id="lsmb14.function.cr-coa-to-account-save-in-description-text-in-accno-text-titleabbrev">
       cr_coa_to_account_save(in_description text, in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
        Provides default rules for setting reconciliation labels.  Currently 
saves a label of accno ||&apos;--&apos; || description.
        <programlisting>
    DECLARE
       v_chart_id int;
    BEGIN
        -- Check for existence of the account already
        PERFORM * FROM cr_coa_to_account WHERE account = in_accno;

        IF NOT FOUND THEN
           -- This is a new account. Insert the relevant data.
           SELECT id INTO v_chart_id FROM chart WHERE accno = in_accno;
           INSERT INTO cr_coa_to_account (chart_id, account) VALUES (v_chart_id, in_accno||&#39;--&#39;||in_description);
        END IF;
        -- Already found, no need to do anything. =) 
    END;
</programlisting>
      </para>
    </section>

<!-- Function cr_report_block_changing_approved() -->
    <section id="lsmb14.function.cr-report-block-changing-approved"
             xreflabel="lsmb14cr_report_block_changing_approved()">
      <title id="lsmb14.function.cr-report-block-changing-approved-title">
       cr_report_block_changing_approved()
      </title>
      <titleabbrev id="lsmb14.function.cr-report-block-changing-approved-titleabbrev">
       cr_report_block_changing_approved()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a simple filter that prevents updating or deleting reconciliation
reports that have already been approved.  To purge old reconciliations you must
disable the block_change_when_approved trigger on cr_report.
        <programlisting>
BEGIN
   IF OLD.approved IS TRUE THEN
       RAISE EXCEPTION &#39;Report is approved.  Cannot change!&#39;;
   END IF;
   IF TG_OP = &#39;DELETE&#39; THEN
       RETURN OLD;
   ELSE
      RETURN NEW;
   END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer) -->
    <section id="lsmb14.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer"
             xreflabel="lsmb14currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)">
      <title id="lsmb14.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer-title">
       currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)
      </title>
      <titleabbrev id="lsmb14.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer-titleabbrev">
       currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return the exchange rate of a given currency, date and exchange rate class (buy or sell). 
        <programlisting>
DECLARE 
    out_exrate exchangerate.buy%TYPE;
    default_currency char(3);
    
    BEGIN 
        SELECT * INTO default_currency  FROM defaults_get_defaultcurrency();
        IF default_currency = in_currency THEN
           RETURN 1;
        END IF; 
        IF in_account_class = 2 THEN
          SELECT buy INTO out_exrate 
          FROM exchangerate
          WHERE transdate = in_date AND curr = in_currency;
        ELSE 
          SELECT sell INTO out_exrate 
          FROM exchangerate
          WHERE transdate = in_date AND curr = in_currency;   
        END IF;
        RETURN out_exrate;
    END;
</programlisting>
      </para>
    </section>

<!-- Function customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer) -->
    <section id="lsmb14.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer"
             xreflabel="lsmb14customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)">
      <title id="lsmb14.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer-title">
       customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer-titleabbrev">
       customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    BEGIN
    return _entity_location_save(
        in_entity_id, NULL,
        in_location_class, in_line_one, in_line_two, in_line_three,
        in_city, in_state, in_mail_code, in_country_id);
    END;

</programlisting>
      </para>
    </section>

<!-- Function date_get_all_years() -->
    <section id="lsmb14.function.date-get-all-years"
             xreflabel="lsmb14date_get_all_years()">
      <title id="lsmb14.function.date-get-all-years-title">
       date_get_all_years()
      </title>
      <titleabbrev id="lsmb14.function.date-get-all-years-titleabbrev">
       date_get_all_years()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return each year inside transdate in transactions. 
Currently it uses a sparse index scan because the number of rows returned is 
very small and the table can be very large.
        <programlisting>
DECLARE next_record int;
BEGIN

SELECT MIN(EXTRACT (&#39;YEAR&#39; FROM transdate))::INT
INTO next_record
FROM acc_trans;

LOOP

  EXIT WHEN next_record IS NULL;
  RETURN NEXT next_record;
  SELECT MIN(EXTRACT (&#39;YEAR&#39; FROM transdate))::INT AS YEAR
  INTO next_record
  FROM acc_trans
  WHERE EXTRACT (&#39;YEAR&#39; FROM transdate) &gt; next_record;


END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function days_in_month(in_date date) -->
    <section id="lsmb14.function.days-in-month-in-date-date"
             xreflabel="lsmb14days_in_month(in_date date)">
      <title id="lsmb14.function.days-in-month-in-date-date-title">
       days_in_month(in_date date)
      </title>
      <titleabbrev id="lsmb14.function.days-in-month-in-date-date-titleabbrev">
       days_in_month(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of days in the month that includes in_date.
        <programlisting>
SELECT (extract(DOM FROM date_trunc(&#39;month&#39;, $1)
                         + &#39;1 month - 1 second&#39;::interval)
      )::int;

</programlisting>
      </para>
    </section>

<!-- Function defaults_get_defaultcurrency() -->
    <section id="lsmb14.function.defaults-get-defaultcurrency"
             xreflabel="lsmb14defaults_get_defaultcurrency()">
      <title id="lsmb14.function.defaults-get-defaultcurrency-title">
       defaults_get_defaultcurrency()
      </title>
      <titleabbrev id="lsmb14.function.defaults-get-defaultcurrency-titleabbrev">
       defaults_get_defaultcurrency()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF bpchar</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return the default currency asigned by the program. 
        <programlisting>
DECLARE defaultcurrency defaults.value%TYPE;
      BEGIN   
           SELECT INTO defaultcurrency substr(value,1,3)
           FROM defaults
           WHERE setting_key = &#39;curr&#39;;
           RETURN NEXT defaultcurrency;
      END;
</programlisting>
      </para>
    </section>

<!-- Function del_recurring() -->
    <section id="lsmb14.function.del-recurring"
             xreflabel="lsmb14del_recurring()">
      <title id="lsmb14.function.del-recurring-title">
       del_recurring()
      </title>
      <titleabbrev id="lsmb14.function.del-recurring-titleabbrev">
       del_recurring()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  DELETE FROM recurring WHERE id = old.id;
  DELETE FROM recurringemail WHERE id = old.id;
  DELETE FROM recurringprint WHERE id = old.id;
  RETURN NULL;
END;
</programlisting>
      </para>
    </section>

<!-- Function del_yearend() -->
    <section id="lsmb14.function.del-yearend"
             xreflabel="lsmb14del_yearend()">
      <title id="lsmb14.function.del-yearend-title">
       del_yearend()
      </title>
      <titleabbrev id="lsmb14.function.del-yearend-titleabbrev">
       del_yearend()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
begin
  delete from yearend where trans_id = old.id;
  return NULL;
end;
</programlisting>
      </para>
    </section>

<!-- Function draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric) -->
    <section id="lsmb14.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric"
             xreflabel="lsmb14draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)">
      <title id="lsmb14.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric-title">
       draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)
      </title>
      <titleabbrev id="lsmb14.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric-titleabbrev">
       draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF draft_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for drafts.  in_type may be any of &apos;ar&apos;, &apos;ap&apos;, or &apos;gl&apos;.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT trans.id, trans.transdate, trans.invoice, 
                       trans.reference, trans.description, 
			sum(case when lower(in_type) = &#39;ap&#39; AND chart.link = &#39;AP&#39;
				 THEN line.amount
				 WHEN lower(in_type) = &#39;ar&#39; AND chart.link = &#39;AR&#39;
				 THEN line.amount * -1
				 WHEN lower(in_type) = &#39;gl&#39; AND line.amount &gt; 0
				 THEN line.amount
			 	 ELSE 0
			    END) as amount
		FROM (
			SELECT id, transdate, reference, 
				description, false as invoice,
                                approved from gl
			WHERE lower(in_type) = &#39;gl&#39;
			UNION
			SELECT id, transdate, invnumber as reference, 
				(SELECT name FROM eca__get_entity(entity_credit_account)),
				invoice, approved from ap
			WHERE lower(in_type) = &#39;ap&#39;
			UNION
			SELECT id, transdate, invnumber as reference,
				description, 
				invoice, approved from ar
			WHERE lower(in_type) = &#39;ar&#39;
			) trans
		JOIN acc_trans line ON (trans.id = line.trans_id)
		JOIN chart ON (line.chart_id = chart.id and charttype = &#39;A&#39;)
           LEFT JOIN voucher v ON (v.trans_id = trans.id)
		WHERE (in_from_date IS NULL or trans.transdate &gt;= in_from_date)
			AND (in_to_date IS NULL 
				or trans.transdate &lt;= in_to_date)
			AND trans.approved IS FALSE
			AND v.id IS NULL
		GROUP BY trans.id, trans.transdate, trans.description, 
                         trans.reference, trans.invoice
		HAVING (in_with_accno IS NULL or in_with_accno = 
			ANY(as_array(chart.accno)))
		ORDER BY trans.reference
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function draft_approve(in_id integer) -->
    <section id="lsmb14.function.draft-approve-in-id-integer"
             xreflabel="lsmb14draft_approve(in_id integer)">
      <title id="lsmb14.function.draft-approve-in-id-integer-title">
       draft_approve(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.draft-approve-in-id-integer-titleabbrev">
       draft_approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the draft from the book.  Only will delete unapproved transactions.
Otherwise an exception is raised and the transaction terminated.
        <programlisting>
declare 
	t_table text;
begin
	SELECT table_name into t_table FROM transactions where id = in_id;

        IF (t_table = &#39;ar&#39;) THEN
                PERFORM cogs__add_for_ar_line(id) FROM invoice 
                  WHERE trans_id = in_id;
		UPDATE ar set approved = true where id = in_id;
	ELSIF (t_table = &#39;ap&#39;) THEN
                PERFORM cogs__add_for_ap_line(id) FROM invoice 
                  WHERE trans_id = in_id;
		UPDATE ap set approved = true where id = in_id;
	ELSIF (t_table = &#39;gl&#39;) THEN
		UPDATE gl set approved = true where id = in_id;
	ELSE
		raise exception &#39;Invalid table % in draft_approve for transaction %&#39;, t_table, in_id;
	END IF;

	IF NOT FOUND THEN
		RETURN FALSE;
	END IF;

	UPDATE transactions 
	SET approved_by = 
			(select entity_id FROM users 
			WHERE username = SESSION_USER), 
		approved_at = now() 
	WHERE id = in_id;

	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function draft_delete(in_id integer) -->
    <section id="lsmb14.function.draft-delete-in-id-integer"
             xreflabel="lsmb14draft_delete(in_id integer)">
      <title id="lsmb14.function.draft-delete-in-id-integer-title">
       draft_delete(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.draft-delete-in-id-integer-titleabbrev">
       draft_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
declare 
	t_table text;
begin
	DELETE FROM ac_tax_form 
	WHERE entry_id IN 
		(SELECT entry_id FROM acc_trans WHERE trans_id = in_id);

        DELETE FROM acc_trans WHERE trans_id = in_id;
	SELECT lower(table_name) into t_table FROM transactions where id = in_id;

        IF t_table = &#39;ar&#39; THEN
		DELETE FROM ar WHERE id = in_id AND approved IS FALSE;
	ELSIF t_table = &#39;ap&#39; THEN
		DELETE FROM ap WHERE id = in_id AND approved IS FALSE;
	ELSIF t_table = &#39;gl&#39; THEN
		DELETE FROM gl WHERE id = in_id AND approved IS FALSE;
	ELSE
		raise exception &#39;Invalid table % in draft_delete for transaction %&#39;, t_table, in_id;
	END IF;
	IF NOT FOUND THEN
		RAISE EXCEPTION &#39;Invalid transaction id %&#39;, in_id;
	END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function drop_custom_field(character varying, character varying) -->
    <section id="lsmb14.function.drop-custom-field-character-varying-character-varying"
             xreflabel="lsmb14drop_custom_field(character varying, character varying)">
      <title id="lsmb14.function.drop-custom-field-character-varying-character-varying-title">
       drop_custom_field(character varying, character varying)
      </title>
      <titleabbrev id="lsmb14.function.drop-custom-field-character-varying-character-varying-titleabbrev">
       drop_custom_field(character varying, character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
table_name ALIAS FOR $1;
custom_field_name ALIAS FOR $2;
BEGIN
	DELETE FROM custom_field_catalog 
	WHERE field_name = custom_field_name AND 
		table_id = (SELECT table_id FROM custom_table_catalog 
			WHERE extends = table_name);
	EXECUTE &#39;ALTER TABLE &#39; || quote_ident(&#39;custom_&#39; || table_name) || 
		&#39; DROP COLUMN &#39; || quote_ident(custom_field_name);
	RETURN TRUE;	
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text) -->
    <section id="lsmb14.function.eca-delete-contact-in-contact-integer-in-class-id-integer-in-credit-id-text"
             xreflabel="lsmb14eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text)">
      <title id="lsmb14.function.eca-delete-contact-in-contact-integer-in-class-id-integer-in-credit-id-text-title">
       eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text)
      </title>
      <titleabbrev id="lsmb14.function.eca-delete-contact-in-contact-integer-in-class-id-integer-in-credit-id-text-titleabbrev">
       eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if at least one record was deleted.  False if no records were
affected.
        <programlisting>
BEGIN

DELETE FROM eca_to_contact
 WHERE credit_id = in_credit_id and contact_class_id = in_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer) -->
    <section id="lsmb14.function.eca-delete-location-in-location-class-integer-in-id-integer-in-credit-id-integer"
             xreflabel="lsmb14eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer)">
      <title id="lsmb14.function.eca-delete-location-in-location-class-integer-in-id-integer-in-credit-id-integer-title">
       eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-delete-location-in-location-class-integer-in-id-integer-in-credit-id-integer-titleabbrev">
       eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the record identified.  Returns true if successful, false if no record
found.
        <programlisting>
BEGIN

DELETE FROM eca_to_location
 WHERE credit_id = in_credit_id AND location_id = in_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function eca__delete_pricematrix(in_entry_id integer, in_credit_id integer) -->
    <section id="lsmb14.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer"
             xreflabel="lsmb14eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)">
      <title id="lsmb14.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer-title">
       eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer-titleabbrev">
       eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval bool;

BEGIN

retval := false;

DELETE FROM partsvendor 
 WHERE entry_id = in_entry_id 
       AND credit_id = in_credit_id;

retval := FOUND;

DELETE FROM partscustomer
 WHERE entry_id = in_entry_id
       AND credit_id = in_credit_id;

RETURN FOUND or retval;

END;
</programlisting>
      </para>
    </section>

<!-- Function eca__get_by_meta_number(in_entity_class text, in_meta_number integer) -->
    <section id="lsmb14.function.eca-get-by-meta-number-in-entity-class-text-in-meta-number-integer"
             xreflabel="lsmb14eca__get_by_meta_number(in_entity_class text, in_meta_number integer)">
      <title id="lsmb14.function.eca-get-by-meta-number-in-entity-class-text-in-meta-number-integer-title">
       eca__get_by_meta_number(in_entity_class text, in_meta_number integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-get-by-meta-number-in-entity-class-text-in-meta-number-integer-titleabbrev">
       eca__get_by_meta_number(in_entity_class text, in_meta_number integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM entity_credit_account
 WHERE entity_class = $2 AND meta_number = $1;
</programlisting>
      </para>
    </section>

<!-- Function eca__get_entity(in_credit_id integer) -->
    <section id="lsmb14.function.eca-get-entity-in-credit-id-integer"
             xreflabel="lsmb14eca__get_entity(in_credit_id integer)">
      <title id="lsmb14.function.eca-get-entity-in-credit-id-integer-title">
       eca__get_entity(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-get-entity-in-credit-id-integer-titleabbrev">
       eca__get_entity(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity to which the entity credit account is
attached.
        <programlisting>

declare
    v_row entity;
BEGIN
    SELECT entity.* INTO v_row FROM entity_credit_account JOIN entity ON entity_credit_account.entity_id = entity.id WHERE entity_credit_account.id = in_credit_id;
    IF NOT FOUND THEN
        raise exception &#39;Could not find entity with ID %&#39;, in_credit_id;
    ELSE
        return next v_row;
    END IF;
END;

</programlisting>
      </para>
    </section>

<!-- Function eca__get_pricematrix(in_credit_id integer) -->
    <section id="lsmb14.function.eca-get-pricematrix-in-credit-id-integer"
             xreflabel="lsmb14eca__get_pricematrix(in_credit_id integer)">
      <title id="lsmb14.function.eca-get-pricematrix-in-credit-id-integer-title">
       eca__get_pricematrix(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-get-pricematrix-in-credit-id-integer-titleabbrev">
       eca__get_pricematrix(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
        This returns the pricematrix for the customer or vendor 
(entity_credit_account identified by in_id), orderd by partnumber, validfrom

        <programlisting>

SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, pc.pricebreak,
       pc.sellprice, NULL, NULL::int, NULL, pc.validfrom, pc.validto, pc.curr,
       pc.entry_id
  FROM partscustomer pc
  JOIN parts p on pc.parts_id = p.id
  JOIN entity_credit_account eca ON pc.credit_id = eca.id
 WHERE pc.credit_id = $1 AND eca.entity_class = 2
 UNION
SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
       pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
       pv.entry_id
  FROM partsvendor pv
  JOIN parts p on pv.parts_id = p.id
  JOIN entity_credit_account eca ON pv.credit_id = eca.id
 WHERE pv.credit_id = $1 and eca.entity_class = 1
 ORDER BY partnumber, validfrom

</programlisting>
      </para>
    </section>

<!-- Function eca__get_pricematrix_by_pricegroup(in_credit_id integer) -->
    <section id="lsmb14.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer"
             xreflabel="lsmb14eca__get_pricematrix_by_pricegroup(in_credit_id integer)">
      <title id="lsmb14.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer-title">
       eca__get_pricematrix_by_pricegroup(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer-titleabbrev">
       eca__get_pricematrix_by_pricegroup(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, pc.pricebreak,
       pc.sellprice, NULL::numeric, NULL::int, NULL::text, pc.validfrom, 
       pc.validto, pc.curr, pc.entry_id
  FROM partscustomer pc
  JOIN parts p on pc.parts_id = p.id
  JOIN entity_credit_account eca ON pc.pricegroup_id = eca.pricegroup_id
 WHERE eca.id = $1 AND eca.entity_class = 2
</programlisting>
      </para>
    </section>

<!-- Function eca__get_taxes(in_id integer) -->
    <section id="lsmb14.function.eca-get-taxes-in-id-integer"
             xreflabel="lsmb14eca__get_taxes(in_id integer)">
      <title id="lsmb14.function.eca-get-taxes-in-id-integer-title">
       eca__get_taxes(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-get-taxes-in-id-integer-titleabbrev">
       eca__get_taxes(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_tax</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of taxable account id&apos;s.
        <programlisting>
select * from eca_tax where eca_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean) -->
    <section id="lsmb14.function.eca-history-in-inc-closed-text-in-inc-open-text-in-entity-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean"
             xreflabel="lsmb14eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)">
      <title id="lsmb14.function.eca-history-in-inc-closed-text-in-inc-open-text-in-entity-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-title">
       eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </title>
      <titleabbrev id="lsmb14.function.eca-history-in-inc-closed-text-in-inc-open-text-in-entity-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-titleabbrev">
       eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_history_result</seg>
        </seglistitem>
       </segmentedlist>
 
       This produces a history detail report, i.e. a list of all products purchased by
a customer over a specific date range.  

meta_number is an exact match, as are in_open and inc_closed.  All other fields
allow for partial matches.  NULL matches all values.
        <programlisting>
     SELECT eca.id, e.name, eca.meta_number, 
            a.id as invoice_id, a.invnumber, a.curr::text, 
            p.id AS parts_id, p.partnumber, 
            i.description, i.qty, i.unit::text, i.sellprice, i.discount, 
            i.deliverydate, null::int as project_id, null::text as projectnumber,
            i.serialnumber, 
            case when $16 = 1 then ex.buy else ex.sell end as exchange_rate,
            ee.id as salesperson_id, 
            ep.last_name || &#39;, &#39; || ep.first_name as salesperson_name
     FROM (select * from entity_credit_account 
            where meta_number = $2
           UNION 
          select * from entity_credit_account WHERE $2 is null
          ) eca  -- broken into unions for performance
     join entity e on eca.entity_id = e.id
     JOIN (select  invnumber, curr, transdate, entity_credit_account, id,
                   person_id, notes
             FROM ar 
            where $16 = 2 and $13 = &#39;i&#39;
                  and (($17 and amount = paid) or ($18 and amount &lt;&gt; paid))
            UNION 
           select invnumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
             FROM ap 
            where $16 = 1 and $13 = &#39;i&#39;
                  and (($17 and amount = paid) or ($18 and amount &lt;&gt; paid))
           union 
           select ordnumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where ($16= 1 and oe.oe_class_id = 2 and $13 = &#39;o&#39; 
                  and quotation is not true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select ordnumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where ($16= 2 and oe.oe_class_id = 1 and $13 = &#39;o&#39;
                  and quotation is not true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select quonumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where($16= 1 and oe.oe_class_id = 4 and $13 = &#39;q&#39;
                and quotation is true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select quonumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where($16= 2 and oe.oe_class_id = 4 and $13 = &#39;q&#39;
                 and quotation is true)
                  and (($17 and not closed) or ($18 and closed))
          ) a ON (a.entity_credit_account = eca.id) -- broken into unions 
                                                    -- for performance
     JOIN ( select id, trans_id, parts_id, qty, description, unit, discount,
                   deliverydate, serialnumber, sellprice
             FROM  invoice where $13 = &#39;i&#39;
            union 
            select id, trans_id, parts_id, qty, description, unit, discount,
                   reqdate, serialnumber, sellprice
             FROM orderitems where $13 &lt;&gt; &#39;i&#39;
          ) i on i.trans_id = a.id
     JOIN parts p ON (p.id = i.parts_id)
LEFT JOIN exchangerate ex ON (ex.transdate = a.transdate)
LEFT JOIN entity ee ON (a.person_id = ee.id)
LEFT JOIN person ep ON (ep.entity_id = ee.id)
    -- these filters don&#39;t perform as well on large databases
    WHERE (e.name ilike &#39;%&#39; || $1 || &#39;%&#39; or $1 is null)
          and ($3 is null or eca.id in 
                 (select credit_id from eca_to_contact
                   where contact ilike &#39;%&#39; || $3 || &#39;%&#39;))
--          and (($4 is null and $5 is null and $6 is null and $7 is null)
--               or eca.id in
--                  (select credit_id from eca_to_location 
--                    where location_id in
--                          (select id from location
--                            where ($4 is null or line_one ilike &#39;%&#39; || $4 || &#39;%&#39;
--                                   or line_two ilike &#39;%&#39; || $4 || &#39;%&#39;) 
--                                  and ($5 is null or city 
--                                                     ilike &#39;%&#39; || $5 || &#39;%&#39;)
--                                  and ($6 is null or state 
--                                                    ilike &#39;%&#39; || $6 || &#39;%&#39;)
--                                  and ($7 is null or mail_code 
--                                                    ilike &#39;%&#39; || $7 || &#39;%&#39;)
--                                  and ($10 is null or country_id = $10))
--                   )
--              )
--          and (a.transdate &gt;= $11 or $11 is null)
--          and (a.transdate &lt;= $12 or $12 is null)
--          and (eca.startdate &gt;= $14 or $14 is null)
--          and (eca.startdate &lt;= $15 or $15 is null)
--          and (a.notes @@ plainto_tsquery($9) or $9 is null)
 ORDER BY eca.meta_number;
</programlisting>
      </para>
    </section>

<!-- Function eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean) -->
    <section id="lsmb14.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean"
             xreflabel="lsmb14eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)">
      <title id="lsmb14.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-title">
       eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </title>
      <titleabbrev id="lsmb14.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-titleabbrev">
       eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_history_result</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates a summary account (no quantities, just parts group by invoice).

meta_number must match exactly or be NULL.  inc_open and inc_closed are exact
matches too.  All other values specify ranges or may match partially.
        <programlisting>
SELECT id, name, meta_number, null::int, null::text, curr, parts_id, partnumber,
       description, sum(qty), unit, null::numeric, null::numeric, null::date, 
       null::int, null::text, null::text, null::numeric,
       null::int, null::text
FROM   eca__history($1, $2, $3, $4, $5, $6, $7, $8, $9,
                   $10, $11, $12, $13, $14, $15, $16, $17, $18)
 group by id, name, meta_number, curr, parts_id, partnumber, description, unit
 order by meta_number;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_contacts(in_credit_id integer) -->
    <section id="lsmb14.function.eca-list-contacts-in-credit-id-integer"
             xreflabel="lsmb14eca__list_contacts(in_credit_id integer)">
      <title id="lsmb14.function.eca-list-contacts-in-credit-id-integer-title">
       eca__list_contacts(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-list-contacts-in-credit-id-integer-titleabbrev">
       eca__list_contacts(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contact info attached to the entity credit account.
        <programlisting>
DECLARE out_row contact_list;
BEGIN
	FOR out_row IN
		SELECT cl.class, cl.id, c.description, c.contact
		FROM eca_to_contact c
		JOIN contact_class cl ON (c.contact_class_id = cl.id)
		WHERE credit_id = in_credit_id
	LOOP
		return next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_locations(in_credit_id integer) -->
    <section id="lsmb14.function.eca-list-locations-in-credit-id-integer"
             xreflabel="lsmb14eca__list_locations(in_credit_id integer)">
      <title id="lsmb14.function.eca-list-locations-in-credit-id-integer-title">
       eca__list_locations(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-list-locations-in-credit-id-integer-titleabbrev">
       eca__list_locations(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of locations attached to the credit account.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT l.id, l.line_one, l.line_two, l.line_three, l.city, 
			l.state, l.mail_code, c.id, c.name, lc.id, lc.class
		FROM location l
		JOIN eca_to_location ctl ON (ctl.location_id = l.id)
		JOIN location_class lc ON (ctl.location_class = lc.id)
		JOIN country c ON (c.id = l.country_id)
		WHERE ctl.credit_id = in_credit_id
		ORDER BY lc.id, l.id, c.name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_notes(in_credit_id integer) -->
    <section id="lsmb14.function.eca-list-notes-in-credit-id-integer"
             xreflabel="lsmb14eca__list_notes(in_credit_id integer)">
      <title id="lsmb14.function.eca-list-notes-in-credit-id-integer-title">
       eca__list_notes(in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-list-notes-in-credit-id-integer-titleabbrev">
       eca__list_notes(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF note</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of notes attached to the entity credit account.
        <programlisting>
DECLARE out_row record;
	t_entity_id int;
BEGIN
        -- ALERT: security definer function.  Be extra careful about EXECUTE
        -- in here. --CT
	SELECT entity_id INTO t_entity_id
	FROM entity_credit_account
	WHERE id = in_credit_id;

	FOR out_row IN
		SELECT *
		FROM note
		WHERE (note_class = 3 and ref_key = in_credit_id) or
			(note_class = 1 and ref_key = t_entity_id)
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer) -->
    <section id="lsmb14.function.eca-location-save-in-old-location-class-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-credit-id-integer"
             xreflabel="lsmb14eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer)">
      <title id="lsmb14.function.eca-location-save-in-old-location-class-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-credit-id-integer-title">
       eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-location-save-in-old-location-class-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-credit-id-integer-titleabbrev">
       eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location to an entity credit account. Returns id of saved record.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
        l_orig_id INT;
    BEGIN
       
        UPDATE eca_to_location
           SET location_class = in_location_class
         WHERE credit_id = in_credit_id
           AND location_class = in_old_location_class
           AND location_id = in_id;
           
         IF FOUND THEN
            SELECT location_save(
                in_id, 
                in_line_one, 
                in_line_two, 
                in_line_three, 
                in_city,
                in_state, 
                in_mail_code, 
                in_country_id
            )
        	INTO l_id; 
        ELSE
            SELECT location_save(
                NULL, 
                in_line_one, 
                in_line_two, 
                in_line_three, 
                in_city,
                in_state, 
                in_mail_code, 
                in_country_id
            )
        	INTO l_id; 
            INSERT INTO eca_to_location 
        		(credit_id, location_class, location_id)
        	VALUES  (in_credit_id, in_location_class, l_id);
        
        END IF;

	RETURN l_id;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer) -->
    <section id="lsmb14.function.eca-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-id-integer"
             xreflabel="lsmb14eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer)">
      <title id="lsmb14.function.eca-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-id-integer-title">
       eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-id-integer-titleabbrev">
       eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity credit account.  Returns the id of the record saved.  
        <programlisting>
    
    DECLARE
        t_entity_class int;
        l_id int;
	t_meta_number text; 
	t_mn_default_key text;
    BEGIN
	-- TODO:  Move to mapping table.
            IF in_entity_class = 1 THEN
	       t_mn_default_key := &#39;vendornumber&#39;;
	    ELSIF in_entity_class = 2 THEN
	       t_mn_default_key := &#39;customernumber&#39;;
	    END IF;
	    IF in_meta_number IS NULL THEN
		t_meta_number := setting_increment(t_mn_default_key);
	    ELSE
		t_meta_number := in_meta_number;
	    END IF;
            update entity_credit_account SET
                discount = in_discount,
                taxincluded = in_taxincluded,
                creditlimit = in_creditlimit,
		description = in_description,
                terms = in_terms,
                ar_ap_account_id = in_ar_ap_account_id,
                cash_account_id = in_cash_account_id,
                discount_account_id = in_discount_account_id,
                meta_number = t_meta_number,
                business_id = in_business_id,
                language_code = in_language_code,
                pricegroup_id = in_pricegroup_id,
                curr = in_curr,
                startdate = in_startdate,
                enddate = in_enddate,
                threshold = in_threshold,
		discount_terms = in_discount_terms,
		pay_to_name = in_pay_to_name,
		taxform_id = in_taxform_id
            where id = in_id;
        
         IF FOUND THEN
            RETURN in_id;
         ELSE
            INSERT INTO entity_credit_account (
                entity_id,
                entity_class,
                discount, 
                description,
                taxincluded,
                creditlimit,
                terms,
                meta_number,
                business_id,
                language_code,
                pricegroup_id,
                curr,
                startdate,
                enddate,
                discount_terms,
                threshold,
		ar_ap_account_id,
                pay_to_name,
                taxform_id,
                cash_account_id,
                discount_account_id
            )
            VALUES (
                in_entity_id,
                in_entity_class,
                in_discount, 
                in_description,
                in_taxincluded,
                in_creditlimit,
                in_terms,
                t_meta_number,
                in_business_id,
                in_language_code,
                in_pricegroup_id,
                in_curr,
                in_startdate,
                in_enddate,
                in_discount_terms,
                in_threshold,
                in_ar_ap_account_id,
                in_pay_to_name,
                in_taxform_id,
		in_cash_account_id,
                in_discount_account_id
            );
            RETURN currval(&#39;entity_credit_account_id_seq&#39;);
       END IF;

    END;
    
</programlisting>
      </para>
    </section>

<!-- Function eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer) -->
    <section id="lsmb14.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-credit-id-integer"
             xreflabel="lsmb14eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer)">
      <title id="lsmb14.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-credit-id-integer-title">
       eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-credit-id-integer-titleabbrev">
       eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the contact record at the entity credit account level.  Returns 1.
        <programlisting>
DECLARE out_id int;
BEGIN

    PERFORM *
       FROM eca_to_contact
      WHERE credit_id = in_credit_id
        AND contact_class_id = in_old_contact_class
        AND contact = in_old_contact;
        
    IF FOUND THEN
        UPDATE eca_to_contact
           SET contact = in_contact,
               description = in_description,
               contact_class_id = in_class_id
         WHERE credit_id = in_credit_id
           AND contact_class_id = in_old_contact_class
           AND contact = in_old_contact;
    ELSE
        INSERT INTO eca_to_contact(credit_id, contact_class_id, 
                description, contact)
        VALUES (in_credit_id, in_class_id, in_description, in_contact);
        
    END IF;

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_notes(in_subject integer, in_note text, in_credit_id text) -->
    <section id="lsmb14.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text"
             xreflabel="lsmb14eca__save_notes(in_subject integer, in_note text, in_credit_id text)">
      <title id="lsmb14.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text-title">
       eca__save_notes(in_subject integer, in_note text, in_credit_id text)
      </title>
      <titleabbrev id="lsmb14.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text-titleabbrev">
       eca__save_notes(in_subject integer, in_note text, in_credit_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity credit account-level note.  Such a note is valid for only one
credit account. Returns the id of the note.  
        <programlisting>
DECLARE out_id int;
BEGIN
	-- TODO, change this to create vector too
	INSERT INTO eca_note (ref_key, note_class, note, vector, subject)
	VALUES (in_credit_id, 3, in_note, &#39;&#39;, in_subject);

	SELECT currval(&#39;note_id_seq&#39;) INTO out_id;
	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer) -->
    <section id="lsmb14.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer"
             xreflabel="lsmb14eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)">
      <title id="lsmb14.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-title">
       eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </title>
      <titleabbrev id="lsmb14.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-titleabbrev">
       eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   retval eca__pricematrix;
   t_insert bool;

BEGIN

t_insert := false;

PERFORM * FROM entity_credit_account 
  WHERE id = in_credit_id AND entity_class = 1;

IF FOUND THEN -- VENDOR
    UPDATE partsvendor
       SET lastcost = in_price,
           leadtime = in_lead_time,
           partnumber = in_partnumber,
           curr = in_curr
     WHERE credit_id = in_credit_id AND entry_id = in_entry_id;

    IF NOT FOUND THEN
        INSERT INTO partsvendor
               (parts_id, credit_id, lastcost, leadtime, partnumber, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_leadtime::int2, 
               in_partnumber, in_curr);
    END IF;

    SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
           pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
           pv.entry_id
      INTO retval
      FROM partsvendor pv
      JOIN parts p ON p.id = pv.parts_id
     WHERE parts_id = in_parts_id and credit_id = in_credit_id;

    RETURN retval;
END IF;

PERFORM * FROM entity_credit_account
  WHERE id = in_credit_id AND entity_class = 2;

IF FOUND THEN -- CUSTOMER
    UPDATE partscustomer
       SET pricebreak = in_pricebreak,
           sellprice  = in_price,
           validfrom  = in_validfrom,
           validto    = in_validto,
           curr       = in_curr
     WHERE entry_id = in_entry_id and credit_id = in_credit_id;

    IF NOT FOUND THEN
        INSERT INTO partscustomer
               (parts_id, credit_id, sellprice, validfrom, validto, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_validfrom, in_validto, 
                in_curr);

        t_insert := true;
    END IF;

    SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, 
           pc.pricebreak, pc.sellprice, NULL, NULL, NULL, pc.validfrom, 
           pc.validto, pc.curr, pc.entry_id
      INTO retval
      FROM partscustomer pc
      JOIN parts p on pc.parts_id = p.id
     WHERE entry_id = CASE WHEN t_insert 
                           THEN currval(&#39;partscustomer_entry_id_seq&#39;) 
                           ELSE in_entry_id 
                      END;
                           
    RETURN retval;

END IF;

RAISE EXCEPTION &#39;No valid entity credit account found&#39;;
   
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__set_taxes(in_tax_ids integer, in_id integer[]) -->
    <section id="lsmb14.function.eca-set-taxes-in-tax-ids-integer-in-id-integerARRAY"
             xreflabel="lsmb14eca__set_taxes(in_tax_ids integer, in_id integer[])">
      <title id="lsmb14.function.eca-set-taxes-in-tax-ids-integer-in-id-integerARRAY-title">
       eca__set_taxes(in_tax_ids integer, in_id integer[])
      </title>
      <titleabbrev id="lsmb14.function.eca-set-taxes-in-tax-ids-integer-in-id-integerARRAY-titleabbrev">
       eca__set_taxes(in_tax_ids integer, in_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Sets the tax values for the customer or vendor.

The entity credit account must exist before calling this function, and must
have a type of either 1 or 2.

        <programlisting>
DECLARE 
    eca entity_credit_account;
    iter int;
BEGIN
     IF in_tax_ids = &#39;{}&#39; THEN
         RETURN NULL;
     END IF;
     SELECT * FROM entity_credit_account into eca WHERE id = in_id;

     DELETE FROM eca_tax WHERE eca_id = in_id;
     FOR iter in array_lower(in_tax_ids, 1) .. array_upper(in_tax_ids, 1)
     LOOP
          INSERT INTO eca_tax (eca_id, chart_id)
          values (in_id, in_tax_ids[iter]);
     END LOOP;
     RETURN TRUE;
end;
</programlisting>
      </para>
    </section>

<!-- Function eca_bu_trigger() -->
    <section id="lsmb14.function.eca-bu-trigger"
             xreflabel="lsmb14eca_bu_trigger()">
      <title id="lsmb14.function.eca-bu-trigger-title">
       eca_bu_trigger()
      </title>
      <titleabbrev id="lsmb14.function.eca-bu-trigger-titleabbrev">
       eca_bu_trigger()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  IF TG_OP = &#39;INSERT&#39; THEN
      INSERT INTO business_unit(class_id, description, credit_id)
      VALUES (7 - NEW.entity_class, NEW.meta_number, NEW.id);
  ELSIF TG_OP = &#39;UPDATE&#39; THEN
      IF new.meta_number &lt;&gt; old.meta_number THEN
         UPDATE business_unit SET description = new.meta_number
          WHERE class_id = 7 - NEW.entity_class
                AND credit_id = new.id;
      END IF;
  ELSIF TG_OP = &#39;DELETE&#39;THEN
      DELETE FROM business_unit WHERE class_id = 7 - NEW.entity_class
                  AND credit_id = old_id;
      RETURN OLD;
  END IF;
  RETURN NEW;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__all_managers() -->
    <section id="lsmb14.function.employee-all-managers"
             xreflabel="lsmb14employee__all_managers()">
      <title id="lsmb14.function.employee-all-managers-title">
       employee__all_managers()
      </title>
      <titleabbrev id="lsmb14.function.employee-all-managers-titleabbrev">
       employee__all_managers()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
   SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ee.role = &#39;manager&#39;
 ORDER BY ee.employeenumber;
</programlisting>
      </para>
    </section>

<!-- Function employee__get(in_entity_id integer) -->
    <section id="lsmb14.function.employee-get-in-entity-id-integer"
             xreflabel="lsmb14employee__get(in_entity_id integer)">
      <title id="lsmb14.function.employee-get-in-entity-id-integer-title">
       employee__get(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.employee-get-in-entity-id-integer-titleabbrev">
       employee__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an employee_result tuple with information specified by the entity_id.

        <programlisting>
   SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE p.entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function employee__get_user(in_entity_id integer) -->
    <section id="lsmb14.function.employee-get-user-in-entity-id-integer"
             xreflabel="lsmb14employee__get_user(in_entity_id integer)">
      <title id="lsmb14.function.employee-get-user-in-entity-id-integer-title">
       employee__get_user(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.employee-get-user-in-entity-id-integer-titleabbrev">
       employee__get_user(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns username, user_id, etc. information if the employee is a user.
        <programlisting>SELECT * FROM users WHERE entity_id = $1;</programlisting>
      </para>
    </section>

<!-- Function employee__list_managers(in_id integer) -->
    <section id="lsmb14.function.employee-list-managers-in-id-integer"
             xreflabel="lsmb14employee__list_managers(in_id integer)">
      <title id="lsmb14.function.employee-list-managers-in-id-integer-title">
       employee__list_managers(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.employee-list-managers-in-id-integer-titleabbrev">
       employee__list_managers(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF employees</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of managers, that is employees with the &apos;manager&apos; role set.
        <programlisting>
DECLARE
	emp employees%ROWTYPE;
BEGIN
	FOR emp IN 
		SELECT 
		    e.salutation,
		    e.first_name,
		    e.last_name,
		    ee.* 
		FROM entity_employee ee
		JOIN entity e on e.id = ee.entity_id
		WHERE ee.sales = &#39;t&#39;::bool AND ee.role=&#39;manager&#39;
			AND ee.entity_id &lt;&gt; coalesce(in_id, -1)
		ORDER BY name
	LOOP
		RETURN NEXT emp;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text) -->
    <section id="lsmb14.function.employee-save-in-employeenumber-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text"
             xreflabel="lsmb14employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)">
      <title id="lsmb14.function.employee-save-in-employeenumber-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text-title">
       employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)
      </title>
      <titleabbrev id="lsmb14.function.employee-save-in-employeenumber-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text-titleabbrev">
       employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an employeerecord with the specified information.
        <programlisting>
DECLARE out_id INT;
BEGIN
	UPDATE entity_employee 
	SET startdate = coalesce(in_start_date, now()::date),
		enddate = in_end_date,
		dob = in_dob,
		role = in_role,
		ssn = in_ssn,
		manager_id = in_manager_id,
		employeenumber = in_employeenumber
	WHERE entity_id = in_entity_id;

	out_id = in_entity_id;

	IF NOT FOUND THEN
		INSERT INTO entity_employee 
			(startdate, enddate, dob, role, ssn, manager_id, 
				employeenumber, entity_id)
		VALUES
			(coalesce(in_start_date, now()::date), in_end_date, 
                                in_dob, in_role, in_ssn,
				in_manager_id, in_employeenumber, 
                                in_entity_id);
		RETURN in_entity_id;
	END IF;
        RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text) -->
    <section id="lsmb14.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text"
             xreflabel="lsmb14employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)">
      <title id="lsmb14.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text-title">
       employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)
      </title>
      <titleabbrev id="lsmb14.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text-titleabbrev">
       employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of employee_result records matching the search criteria.

employeenumber is an exact match.  
stardate_from and startdate_to specify the start dates for employee searches
All others are partial matches.

NULLs match all values.
        <programlisting>
SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id, 
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity e ON p.entity_id = e.id
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ($7 is null or p.entity_id in (select ref_key from entity_note
                                          WHERE note ilike &#39;%&#39; || $7 || &#39;%&#39;))
          and ($1 is null or $1 = ee.employeenumber)
          and ($2 is null or $2 &lt;= ee.startdate)
          and ($3 is null or $3 &gt;= ee.startdate)
          and ($4 is null or p.first_name ilike &#39;%&#39; || $4 || &#39;%&#39;)
          and ($5 is null or p.middle_name ilike &#39;%&#39; || $5 || &#39;%&#39;)
          and ($6 is null or p.last_name ilike &#39;%&#39; || $6 || &#39;%&#39;);
</programlisting>
      </para>
    </section>

<!-- Function employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean) -->
    <section id="lsmb14.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean"
             xreflabel="lsmb14employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)">
      <title id="lsmb14.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean-title">
       employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)
      </title>
      <titleabbrev id="lsmb14.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean-titleabbrev">
       employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF employee_search</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	emp employee_search%ROWTYPE;
BEGIN
	FOR emp IN
		SELECT * FROM employee_search
		WHERE coalesce(startdate, &#39;infinity&#39;::timestamp)
			&gt;= coalesce(in_startdateto, &#39;-infinity&#39;::timestamp)
			AND coalesce(startdate, &#39;-infinity&#39;::timestamp) &lt;=
				coalesce(in_startdatefrom, 
						&#39;infinity&#39;::timestamp)
			AND coalesce(enddate, &#39;-infinity&#39;::timestamp) &lt;= 
				coalesce(in_enddateto, &#39;infinity&#39;::timestamp)
			AND coalesce(enddate, &#39;infinity&#39;::timestamp) &gt;= 
				coalesce(in_enddatefrom, &#39;-infinity&#39;::timestamp)
			AND (name % in_name
			    OR note % in_notes)
			AND (sales = &#39;t&#39; OR coalesce(in_sales, &#39;f&#39;) = &#39;f&#39;)
	LOOP
		RETURN NEXT emp;
	END LOOP;
	return;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee_set_location(in_location integer, in_employee integer) -->
    <section id="lsmb14.function.employee-set-location-in-location-integer-in-employee-integer"
             xreflabel="lsmb14employee_set_location(in_location integer, in_employee integer)">
      <title id="lsmb14.function.employee-set-location-in-location-integer-in-employee-integer-title">
       employee_set_location(in_location integer, in_employee integer)
      </title>
      <titleabbrev id="lsmb14.function.employee-set-location-in-location-integer-in-employee-integer-titleabbrev">
       employee_set_location(in_location integer, in_employee integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

    INSERT INTO entity_to_location (entity_id,location_id) 
    SELECT entity_id, $2
      FROM person WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function entity__delete_bank_account(in_id integer, in_entity_id integer) -->
    <section id="lsmb14.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer"
             xreflabel="lsmb14entity__delete_bank_account(in_id integer, in_entity_id integer)">
      <title id="lsmb14.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer-title">
       entity__delete_bank_account(in_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer-titleabbrev">
       entity__delete_bank_account(in_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the bank account identitied by in_id if it is attached to the entity
identified by entity_id.  Returns true if a record is deleted, false if not.
        <programlisting>
BEGIN

UPDATE entity_credit_account SET bank_account = NULL
 WHERE entity_id = in_entity_id AND bank_account = in_id;

DELETE FROM entity_bank_account
 WHERE id = in_id AND entity_id = in_entity_id;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text) -->
    <section id="lsmb14.function.entity-delete-contact-in-contact-integer-in-class-id-integer-in-entity-id-text"
             xreflabel="lsmb14entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text)">
      <title id="lsmb14.function.entity-delete-contact-in-contact-integer-in-class-id-integer-in-entity-id-text-title">
       entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text)
      </title>
      <titleabbrev id="lsmb14.function.entity-delete-contact-in-contact-integer-in-class-id-integer-in-entity-id-text-titleabbrev">
       entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if at least one record was deleted.  False if no records were 
affected.
        <programlisting>
BEGIN

DELETE FROM entity_to_contact
 WHERE entity_id = in_entity_id
       and contact_class_id = in_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer) -->
    <section id="lsmb14.function.entity-delete-location-in-location-class-integer-in-id-integer-in-entity-id-integer"
             xreflabel="lsmb14entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer)">
      <title id="lsmb14.function.entity-delete-location-in-location-class-integer-in-id-integer-in-entity-id-integer-title">
       entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-delete-location-in-location-class-integer-in-id-integer-in-entity-id-integer-titleabbrev">
       entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the record identified.  Returns true if successful, false if no record
found.
        <programlisting>
BEGIN

DELETE FROM entity_to_location
 WHERE entity_id = in_entity_id AND location_id = in_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function entity__get(in_entity_id integer) -->
    <section id="lsmb14.function.entity-get-in-entity-id-integer"
             xreflabel="lsmb14entity__get(in_entity_id integer)">
      <title id="lsmb14.function.entity-get-in-entity-id-integer-title">
       entity__get(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-get-in-entity-id-integer-titleabbrev">
       entity__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity record with the entity id.
        <programlisting>

declare
    v_row entity;
BEGIN
    -- Removing the exception when not found handling.  Applications are
    -- perfectly capable of handling whether an entity was not found.  No need
    -- for a database-level exception here. Moreover such results may be useful
    -- --CT

    SELECT * INTO v_row FROM entity WHERE id = in_entity_id;
    return next v_row;
END;

</programlisting>
      </para>
    </section>

<!-- Function entity__list_bank_account(in_entity_id integer) -->
    <section id="lsmb14.function.entity-list-bank-account-in-entity-id-integer"
             xreflabel="lsmb14entity__list_bank_account(in_entity_id integer)">
      <title id="lsmb14.function.entity-list-bank-account-in-entity-id-integer-title">
       entity__list_bank_account(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-list-bank-account-in-entity-id-integer-titleabbrev">
       entity__list_bank_account(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_bank_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all bank accounts for the entity.
        <programlisting>
DECLARE out_row entity_bank_account%ROWTYPE;
BEGIN
	FOR out_row IN
		SELECT * from entity_bank_account where entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_classes() -->
    <section id="lsmb14.function.entity-list-classes"
             xreflabel="lsmb14entity__list_classes()">
      <title id="lsmb14.function.entity-list-classes-title">
       entity__list_classes()
      </title>
      <titleabbrev id="lsmb14.function.entity-list-classes-titleabbrev">
       entity__list_classes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of entity classes, ordered by assigned ids
        <programlisting>
DECLARE out_row entity_class;
BEGIN
	FOR out_row IN 
		SELECT * FROM entity_class
             LEFT JOIN defaults ON setting_key = &#39;roll_prefix&#39;
		WHERE active and pg_has_role(SESSION_USER, 
                                     coalesce(defaults.value, 
                                     &#39;lsmb_&#39; || current_database() || &#39;__&#39;) ||
                                     &#39;contact_class_&#39; ||
                                     lower(regexp_replace(class, &#39; &#39;, &#39;_&#39;)), 
                                     &#39;USAGE&#39;)
		ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_contacts(in_entity_id integer) -->
    <section id="lsmb14.function.entity-list-contacts-in-entity-id-integer"
             xreflabel="lsmb14entity__list_contacts(in_entity_id integer)">
      <title id="lsmb14.function.entity-list-contacts-in-entity-id-integer-title">
       entity__list_contacts(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-list-contacts-in-entity-id-integer-titleabbrev">
       entity__list_contacts(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all contact info for the entity.
        <programlisting>
DECLARE out_row contact_list;
BEGIN
	FOR out_row IN
		SELECT cl.class, cl.id, c.description, c.contact
		FROM entity_to_contact c
		JOIN contact_class cl ON (c.contact_class_id = cl.id)
		WHERE c.entity_id = in_entity_id
	LOOP
		return next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_credit(in_entity_class integer, in_entity_id integer) -->
    <section id="lsmb14.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer"
             xreflabel="lsmb14entity__list_credit(in_entity_class integer, in_entity_id integer)">
      <title id="lsmb14.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer-title">
       entity__list_credit(in_entity_class integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer-titleabbrev">
       entity__list_credit(in_entity_class integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_credit_retrieve</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of entity credit account entries for the entity and of the
entity class.
        <programlisting>
DECLARE out_row entity_credit_retrieve;
BEGIN
	
	FOR out_row IN 
		SELECT  ec.id, e.id, ec.entity_class, ec.discount, 
                        ec.discount_terms,
			ec.taxincluded, ec.creditlimit, ec.terms, 
			ec.meta_number, ec.description, ec.business_id, 
			ec.language_code, 
			ec.pricegroup_id, ec.curr, ec.startdate, 
			ec.enddate, ec.ar_ap_account_id, ec.cash_account_id, 
                        ec.discount_account_id,
			ec.threshold, e.control_code, ec.id, ec.pay_to_name,
                        ec.taxform_id
		FROM entity e 
		JOIN entity_credit_account ec ON (e.id = ec.entity_id)
		WHERE e.id = in_entity_id
			AND ec.entity_class = 
				CASE WHEN in_entity_class = 3 THEN 2
				     WHEN in_entity_class IS NULL 
					THEN ec.entity_class
				ELSE in_entity_class END
	LOOP

		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_locations(in_entity_id integer) -->
    <section id="lsmb14.function.entity-list-locations-in-entity-id-integer"
             xreflabel="lsmb14entity__list_locations(in_entity_id integer)">
      <title id="lsmb14.function.entity-list-locations-in-entity-id-integer-title">
       entity__list_locations(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-list-locations-in-entity-id-integer-titleabbrev">
       entity__list_locations(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all locations for an entity.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT l.id, l.line_one, l.line_two, l.line_three, l.city, 
			l.state, l.mail_code, c.id, c.name, lc.id, lc.class
		FROM location l
		JOIN entity_to_location ctl ON (ctl.location_id = l.id)
		JOIN location_class lc ON (ctl.location_class = lc.id)
		JOIN country c ON (c.id = l.country_id)
		WHERE ctl.entity_id = in_entity_id
		ORDER BY lc.id, l.id, c.name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_notes(in_entity_id integer) -->
    <section id="lsmb14.function.entity-list-notes-in-entity-id-integer"
             xreflabel="lsmb14entity__list_notes(in_entity_id integer)">
      <title id="lsmb14.function.entity-list-notes-in-entity-id-integer-title">
       entity__list_notes(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-list-notes-in-entity-id-integer-titleabbrev">
       entity__list_notes(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of notes (including content) attached to the entity.
        <programlisting>
DECLARE out_row record;
BEGIN
	FOR out_row IN
		SELECT *
		FROM entity_note
		WHERE ref_key = in_entity_id
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date) -->
    <section id="lsmb14.function.entity-location-save-in-created-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-entity-id-date"
             xreflabel="lsmb14entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date)">
      <title id="lsmb14.function.entity-location-save-in-created-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-entity-id-date-title">
       entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date)
      </title>
      <titleabbrev id="lsmb14.function.entity-location-save-in-created-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-entity-id-date-titleabbrev">
       entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location to a company.  Returns the location id.
        <programlisting>
    BEGIN
    return _entity_location_save(
        in_entity_id, in_id,
        in_location_class, in_line_one, in_line_two, 
        &#39;&#39;, in_city , in_state, in_mail_code, in_country_id);
    END;

</programlisting>
      </para>
    </section>

<!-- Function entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer) -->
    <section id="lsmb14.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer"
             xreflabel="lsmb14entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)">
      <title id="lsmb14.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer-title">
       entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer-titleabbrev">
       entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves bank account to the credit account.
        <programlisting>
DECLARE out_id int;
BEGIN
        UPDATE entity_bank_account
           SET bic = in_bic,
               iban = in_iban
         WHERE id = in_bank_account_id;

        IF FOUND THEN
                out_id = in_bank_account_id;
        ELSE
	  	INSERT INTO entity_bank_account(entity_id, bic, iban)
		VALUES(in_entity_id, in_bic, in_iban);
	        SELECT CURRVAL(&#39;entity_bank_account_id_seq&#39;) INTO out_id ;
	END IF;

	IF in_credit_id IS NOT NULL THEN
		UPDATE entity_credit_account SET bank_account = out_id
		WHERE id = in_credit_id;
	END IF;

	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer) -->
    <section id="lsmb14.function.entity-save-contact-in-old-class-id-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-entity-id-integer"
             xreflabel="lsmb14entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer)">
      <title id="lsmb14.function.entity-save-contact-in-old-class-id-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-entity-id-integer-title">
       entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-save-contact-in-old-class-id-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-entity-id-integer-titleabbrev">
       entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves company contact information.  The return value is meaningless. 
        <programlisting>
DECLARE out_id int;
BEGIN
        DELETE FROM entity_to_contact 
         WHERE entity_id = in_entity_id AND contact = in_old_contact 
               AND contact_class_id = in_old_class_id;

	INSERT INTO entity_to_contact 
               (entity_id, contact_class_id, description, contact)
	VALUES (in_entity_id, in_class_id, in_description, in_contact);

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__save_notes(in_subject integer, in_note text, in_entity_id text) -->
    <section id="lsmb14.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text"
             xreflabel="lsmb14entity__save_notes(in_subject integer, in_note text, in_entity_id text)">
      <title id="lsmb14.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text-title">
       entity__save_notes(in_subject integer, in_note text, in_entity_id text)
      </title>
      <titleabbrev id="lsmb14.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text-titleabbrev">
       entity__save_notes(in_subject integer, in_note text, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity-level note.  Such a note is valid for all credit accounts 
attached to that entity.  Returns the id of the note.  
        <programlisting>
DECLARE out_id int;
BEGIN
	-- TODO, change this to create vector too
	INSERT INTO entity_note (ref_key, note_class, entity_id, note, vector, subject)
	VALUES (in_entity_id, 1, in_entity_id, in_note, &#39;&#39;, in_subject);

	SELECT currval(&#39;note_id_seq&#39;) INTO out_id;
	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit__get(in_id integer) -->
    <section id="lsmb14.function.entity-credit-get-in-id-integer"
             xreflabel="lsmb14entity_credit__get(in_id integer)">
      <title id="lsmb14.function.entity-credit-get-in-id-integer-title">
       entity_credit__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-credit-get-in-id-integer-titleabbrev">
       entity_credit__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity credit account info.
        <programlisting>
SELECT * FROM entity_credit_account WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text) -->
    <section id="lsmb14.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text"
             xreflabel="lsmb14entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)">
      <title id="lsmb14.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text-title">
       entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)
      </title>
      <titleabbrev id="lsmb14.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text-titleabbrev">
       entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an entity credit id, based on entity_id, entity_class, 
and meta_number.  This is the preferred way to locate an account if all three of 
these are known
        <programlisting>
DECLARE out_var int;
BEGIN
	SELECT id INTO out_var FROM entity_credit_account
	WHERE entity_id = in_entity_id 
		AND in_entity_class = entity_class
		AND in_meta_number = meta_number;

	RETURN out_var;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer) -->
    <section id="lsmb14.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer"
             xreflabel="lsmb14entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)">
      <title id="lsmb14.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer-title">
       entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer-titleabbrev">
       entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the credit id from the meta_number and entity_class.
        <programlisting>
DECLARE out_credit_id int;
BEGIN
	SELECT id INTO out_credit_id 
	FROM entity_credit_account 
	WHERE meta_number = in_meta_number 
		AND entity_class = in_account_class;

	RETURN out_credit_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_save(in_entity_class integer, in_name text, in_entity_id integer) -->
    <section id="lsmb14.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer"
             xreflabel="lsmb14entity_save(in_entity_class integer, in_name text, in_entity_id integer)">
      <title id="lsmb14.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer-title">
       entity_save(in_entity_class integer, in_name text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer-titleabbrev">
       entity_save(in_entity_class integer, in_name text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Currently unused.  Left in because it is believed it may be helpful.

This saves an entity, with the control code being the next available via the 
defaults table.
        <programlisting>

    DECLARE
        e entity;
        e_id int;
        
    BEGIN
    
        select * into e from entity where id = in_entity_id;
        
        update 
            entity 
        SET
            name = in_name,
            entity_class = in_entity_class
        WHERE
            id = in_entity_id;
        IF NOT FOUND THEN
            -- do the insert magic.
            e_id = nextval(&#39;entity_id_seq&#39;);
            insert into entity (id, name, entity_class) values 
                (e_id,
                in_name,
                in_entity_class
                );
            return e_id;
        END IF;
        return in_entity_id;
            
    END;

</programlisting>
      </para>
    </section>

<!-- Function eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer) -->
    <section id="lsmb14.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer"
             xreflabel="lsmb14eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)">
      <title id="lsmb14.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-title">
       eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </title>
      <titleabbrev id="lsmb14.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-titleabbrev">
       eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Zeroes accounts and then creates a checkpoint. in_end_date is the date when
the books are to be closed, in_reference and in_description become the 
reference and description of the gl transaction, and in_retention_acc_id is
the retained earnings account id.
        <programlisting>
BEGIN
	IF eoy_zero_accounts(in_end_date, in_reference, in_description, in_retention_acc_id) &gt; 0 THEN
		PERFORM eoy_create_checkpoint(in_end_date);
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_create_checkpoint(in_end_date date) -->
    <section id="lsmb14.function.eoy-create-checkpoint-in-end-date-date"
             xreflabel="lsmb14eoy_create_checkpoint(in_end_date date)">
      <title id="lsmb14.function.eoy-create-checkpoint-in-end-date-date-title">
       eoy_create_checkpoint(in_end_date date)
      </title>
      <titleabbrev id="lsmb14.function.eoy-create-checkpoint-in-end-date-date-titleabbrev">
       eoy_create_checkpoint(in_end_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates checkpoints for each account at a specific date.  Books are considered
closed when they occur before the latest checkpoint timewise.  This means that
balances (and credit/debit amounts) can be calculated starting at a checkpoint
and moving forward (thus providing a mechanism for expunging old data while 
keeping balances correct at some future point).
        <programlisting>
DECLARE ret_val int;
	approval_check int;
	cp_date        date;
BEGIN
	IF in_end_date &gt; now()::date THEN
		RAISE EXCEPTION &#39;Invalid date:  Must be earlier than present&#39;;
	END IF;

	SELECT count(*) into approval_check
	FROM acc_trans ac
	JOIN (
		select id, approved, transdate FROM ar UNION
		SELECT id, approved, transdate FROM gl UNION
		SELECT id, approved, transdate FROM ap
	) gl ON (gl.id = ac.trans_id)
	WHERE (ac.approved IS NOT TRUE AND ac.transdate &lt;= in_end_date) 
		OR (gl.approved IS NOT TRUE AND gl.transdate &lt;= in_end_date);

	if approval_check &gt; 0 THEN
		RAISE EXCEPTION &#39;Unapproved transactions in closed period&#39;;
	END IF;
	
	SELECT max(end_date) INTO cp_date FROM account_checkpoint WHERE
	end_date &lt; in_end_date;

	INSERT INTO 
	account_checkpoint (end_date, account_id, amount, debits, credits)
    SELECT in_end_date, COALESCE(a.chart_id, cp.account_id),
	    COALESCE(SUM (a.amount),0) + coalesce(MAX (cp.amount), 0),
	    COALESCE(SUM (CASE WHEN (a.amount &lt; 0) THEN a.amount ELSE 0 END), 0) +
	     COALESCE( MIN (cp.debits), 0),
	    COALESCE(SUM (CASE WHEN (a.amount &gt; 0) THEN a.amount ELSE 0 END), 0) +
	     COALESCE( MAX (cp.credits), 0)
	FROM 
	(SELECT * FROM acc_trans WHERE transdate &lt;= in_end_date AND
	 transdate &gt; COALESCE(cp_date, &#39;1200-01-01&#39;)) a
	FULL OUTER JOIN (
		select account_id, end_date, amount, debits, credits 
		from account_checkpoint
		WHERE end_date = cp_date
		) cp on (a.chart_id = cp.account_id)
	group by COALESCE(a.chart_id, cp.account_id);

	SELECT count(*) INTO ret_val FROM account_checkpoint 
	where end_date = in_end_date;

	return ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_earnings_accounts() -->
    <section id="lsmb14.function.eoy-earnings-accounts"
             xreflabel="lsmb14eoy_earnings_accounts()">
      <title id="lsmb14.function.eoy-earnings-accounts-title">
       eoy_earnings_accounts()
      </title>
      <titleabbrev id="lsmb14.function.eoy-earnings-accounts-titleabbrev">
       eoy_earnings_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists equity accounts for the retained earnings dropdown.
        <programlisting>
    SELECT * 
      FROM account
     WHERE category = &#39;Q&#39;
     ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function eoy_reopen_books(in_end_date date) -->
    <section id="lsmb14.function.eoy-reopen-books-in-end-date-date"
             xreflabel="lsmb14eoy_reopen_books(in_end_date date)">
      <title id="lsmb14.function.eoy-reopen-books-in-end-date-date-title">
       eoy_reopen_books(in_end_date date)
      </title>
      <titleabbrev id="lsmb14.function.eoy-reopen-books-in-end-date-date-titleabbrev">
       eoy_reopen_books(in_end_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Removes checkpoints and reverses yearend transactions on in_end_date
        <programlisting>
BEGIN
	PERFORM count(*) FROM account_checkpoint WHERE end_date = in_end_date;

	IF NOT FOUND THEN
		RETURN FALSE;
	END IF;

	DELETE FROM account_checkpoint WHERE end_date = in_end_date;

	PERFORM count(*) FROM yearend 
	WHERE transdate = in_end_date and reversed is not true;

	IF FOUND THEN
		INSERT INTO gl (reference, description, approved)
		SELECT &#39;Reversing &#39; || reference, &#39;Reversing &#39; || description,
			true
		FROM gl WHERE id = (select trans_id from yearend 
			where transdate = in_end_date and reversed is not true);

		INSERT INTO acc_trans (chart_id, amount, transdate, trans_id,
			approved)
		SELECT chart_id, amount * -1, currval(&#39;id&#39;), true
		FROM acc_trans where trans_id = (select trans_id from yearend
			where transdate = in_end_date and reversed is not true);

		UPDATE yearend SET reversed = true where transdate = in_end_date
			and reversed is not true;
	END IF;

	DELETE FROM account_checkpoint WHERE end_date = in_end_date;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer) -->
    <section id="lsmb14.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer"
             xreflabel="lsmb14eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)">
      <title id="lsmb14.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-title">
       eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </title>
      <titleabbrev id="lsmb14.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-titleabbrev">
       eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts a transaction which zeroes the income and expense accounts, moving the
net balance there into a retained earnings account identified by 
in_retention_acc_id.
        <programlisting>
DECLARE ret_val int;
BEGIN
	INSERT INTO gl (transdate, reference, description, approved)
	VALUES (in_end_date, in_reference, in_description, true);

	INSERT INTO yearend (trans_id, transdate) values (currval(&#39;id&#39;), in_end_date);
	INSERT INTO acc_trans (transdate, chart_id, trans_id, amount)
	SELECT in_end_date, a.chart_id, currval(&#39;id&#39;),
		(sum(a.amount) + coalesce(max(cp.amount), 0)) * -1
	FROM acc_trans a
	LEFT JOIN (
		select account_id, end_date, amount from account_checkpoint
		WHERE end_date = (select max(end_date) from account_checkpoint
				where end_date &lt; in_end_date)
		) cp on (a.chart_id = cp.account_id)
	JOIN account acc ON (acc.id = a.chart_id)
	WHERE a.transdate &lt;= in_end_date 
		AND a.transdate &gt; coalesce(cp.end_date, a.transdate - 1)
		AND (acc.category IN (&#39;I&#39;, &#39;E&#39;)
                      OR acc.category = &#39;Q&#39; AND acc.is_temp)
	GROUP BY a.chart_id;

	INSERT INTO acc_trans (transdate, trans_id, chart_id, amount)
	SELECT in_end_date, currval(&#39;id&#39;), in_retention_acc_id, 
		coalesce(sum(amount) * -1, 0)
	FROM acc_trans WHERE trans_id = currval(&#39;id&#39;);


	SELECT count(*) INTO ret_val from acc_trans 
	where trans_id = currval(&#39;id&#39;);

	RETURN ret_val;
end;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb14.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb14file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb14.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb14.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a good or service.  in_content OR id can be set.
Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to entity credit accounts.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_eca
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb14.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb14file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb14.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb14.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a contact or entity.  in_content OR id can be 
set. Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to entities
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_entity
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb14.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb14file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb14.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb14.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to an order.  in_content OR id can be set.
Setting both raises an exception.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Conflicting options file_id and content$e$;
       END IF;
       IF in_file_class = 1 THEN
           INSERT INTO file_tx_to_order        
                  (file_id, source_class, ref_key, dest_class, attached_by,
                  attached_at)
           VALUES (in_id, 1, in_ref_key, 2, person__get_my_entity_id(), now());
       ELSIF in_file_class = 2 THEN
           INSERT INTO file_order_to_order
                  (file_id, source_class, ref_key, dest_class, attached_by,
                  attached_at)
           VALUES (in_id, 2, in_ref_key, 2, person__get_my_entity_id(), now());
       ELSE 
           RAISE EXCEPTION $E$Invalid file class$E$;
       END IF;
       SELECT * INTO retval FROM file_base where id = in_id;
       RETURN retval;
   ELSE
       INSERT INTO file_order
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb14.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb14file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb14.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb14.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a good or service.  in_content OR id can be set.
Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to parts
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_part
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="lsmb14.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="lsmb14file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="lsmb14.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="lsmb14.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a transaction.  in_content OR id can be set.
Setting both raises an exception.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       INSERT INTO file_order_to_tx        
              (file_id, source_class, ref_key, dest_class, attached_by,
              attached_at)
       VALUES (in_id, 2, in_ref_key, 1, person__get_my_entity_id(), now());

       SELECT * INTO retval FROM file_base where id = in_id;
       RETURN retval;
   ELSE
       INSERT INTO file_transaction 
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__get(in_file_class integer, in_id integer) -->
    <section id="lsmb14.function.file-get-in-file-class-integer-in-id-integer"
             xreflabel="lsmb14file__get(in_file_class integer, in_id integer)">
      <title id="lsmb14.function.file-get-in-file-class-integer-in-id-integer-title">
       file__get(in_file_class integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.file-get-in-file-class-integer-in-id-integer-titleabbrev">
       file__get(in_file_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves the file information specified including content.
        <programlisting>
SELECT * FROM file_base where id = $1 and file_class = $2;
</programlisting>
      </para>
    </section>

<!-- Function file__get_for_template(in_file_class integer, in_ref_key integer) -->
    <section id="lsmb14.function.file-get-for-template-in-file-class-integer-in-ref-key-integer"
             xreflabel="lsmb14file__get_for_template(in_file_class integer, in_ref_key integer)">
      <title id="lsmb14.function.file-get-for-template-in-file-class-integer-in-ref-key-integer-title">
       file__get_for_template(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="lsmb14.function.file-get-for-template-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__get_for_template(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 

SELECT m.mime_type, CASE WHEN f.file_class = 3 THEN ref_key ||&#39;-&#39;|| f.file_name
                         ELSE f.file_name END, 
       f.description, f.uploaded_by, e.name, 
       f.uploaded_at, f.id, f.ref_key, f.file_class,  f.content
  FROM mime_type m
  JOIN file_base f ON f.mime_type_id = m.id
  JOIN entity e ON f.uploaded_by = e.id
 WHERE f.ref_key = $1 and f.file_class = $2
       AND m.invoice_include 
       OR f.id IN (SELECT max(fb.id) 
                   FROM file_base fb
                   JOIN mime_type m ON fb.mime_type_id = m.id
                        AND m.mime_type ilike &#39;image%&#39;
                   JOIN invoice i ON i.trans_id = $1
                        AND i.parts_id = fb.ref_key
                  WHERE fb.file_class = 3)
</programlisting>
      </para>
    </section>

<!-- Function file__get_mime_type(in_mime_type_text integer, in_mime_type_id text) -->
    <section id="lsmb14.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text"
             xreflabel="lsmb14file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)">
      <title id="lsmb14.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text-title">
       file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)
      </title>
      <titleabbrev id="lsmb14.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text-titleabbrev">
       file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>mime_type</seg>
        </seglistitem>
       </segmentedlist>
 
       Retrieves mime type information associated with a file object.
        <programlisting>
select * from mime_type 
 where ($1 IS NULL OR id = $1) AND ($2 IS NULL OR mime_type = $2);
</programlisting>
      </para>
    </section>

<!-- Function file__list_by(in_file_class integer, in_ref_key integer) -->
    <section id="lsmb14.function.file-list-by-in-file-class-integer-in-ref-key-integer"
             xreflabel="lsmb14file__list_by(in_file_class integer, in_ref_key integer)">
      <title id="lsmb14.function.file-list-by-in-file-class-integer-in-ref-key-integer-title">
       file__list_by(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="lsmb14.function.file-list-by-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__list_by(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of files attached to a database object.  No content is 
retrieved.
        <programlisting>

SELECT m.mime_type, f.file_name, f.description, f.uploaded_by, e.name, 
       f.uploaded_at, f.id, f.ref_key, f.file_class, 
       case when m.mime_type = &#39;text/x-uri&#39; THEN f.content ELSE NULL END
  FROM mime_type m
  JOIN file_base f ON f.mime_type_id = m.id
  JOIN entity e ON f.uploaded_by = e.id
 WHERE f.ref_key = $1 and f.file_class = $2;

</programlisting>
      </para>
    </section>

<!-- Function file__list_links(in_file_class integer, in_ref_key integer) -->
    <section id="lsmb14.function.file-list-links-in-file-class-integer-in-ref-key-integer"
             xreflabel="lsmb14file__list_links(in_file_class integer, in_ref_key integer)">
      <title id="lsmb14.function.file-list-links-in-file-class-integer-in-ref-key-integer-title">
       file__list_links(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="lsmb14.function.file-list-links-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__list_links(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_links</seg>
        </seglistitem>
       </segmentedlist>
 
        This function retrieves a list of file attachments on a specified object.
        <programlisting> select * from file_links where ref_key = $1 and dest_class = $2;
</programlisting>
      </para>
    </section>

<!-- Function file_links_vrebuild() -->
    <section id="lsmb14.function.file-links-vrebuild"
             xreflabel="lsmb14file_links_vrebuild()">
      <title id="lsmb14.function.file-links-vrebuild-title">
       file_links_vrebuild()
      </title>
      <titleabbrev id="lsmb14.function.file-links-vrebuild-titleabbrev">
       file_links_vrebuild()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   viewline file_view_catalog%rowtype;
   stmt text;
BEGIN
   stmt := &#39;&#39;;
   FOR viewline IN
       select * from file_view_catalog
   LOOP
       IF stmt = &#39;&#39; THEN
           stmt := &#39;SELECT * FROM &#39; || quote_ident(viewline.view_name) || &#39;
&#39;;
       ELSE
           stmt := stmt || &#39; UNION
SELECT * FROM &#39;|| quote_ident(viewline.view_name) || &#39;
&#39;;
       END IF; 
   END LOOP;
   EXECUTE &#39;CREATE OR REPLACE VIEW file_links AS
&#39; || stmt;
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function form_check(in_form_id integer, in_session_id integer) -->
    <section id="lsmb14.function.form-check-in-form-id-integer-in-session-id-integer"
             xreflabel="lsmb14form_check(in_form_id integer, in_session_id integer)">
      <title id="lsmb14.function.form-check-in-form-id-integer-in-session-id-integer-title">
       form_check(in_form_id integer, in_session_id integer)
      </title>
      <titleabbrev id="lsmb14.function.form-check-in-form-id-integer-in-session-id-integer-titleabbrev">
       form_check(in_form_id integer, in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks to see if an open form (record in open_forms) exists with 
the form_id and session_id provided.  Returns true if exists, false if not.
        <programlisting>
SELECT count(*) = 1 
  FROM open_forms f
  JOIN &quot;session&quot; s USING (session_id)
  JOIN users u ON (s.users_id = u.id)
 WHERE f.session_id = $1 and f.id = $2 and u.username = SESSION_USER;
</programlisting>
      </para>
    </section>

<!-- Function form_close(in_form_id integer, in_session_id integer) -->
    <section id="lsmb14.function.form-close-in-form-id-integer-in-session-id-integer"
             xreflabel="lsmb14form_close(in_form_id integer, in_session_id integer)">
      <title id="lsmb14.function.form-close-in-form-id-integer-in-session-id-integer-title">
       form_close(in_form_id integer, in_session_id integer)
      </title>
      <titleabbrev id="lsmb14.function.form-close-in-form-id-integer-in-session-id-integer-titleabbrev">
       form_close(in_form_id integer, in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Closes out the form by deleting it from the open_forms table.

Returns true if found, false if not.

        <programlisting>
DECLARE form_test bool;
BEGIN
	form_test := form_check(in_session_id, in_form_id);

	IF form_test is true THEN 
		DELETE FROM open_forms 
		WHERE session_id = in_session_id AND id = in_form_id;

		RETURN TRUE;

	ELSE RETURN FALSE;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function form_open(in_session_id integer) -->
    <section id="lsmb14.function.form-open-in-session-id-integer"
             xreflabel="lsmb14form_open(in_session_id integer)">
      <title id="lsmb14.function.form-open-in-session-id-integer-title">
       form_open(in_session_id integer)
      </title>
      <titleabbrev id="lsmb14.function.form-open-in-session-id-integer-titleabbrev">
       form_open(in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This opens a form, and returns the id of the form opened.
        <programlisting>
DECLARE usertest bool;
BEGIN
        SELECT count(*) = 1 INTO usertest FROM session 
         WHERE session_id = in_session_id 
               AND users_id IN (select id from users 
                                WHERE username = SESSION_USER);

        IF usertest is not true THEN
            RAISE EXCEPTION &#39;Invalid session&#39;;
        END IF;
      
	INSERT INTO open_forms (session_id) VALUES (in_session_id);
	RETURN currval(&#39;open_forms_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function get_default_lang() -->
    <section id="lsmb14.function.get-default-lang"
             xreflabel="lsmb14get_default_lang()">
      <title id="lsmb14.function.get-default-lang-title">
       get_default_lang()
      </title>
      <titleabbrev id="lsmb14.function.get-default-lang-titleabbrev">
       get_default_lang()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT coalesce((select description FROM language 
    WHERE code = (SELECT substring(value, 1, 2) FROM defaults
                   WHERE setting_key = &#39;default_language&#39;)), &#39;english&#39;);
</programlisting>
      </para>
    </section>

<!-- Function get_fractional_month(in_date_second date, in_date_first date) -->
    <section id="lsmb14.function.get-fractional-month-in-date-second-date-in-date-first-date"
             xreflabel="lsmb14get_fractional_month(in_date_second date, in_date_first date)">
      <title id="lsmb14.function.get-fractional-month-in-date-second-date-in-date-first-date-title">
       get_fractional_month(in_date_second date, in_date_first date)
      </title>
      <titleabbrev id="lsmb14.function.get-fractional-month-in-date-second-date-in-date-first-date-titleabbrev">
       get_fractional_month(in_date_second date, in_date_first date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of months between two dates in numeric form.
        <programlisting>
SELECT CASE WHEN is_same_month($1, $2)
            THEN ($2 - $1)::numeric
                 / days_in_month($1)
            ELSE (get_fractional_month(
                   $1, (date_trunc(&#39;MONTH&#39;, $1) 
                       + &#39;1 month - 1 second&#39;::interval)::date)
                 + get_fractional_month(date_trunc(&#39;MONTH&#39;, $2)::date, $2)
                 + (extract (&#39;YEAR&#39; from $2) - extract (&#39;YEAR&#39; from $1) * 12)
                 + extract (&#39;MONTH&#39; from $1) - extract (&#39;MONTH&#39; from $2) 
                 - 1)::numeric
            END;
</programlisting>
      </para>
    </section>

<!-- Function get_fractional_year(in_date_to date, in_date_from date) -->
    <section id="lsmb14.function.get-fractional-year-in-date-to-date-in-date-from-date"
             xreflabel="lsmb14get_fractional_year(in_date_to date, in_date_from date)">
      <title id="lsmb14.function.get-fractional-year-in-date-to-date-in-date-from-date-title">
       get_fractional_year(in_date_to date, in_date_from date)
      </title>
      <titleabbrev id="lsmb14.function.get-fractional-year-in-date-to-date-in-date-from-date-titleabbrev">
       get_fractional_year(in_date_to date, in_date_from date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the decimal representation of the fractional year.
        <programlisting>
   select ($2 - $1
            - leap_days(next_leap_year_calc($1, false), 
                       next_leap_year_calc($2, true)))
            /365::numeric;
</programlisting>
      </para>
    </section>

<!-- Function get_link_descriptions() -->
    <section id="lsmb14.function.get-link-descriptions"
             xreflabel="lsmb14get_link_descriptions()">
      <title id="lsmb14.function.get-link-descriptions-title">
       get_link_descriptions()
      </title>
      <titleabbrev id="lsmb14.function.get-link-descriptions-titleabbrev">
       get_link_descriptions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_link_description</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets a set of all valid account_link descriptions.
        <programlisting>
    SELECT * FROM account_link_description;
</programlisting>
      </para>
    </section>

<!-- Function gl_audit_trail_append() -->
    <section id="lsmb14.function.gl-audit-trail-append"
             xreflabel="lsmb14gl_audit_trail_append()">
      <title id="lsmb14.function.gl-audit-trail-append-title">
       gl_audit_trail_append()
      </title>
      <titleabbrev id="lsmb14.function.gl-audit-trail-append-titleabbrev">
       gl_audit_trail_append()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides centralized support for insertions into audittrail.

        <programlisting>
DECLARE
   t_reference text;
   t_row RECORD;
BEGIN

IF TG_OP = &#39;INSERT&#39; then
   t_row := NEW;
ELSE
   t_row := OLD;
END IF;

IF TG_RELNAME IN (&#39;ar&#39;, &#39;ap&#39;) THEN
    t_reference := t_row.invnumber;
ELSE 
    t_reference := t_row.reference;
END IF;

INSERT INTO audittrail (trans_id,tablename,reference, action, person_id)
values (t_row.id,TG_RELNAME,t_reference, TG_OP, person__get_my_entity_id());

return null; -- AFTER TRIGGER ONLY, SAFE
END;
</programlisting>
      </para>
    </section>

<!-- Function in_tree(in_search_array integer, in_node_id lsmb14.tree_record[]) -->
    <section id="lsmb14.function.in-tree-in-search-array-integer-in-node-id-lsmb14.tree-recordARRAY"
             xreflabel="lsmb14in_tree(in_search_array integer, in_node_id lsmb14.tree_record[])">
      <title id="lsmb14.function.in-tree-in-search-array-integer-in-node-id-lsmb14.tree-recordARRAY-title">
       in_tree(in_search_array integer, in_node_id lsmb14.tree_record[])
      </title>
      <titleabbrev id="lsmb14.function.in-tree-in-search-array-integer-in-node-id-lsmb14.tree-recordARRAY-titleabbrev">
       in_tree(in_search_array integer, in_node_id lsmb14.tree_record[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT CASE WHEN count(*) &gt; 0 THEN true ELSE false END
  FROM unnest($2) r
 WHERE t @&gt; array[$1];
</programlisting>
      </para>
    </section>

<!-- Function in_tree(in_search_array integer[], in_node_id lsmb14.tree_record[]) -->
    <section id="lsmb14.function.in-tree-in-search-array-integerARRAY-in-node-id-lsmb14.tree-recordARRAY"
             xreflabel="lsmb14in_tree(in_search_array integer[], in_node_id lsmb14.tree_record[])">
      <title id="lsmb14.function.in-tree-in-search-array-integerARRAY-in-node-id-lsmb14.tree-recordARRAY-title">
       in_tree(in_search_array integer[], in_node_id lsmb14.tree_record[])
      </title>
      <titleabbrev id="lsmb14.function.in-tree-in-search-array-integerARRAY-in-node-id-lsmb14.tree-recordARRAY-titleabbrev">
       in_tree(in_search_array integer[], in_node_id lsmb14.tree_record[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT bool_and(in_tree(e, $2))
  FROM unnest($1) e;
</programlisting>
      </para>
    </section>

<!-- Function inventory_adj__details(in_id integer) -->
    <section id="lsmb14.function.inventory-adj-details-in-id-integer"
             xreflabel="lsmb14inventory_adj__details(in_id integer)">
      <title id="lsmb14.function.inventory-adj-details-in-id-integer-title">
       inventory_adj__details(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.inventory-adj-details-in-id-integer-titleabbrev">
       inventory_adj__details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF inventory_adjustment_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 

   SELECT l.parts_id, p.partnumber, p.description, l.counted, l.expected, 
          l.counted - l.expected
     FROM inventory_report_line l
     JOIN parts p ON l.parts_id = p.id
    WHERE l.report_id = $1;

</programlisting>
      </para>
    </section>

<!-- Function inventory_adj__get(in_id integer) -->
    <section id="lsmb14.function.inventory-adj-get-in-id-integer"
             xreflabel="lsmb14inventory_adj__get(in_id integer)">
      <title id="lsmb14.function.inventory-adj-get-in-id-integer-title">
       inventory_adj__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.inventory-adj-get-in-id-integer-titleabbrev">
       inventory_adj__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF inventory_adjustment_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

   SELECT r.id, r.transdate, r.source, r.ar_trans_id, r.ap_trans_id,
          ar.invnumber, ap.invnumber
     FROM inventory_report r
     JOIN inventory_report_line l ON l.report_id = r.id 
LEFT JOIN ar ON ar.id = r.ar_trans_id
LEFT JOIN ap ON ap.id = r.ap_trans_id
    WHERE r.id = $1;

</programlisting>
      </para>
    </section>

<!-- Function inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text) -->
    <section id="lsmb14.function.inventory-adj-search-in-source-date-in-partnumber-date-in-to-date-text-in-from-date-text"
             xreflabel="lsmb14inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text)">
      <title id="lsmb14.function.inventory-adj-search-in-source-date-in-partnumber-date-in-to-date-text-in-from-date-text-title">
       inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text)
      </title>
      <titleabbrev id="lsmb14.function.inventory-adj-search-in-source-date-in-partnumber-date-in-to-date-text-in-from-date-text-titleabbrev">
       inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF inventory_adjustment_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

   SELECT r.id, r.transdate, r.source, r.ar_trans_id, r.ap_trans_id,
          ar.invnumber, ap.invnumber
     FROM inventory_report r
     JOIN inventory_report_line l ON l.report_id = r.id 
     JOIN parts p ON l.parts_id = p.id
LEFT JOIN ar ON ar.id = r.ar_trans_id
LEFT JOIN ap ON ap.id = r.ap_trans_id
    WHERE ($1 is null or $1 &lt;= r.transdate) AND
          ($2 is null OR $2 &gt;= r.transdate) AND
          ($3 IS NULL OR plainto_tsquery($3) @@ tsvector(p.partnumber)) AND
          ($4 IS NULL OR source LIKE $4 || &#39;%&#39;);
 
</programlisting>
      </para>
    </section>

<!-- Function invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text) -->
    <section id="lsmb14.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text"
             xreflabel="lsmb14invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)">
      <title id="lsmb14.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text-title">
       invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)
      </title>
      <titleabbrev id="lsmb14.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text-titleabbrev">
       invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>ap</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval ap;
BEGIN
	SELECT * INTO retval FROM ap WHERE entity_credit_id = 
		(select id from entity_credit_account where entity_class = 1
		AND meta_number = in_meta_number)
		AND invnumber = in_invoice_number;
	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function is_leapyear(in_date date) -->
    <section id="lsmb14.function.is-leapyear-in-date-date"
             xreflabel="lsmb14is_leapyear(in_date date)">
      <title id="lsmb14.function.is-leapyear-in-date-date-title">
       is_leapyear(in_date date)
      </title>
      <titleabbrev id="lsmb14.function.is-leapyear-in-date-date-titleabbrev">
       is_leapyear(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if date is in a leapyear.  False if not.  Uses the built-in 
PostgreSQL date handling, and no direct detection is done in our code.
        <programlisting>
    select extract(&#39;day&#39; FROM (
                           (extract(&#39;year&#39; FROM $1)::text 
                           || &#39;-02-28&#39;)::date + &#39;1 day&#39;::interval)::date) 
           = 29;
</programlisting>
      </para>
    </section>

<!-- Function is_same_month(in_date2 date, in_date1 date) -->
    <section id="lsmb14.function.is-same-month-in-date2-date-in-date1-date"
             xreflabel="lsmb14is_same_month(in_date2 date, in_date1 date)">
      <title id="lsmb14.function.is-same-month-in-date2-date-in-date1-date-title">
       is_same_month(in_date2 date, in_date1 date)
      </title>
      <titleabbrev id="lsmb14.function.is-same-month-in-date2-date-in-date1-date-titleabbrev">
       is_same_month(in_date2 date, in_date1 date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the two dates are in the same month and year. False 
otherwise.
        <programlisting>
SELECT is_same_year($1, $2) 
       and extract (&#39;MONTH&#39; from $1) = extract (&#39;MONTH&#39; from $2);
</programlisting>
      </para>
    </section>

<!-- Function is_same_year(in_date2 date, in_date1 date) -->
    <section id="lsmb14.function.is-same-year-in-date2-date-in-date1-date"
             xreflabel="lsmb14is_same_year(in_date2 date, in_date1 date)">
      <title id="lsmb14.function.is-same-year-in-date2-date-in-date1-date-title">
       is_same_year(in_date2 date, in_date1 date)
      </title>
      <titleabbrev id="lsmb14.function.is-same-year-in-date2-date-in-date1-date-titleabbrev">
       is_same_year(in_date2 date, in_date1 date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the two dates are in the same year, false otherwise.
        <programlisting>
SELECT  extract (&#39;YEAR&#39; from $1) = extract (&#39;YEAR&#39; from $2);
</programlisting>
      </para>
    </section>

<!-- Function je_get_default_lines() -->
    <section id="lsmb14.function.je-get-default-lines"
             xreflabel="lsmb14je_get_default_lines()">
      <title id="lsmb14.function.je-get-default-lines-title">
       je_get_default_lines()
      </title>
      <titleabbrev id="lsmb14.function.je-get-default-lines-titleabbrev">
       je_get_default_lines()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>character varying</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT value FROM menu_attribute where node_id = 74 and attribute = &#39;rowcount&#39;;
</programlisting>
      </para>
    </section>

<!-- Function je_set_default_lines(in_rowcount integer) -->
    <section id="lsmb14.function.je-set-default-lines-in-rowcount-integer"
             xreflabel="lsmb14je_set_default_lines(in_rowcount integer)">
      <title id="lsmb14.function.je-set-default-lines-in-rowcount-integer-title">
       je_set_default_lines(in_rowcount integer)
      </title>
      <titleabbrev id="lsmb14.function.je-set-default-lines-in-rowcount-integer-titleabbrev">
       je_set_default_lines(in_rowcount integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
    UPDATE menu_attribute set value = $1 
     where node_id = 74 and attribute=&#39;rowcount&#39;;

    IF NOT FOUND THEN
         INSERT INTO menu_attribute (node_id, attribute, value)
              values (74, &#39;rowcount&#39;, $1);
    END IF;
    RETURN $1; 
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean) -->
    <section id="lsmb14.function.journal-add-in-is-template-text-in-approved-text-in-transaction-date-integer-in-entry-type-date-in-description-boolean-in-source-boolean"
             xreflabel="lsmb14journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean)">
      <title id="lsmb14.function.journal-add-in-is-template-text-in-approved-text-in-transaction-date-integer-in-entry-type-date-in-description-boolean-in-source-boolean-title">
       journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean)
      </title>
      <titleabbrev id="lsmb14.function.journal-add-in-is-template-text-in-approved-text-in-transaction-date-integer-in-entry-type-date-in-description-boolean-in-source-boolean-titleabbrev">
       journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>journal_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval journal_entry;
BEGIN
	INSERT INTO journal_entry (source, description, entry_type, transaction_date,
			approved, is_template)
	VALUES (in_source, in_description, in_entry_type, in_transaction_date,
			coalesce(in_approved, false), 
			coalesce(in_is_template, false));

	SELECT * INTO retval FROM journal_entry WHERE id = currval(&#39;journal_id_seq&#39;);
	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[]) -->
    <section id="lsmb14.function.journal-add-line-in-business-units-integer-in-memo-integer-in-cleared-numeric-in-amount-boolean-in-journal-id-text-in-account-id-integerARRAY"
             xreflabel="lsmb14journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[])">
      <title id="lsmb14.function.journal-add-line-in-business-units-integer-in-memo-integer-in-cleared-numeric-in-amount-boolean-in-journal-id-text-in-account-id-integerARRAY-title">
       journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[])
      </title>
      <titleabbrev id="lsmb14.function.journal-add-line-in-business-units-integer-in-memo-integer-in-cleared-numeric-in-amount-boolean-in-journal-id-text-in-account-id-integerARRAY-titleabbrev">
       journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>journal_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval journal_line;
BEGIN
	INSERT INTO journal_line(account_id, journal_id, amount, cleared, memo)
	VALUES (in_account_id, in_journal_id, in_amount, 
		coalesce(in_cleared, false), in_memo);

        INSERT INTO business_unit_jl(entry_id, bu_class, bu_id)
        SELECT currval(&#39;journal_line_line_id_seq&#39;), business_unit_class, bu
          FROM business_unit
         WHERE id = any(in_business_units);

	SELECT * INTO retval FROM journal_line where line_id = currval(&#39;journal_line_line_id_seq&#39;);
	return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__get_entry(in_id integer) -->
    <section id="lsmb14.function.journal-get-entry-in-id-integer"
             xreflabel="lsmb14journal__get_entry(in_id integer)">
      <title id="lsmb14.function.journal-get-entry-in-id-integer-title">
       journal__get_entry(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.journal-get-entry-in-id-integer-titleabbrev">
       journal__get_entry(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>journal_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM journal_entry where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function journal__get_invoice(in_id integer) -->
    <section id="lsmb14.function.journal-get-invoice-in-id-integer"
             xreflabel="lsmb14journal__get_invoice(in_id integer)">
      <title id="lsmb14.function.journal-get-invoice-in-id-integer-title">
       journal__get_invoice(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.journal-get-invoice-in-id-integer-titleabbrev">
       journal__get_invoice(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>eca_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM eca_invoice where journal_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function journal__lines(in_id integer) -->
    <section id="lsmb14.function.journal-lines-in-id-integer"
             xreflabel="lsmb14journal__lines(in_id integer)">
      <title id="lsmb14.function.journal-lines-in-id-integer-title">
       journal__lines(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.journal-lines-in-id-integer-titleabbrev">
       journal__lines(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF journal_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
select * from journal_line where journal_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying) -->
    <section id="lsmb14.function.journal-make-invoice-in-language-code-integer-in-credit-id-integer-in-reverse-boolean-in-on-hold-boolean-in-journal-id-integer-in-order-id-character-varying"
             xreflabel="lsmb14journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying)">
      <title id="lsmb14.function.journal-make-invoice-in-language-code-integer-in-credit-id-integer-in-reverse-boolean-in-on-hold-boolean-in-journal-id-integer-in-order-id-character-varying-title">
       journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying)
      </title>
      <titleabbrev id="lsmb14.function.journal-make-invoice-in-language-code-integer-in-credit-id-integer-in-reverse-boolean-in-on-hold-boolean-in-journal-id-integer-in-order-id-character-varying-titleabbrev">
       journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval eca_invoice;
BEGIN	
	INSERT INTO eca_invoice (order_id, journal_id, on_hold, reverse,
		credit_id, language_code)
	VALUES (in_order_id, in_journal_id, coalesce(in_on_hold, false), 
		in_reverse, in_credit_id, in_language_code);

	SELECT * INTO retval FROM eca_invoice WHERE journal_id = in_journal_id;

	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer) -->
    <section id="lsmb14.function.journal-search-in-entity-class-text-in-meta-number-text-in-is-template-integer-in-department-id-date-in-approved-boolean-in-transaction-date-integer-in-entry-type-boolean-in-description-text-in-source-integer"
             xreflabel="lsmb14journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer)">
      <title id="lsmb14.function.journal-search-in-entity-class-text-in-meta-number-text-in-is-template-integer-in-department-id-date-in-approved-boolean-in-transaction-date-integer-in-entry-type-boolean-in-description-text-in-source-integer-title">
       journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer)
      </title>
      <titleabbrev id="lsmb14.function.journal-search-in-entity-class-text-in-meta-number-text-in-is-template-integer-in-department-id-date-in-approved-boolean-in-transaction-date-integer-in-entry-type-boolean-in-description-text-in-source-integer-titleabbrev">
       journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF journal_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval journal_search_result;
BEGIN
	FOR retval IN 
		SELECT j.id, j.source, j.description, j.entry_type, 
			j.transaction_date, j.approved, 
			j.is_template, eca.meta_number, 
			e.name, ec.class
		FROM journal_entry j
		LEFT JOIN eca_invoice i ON (i.journal_id = j.id)
		LEFT JOIN entity_credit_account eca ON (eca.id = credit_id)
		LEFT JOIN entity e ON (eca.entity_id = e.id)
		LEFT JOIN entity_class ec ON (eca.entity_class = ec.id)
		WHERE (in_source IS NULL OR in_source = j.source) AND
			(in_description IS NULL 
				or in_description = j.description) AND
			(in_entry_type is null or in_entry_type = j.entry_type)
			and (in_transaction_date is null 
				or in_transaction_date = j.transaction_date) and
			j.approved = coalesce(in_approved, true) and
			j.is_template = coalesce(in_is_template, false) and
			(in_department_id is null 
				or j.department_id = in_department_id) and
			(in_meta_number is null 
				or eca.meta_number = in_meta_number) and
			(in_entity_class is null
				or eca.entity_class = in_entity_class)
	LOOP
		RETURN NEXT retval;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__validate_entry(in_id integer) -->
    <section id="lsmb14.function.journal-validate-entry-in-id-integer"
             xreflabel="lsmb14journal__validate_entry(in_id integer)">
      <title id="lsmb14.function.journal-validate-entry-in-id-integer-title">
       journal__validate_entry(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.journal-validate-entry-in-id-integer-titleabbrev">
       journal__validate_entry(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
	SELECT sum(amount) = 0 FROM journal_line WHERE journal_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function lastcost(integer) -->
    <section id="lsmb14.function.lastcost-integer"
             xreflabel="lsmb14lastcost(integer)">
      <title id="lsmb14.function.lastcost-integer-title">
       lastcost(integer)
      </title>
      <titleabbrev id="lsmb14.function.lastcost-integer-titleabbrev">
       lastcost(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE

v_cost float;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost sellprice FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id
  ORDER BY a.transdate desc, a.id desc
  LIMIT 1;

  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

RETURN v_cost;
END;
</programlisting>
      </para>
    </section>

<!-- Function leap_days(in_year_to integer, in_year_from integer) -->
    <section id="lsmb14.function.leap-days-in-year-to-integer-in-year-from-integer"
             xreflabel="lsmb14leap_days(in_year_to integer, in_year_from integer)">
      <title id="lsmb14.function.leap-days-in-year-to-integer-in-year-from-integer-title">
       leap_days(in_year_to integer, in_year_from integer)
      </title>
      <titleabbrev id="lsmb14.function.leap-days-in-year-to-integer-in-year-from-integer-titleabbrev">
       leap_days(in_year_to integer, in_year_from integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the number of leap years between the two year inputs, inclusive.
        <programlisting>
   SELECT count(*)::int
   FROM generate_series($1, $2)
   WHERE is_leapyear((generate_series::text || &#39;-01-01&#39;)::date);
</programlisting>
      </para>
    </section>

<!-- Function list_taxforms(in_entity_id integer) -->
    <section id="lsmb14.function.list-taxforms-in-entity-id-integer"
             xreflabel="lsmb14list_taxforms(in_entity_id integer)">
      <title id="lsmb14.function.list-taxforms-in-entity-id-integer-title">
       list_taxforms(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.list-taxforms-in-entity-id-integer-titleabbrev">
       list_taxforms(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of tax forms for the entity&apos;s country.
        <programlisting>
DECLARE t_country_tax_form country_tax_form;
BEGIN

	FOR t_country_tax_form IN 

		      SELECT * 
		            FROM country_tax_form where country_id in(SELECT country_id from entity where id=in_entity_id)
        LOOP

	RETURN NEXT t_country_tax_form;
	
	END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function location__deactivate(in_id integer) -->
    <section id="lsmb14.function.location-deactivate-in-id-integer"
             xreflabel="lsmb14location__deactivate(in_id integer)">
      <title id="lsmb14.function.location-deactivate-in-id-integer-title">
       location__deactivate(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.location-deactivate-in-id-integer-titleabbrev">
       location__deactivate(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>location</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

UPDATE location set active = false, inactive_date = now()
 WHERE id = $1;

SELECT * FROM location WHERE id = 1;

</programlisting>
      </para>
    </section>

<!-- Function location__get(in_id integer) -->
    <section id="lsmb14.function.location-get-in-id-integer"
             xreflabel="lsmb14location__get(in_id integer)">
      <title id="lsmb14.function.location-get-in-id-integer-title">
       location__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.location-get-in-id-integer-titleabbrev">
       location__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the location specified by in_id.
        <programlisting>
DECLARE
	out_location location%ROWTYPE;
BEGIN
	SELECT * INTO out_location FROM location WHERE id = in_id;
	RETURN out_location;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_delete(in_id integer) -->
    <section id="lsmb14.function.location-delete-in-id-integer"
             xreflabel="lsmb14location_delete(in_id integer)">
      <title id="lsmb14.function.location-delete-in-id-integer-title">
       location_delete(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.location-delete-in-id-integer-titleabbrev">
       location_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
        DELETES the location specified by in_id.  Does not return a value.
        <programlisting>
BEGIN
	DELETE FROM location WHERE id = in_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_all() -->
    <section id="lsmb14.function.location-list-all"
             xreflabel="lsmb14location_list_all()">
      <title id="lsmb14.function.location-list-all-title">
       location_list_all()
      </title>
      <titleabbrev id="lsmb14.function.location-list-all-titleabbrev">
       location_list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all locations, ordered by country, state, and city. 
        <programlisting>
DECLARE 
	out_location location%ROWTYPE;
BEGIN
	FOR out_location IN
		SELECT * FROM location 
		ORDER BY country, state, city
	LOOP
		RETURN NEXT out_location;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_class() -->
    <section id="lsmb14.function.location-list-class"
             xreflabel="lsmb14location_list_class()">
      <title id="lsmb14.function.location-list-class-title">
       location_list_class()
      </title>
      <titleabbrev id="lsmb14.function.location-list-class-titleabbrev">
       location_list_class()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists location classes, by default in order entered.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM location_class ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_country() -->
    <section id="lsmb14.function.location-list-country"
             xreflabel="lsmb14location_list_country()">
      <title id="lsmb14.function.location-list-country-title">
       location_list_country()
      </title>
      <titleabbrev id="lsmb14.function.location-list-country-titleabbrev">
       location_list_country()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF country</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists countries, by default in alphabetical order.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM country ORDER BY name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer) -->
    <section id="lsmb14.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer"
             xreflabel="lsmb14location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)">
      <title id="lsmb14.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer-title">
       location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)
      </title>
      <titleabbrev id="lsmb14.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer-titleabbrev">
       location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Note that this does NOT override the data in the database unless in_location_id is specified.
Instead we search for locations matching the desired specifications and if none 
are found, we insert one.  Either way, the return value of the location can be
used for mapping to other things.  This is necessary because locations are 
only loosly coupled with entities, etc.
        <programlisting>
DECLARE
	location_id integer;
	location_row RECORD;
BEGIN
	
	IF in_location_id IS NULL THEN
	    SELECT id INTO location_id FROM location
	    WHERE line_one = in_address1 AND line_two = in_address2
	          AND line_three = in_address3 AND in_city = city 
	          AND in_state = state AND in_zipcode = mail_code
	          AND in_country = country_id 
	    LIMIT 1;

	    IF NOT FOUND THEN
	    -- Straight insert.
	    location_id = nextval(&#39;location_id_seq&#39;);
	    INSERT INTO location (
	        id, 
	        line_one, 
	        line_two,
	        line_three,
	        city,
	        state,
	        mail_code,
	        country_id)
	    VALUES (
	        location_id,
	        in_address1,
	        in_address2,
	        in_address3,
	        in_city,
	        in_state,
	        in_zipcode,
	        in_country
	        );
	    END IF;
	    return location_id;
	ELSE
	    RAISE NOTICE &#39;Overwriting location id %&#39;, in_location_id;
	    -- Test it.
	    SELECT * INTO location_row FROM location WHERE id = in_location_id;
	    IF NOT FOUND THEN
	        -- Tricky users are lying to us.
	        RAISE EXCEPTION &#39;location_save called with nonexistant location ID %&#39;, in_location_id;
	    ELSE
	        -- Okay, we&#39;re good.
	        
	        UPDATE location SET
	            line_one = in_address1,
	            line_two = in_address2,
	            line_three = in_address3,
	            city = in_city, 
	            state = in_state,
	            mail_code = in_zipcode,
	            country_id = in_country
	        WHERE id = in_location_id;
	        return in_location_id;
	    END IF;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying) -->
    <section id="lsmb14.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying"
             xreflabel="lsmb14location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)">
      <title id="lsmb14.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying-title">
       location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)
      </title>
      <titleabbrev id="lsmb14.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying-titleabbrev">
       location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns matching locations.  All matches may be partial.
        <programlisting>
DECLARE
	out_location location%ROWTYPE;
BEGIN
	FOR out_location IN
		SELECT * FROM location 
		WHERE address1 ilike &#39;%&#39; || in_address1 || &#39;%&#39;
			AND address2 ilike &#39;%&#39; || in_address2 || &#39;%&#39;
			AND in_city ilike &#39;%&#39; || in_city || &#39;%&#39;
			AND in_state ilike &#39;%&#39; || in_state || &#39;%&#39;
			AND in_zipcode ilike &#39;%&#39; || in_zipcode || &#39;%&#39;
			AND in_country ilike &#39;%&#39; || in_country || &#39;%&#39;
	LOOP
		RETURN NEXT out_location;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function lock_record(in_session_id integer, in_id integer) -->
    <section id="lsmb14.function.lock-record-in-session-id-integer-in-id-integer"
             xreflabel="lsmb14lock_record(in_session_id integer, in_id integer)">
      <title id="lsmb14.function.lock-record-in-session-id-integer-in-id-integer-title">
       lock_record(in_session_id integer, in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.lock-record-in-session-id-integer-in-id-integer-titleabbrev">
       lock_record(in_session_id integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function seeks to lock a record with an id of in_id to a session with an
id of in_session_id.  If possible, it returns true.  If it is already locked,
false.  These are not hard locks and the application is free to disregard or 
not even ask.  They time out when the session is destroyed.

        <programlisting>
declare
   locked int;
begin
   SELECT locked_by into locked from transactions where id = $1;
   IF NOT FOUND THEN
	RETURN FALSE;
   ELSEIF locked is not null AND locked &lt;&gt; $2 THEN
        RETURN FALSE;
   END IF;
   UPDATE transactions set locked_by = $2 where id = $1;
   RETURN TRUE;
end;
</programlisting>
      </para>
    </section>

<!-- Function lsmb_module__get(in_id integer) -->
    <section id="lsmb14.function.lsmb-module-get-in-id-integer"
             xreflabel="lsmb14lsmb_module__get(in_id integer)">
      <title id="lsmb14.function.lsmb-module-get-in-id-integer-title">
       lsmb_module__get(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.lsmb-module-get-in-id-integer-titleabbrev">
       lsmb_module__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>lsmb_module</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a single module&apos;s info by id. 
        <programlisting> SELECT * FROM lsmb_module where id = $1; </programlisting>
      </para>
    </section>

<!-- Function lsmb_module__list() -->
    <section id="lsmb14.function.lsmb-module-list"
             xreflabel="lsmb14lsmb_module__list()">
      <title id="lsmb14.function.lsmb-module-list-title">
       lsmb_module__list()
      </title>
      <titleabbrev id="lsmb14.function.lsmb-module-list-titleabbrev">
       lsmb_module__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF lsmb_module</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all defined modules, ordered by id. 
        <programlisting> SELECT * FROM lsmb_module ORDER BY id </programlisting>
      </para>
    </section>

<!-- Function menu_children(in_parent_id integer) -->
    <section id="lsmb14.function.menu-children-in-parent-id-integer"
             xreflabel="lsmb14menu_children(in_parent_id integer)">
      <title id="lsmb14.function.menu-children-in-parent-id-integer-title">
       menu_children(in_parent_id integer)
      </title>
      <titleabbrev id="lsmb14.function.menu-children-in-parent-id-integer-titleabbrev">
       menu_children(in_parent_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF menu_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns all menu  items which are children of in_parent_id 
(the only input parameter). 

It is thus similar to menu_generate() but it only returns the menu items 
associated with nodes directly descendant from the parent.  It is used for
menues for frameless browsers.
        <programlisting>
SELECT * FROM menu_generate() where parent = $1;
</programlisting>
      </para>
    </section>

<!-- Function menu_generate() -->
    <section id="lsmb14.function.menu-generate"
             xreflabel="lsmb14menu_generate()">
      <title id="lsmb14.function.menu-generate-title">
       menu_generate()
      </title>
      <titleabbrev id="lsmb14.function.menu-generate-titleabbrev">
       menu_generate()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF menu_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function returns the complete menu tree.  It is used to generate nested
menus for the web interface.

        <programlisting>
DECLARE 
	item menu_item;
	arg menu_attribute%ROWTYPE;
BEGIN
	FOR item IN 
               WITH RECURSIVE tree (path, id, parent, level, positions)
                               AS (select id::text as path, id, parent, 
                                           0 as level, position::text
                                      FROM menu_node where parent is null
                                     UNION 
                                    select path || &#39;,&#39; || n.id::text, n.id, 
                                           n.parent,
                                           t.level + 1, 
                                           t.positions || &#39;,&#39; || n.position
                                      FROM menu_node n
                                      JOIN tree t ON t.id = n.parent) 
		SELECT n.position, n.id, c.level, n.label, c.path, n.parent,
                       to_args(array[ma.attribute, ma.value])
		FROM tree c
		JOIN menu_node n USING(id)
                JOIN menu_attribute ma ON (n.id = ma.node_id)
               WHERE n.id IN (select node_id 
                                FROM menu_acl acl
                          LEFT JOIN pg_roles pr on pr.rolname = acl.role_name
                               WHERE CASE WHEN role_name 
                                                           ilike &#39;public&#39;
                                                      THEN true
                                                      WHEN rolname IS NULL
                                                      THEN FALSE
                                                      ELSE pg_has_role(rolname,
                                                                       &#39;USAGE&#39;)
                                      END
                            GROUP BY node_id
                              HAVING bool_and(CASE WHEN acl_type ilike &#39;DENY&#39;
                                                   THEN FALSE
                                                   WHEN acl_type ilike &#39;ALLOW&#39;
                                                   THEN TRUE
                                                END))
                    or exists (select cn.id, cc.path
                                 FROM tree cc
                                 JOIN menu_node cn USING(id)
                                WHERE cn.id IN 
                                      (select node_id 
                                         FROM menu_acl acl
                                    LEFT JOIN pg_roles pr 
                                              on pr.rolname = acl.role_name
                                        WHERE CASE WHEN rolname 
                                                           ilike &#39;public&#39;
                                                      THEN true
                                                      WHEN rolname IS NULL
                                                      THEN FALSE
                                                      ELSE pg_has_role(rolname,
                                                                       &#39;USAGE&#39;)
                                                END
                                     GROUP BY node_id
                                       HAVING bool_and(CASE WHEN acl_type 
                                                                 ilike &#39;DENY&#39;
                                                            THEN false
                                                            WHEN acl_type 
                                                                 ilike &#39;ALLOW&#39;
                                                            THEN TRUE
                                                         END))
                                       and cc.path::text 
                                           like c.path::text || &#39;,%&#39;)
            GROUP BY n.position, n.id, c.level, n.label, c.path, c.positions,
                     n.parent
            ORDER BY string_to_array(c.positions, &#39;,&#39;)::int[]
	LOOP
		RETURN NEXT item;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function menu_insert(in_label integer, in_position integer, in_parent_id text) -->
    <section id="lsmb14.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text"
             xreflabel="lsmb14menu_insert(in_label integer, in_position integer, in_parent_id text)">
      <title id="lsmb14.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text-title">
       menu_insert(in_label integer, in_position integer, in_parent_id text)
      </title>
      <titleabbrev id="lsmb14.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text-titleabbrev">
       menu_insert(in_label integer, in_position integer, in_parent_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function inserts menu items at arbitrary positions.  The arguments are, in
order:  parent, position, label.  The return value is the id number of the menu
item created. 
        <programlisting>
DECLARE
	new_id int;
BEGIN
	UPDATE menu_node 
	SET position = position * -1
	WHERE parent = in_parent_id
		AND position &gt;= in_position;

	INSERT INTO menu_node (parent, position, label)
	VALUES (in_parent_id, in_position, in_label);

	SELECT INTO new_id currval(&#39;menu_node_id_seq&#39;);

	UPDATE menu_node 
	SET position = (position * -1) + 1
	WHERE parent = in_parent_id
		AND position &lt; 0;

	RETURN new_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function months_passed(in_end timestamp without time zone, in_start timestamp without time zone) -->
    <section id="lsmb14.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone"
             xreflabel="lsmb14months_passed(in_end timestamp without time zone, in_start timestamp without time zone)">
      <title id="lsmb14.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone-title">
       months_passed(in_end timestamp without time zone, in_start timestamp without time zone)
      </title>
      <titleabbrev id="lsmb14.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone-titleabbrev">
       months_passed(in_end timestamp without time zone, in_start timestamp without time zone)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of months between in_start and in_end.
        <programlisting>

-- The addition of one day is so that it will return &#39;1&#39; when run on the end
-- day of consecutive months.

select (extract (months from age($2 + &#39;1 day&#39;, $1 + &#39;1 day&#39;))
       + extract (years from age($2, $1)) * 12)::int;
</programlisting>
      </para>
    </section>

<!-- Function next_leap_year_calc(is_end date, in_date boolean) -->
    <section id="lsmb14.function.next-leap-year-calc-is-end-date-in-date-boolean"
             xreflabel="lsmb14next_leap_year_calc(is_end date, in_date boolean)">
      <title id="lsmb14.function.next-leap-year-calc-is-end-date-in-date-boolean-title">
       next_leap_year_calc(is_end date, in_date boolean)
      </title>
      <titleabbrev id="lsmb14.function.next-leap-year-calc-is-end-date-in-date-boolean-titleabbrev">
       next_leap_year_calc(is_end date, in_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Next relevant leap year calculation for a daily depreciation calculation
        <programlisting>
SELECT 
          (CASE WHEN extract(&#39;doy&#39; FROM $1) &lt; 59
          THEN extract(&#39;year&#39; FROM $1)
          ELSE extract(&#39;year&#39; FROM $1) + 1
          END)::int
          -
          CASE WHEN $2 THEN 1 ELSE 0 END;
</programlisting>
      </para>
    </section>

<!-- Function parse_date(in_date date) -->
    <section id="lsmb14.function.parse-date-in-date-date"
             xreflabel="lsmb14parse_date(in_date date)">
      <title id="lsmb14.function.parse-date-in-date-date-title">
       parse_date(in_date date)
      </title>
      <titleabbrev id="lsmb14.function.parse-date-in-date-date-titleabbrev">
       parse_date(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
        Simple way to cast a Perl string to a
date format of known type. 
        <programlisting> select $1; </programlisting>
      </para>
    </section>

<!-- Function parts__get_by_id(in_id integer) -->
    <section id="lsmb14.function.parts-get-by-id-in-id-integer"
             xreflabel="lsmb14parts__get_by_id(in_id integer)">
      <title id="lsmb14.function.parts-get-by-id-in-id-integer-title">
       parts__get_by_id(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.parts-get-by-id-in-id-integer-titleabbrev">
       parts__get_by_id(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM parts WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function parts__get_by_partnumber(in_partnumber text) -->
    <section id="lsmb14.function.parts-get-by-partnumber-in-partnumber-text"
             xreflabel="lsmb14parts__get_by_partnumber(in_partnumber text)">
      <title id="lsmb14.function.parts-get-by-partnumber-in-partnumber-text-title">
       parts__get_by_partnumber(in_partnumber text)
      </title>
      <titleabbrev id="lsmb14.function.parts-get-by-partnumber-in-partnumber-text-titleabbrev">
       parts__get_by_partnumber(in_partnumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM PARTS WHERE partnumber = $1 and obsolete is not true; 
</programlisting>
      </para>
    </section>

<!-- Function parts__search_lite(in_description text, in_partnumber text) -->
    <section id="lsmb14.function.parts-search-lite-in-description-text-in-partnumber-text"
             xreflabel="lsmb14parts__search_lite(in_description text, in_partnumber text)">
      <title id="lsmb14.function.parts-search-lite-in-description-text-in-partnumber-text-title">
       parts__search_lite(in_description text, in_partnumber text)
      </title>
      <titleabbrev id="lsmb14.function.parts-search-lite-in-description-text-in-partnumber-text-titleabbrev">
       parts__search_lite(in_description text, in_partnumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * 
  FROM parts 
 WHERE ($1 IS NULL OR (partnumber like $1 || &#39;%&#39;))
       AND ($2 IS NULL 
            OR (description
                @@
                plainto_tsquery(get_default_lang()::regconfig, $2)))
       AND not obsolete
ORDER BY partnumber;
</programlisting>
      </para>
    </section>

<!-- Function payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar) -->
    <section id="lsmb14.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar"
             xreflabel="lsmb14payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)">
      <title id="lsmb14.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar-title">
       payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)
      </title>
      <titleabbrev id="lsmb14.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar-titleabbrev">
       payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
Reverses a payment.  All fields are mandatory except batch_id and voucher_id
because they determine the identity of the payment to be reversed.

        <programlisting>
DECLARE
	pay_row record;
        t_voucher_id int;
        t_voucher_inserted bool;
        t_currs text[];
        t_rev_fx numeric;
        t_fxgain_id int;
        t_fxloss_id int;
        t_paid_fx numeric;
BEGIN
        SELECT * INTO t_rev_fx FROM currency_get_exchangerate(
              in_currency, in_date_reversed, in_account_class);

        SELECT * INTO t_paid_fx FROM currency_get_exchangerate(
              in_currency, in_date_paid, in_account_class);

       select value::int INTO t_fxgain_id FROM setting_get(&#39;fxgain_accno_id&#39;);
       select value::int INTO t_fxloss_id FROM setting_get(&#39;fxloss_accno_id&#39;);

       SELECT string_to_array(value, &#39;:&#39;) into t_currs
          from defaults
         where setting_key = &#39;curr&#39;;

        IF in_currency IS NULL OR in_currency = t_currs[1] THEN
                t_rev_fx := 1;
                t_paid_fx := 1;
        ELSIF t_rev_fx IS NULL THEN
                t_rev_fx := in_exchangerate;
                PERFORM payments_set_exchangerate(in_account_class,
                                                  in_exchangerate,
                                                  in_currency,
                                                  in_date_reversed);
        ELSIF t_rev_fx &lt;&gt; in_exchangerate THEN
                RAISE EXCEPTION &#39;Exchange rate different than on file&#39;;
        END IF;
        IF t_rev_fx IS NULL THEN
            RAISE EXCEPTION &#39;No exchangerate provided and not default currency&#39;;
        END IF;


        IF in_batch_id IS NOT NULL THEN
		t_voucher_id := nextval(&#39;voucher_id_seq&#39;);
		t_voucher_inserted := FALSE;
	END IF;
	FOR pay_row IN 
		SELECT a.*, c.ar_ap_account_id, arap.curr, arap.fxrate
		FROM acc_trans a
		JOIN (select id, curr, entity_credit_account, 
                             CASE WHEN curr = t_currs[1] THEN 1
                                   ELSE buy END as fxrate
			FROM ar 
                   LEFT JOIN exchangerate USING (transdate, curr)
                       WHERE in_account_class = 2
			UNION
			SELECT id, curr, entity_credit_account, 
                               CASE WHEN curr = t_currs[1] THEN 1
                                    ELSE sell END as fxrate
			FROM ap
                   LEFT JOIN exchangerate USING (transdate, curr)
                       WHERE in_account_class = 1
		) arap ON (a.trans_id = arap.id)
		JOIN entity_credit_account c 
			ON (arap.entity_credit_account = c.id)
		JOIN account ch ON (a.chart_id = ch.id)
		WHERE a.source IS NOT DISTINCT FROM in_source
			AND a.transdate = in_date_paid
			AND in_credit_id = arap.entity_credit_account
			AND in_cash_accno = ch.accno
                        and in_voucher_id IS NOT DISTINCT FROM voucher_id
	LOOP
                IF pay_row.curr = t_currs[1] THEN
                   pay_row.fxrate = 1;
                END IF;

		IF in_batch_id IS NOT NULL 
			AND t_voucher_inserted IS NOT TRUE
		THEN
			INSERT INTO voucher 
			(id, trans_id, batch_id, batch_class)
			VALUES
			(t_voucher_id, pay_row.trans_id, in_batch_id,
				CASE WHEN in_account_class = 1 THEN 4
				     WHEN in_account_class = 2 THEN 7
				END);

			t_voucher_inserted := TRUE;
		END IF;

		INSERT INTO acc_trans
		(trans_id, chart_id, amount, transdate, source, memo, approved,
			voucher_id) 
		VALUES 
		(pay_row.trans_id, pay_row.chart_id, 
                        pay_row.amount / t_paid_fx * -1 * t_rev_fx, 
			in_date_reversed, in_source, &#39;Reversing &#39; || 
			COALESCE(in_source, &#39;&#39;), 
			case when in_batch_id is not null then false 
			else true end, t_voucher_id),
                 (pay_row.trans_id, pay_row.ar_ap_account_id, 
                        pay_row.amount / t_paid_fx * pay_row.fxrate,
			in_date_reversed, in_source, &#39;Reversing &#39; ||
			COALESCE(in_source, &#39;&#39;), 
			case when in_batch_id is not null then false 
			else true end, t_voucher_id),
                 (pay_row.trans_id, 
                  case when pay_row.fxrate &gt; t_rev_fx 
                       THEN t_fxloss_id ELSE t_fxgain_id END, 
                  pay_row.amount / t_paid_fx * (t_rev_fx - pay_row.fxrate),
                  in_date_reversed, in_source, &#39;Reversing &#39; ||  
                                                COALESCE(in_source, &#39;&#39;),
                   case when in_batch_id is not null then false
                        else true end, t_voucher_id);

                   
	END LOOP;
	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar) -->
    <section id="lsmb14.function.payment-search-in-currency-text-in-account-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar"
             xreflabel="lsmb14payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)">
      <title id="lsmb14.function.payment-search-in-currency-text-in-account-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar-title">
       payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)
      </title>
      <titleabbrev id="lsmb14.function.payment-search-in-currency-text-in-account-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar-titleabbrev">
       payment__search(in_currency text, in_account_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_record</seg>
        </seglistitem>
       </segmentedlist>
 
       This searches for payments.  in_date_to and _date_from specify the acceptable
date range.  All other matches are exact except that null matches all values.

Currently (and to support earlier data) we define a payment as a collection of
acc_trans records against the same credit account and cash account, on the same
day with the same source number, and optionally the same voucher id.
        <programlisting>
DECLARE 
	out_row payment_record;
BEGIN
	FOR out_row IN 
		select sum(CASE WHEN c.entity_class = 1 then a.amount
				ELSE a.amount * -1 END), c.meta_number, 
			c.id, co.legal_name,
			compound_array(ARRAY[ARRAY[ch.id::text, ch.accno, 
				ch.description]]), a.source, 
			b.control_code, b.description, a.voucher_id, a.transdate
		FROM entity_credit_account c
		JOIN ( select entity_credit_account, id, curr
			FROM ar WHERE in_account_class = 2
			UNION
			SELECT entity_credit_account, id, curr
			FROM ap WHERE in_account_class = 1
			) arap ON (arap.entity_credit_account = c.id)
		JOIN acc_trans a ON (arap.id = a.trans_id)
		JOIN chart ch ON (ch.id = a.chart_id)
		JOIN company co ON (c.entity_id = co.entity_id)
		LEFT JOIN voucher v ON (v.id = a.voucher_id)
		LEFT JOIN batch b ON (b.id = v.batch_id)
		WHERE (ch.accno = in_cash_accno)
                        AND (in_currency IS NULL OR in_currency = arap.curr)
			AND (c.id = in_credit_id OR in_credit_id IS NULL)
			AND (a.transdate &gt;= in_date_from 
				OR in_date_from IS NULL)
			AND (a.transdate &lt;= in_date_to OR in_date_to IS NULL)
			AND (source = in_source OR in_source IS NULL)
		GROUP BY c.meta_number, c.id, co.legal_name, a.transdate, 
			a.source, a.memo, b.id, b.control_code, b.description, 
                        voucher_id
		ORDER BY a.transdate, c.meta_number, a.source
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text) -->
    <section id="lsmb14.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text"
             xreflabel="lsmb14payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)">
      <title id="lsmb14.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text-title">
       payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)
      </title>
      <titleabbrev id="lsmb14.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text-titleabbrev">
       payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This posts the payments for large batch workflows.

Note that in_transactions is a two-dimensional numeric array.  Of each 
sub-array, the first element is the (integer) transaction id, and the second
is the amount for that transaction.  
        <programlisting>
DECLARE 
        out_count int;
        t_voucher_id int;
        t_trans_id int;
        t_amount numeric;
        t_ar_ap_id int;
        t_cash_id int;
        t_currs text[];
        t_exchangerate numeric;
        t_cash_sign int;
BEGIN

        SELECT * INTO t_exchangerate FROM currency_get_exchangerate(
              in_currency, in_payment_date, in_account_class);

        IF in_batch_id IS NULL THEN
                -- t_voucher_id := NULL;
                RAISE EXCEPTION &#39;Bulk Post Must be from Batch!&#39;;
        ELSE
                INSERT INTO voucher (batch_id, batch_class, trans_id)
                values (in_batch_id,
                (SELECT batch_class_id FROM batch WHERE id = in_batch_id),
                in_transactions[1][1]);

                t_voucher_id := currval(&#39;voucher_id_seq&#39;);
        END IF;

        SELECT string_to_array(value, &#39;:&#39;) into t_currs 
          from defaults 
         where setting_key = &#39;curr&#39;;

        IF (in_currency IS NULL OR in_currency = t_currs[1]) THEN
                t_exchangerate := 1;
        ELSIF t_exchangerate IS NULL THEN
                t_exchangerate := in_exchangerate;
                PERFORM payments_set_exchangerate(in_account_class,
                                                  in_exchangerate, 
                                                  in_currency,
                                                  in_payment_date);
        ELSIF t_exchangerate &lt;&gt; in_exchangerate THEN
                RAISE EXCEPTION &#39;Exchange rate different than on file&#39;;
        END IF;
        IF t_exchangerate IS NULL THEN
            RAISE EXCEPTION &#39;No exchangerate provided and not default currency&#39;;
        END IF;

        CREATE TEMPORARY TABLE bulk_payments_in
           (id int, amount numeric, fxrate numeric, gain_loss_accno int);

        select id into t_ar_ap_id from chart where accno = in_ar_ap_accno;
        select id into t_cash_id from chart where accno = in_cash_accno;

        FOR out_count IN 
                        array_lower(in_transactions, 1) ..
                        array_upper(in_transactions, 1)
        LOOP
            -- Fill the bulk payments table
            INSERT INTO bulk_payments_in(id, amount)
            VALUES (in_transactions[out_count][1],
                    in_transactions[out_count][2]);
        END LOOP;

        IF in_account_class = 1 THEN
            t_cash_sign := 1;
        ELSE
            t_cash_sign := -1;
        END IF;

        IF (in_currency IS NULL OR in_currency = t_currs[1]) THEN
            UPDATE bulk_payments_in
               SET fxrate = 1;
        ELSE
            UPDATE bulk_payments_in
               SET fxrate =
                (SELECT CASE WHEN in_account_class = 1 THEN sell
                             ELSE buy
                        END
                   FROM exchangerate e
                   JOIN (SELECT transdate, id, curr FROM ar
                         UNION
                         SELECT transdate, id, curr FROM ap) a
                     ON (e.transdate = a.transdate
                         AND e.curr = a.curr)
                   WHERE a.id = bulk_payments_in.id);
            UPDATE bulk_payments_in
               SET gain_loss_accno =
                (SELECT value::int FROM defaults
                  WHERE setting_key = &#39;fxgain_accno_id&#39;)
             WHERE ((t_exchangerate - bulk_payments_in.fxrate) * t_cash_sign) &lt; 0;
            UPDATE bulk_payments_in
               SET gain_loss_accno = (SELECT value::int FROM defaults
                  WHERE setting_key = &#39;fxloss_accno_id&#39;)
             WHERE ((t_exchangerate - bulk_payments_in.fxrate) * t_cash_sign) &gt; 0;
            -- explicitly leave zero gain/loss accno_id entries at NULL
            -- so we have an easy check for which 
        END IF;

        -- Insert cash side
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, t_cash_id, amount * t_cash_sign * t_exchangerate/fxrate,
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in  where amount &lt;&gt; 0;

        -- early payment discounts
        INSERT INTO acc_trans
               (trans_id, chart_id, amount, approved,
               voucher_id, transdate, source)
        SELECT bpi.id, eca.discount_account_id, 
               amount * t_cash_sign * t_exchangerate/fxrate 
               / (1 - discount::numeric/100) 
               * (discount::numeric/100),
               CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
               t_voucher_id, in_payment_date, in_source
          FROM bulk_payments_in bpi
          JOIN (select entity_credit_account, id, transdate FROM ar 
                 WHERE in_account_class = 2
                 UNION
                SELECT entity_credit_account, id, transdate FROM ap
                 WHERE in_account_class = 1) gl ON gl.id = bpi.id
          JOIN entity_credit_account eca ON gl.entity_credit_account = eca.id
         WHERE bpi.amount &lt;&gt; 0 
               AND extract(&#39;days&#39; from age(gl.transdate)) &lt; eca.discount_terms;

        INSERT INTO acc_trans
               (trans_id, chart_id, amount, approved,
               voucher_id, transdate, source)
        SELECT bpi.id, t_ar_ap_id, 
               amount * t_cash_sign * -1 * t_exchangerate/fxrate 
               / (1 - discount::numeric/100) 
               * (discount::numeric/100),
               CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
               t_voucher_id, in_payment_date, in_source
          FROM bulk_payments_in bpi
          JOIN (select entity_credit_account, id, transdate FROM ar 
                 WHERE in_account_class = 2
                 UNION
                SELECT entity_credit_account, id, transdate FROM ap
                 WHERE in_account_class = 1) gl ON gl.id = bpi.id
          JOIN entity_credit_account eca ON gl.entity_credit_account = eca.id
         WHERE bpi.amount &lt;&gt; 0 
               AND extract(&#39;days&#39; from age(gl.transdate)) &lt; eca.discount_terms;

        -- Insert ar/ap side
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, t_ar_ap_id,
                  amount * -1 * t_cash_sign,
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in where amount &lt;&gt; 0;

        -- Insert fx gain/loss effects, if applicable
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, gain_loss_accno,
                  amount * t_cash_sign * (1 - t_exchangerate/fxrate),
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in
            WHERE amount &lt;&gt; 0 AND gain_loss_accno IS NOT NULL;

        DROP TABLE bulk_payments_in;
        perform unlock_all();
        return out_count;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_gather_header_info(in_payment_id integer, in_account_class integer) -->
    <section id="lsmb14.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer"
             xreflabel="lsmb14payment_gather_header_info(in_payment_id integer, in_account_class integer)">
      <title id="lsmb14.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer-title">
       payment_gather_header_info(in_payment_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer-titleabbrev">
       payment_gather_header_info(in_payment_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_header_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function finds a payment based on the id and retrieves the record, 
it is usefull for printing payments :) 
        <programlisting>
 DECLARE out_payment payment_header_item;
 BEGIN
 FOR out_payment IN 
   SELECT p.id as payment_id, p.reference as payment_reference, p.payment_date,  
          c.legal_name as legal_name, am.amount as amount, em.first_name, em.last_name, p.currency, p.notes
   FROM payment p
   JOIN entity_employee ent_em ON (ent_em.entity_id = p.employee_id)
   JOIN person em ON (ent_em.entity_id = em.entity_id)
   JOIN entity_credit_account eca ON (eca.id = p.entity_credit_id)
   JOIN company c ON   (c.entity_id  = eca.entity_id)
   JOIN payment_links pl ON (p.id = pl.payment_id)
   LEFT JOIN (  SELECT sum(a.amount) as amount
 		FROM acc_trans a
 		JOIN account acc ON (a.chart_id = acc.id)
                JOIN account_link al ON (acc.id =al.account_id)
 		JOIN payment_links pl ON (pl.entry_id=a.entry_id)
 		WHERE al.description in  
                       (&#39;AP_paid&#39;, &#39;AP_discount&#39;, &#39;AR_paid&#39;, &#39;AR_discount&#39;) 
                       and ((in_account_class = 1 AND al.description like &#39;AP%&#39;)
                       or (in_account_class = 2 AND al.description like &#39;AR%&#39;))
             ) am ON (true)
   WHERE p.id = in_payment_id
 LOOP
     RETURN NEXT out_payment;
 END LOOP;

 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_gather_line_info(in_payment_id integer, in_account_class integer) -->
    <section id="lsmb14.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer"
             xreflabel="lsmb14payment_gather_line_info(in_payment_id integer, in_account_class integer)">
      <title id="lsmb14.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer-title">
       payment_gather_line_info(in_payment_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer-titleabbrev">
       payment_gather_line_info(in_payment_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_line_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function finds a payment based on the id and retrieves all the line records, 
it is usefull for printing payments and build reports :) 
        <programlisting>
 DECLARE out_payment_line payment_line_item;
 BEGIN
   FOR out_payment_line IN 
     SELECT pl.payment_id, ac.entry_id, pl.type as link_type, ac.trans_id, a.invnumber as invoice_number,
     ac.chart_id, ch.accno as chart_accno, ch.description as chart_description, ch.link as chart_link,
     ac.amount,  ac.transdate as trans_date, ac.source, ac.cleared_on, ac.fx_transaction, ac.project_id,
     ac.memo, ac.invoice_id, ac.approved, ac.cleared_on, ac.reconciled_on
     FROM acc_trans ac
     JOIN payment_links pl ON (pl.entry_id = ac.entry_id )
     JOIN chart         ch ON (ch.id = ac.chart_id)
     LEFT JOIN (SELECT id,invnumber
                 FROM ar WHERE in_account_class = 2
                 UNION
                 SELECT id,invnumber
                 FROM ap WHERE in_account_class = 1
                ) a ON (ac.trans_id = a.id)
     WHERE pl.payment_id = in_payment_id
   LOOP
      RETURN NEXT out_payment_line;
   END LOOP;  
 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_get_all_accounts(in_account_class integer) -->
    <section id="lsmb14.function.payment-get-all-accounts-in-account-class-integer"
             xreflabel="lsmb14payment_get_all_accounts(in_account_class integer)">
      <title id="lsmb14.function.payment-get-all-accounts-in-account-class-integer-title">
       payment_get_all_accounts(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-all-accounts-in-account-class-integer-titleabbrev">
       payment_get_all_accounts(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        This function takes a single argument (1 for vendor, 2 for customer as 
always) and returns all entities with accounts of the appropriate type. 
        <programlisting>
DECLARE out_entity entity%ROWTYPE;
BEGIN
	FOR out_entity IN
		SELECT  ec.id, 
			e.name, e.entity_class, e.created 
		FROM entity e
		JOIN entity_credit_account ec ON (ec.entity_id = e.id)
				WHERE e.entity_class = in_account_class
	LOOP
		RETURN NEXT out_entity;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text) -->
    <section id="lsmb14.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text"
             xreflabel="lsmb14payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)">
      <title id="lsmb14.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text-title">
       payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text-titleabbrev">
       payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_contact_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes the following arguments (all prefaced with in_ in the db):
account_class: 1 for vendor, 2 for customer
business_type: integer of business.id.
currency: char(3) of currency (for example &apos;USD&apos;)
date_from, date_to:  These dates are inclusive.
batch_id:  For payment batches, where fees are concerned.
ar_ap_accno:  The AR/AP account number.

This then returns a set of contact information with a 2 dimensional array 
cnsisting of outstanding invoices.

Note that the payment selection logic is that this returns all invoices which are
either approved or in the batch_id specified.  It also locks the invoices using 
the LedgerSMB discretionary locking framework, and if not possible, returns the 
username of the individual who has the lock.

        <programlisting>
DECLARE payment_item payment_contact_invoice;
BEGIN
        FOR payment_item IN
                  SELECT c.id AS contact_id, e.control_code as econtrol_code, 
                        c.description as eca_description, 
                        e.name AS contact_name,
                         c.meta_number AS account_number,
                         sum( case when u.username IS NULL or 
                                       u.username = SESSION_USER 
                             THEN 
                              coalesce(p.due::numeric, 0) -
                              CASE WHEN c.discount_terms 
                                        &gt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due::numeric, 0)) * 
                                        coalesce(c.discount::numeric, 0) / 100
                              END
                             ELSE 0::numeric
                             END) AS total_due,
                         compound_array(ARRAY[[
                              a.id::text, a.invnumber, a.transdate::text, 
                              a.amount::text, (a.amount - p.due)::text,
                              (CASE WHEN c.discount_terms 
                                        &lt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due, 0) * coalesce(c.discount, 0) / 100)
                              END)::text, 
                              (coalesce(p.due, 0) -
                              (CASE WHEN c.discount_terms 
                                        &lt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due, 0)) * coalesce(c.discount, 0) / 100
                              END))::text,
                                case when u.username IS NOT NULL 
                                          and u.username &lt;&gt; SESSION_USER 
                                     THEN 0::text
                                     ELSE 1::text
                                END,
                                COALESCE(u.username, 0::text)
                                ]]),
                              sum(case when a.batch_id = in_batch_id then 1
                                  else 0 END),
                              bool_and(lock_record(a.id, (select max(session_id)
                                FROM &quot;session&quot; where users_id = (
                                        select id from users WHERE username =
                                        SESSION_USER))))
                           
                    FROM entity e
                    JOIN entity_credit_account c ON (e.id = c.entity_id)
                    JOIN (SELECT ap.id, invnumber, transdate, amount, entity_id, 
                                 curr, 1 as invoice_class,
                                 entity_credit_account, on_hold, v.batch_id,
                                 approved, paid
                            FROM ap
                       LEFT JOIN (select * from voucher where batch_class = 1) v 
                                 ON (ap.id = v.trans_id)
                           WHERE in_account_class = 1
                                 AND (v.batch_class = 1 or v.batch_id IS NULL)
                           UNION
                          SELECT ar.id, invnumber, transdate, amount, entity_id,
                                 curr, 2 as invoice_class,
                                 entity_credit_account, on_hold, v.batch_id,
                                 approved, paid
                            FROM ar
                       LEFT JOIN (select * from voucher where batch_class = 2) v 
                                 ON (ar.id = v.trans_id)
                           WHERE in_account_class = 2
                                 AND (v.batch_class = 2 or v.batch_id IS NULL)
                        ORDER BY transdate
                         ) a ON (a.entity_credit_account = c.id)
                    JOIN transactions t ON (a.id = t.id)
                    JOIN (SELECT acc_trans.trans_id, 
                                 sum(CASE WHEN in_account_class = 1 THEN amount
                                          WHEN in_account_class = 2 
                                          THEN amount * -1
                                     END) AS due 
                            FROM acc_trans 
                            JOIN account coa ON (coa.id = acc_trans.chart_id)
                            JOIN account_link al ON (al.account_id = coa.id)
                       LEFT JOIN voucher v ON (acc_trans.voucher_id = v.id)
                           WHERE ((al.description = &#39;AP&#39; AND in_account_class = 1)
                                 OR (al.description = &#39;AR&#39; AND in_account_class = 2))
                           AND (approved IS TRUE or v.batch_class IN (3, 6))
                        GROUP BY acc_trans.trans_id) p ON (a.id = p.trans_id)
                LEFT JOIN &quot;session&quot; s ON (s.&quot;session_id&quot; = t.locked_by)
                LEFT JOIN users u ON (u.id = s.users_id)
                   WHERE (a.batch_id = in_batch_id
                          OR (a.invoice_class = in_account_class
                             AND a.approved
                         AND due &lt;&gt; 0
                         AND NOT a.on_hold
                         AND a.curr = in_currency
                         AND EXISTS (select trans_id FROM acc_trans
                                      WHERE trans_id = a.id AND
                                            chart_id = (SELECT id from account
                                                         WHERE accno
                                                               = in_ar_ap_accno)
                                    )))
                         AND (in_meta_number IS NULL OR 
                             in_meta_number = c.meta_number)
                GROUP BY c.id, e.name, c.meta_number, c.threshold, 
                        e.control_code, c.description
                  HAVING  (sum(p.due) &gt;= c.threshold
                        OR sum(case when a.batch_id = in_batch_id then 1
                                  else 0 END) &gt; 0)
        ORDER BY c.meta_number ASC
        LOOP
                RETURN NEXT payment_item;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer) -->
    <section id="lsmb14.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer"
             xreflabel="lsmb14payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)">
      <title id="lsmb14.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer-title">
       payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer-titleabbrev">
       payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_overpayments_available_amount</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_overpayment payment_overpayments_available_amount;
BEGIN
      FOR out_overpayment IN
              SELECT chart_id, accno,   chart_description, abs(sum(available))
              FROM overpayments
              WHERE payment_class  = in_account_class 
              AND entity_credit_id = in_entity_credit_id 
              AND available &lt;&gt; 0
              GROUP BY chart_id, accno, chart_description
      LOOP
           RETURN NEXT out_overpayment;
      END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_entity_account_payment_info(in_entity_credit_id integer) -->
    <section id="lsmb14.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer"
             xreflabel="lsmb14payment_get_entity_account_payment_info(in_entity_credit_id integer)">
      <title id="lsmb14.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer-title">
       payment_get_entity_account_payment_info(in_entity_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer-titleabbrev">
       payment_get_entity_account_payment_info(in_entity_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns payment information on the entity credit account as
  required to for discount calculations and payment processing. 
        <programlisting>
 SELECT ec.id, cp.legal_name ||
        coalesce(&#39;:&#39; || ec.description,&#39;&#39;) as name,
        e.entity_class, ec.discount_account_id, ec.meta_number
 FROM entity_credit_account ec
 JOIN entity e ON (ec.entity_id = e.id)
 JOIN company cp ON (cp.entity_id = e.id)
 WHERE ec.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text) -->
    <section id="lsmb14.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text"
             xreflabel="lsmb14payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)">
      <title id="lsmb14.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text-title">
       payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text-titleabbrev">
       payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a minimal set of information about customer or vendor accounts
as needed for discount calculations and the like.
        <programlisting>
 DECLARE out_entity payment_vc_info;
 

 BEGIN
 	FOR out_entity IN
              SELECT ec.id, cp.legal_name || 
                     coalesce(&#39;:&#39; || ec.description,&#39;&#39;) as name, 
                     e.entity_class, ec.discount_account_id, ec.meta_number
 		FROM entity_credit_account ec
 		JOIN entity e ON (ec.entity_id = e.id)
 		JOIN company cp ON (cp.entity_id = e.id)
		WHERE ec.entity_class = in_account_class
		AND (cp.legal_name ilike coalesce(&#39;%&#39;||in_vc_name||&#39;%&#39;,&#39;%%&#39;) OR cp.tax_id = in_vc_idn)
	LOOP
		RETURN NEXT out_entity;
	END LOOP;
 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_get_open_accounts(in_account_class integer) -->
    <section id="lsmb14.function.payment-get-open-accounts-in-account-class-integer"
             xreflabel="lsmb14payment_get_open_accounts(in_account_class integer)">
      <title id="lsmb14.function.payment-get-open-accounts-in-account-class-integer-title">
       payment_get_open_accounts(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-open-accounts-in-account-class-integer-titleabbrev">
       payment_get_open_accounts(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        This function takes a single argument (1 for vendor, 2 for customer as 
always) and returns all entities with open accounts of the appropriate type. 
        <programlisting>
DECLARE out_entity entity%ROWTYPE;
BEGIN
        FOR out_entity IN
                SELECT ec.id, cp.legal_name as name, e.entity_class, e.created
                FROM entity e
                JOIN entity_credit_account ec ON (ec.entity_id = e.id)
                JOIN company cp ON (cp.entity_id = e.id)
                        WHERE ec.entity_class = in_account_class
                        AND CASE WHEN in_account_class = 1 THEN
                                ec.id IN
                                (SELECT entity_credit_account
                                   FROM acc_trans
                                   JOIN chart ON (acc_trans.chart_id = chart.id)
                                   JOIN ap ON (acc_trans.trans_id = ap.id)
                                   WHERE link = &#39;AP&#39;
                                   GROUP BY chart_id,
                                         trans_id, entity_credit_account
                                   HAVING SUM(acc_trans.amount) &lt;&gt; 0)
                               WHEN in_account_class = 2 THEN
                                ec.id IN (SELECT entity_credit_account
                                   FROM acc_trans
                                   JOIN chart ON (acc_trans.chart_id = chart.id)
                                   JOIN ar ON (acc_trans.trans_id = ar.id)
                                   WHERE link = &#39;AR&#39;
                                   GROUP BY chart_id,
                                         trans_id, entity_credit_account
                                   HAVING SUM(acc_trans.amount) &lt;&gt; 0)
                          END
        LOOP
                RETURN NEXT out_entity;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text) -->
    <section id="lsmb14.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text"
             xreflabel="lsmb14payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)">
      <title id="lsmb14.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text-title">
       payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text-titleabbrev">
       payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
        
This function is based on payment_get_open_invoices and returns only one invoice if the in_invnumber is set. 
if no in_invnumber is passed this function behaves the same as payment_get_open_invoices

        <programlisting>
DECLARE payment_inv payment_invoice;
BEGIN
	FOR payment_inv IN
		SELECT * from payment_get_open_invoices(in_account_class, in_entity_credit_id, in_curr, in_datefrom, in_dateto, in_amountfrom,
		in_amountto, in_department_id)
		WHERE (invnumber like in_invnumber OR in_invnumber IS NULL)
	LOOP
		RETURN NEXT payment_inv;
	END LOOP;
END;

</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer) -->
    <section id="lsmb14.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer"
             xreflabel="lsmb14payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)">
      <title id="lsmb14.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer-title">
       payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer-titleabbrev">
       payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
        This function is the base for get_open_invoice and returns all open invoices for the entity_credit_id
it has a lot of options to enable filtering and use the same logic for entity_class_id and currency. 
        <programlisting>
DECLARE payment_inv payment_invoice;
BEGIN
	FOR payment_inv IN
		SELECT a.id AS invoice_id, a.invnumber AS invnumber,a.invoice AS invoice, 
		       a.transdate AS invoice_date, a.amount AS amount, 
		       a.amount/
		       (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		        ELSE
		        (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		        END) as amount_fx, 
		       (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END) AS discount,
		        (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END)/
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		        ELSE
		        (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		        END) as discount_fx,		        
		        ac.due - (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END) AS due,
		        (ac.due - (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0 
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END))/
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		         ELSE
		         (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		         END) AS due_fx,
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
		         THEN 1
		         ELSE
		        (CASE WHEN in_account_class = 2
		         THEN ex.buy
		         ELSE ex.sell END)
		         END) AS exchangerate
                 --TODO HV prepare drop entity_id from ap,ar
                 --FROM  (SELECT id, invnumber, transdate, amount, entity_id,
                 FROM  (SELECT id, invnumber, invoice, transdate, amount,
		               1 as invoice_class, curr,
		               entity_credit_account, department_id, approved
		          FROM ap
                         UNION
		         --SELECT id, invnumber, transdate, amount, entity_id,
		         SELECT id, invnumber, invoice, transdate, amount,
		               2 AS invoice_class, curr,
		               entity_credit_account, department_id, approved
		         FROM ar
		         ) a 
		JOIN (SELECT trans_id, chart_id, sum(CASE WHEN in_account_class = 1 THEN amount
		                                  WHEN in_account_class = 2 
		                             THEN amount * -1
		                             END) as due
		        FROM acc_trans 
		        GROUP BY trans_id, chart_id) ac ON (ac.trans_id = a.id)
		        JOIN chart ON (chart.id = ac.chart_id)
		        LEFT JOIN exchangerate ex ON ( ex.transdate = a.transdate AND ex.curr = a.curr )         
		        JOIN entity_credit_account c ON (c.id = a.entity_credit_account)
                --        OR (a.entity_credit_account IS NULL and a.entity_id = c.entity_id))
	 	        WHERE ((chart.link = &#39;AP&#39; AND in_account_class = 1)
		              OR (chart.link = &#39;AR&#39; AND in_account_class = 2))
              	        AND a.invoice_class = in_account_class
		        AND c.entity_class = in_account_class
		        AND c.id = in_entity_credit_id
                        --### short term: ignore fractional cent differences
		        AND a.curr = in_curr
		        AND (a.transdate &gt;= in_datefrom 
		             OR in_datefrom IS NULL)
		        AND (a.transdate &lt;= in_dateto
		             OR in_dateto IS NULL)
		        AND (a.amount &gt;= in_amountfrom 
		             OR in_amountfrom IS NULL)
		        AND (a.amount &lt;= in_amountto
		             OR in_amountto IS NULL)
		        AND (a.department_id = in_department_id
		             OR in_department_id IS NULL)
		        AND due &lt;&gt; 0 
		        AND a.approved = true         
		        GROUP BY a.invnumber, a.transdate, a.amount, amount_fx, discount, discount_fx, ac.due, a.id, c.discount_terms, ex.buy, ex.sell, a.curr, a.invoice
	LOOP
		RETURN NEXT payment_inv;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_overpayment_entities(in_account_class integer) -->
    <section id="lsmb14.function.payment-get-open-overpayment-entities-in-account-class-integer"
             xreflabel="lsmb14payment_get_open_overpayment_entities(in_account_class integer)">
      <title id="lsmb14.function.payment-get-open-overpayment-entities-in-account-class-integer-title">
       payment_get_open_overpayment_entities(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-open-overpayment-entities-in-account-class-integer-titleabbrev">
       payment_get_open_overpayment_entities(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
 DECLARE out_entity payment_vc_info;
 BEGIN
	FOR out_entity IN
    		SELECT DISTINCT entity_credit_id, legal_name, e.entity_class, discount, o.meta_number
    		FROM overpayments o
    		JOIN entity e ON (e.id=o.entity_id)
    		WHERE available &lt;&gt; 0 AND in_account_class = payment_class
        LOOP
                RETURN NEXT out_entity;
        END LOOP;
 END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer) -->
    <section id="lsmb14.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer"
             xreflabel="lsmb14payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)">
      <title id="lsmb14.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer-title">
       payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer-titleabbrev">
       payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF overpayments</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of available overpayments
        <programlisting>
DECLARE out_overpayment overpayments%ROWTYPE;
BEGIN
      FOR out_overpayment IN
              SELECT DISTINCT * 
              FROM overpayments
              WHERE payment_class  = in_account_class 
              AND entity_credit_id = in_entity_credit_id 
              AND available &lt;&gt; 0
              AND (in_chart_id IS NULL OR chart_id = in_chart_id )
              ORDER BY payment_date
            
      LOOP
           RETURN NEXT out_overpayment;
      END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer) -->
    <section id="lsmb14.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer"
             xreflabel="lsmb14payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)">
      <title id="lsmb14.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer-title">
       payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer-titleabbrev">
       payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns vendor or customer info 
        <programlisting>
DECLARE out_row payment_location_result;
	BEGIN
		FOR out_row IN
                SELECT l.id, l.line_one, l.line_two, l.line_three, l.city,
                       l.state, l.mail_code, c.name, lc.class
                FROM location l
                JOIN entity_to_location ctl ON (ctl.location_id = l.id)
                JOIN entity cp ON (ctl.entity_id = cp.id)
                JOIN location_class lc ON (ctl.location_class = lc.id)
                JOIN country c ON (c.id = l.country_id)
                JOIN entity_credit_account ec ON (ec.entity_id = cp.entity_id)
                WHERE ec.id = in_entity_credit_id AND
                      lc.id = in_location_class_id
                ORDER BY lc.id, l.id, c.name
                LOOP
                	RETURN NEXT out_row;
		END LOOP;
	END;
</programlisting>
      </para>
    </section>

<!-- Function payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean) -->
    <section id="lsmb14.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean"
             xreflabel="lsmb14payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)">
      <title id="lsmb14.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean-title">
       payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)
      </title>
      <titleabbrev id="lsmb14.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean-titleabbrev">
       payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts a payment.  in_op_* arrays are cross-indexed with eachother.
Other arrays are cross-indexed with eachother.

This API will probably change in 1.4 as we start looking at using more custom
complex types and arrays of those (requires Pg 8.4 or higher).

        <programlisting>
DECLARE var_payment_id int;
DECLARE var_gl_id int;
DECLARE var_entry record;
DECLARE var_entry_id int[];
DECLARE out_count int;
DECLARE coa_id record;
DECLARE var_employee int;
DECLARE var_account_id int;
DECLARE default_currency char(3);
DECLARE current_exchangerate numeric;
DECLARE old_exchangerate numeric;
DECLARE fx_gain_loss_amount numeric;
BEGIN
      IF array_upper(in_amount, 1) &lt;&gt; array_upper(in_cash_account_id, 1) THEN
          RAISE EXCEPTION &#39;Wrong number of accounts&#39;;
      END IF;
        
        SELECT * INTO default_currency  FROM defaults_get_defaultcurrency(); 
        SELECT * INTO current_exchangerate FROM currency_get_exchangerate(in_curr, in_datepaid, in_account_class);


        SELECT INTO var_employee p.id 
        FROM users u
        JOIN person p ON (u.entity_id=p.entity_id)
        WHERE username = SESSION_USER LIMIT 1;
        -- 
        -- WE HAVE TO INSERT THE PAYMENT, USING THE GL INFORMATION
        -- THE ID IS GENERATED BY payment_id_seq
        --
   	INSERT INTO payment (reference, payment_class, payment_date,
	                      employee_id, currency, notes, department_id, entity_credit_id) 
	VALUES ((CASE WHEN in_account_class = 1 THEN
	                                setting_increment(&#39;rcptnumber&#39;) -- I FOUND THIS ON sql/modules/Settings.sql 
			             ELSE 						-- and it is very usefull				
			                setting_increment(&#39;paynumber&#39;) 
			             END),
	         in_account_class, in_datepaid, var_employee,
                 in_curr, in_notes, in_department_id, in_entity_credit_id);
        SELECT currval(&#39;payment_id_seq&#39;) INTO var_payment_id; -- WE&#39;LL NEED THIS VALUE TO USE payment_link table
        -- WE&#39;LL NEED THIS VALUE TO JOIN WITH PAYMENT
        -- NOW COMES THE HEAVY PART, STORING ALL THE POSSIBLE TRANSACTIONS... 
        --
        -- FIRST WE SHOULD INSERT THE CASH ACCOUNTS
        --
        -- WE SHOULD HAVE THE DATA STORED AS (ACCNO, AMOUNT), SO
     IF (array_upper(in_cash_account_id, 1) &gt; 0) THEN
	FOR out_count IN 
			array_lower(in_cash_account_id, 1) ..
			array_upper(in_cash_account_id, 1)
	LOOP
	        INSERT INTO acc_trans (chart_id, amount,
		                       trans_id, transdate, approved, source, memo)
		VALUES (in_cash_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_amount[out_count]*current_exchangerate  
		        ELSE (in_amount[out_count]*current_exchangerate)* - 1
		        END,
		        in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true), 
		        in_source[out_count], in_memo[out_count]);
                INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 1);
		IF (in_ovp_payment_id IS NOT NULL AND in_ovp_payment_id[out_count] IS NOT NULL) THEN
                	INSERT INTO payment_links
                	VALUES (in_ovp_payment_id[out_count], currval(&#39;acc_trans_entry_id_seq&#39;), 0);
		END IF;
		
	END LOOP;
	-- NOW LETS HANDLE THE AR/AP ACCOUNTS
	-- WE RECEIVED THE TRANSACTIONS_ID AND WE CAN OBTAIN THE ACCOUNT FROM THERE
	FOR out_count IN
		     array_lower(in_transaction_id, 1) ..
		     array_upper(in_transaction_id, 1)
       LOOP
               SELECT INTO var_account_id chart_id FROM acc_trans as ac
	        JOIN chart as c ON (c.id = ac.chart_id) 
       	        WHERE 
       	        trans_id = in_transaction_id[out_count] AND
       	        ( c.link = &#39;AP&#39; OR c.link = &#39;AR&#39; );
        -- We need to know the exchangerate of this transaction
	-- ### BUG: we don&#39;t have a guarantee that the transaction is
	--          the same currency as in_curr, so, we can&#39;t use
	--          current_exchangerate as the basis for fx gain/loss
	--          calculations
        IF (in_curr = default_currency) THEN 
           old_exchangerate := 1;
        ELSIF (in_account_class = 2) THEN
           SELECT buy INTO old_exchangerate 
           FROM exchangerate e
           JOIN ar a ON (a.transdate = e.transdate)
                        AND (a.curr = e.curr)
           WHERE a.id = in_transaction_id[out_count];
        ELSE 
           SELECT sell INTO old_exchangerate 
           FROM exchangerate e
           JOIN ap a ON (a.transdate = e.transdate)
                        AND (a.curr = e.curr)
           WHERE a.id = in_transaction_id[out_count];
        END IF;
        -- Now we post the AP/AR transaction
        INSERT INTO acc_trans (chart_id, amount,
                                trans_id, transdate, approved, source, memo)
		VALUES (var_account_id, 
		        CASE WHEN in_account_class = 1 THEN 
		        
		        (in_amount[out_count]*old_exchangerate) * -1 
		        ELSE in_amount[out_count]*old_exchangerate
		        END,
		        in_transaction_id[out_count], in_datepaid,  coalesce(in_approved, true), 
		        in_source[out_count], in_memo[out_count]);
        -- Lets set the gain/loss, if  fx_gain_loss_amount equals zero then we dont need to post
        -- any transaction
       fx_gain_loss_amount := in_amount[out_count]*current_exchangerate - in_amount[out_count]*old_exchangerate;
       IF (in_account_class = 1) THEN
         -- in case of vendor invoices, the invoice amounts have been negated, do the same with the diff
         fx_gain_loss_amount := fx_gain_loss_amount * -1;
       END IF;

       IF (fx_gain_loss_amount &lt; 0) THEN
           INSERT INTO acc_trans (chart_id, amount, trans_id, transdate, approved, source)
            VALUES ((select value::int from defaults WHERE setting_key = &#39;fxgain_accno_id&#39;),
                    fx_gain_loss_amount, in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true),
                    in_source[out_count]);
        ELSIF (fx_gain_loss_amount &gt; 0) THEN
            INSERT INTO acc_trans (chart_id, amount, trans_id, transdate, approved, source)
            VALUES ((select value::int from defaults WHERE setting_key = &#39;fxloss_accno_id&#39;),
                    fx_gain_loss_amount, in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true),
                    in_source[out_count]);
        END IF; 
        -- Now we set the links
         INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 1);
      END LOOP;
     END IF; -- END IF 
--
-- WE NEED TO HANDLE THE OVERPAYMENTS NOW
--
       --
       -- FIRST WE HAVE TO MAKE THE GL TO HOLD THE OVERPAYMENT TRANSACTIONS
       -- THE ID IS GENERATED BY gl_id_seq
       --
       
  IF (array_upper(in_op_cash_account_id, 1) &gt; 0) THEN
       INSERT INTO gl (reference, description, transdate,
                       person_id, notes, approved, department_id) 
              VALUES (setting_increment(&#39;glnumber&#39;),
	              in_gl_description, in_datepaid, var_employee,
	              in_notes, in_approved, in_department_id);
       SELECT currval(&#39;id&#39;) INTO var_gl_id;   
--
-- WE NEED TO SET THE GL_ID FIELD ON PAYMENT&#39;S TABLE
--
       UPDATE payment SET gl_id = var_gl_id 
       WHERE id = var_payment_id;
       -- NOW COMES THE HEAVY PART, STORING ALL THE POSSIBLE TRANSACTIONS... 
       --
       -- FIRST WE SHOULD INSERT THE OVERPAYMENT CASH ACCOUNTS
       --
	FOR out_count IN 
			array_lower(in_op_cash_account_id, 1) ..
			array_upper(in_op_cash_account_id, 1)
	LOOP
	        INSERT INTO acc_trans (chart_id, amount,
		                       trans_id, transdate, approved, source, memo)
		VALUES (in_op_cash_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_op_amount[out_count]  
		        ELSE in_op_amount[out_count] * - 1
		        END,
		        var_gl_id, in_datepaid, coalesce(in_approved, true), 
		        in_op_source[out_count], in_op_memo[out_count]);
	        INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 2);
		
	END LOOP;
	-- NOW LETS HANDLE THE OVERPAYMENT ACCOUNTS
	FOR out_count IN
		     array_lower(in_op_account_id, 1) ..
		     array_upper(in_op_account_id, 1)
	LOOP
         INSERT INTO acc_trans (chart_id, amount,
                                trans_id, transdate, approved, source, memo)
		VALUES (in_op_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_op_amount[out_count] * -1 
		        ELSE in_op_amount[out_count]
		        END,
		        var_gl_id, in_datepaid,  coalesce(in_approved, true), 
		        in_op_source[out_count], in_op_memo[out_count]);
		INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 2);
	END LOOP;	        
 END IF;  
 return var_payment_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_type__get_label(in_payment_type_id integer) -->
    <section id="lsmb14.function.payment-type-get-label-in-payment-type-id-integer"
             xreflabel="lsmb14payment_type__get_label(in_payment_type_id integer)">
      <title id="lsmb14.function.payment-type-get-label-in-payment-type-id-integer-title">
       payment_type__get_label(in_payment_type_id integer)
      </title>
      <titleabbrev id="lsmb14.function.payment-type-get-label-in-payment-type-id-integer-titleabbrev">
       payment_type__get_label(in_payment_type_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_type</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all information on a payment type by the id.  This should be renamed
to account for its behavior in future versions.
        <programlisting>
DECLARE out_row payment_type%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM payment_type where id=in_payment_type_id LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_type__list() -->
    <section id="lsmb14.function.payment-type-list"
             xreflabel="lsmb14payment_type__list()">
      <title id="lsmb14.function.payment-type-list-title">
       payment_type__list()
      </title>
      <titleabbrev id="lsmb14.function.payment-type-list-titleabbrev">
       payment_type__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_row payment_type%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM payment_type LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payments_get_open_currencies(in_account_class integer) -->
    <section id="lsmb14.function.payments-get-open-currencies-in-account-class-integer"
             xreflabel="lsmb14payments_get_open_currencies(in_account_class integer)">
      <title id="lsmb14.function.payments-get-open-currencies-in-account-class-integer-title">
       payments_get_open_currencies(in_account_class integer)
      </title>
      <titleabbrev id="lsmb14.function.payments-get-open-currencies-in-account-class-integer-titleabbrev">
       payments_get_open_currencies(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF bpchar</seg>
        </seglistitem>
       </segmentedlist>
 
        This does a sparse scan to find currencies attached to open invoices.

It should scale per the number of currencies used rather than the size of the 
ar or ap tables.

        <programlisting>
DECLARE result char(3);
BEGIN
select min(curr) into result from ar WHERE in_account_class = 2
union 
select min(curr) from ap WHERE in_account_class = 1;


LOOP
   EXIT WHEN result IS NULL;
   return next result;

   SELECT min(curr) INTO result from ar 
    where in_account_class = 2 and curr &gt; result
            union 
   select min(curr) from ap 
    WHERE in_account_class = 1 and curr &gt; result
    LIMIT 1;

END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date) -->
    <section id="lsmb14.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date"
             xreflabel="lsmb14payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)">
      <title id="lsmb14.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date-title">
       payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)
      </title>
      <titleabbrev id="lsmb14.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date-titleabbrev">
       payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        1.3 only.  This will be replaced by a more generic function in 1.4.

This sets the exchange rate for a class of transactions (payable, receivable) 
to a certain rate for a specific date.
        <programlisting>
DECLARE current_exrate  exchangerate%ROWTYPE;
BEGIN
select  * INTO current_exrate
        FROM  exchangerate 
        WHERE transdate = in_datepaid
              AND curr = in_curr;
IF current_exrate.transdate = in_datepaid THEN
   IF in_account_class = 2 THEN 
      UPDATE exchangerate set buy = in_exchangerate  where transdate = in_datepaid;
   ELSE
      UPDATE exchangerate set sell = in_exchangerate where transdate = in_datepaid;
   END IF;
   RETURN 0; 
ELSE
    IF in_account_class = 2 THEN
     INSERT INTO exchangerate (curr, transdate, buy) values (in_curr, in_datepaid, in_exchangerate);
  ELSE   
     INSERT INTO exchangerate (curr, transdate, sell) values (in_curr, in_datepaid, in_exchangerate);
  END IF;                                       
RETURN 0;
END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function periods_get() -->
    <section id="lsmb14.function.periods-get"
             xreflabel="lsmb14periods_get()">
      <title id="lsmb14.function.periods-get-title">
       periods_get()
      </title>
      <titleabbrev id="lsmb14.function.periods-get-titleabbrev">
       periods_get()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF periods</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns dates for year to date, and last year.
        <programlisting>
SELECT * FROM periods ORDER BY id
</programlisting>
      </para>
    </section>

<!-- Function person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text) -->
    <section id="lsmb14.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text"
             xreflabel="lsmb14person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)">
      <title id="lsmb14.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text-title">
       person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)
      </title>
      <titleabbrev id="lsmb14.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text-titleabbrev">
       person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes a contact record specified for the person.  Returns true if a record
was found and deleted, false if not.
        <programlisting>
BEGIN

DELETE FROM entity_to_contact
 WHERE person_id = (SELECT entity_id FROM person WHERE id = in_person_id) 
       and contact_class_id = in_contact_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer) -->
    <section id="lsmb14.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer"
             xreflabel="lsmb14person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)">
      <title id="lsmb14.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer-title">
       person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer-titleabbrev">
       person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Deletes a location mapping to a person.  Returns true if found, false if no
data deleted.
        <programlisting>
BEGIN

DELETE FROM entity_to_location
 WHERE person_id = (select entity_id from person where id = in_person_id) 
       AND location_id = in_location_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function person__get(in_entity_id integer) -->
    <section id="lsmb14.function.person-get-in-entity-id-integer"
             xreflabel="lsmb14person__get(in_entity_id integer)">
      <title id="lsmb14.function.person-get-in-entity-id-integer-title">
       person__get(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-get-in-entity-id-integer-titleabbrev">
       person__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>person_entity</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT e.id, e.control_code, e.name, e.country_id, c.name, 
       p.first_name, p.middle_name, p.last_name
  FROM entity e
  JOIN country c ON c.id = e.country_id
  JOIN person p ON p.entity_id = e.id
 WHERE e.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function person__get_by_cc(in_control_code text) -->
    <section id="lsmb14.function.person-get-by-cc-in-control-code-text"
             xreflabel="lsmb14person__get_by_cc(in_control_code text)">
      <title id="lsmb14.function.person-get-by-cc-in-control-code-text-title">
       person__get_by_cc(in_control_code text)
      </title>
      <titleabbrev id="lsmb14.function.person-get-by-cc-in-control-code-text-titleabbrev">
       person__get_by_cc(in_control_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>person_entity</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT e.id, e.control_code, e.name, e.country_id, c.name, 
       p.first_name, p.middle_name, p.last_name
  FROM entity e
  JOIN country c ON c.id = e.country_id
  JOIN person p ON p.entity_id = e.id
 WHERE e.control_code = $1;
</programlisting>
      </para>
    </section>

<!-- Function person__get_my_entity_id() -->
    <section id="lsmb14.function.person-get-my-entity-id"
             xreflabel="lsmb14person__get_my_entity_id()">
      <title id="lsmb14.function.person-get-my-entity-id-title">
       person__get_my_entity_id()
      </title>
      <titleabbrev id="lsmb14.function.person-get-my-entity-id-titleabbrev">
       person__get_my_entity_id()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity_id of the current, logged in user.
        <programlisting>
	SELECT entity_id from users where username = SESSION_USER;
</programlisting>
      </para>
    </section>

<!-- Function person__list_bank_account(in_entity_id integer) -->
    <section id="lsmb14.function.person-list-bank-account-in-entity-id-integer"
             xreflabel="lsmb14person__list_bank_account(in_entity_id integer)">
      <title id="lsmb14.function.person-list-bank-account-in-entity-id-integer-title">
       person__list_bank_account(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-list-bank-account-in-entity-id-integer-titleabbrev">
       person__list_bank_account(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_bank_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists bank accounts for a person
        <programlisting>
DECLARE out_row entity_bank_account%ROWTYPE;
BEGIN
	FOR out_row IN
		SELECT * from entity_bank_account where entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_contacts(in_entity_id integer) -->
    <section id="lsmb14.function.person-list-contacts-in-entity-id-integer"
             xreflabel="lsmb14person__list_contacts(in_entity_id integer)">
      <title id="lsmb14.function.person-list-contacts-in-entity-id-integer-title">
       person__list_contacts(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-list-contacts-in-entity-id-integer-titleabbrev">
       person__list_contacts(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contacts attached to the function.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN 
		SELECT cc.class, cc.id, c.description, c.contact
		FROM entity_to_contact c
		JOIN contact_class cc ON (c.contact_class_id = cc.id)
		JOIN person p ON (c.person_id = p.entity_id)
		WHERE p.entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_languages() -->
    <section id="lsmb14.function.person-list-languages"
             xreflabel="lsmb14person__list_languages()">
      <title id="lsmb14.function.person-list-languages-title">
       person__list_languages()
      </title>
      <titleabbrev id="lsmb14.function.person-list-languages-titleabbrev">
       person__list_languages()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF language</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of languages ordered by code
        <programlisting> SELECT * FROM language ORDER BY code ASC </programlisting>
      </para>
    </section>

<!-- Function person__list_locations(in_entity_id integer) -->
    <section id="lsmb14.function.person-list-locations-in-entity-id-integer"
             xreflabel="lsmb14person__list_locations(in_entity_id integer)">
      <title id="lsmb14.function.person-list-locations-in-entity-id-integer-title">
       person__list_locations(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-list-locations-in-entity-id-integer-titleabbrev">
       person__list_locations(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of locations specified attached to the person.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT l.id, l.line_one, l.line_two, l.line_three, l.city, 
			l.state, l.mail_code, c.id, c.name, lc.id, lc.class
		FROM location l
		JOIN entity_to_location ctl ON (ctl.location_id = l.id)
		JOIN person p ON (ctl.person_id = p.entity_id)
		JOIN location_class lc ON (ctl.location_class = lc.id)
		JOIN country c ON (c.id = l.country_id)
		WHERE p.entity_id = in_entity_id
		ORDER BY lc.id, l.id, c.name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_notes(in_entity_id integer) -->
    <section id="lsmb14.function.person-list-notes-in-entity-id-integer"
             xreflabel="lsmb14person__list_notes(in_entity_id integer)">
      <title id="lsmb14.function.person-list-notes-in-entity-id-integer-title">
       person__list_notes(in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-list-notes-in-entity-id-integer-titleabbrev">
       person__list_notes(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of notes attached to a person.
        <programlisting>
DECLARE out_row record;
BEGIN
	FOR out_row IN
		SELECT *
		FROM entity_note
		WHERE ref_key = in_entity_id
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_salutations() -->
    <section id="lsmb14.function.person-list-salutations"
             xreflabel="lsmb14person__list_salutations()">
      <title id="lsmb14.function.person-list-salutations-title">
       person__list_salutations()
      </title>
      <titleabbrev id="lsmb14.function.person-list-salutations-titleabbrev">
       person__list_salutations()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF salutation</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of salutations ordered by id.
        <programlisting> SELECT * FROM salutation ORDER BY id ASC </programlisting>
      </para>
    </section>

<!-- Function person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer) -->
    <section id="lsmb14.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer"
             xreflabel="lsmb14person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)">
      <title id="lsmb14.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer-title">
       person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer-titleabbrev">
       person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the person with the information specified.  Returns the entity_id
of the record saved.
        <programlisting>

    DECLARE
        e_id int;
        e entity;
        loc location;
        l_id int;
        p_id int;
    BEGIN
    
    select * into e from entity where id = in_entity_id and entity_class = 3;
    e_id := in_entity_id; 
    
    IF FOUND THEN
        UPDATE entity 
           SET name = in_first_name || &#39; &#39; || in_last_name,
               country_id = in_country_id
         WHERE id = in_entity_id; 
    ELSE
        INSERT INTO entity (name, entity_class, country_id) 
	values (in_first_name || &#39; &#39; || in_last_name, 3, in_country_id);
	e_id := currval(&#39;entity_id_seq&#39;);
       
    END IF;
    
      
    UPDATE person SET
            salutation_id = in_salutation_id,
            first_name = in_first_name,
            last_name = in_last_name,
            middle_name = in_middle_name
    WHERE
            entity_id = in_entity_id;
    IF FOUND THEN
	RETURN in_entity_id;
    ELSE 
        -- Do an insert
        
        INSERT INTO person (salutation_id, first_name, last_name, entity_id)
	VALUES (in_salutation_id, in_first_name, in_last_name, e_id);

        RETURN e_id;
    
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer) -->
    <section id="lsmb14.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer"
             xreflabel="lsmb14person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)">
      <title id="lsmb14.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer-title">
       person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer-titleabbrev">
       person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves saves contact info.  Returns 1 if a row was inserted, 0 if it was 
updated. 
        <programlisting>
DECLARE 
    out_id int;
    v_orig entity_to_contact;
BEGIN
    
    SELECT cc.* into v_orig 
      FROM entity_to_contact cc
      JOIN person p ON (p.entity_id = cc.entity_id)
     WHERE p.entity_id = in_entity_id 
    and cc.contact_class_id = in_old_contact_class
    AND cc.contact = in_old_contact;
    
    IF NOT FOUND THEN
    
        -- create
        INSERT INTO entity_to_contact
               (entity_id, contact_class_id, contact, description)
        VALUES (in_entity_id, in_contact_class, in_contact_new, in_description);

        return 1;
    ELSE
        -- edit.
        UPDATE entity_to_contact
           SET contact = in_contact_new, description = in_description
         WHERE contact = in_old_contact
               AND entity_id = in_entity_id
               AND contact_class_id = in_old_contact_class;
        return 0;
    END IF;
    
END;
</programlisting>
      </para>
    </section>

<!-- Function person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer) -->
    <section id="lsmb14.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer"
             xreflabel="lsmb14person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)">
      <title id="lsmb14.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer-title">
       person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="lsmb14.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer-titleabbrev">
       person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location mapped to the person with the specified information.
Returns the location id saved.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
	    t_person_id int;
    BEGIN
	SELECT id INTO t_person_id
	FROM person WHERE entity_id = in_entity_id;

    UPDATE entity_to_location
       SET location_class = in_location_class
     WHERE entity_id = in_entity_id
           AND location_class = in_old_location_class
           AND location_id = in_location_id;
    
    
    IF NOT FOUND THEN
        -- Create a new one.
        l_id := location_save(
            in_location_id, 
    	    in_line_one, 
    	    in_line_two, 
    	    in_line_three, 
    	    in_city,
    		in_state, 
    		in_mail_code, 
    		in_country_code);
    	
        INSERT INTO entity_to_location 
    		(entity_id, location_id, location_class)
    	VALUES  (in_entity_id, l_id, in_location_class);
    ELSE
        l_id := location_save(
            in_location_id, 
    	    in_line_one, 
    	    in_line_two, 
    	    in_line_three, 
    	    in_city,
    		in_state, 
    		in_mail_code, 
    		in_country_code);
        -- Update the old one.
    END IF;
    return l_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function pnl__customer(in_to_date integer, in_from_date date, in_id date) -->
    <section id="lsmb14.function.pnl-customer-in-to-date-integer-in-from-date-date-in-id-date"
             xreflabel="lsmb14pnl__customer(in_to_date integer, in_from_date date, in_id date)">
      <title id="lsmb14.function.pnl-customer-in-to-date-integer-in-from-date-date-in-id-date-title">
       pnl__customer(in_to_date integer, in_from_date date, in_id date)
      </title>
      <titleabbrev id="lsmb14.function.pnl-customer-in-to-date-integer-in-from-date-date-in-id-date-titleabbrev">
       pnl__customer(in_to_date integer, in_from_date date, in_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH gl (id) AS
 ( SELECT id FROM ap WHERE approved is true AND entity_credit_account = $1
UNION ALL
   SELECT id FROM ar WHERE approved is true AND entity_credit_account = $1
)
SELECT a.id, a.accno, a.description, a.category, 
       ah.id, ah.accno, ah.description,
       CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END * sum(ac.amount)
  FROM account a
  JOIN account_heading ah on a.heading = ah.id
  JOIN acc_trans ac ON a.id = ac.chart_id
  JOIN gl ON ac.trans_id = gl.id
 WHERE ac.approved is true 
          AND ($2 IS NULL OR ac.transdate &gt;= $2) 
          AND ($3 IS NULL OR ac.transdate &lt;= $3)
          AND a.category IN (&#39;I&#39;, &#39;E&#39;)
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__income_statement_accrual(in_business_units date, in_to_date date, in_from_date integer[]) -->
    <section id="lsmb14.function.pnl-income-statement-accrual-in-business-units-date-in-to-date-date-in-from-date-integerARRAY"
             xreflabel="lsmb14pnl__income_statement_accrual(in_business_units date, in_to_date date, in_from_date integer[])">
      <title id="lsmb14.function.pnl-income-statement-accrual-in-business-units-date-in-to-date-date-in-from-date-integerARRAY-title">
       pnl__income_statement_accrual(in_business_units date, in_to_date date, in_from_date integer[])
      </title>
      <titleabbrev id="lsmb14.function.pnl-income-statement-accrual-in-business-units-date-in-to-date-date-in-from-date-integerARRAY-titleabbrev">
       pnl__income_statement_accrual(in_business_units date, in_to_date date, in_from_date integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, parent, path) AS (
      SELECT id, null, row(array[id])::tree_record FROM business_unit
       WHERE id = any($3)
      UNION ALL
      SELECT bu.id, parent, row((path).t || bu.id)::tree_record
        FROM business_unit bu
        JOIN bu_tree ON bu.parent_id = bu_tree.id
)
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END * sum(ac.amount)
     FROM account a
     JOIN account_heading ah on a.heading = ah.id
     JOIN acc_trans ac ON a.id = ac.chart_id AND ac.approved
     JOIN tx_report gl ON ac.trans_id = gl.id
LEFT JOIN (select array_agg(path) as bu_ids, entry_id
             FROM business_unit_ac buac
             JOIN bu_tree ON bu_tree.id = buac.bu_id
        GROUP BY buac.entry_id) bu
          ON (ac.entry_id = bu.entry_id)
    WHERE ac.approved is true 
          AND ($1 IS NULL OR ac.transdate &gt;= $1) 
          AND ($2 IS NULL OR ac.transdate &lt;= $2)
          AND ($3 = &#39;{}&#39; 
              OR $3 is null or in_tree($3, bu_ids))
          AND a.category IN (&#39;I&#39;, &#39;E&#39;)
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__income_statement_cash(in_business_units date, in_to_date date, in_from_date integer[]) -->
    <section id="lsmb14.function.pnl-income-statement-cash-in-business-units-date-in-to-date-date-in-from-date-integerARRAY"
             xreflabel="lsmb14pnl__income_statement_cash(in_business_units date, in_to_date date, in_from_date integer[])">
      <title id="lsmb14.function.pnl-income-statement-cash-in-business-units-date-in-to-date-date-in-from-date-integerARRAY-title">
       pnl__income_statement_cash(in_business_units date, in_to_date date, in_from_date integer[])
      </title>
      <titleabbrev id="lsmb14.function.pnl-income-statement-cash-in-business-units-date-in-to-date-date-in-from-date-integerARRAY-titleabbrev">
       pnl__income_statement_cash(in_business_units date, in_to_date date, in_from_date integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, parent, path) AS (
      SELECT id, null, row(array[id])::tree_record FROM business_unit
       WHERE id = any($3)
      UNION ALL
      SELECT bu.id, parent, row((path).t || bu.id)::tree_record
        FROM business_unit bu
        JOIN bu_tree ON bu.parent_id = bu_tree.id
)
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END 
               * sum(ac.amount * ca.portion)
     FROM account a
     JOIN account_heading ah on a.heading = ah.id
     JOIN acc_trans ac ON a.id = ac.chart_id AND ac.approved
     JOIN tx_report gl ON ac.trans_id = gl.id
     JOIN cash_impact ca ON gl.id = ca.id
LEFT JOIN (select array_agg(path) as bu_ids, entry_id
             FROM business_unit_ac buac
             JOIN bu_tree ON bu_tree.id = buac.bu_id
         GROUP BY entry_id) bu 
          ON (ac.entry_id = bu.entry_id)
    WHERE ac.approved is true 
          AND ($3 = &#39;{}&#39; 
              OR $3 is null or in_tree($3, bu_ids))
          AND ($1 IS NULL OR ac.transdate &gt;= $1) 
          AND ($2 IS NULL OR ac.transdate &lt;= $2)
          AND a.category IN (&#39;I&#39;, &#39;E&#39;)
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__invoice(in_id integer) -->
    <section id="lsmb14.function.pnl-invoice-in-id-integer"
             xreflabel="lsmb14pnl__invoice(in_id integer)">
      <title id="lsmb14.function.pnl-invoice-in-id-integer-title">
       pnl__invoice(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.pnl-invoice-in-id-integer-titleabbrev">
       pnl__invoice(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT a.id, a.accno, a.description, a.category, 
       ah.id, ah.accno, ah.description,
       CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END * sum(ac.amount)
  FROM account a
  JOIN account_heading ah on a.heading = ah.id
  JOIN acc_trans ac ON a.id = ac.chart_id
 WHERE ac.approved AND ac.trans_id = $1 AND a.category IN (&#39;I&#39;, &#39;E&#39;)
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[]) -->
    <section id="lsmb14.function.pnl-product-in-business-units-date-in-parts-id-date-in-to-date-integer-in-from-date-integerARRAY"
             xreflabel="lsmb14pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[])">
      <title id="lsmb14.function.pnl-product-in-business-units-date-in-parts-id-date-in-to-date-integer-in-from-date-integerARRAY-title">
       pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[])
      </title>
      <titleabbrev id="lsmb14.function.pnl-product-in-business-units-date-in-parts-id-date-in-to-date-integer-in-from-date-integerARRAY-titleabbrev">
       pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, parent, path) AS (
      SELECT id, null, row(array[id])::tree_record FROM business_unit
       WHERE id = any($4)
      UNION ALL
      SELECT bu.id, parent, row((path).t || bu.id)::tree_record
        FROM business_unit bu
        JOIN bu_tree ON bu.parent_id = bu_tree.id
)
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          sum(ac.amount) * -1 
     FROM account a
     JOIN account_heading ah on a.heading = ah.id
     JOIN acc_trans ac ON ac.chart_id = a.id
     JOIN invoice i ON i.id = ac.invoice_id
     JOIN account_link l ON l.account_id = a.id
     JOIN ar ON ar.id = ac.trans_id
LEFT JOIN (select as_array(bu.path) as bu_ids, entry_id
             from business_unit_inv bui 
             JOIN bu_tree bu ON bui.bu_id = bu.id
         GROUP BY entry_id) bui ON bui.entry_id = i.id
    WHERE i.parts_id = $3
          AND (ac.transdate &gt;= $1 OR $1 IS NULL) 
          AND (ac.transdate &lt;= $2 OR $2 IS NULL)
          AND ar.approved
          AND l.description = &#39;IC_expense&#39;
          AND ($4 is null or $4 = &#39;{}&#39; OR in_tree($4, bu_ids))
 GROUP BY a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description
    UNION
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          sum(i.sellprice * i.qty * (1 - coalesce(i.discount, 0)))
     FROM parts p
     JOIN invoice i ON i.id = p.id
     JOIN acc_trans ac ON ac.invoice_id = i.id
     JOIN account a ON p.income_accno_id = a.id
     JOIN ar ON ar.id = ac.trans_id
     JOIN account_heading ah on a.heading = ah.id
LEFT JOIN (select as_array(bu.path) as bu_ids, entry_id
             from business_unit_inv bui 
             JOIN bu_tree bu ON bui.bu_id = bu.id
         GROUP BY entry_id) bui ON bui.entry_id = i.id
    WHERE i.parts_id = $3
          AND (ac.transdate &gt;= $1 OR $1 IS NULL) 
          AND (ac.transdate &lt;= $2 OR $2 IS NULL)
          AND ar.approved
          AND ($4 is null or $4 = &#39;{}&#39; OR in_tree($4, bu_ids))
 GROUP BY a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description
</programlisting>
      </para>
    </section>

<!-- Function pricegroup__list() -->
    <section id="lsmb14.function.pricegroup-list"
             xreflabel="lsmb14pricegroup__list()">
      <title id="lsmb14.function.pricegroup-list-title">
       pricegroup__list()
      </title>
      <titleabbrev id="lsmb14.function.pricegroup-list-titleabbrev">
       pricegroup__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pricegroup</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an alphabetically ordered pricegroup list.
        <programlisting>
SELECT * FROM pricegroup ORDER BY pricegroup;
</programlisting>
      </para>
    </section>

<!-- Function pricegroups__list() -->
    <section id="lsmb14.function.pricegroups-list"
             xreflabel="lsmb14pricegroups__list()">
      <title id="lsmb14.function.pricegroups-list-title">
       pricegroups__list()
      </title>
      <titleabbrev id="lsmb14.function.pricegroups-list-titleabbrev">
       pricegroups__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pricegroup</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM pricegroup;
</programlisting>
      </para>
    </section>

<!-- Function pricelist__delete(credit_id integer, entry_id integer) -->
    <section id="lsmb14.function.pricelist-delete-credit-id-integer-entry-id-integer"
             xreflabel="lsmb14pricelist__delete(credit_id integer, entry_id integer)">
      <title id="lsmb14.function.pricelist-delete-credit-id-integer-entry-id-integer-title">
       pricelist__delete(credit_id integer, entry_id integer)
      </title>
      <titleabbrev id="lsmb14.function.pricelist-delete-credit-id-integer-entry-id-integer-titleabbrev">
       pricelist__delete(credit_id integer, entry_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
delete from partscustomer where entry_id = $1 and credit_id = $2;
delete from partsvendor where entry_id = $1 and credit_id = $2;
select true;
</programlisting>
      </para>
    </section>

<!-- Function pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer) -->
    <section id="lsmb14.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer"
             xreflabel="lsmb14pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)">
      <title id="lsmb14.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-title">
       pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </title>
      <titleabbrev id="lsmb14.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-titleabbrev">
       pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   retval eca__pricematrix;
   t_insert bool;
   t_entity_class int;

BEGIN

t_insert := false;

SELECT entity_class INTO t_entity_class FROM entity_credit_account 
  WHERE id = in_credit_id;

IF t_entity_class = 1 THEN -- VENDOR
    UPDATE partsvendor
       SET lastcost = in_price,
           leadtime = in_lead_time,
           partnumber = in_partnumber,
           curr = in_curr
     WHERE credit_id = in_credit_id AND entry_id = in_entry_id;

    IF NOT FOUND THEN
        INSERT INTO partsvendor
               (parts_id, credit_id, lastcost, leadtime, partnumber, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_leadtime::int2, 
               in_partnumber, in_curr);
    END IF;

    SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
           pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
           pv.entry_id
      INTO retval
      FROM partsvendor pv
      JOIN parts p ON p.id = pv.parts_id
     WHERE parts_id = in_parts_id and credit_id = in_credit_id;

    RETURN retval;

ELSIF t_entity_class = 2 THEN -- CUSTOMER
    UPDATE partscustomer
       SET pricebreak = in_pricebreak,
           sellprice  = in_price,
           validfrom  = in_validfrom,
           validto    = in_validto,
           curr       = in_curr
     WHERE entry_id = in_entry_id and credit_id = in_credit_id;

    IF NOT FOUND THEN
        INSERT INTO partscustomer
               (parts_id, credit_id, sellprice, validfrom, validto, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_validfrom, in_validto, 
                in_curr);

        t_insert := true;
    END IF;

    SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, 
           pc.pricebreak, pc.sellprice, NULL, NULL, NULL, pc.validfrom, 
           pc.validto, pc.curr, pc.entry_id
      INTO retval
      FROM partscustomer pc
      JOIN parts p on pc.parts_id = p.id
     WHERE entry_id = CASE WHEN t_insert 
                           THEN currval(&#39;partscustomer_entry_id_seq&#39;) 
                           ELSE in_entry_id 
                      END;
                           
    RETURN retval;

ELSE

RAISE EXCEPTION &#39;No valid entity credit account found&#39;;

END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__account_list() -->
    <section id="lsmb14.function.reconciliation-account-list"
             xreflabel="lsmb14reconciliation__account_list()">
      <title id="lsmb14.function.reconciliation-account-list-title">
       reconciliation__account_list()
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-account-list-titleabbrev">
       reconciliation__account_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF recon_accounts</seg>
        </seglistitem>
       </segmentedlist>
 
        returns set of accounts set up for reconciliation.  Currently we pull the 
account number and description from the account table.
        <programlisting>
    SELECT
        coa.accno || &#39; &#39; || coa.description as name,
        coa.accno, coa.id as id
    FROM account coa
         JOIN cr_coa_to_account cta ON cta.chart_id = coa.id
    ORDER BY coa.accno;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric) -->
    <section id="lsmb14.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric"
             xreflabel="lsmb14reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)">
      <title id="lsmb14.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric-title">
       reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric-titleabbrev">
       reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        
This function is used for automatically matching entries from an external source
like a bank-produced csv file.

This function is very sensitive to ordering of inputs.  NULL or empty in_scn values MUST be submitted after meaningful scns.  It is also highly recommended 
that within each category, one submits in order of amount.  We should therefore
wrap it in another function which can operate on a set, perhaps in 1.4....
        <programlisting>
    
    DECLARE
	in_account int;
        la RECORD;
        t_errorcode INT;
        our_value NUMERIC;
        lid INT;
	in_count int;
	t_scn TEXT;
	t_uid int;
	t_prefix text;
        t_amount numeric;
    BEGIN
        SELECT CASE WHEN a.category in (&#39;A&#39;, &#39;E&#39;) THEN in_amount * -1
                    ELSE in_amount
               END into t_amount
          FROM cr_report r JOIN account a ON r.chart_id = a.id
         WHERE r.id = in_report_id; 

	SELECT value into t_prefix FROM defaults WHERE setting_key = &#39;check_prefix&#39;;

	t_uid := person__get_my_entity_id();
	IF in_scn = &#39;&#39; THEN 
		t_scn := NULL;
	ELSE 
		t_scn := t_prefix || in_scn;
	END IF;
	IF t_scn IS NOT NULL THEN
                -- could this be changed to update, if not found insert?
		SELECT count(*) INTO in_count FROM cr_report_line
		WHERE scn ilike t_scn AND report_id = in_report_id 
			AND their_balance = 0;

		IF in_count = 0 THEN
			INSERT INTO cr_report_line
			(report_id, scn, their_balance, our_balance, clear_time,
				&quot;user&quot;, trans_type)
			VALUES 
			(in_report_id, t_scn, t_amount, 0, in_date, t_uid,
				in_type);
		ELSIF in_count = 1 THEN
			UPDATE cr_report_line
			SET their_balance = t_amount, clear_time = in_date,
				cleared = true
			WHERE t_scn = scn AND report_id = in_report_id
				AND their_balance = 0;
		ELSE 
			SELECT count(*) INTO in_count FROM cr_report_line
			WHERE t_scn ilike scn AND report_id = in_report_id
				AND our_value = t_amount and their_balance = 0;

			IF in_count = 0 THEN -- no match among many of values
				SELECT id INTO lid FROM cr_report_line
                        	WHERE t_scn ilike scn AND report_id = in_report_id
				ORDER BY our_balance ASC limit 1;

				UPDATE cr_report_line
                                SET their_balance = t_amount, 
					clear_time = in_date,
					trans_type = in_type,
					cleared = true
                                WHERE id = lid;

			ELSIF in_count = 1 THEN -- EXECT MATCH
				UPDATE cr_report_line
				SET their_balance = t_amount, 
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
				WHERE t_scn = scn AND report_id = in_report_id
                                	AND our_value = t_amount 
					AND their_balance = 0;
			ELSE -- More than one match
				SELECT id INTO lid FROM cr_report_line
                        	WHERE t_scn ilike scn AND report_id = in_report_id
                                	AND our_value = t_amount
				ORDER BY id ASC limit 1;

				UPDATE cr_report_line
                                SET their_balance = t_amount,
					trans_type = in_type,
					cleared = true,
					clear_time = in_date
                                WHERE id = lid;
				
			END IF;
		END IF;
	ELSE -- scn IS NULL, check on amount instead
		SELECT count(*) INTO in_count FROM cr_report_line
		WHERE report_id = in_report_id AND our_balance = t_amount
			AND their_balance = 0 and post_date = in_date
			and scn NOT LIKE t_prefix || &#39;%&#39;;

		IF in_count = 0 THEN -- no match
			INSERT INTO cr_report_line
			(report_id, scn, their_balance, our_balance, clear_time,
			&quot;user&quot;, trans_type)
			VALUES 
			(in_report_id, t_scn, t_amount, 0, in_date, t_uid,
			in_type);
		ELSIF in_count = 1 THEN -- perfect match
			UPDATE cr_report_line SET their_balance = t_amount,
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
			WHERE report_id = in_report_id AND our_balance = t_amount
                        	AND their_balance = 0 and
				in_scn NOT LIKE t_prefix || &#39;%&#39;;
		ELSE -- more than one match
			SELECT min(id) INTO lid FROM cr_report_line
			WHERE report_id = in_report_id AND our_balance = t_amount
                        	AND their_balance = 0 and post_date = in_date
				AND scn NOT LIKE t_prefix || &#39;%&#39;
			LIMIT 1;

			UPDATE cr_report_line SET their_balance = t_amount,
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
			WHERE id = lid;
			
		END IF;
	END IF;
        return 1; 
        
    END;    
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_my_report(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-delete-my-report-in-report-id-integer"
             xreflabel="lsmb14reconciliation__delete_my_report(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-delete-my-report-in-report-id-integer-title">
       reconciliation__delete_my_report(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-delete-my-report-in-report-id-integer-titleabbrev">
       reconciliation__delete_my_report(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       This function allows a user to delete his or her own unsubmitted, unapproved
reconciliation reports only.  This is designed to allow a user to back out of
the reconciliation process without cluttering up the search results for others.

        <programlisting>
BEGIN
    DELETE FROM cr_report_line
     WHERE report_id = in_report_id
           AND report_id IN (SELECT id FROM cr_report
                              WHERE entered_username = SESSION_USER
                                    AND submitted IS NOT TRUE
                                    and approved IS NOT TRUE);
    DELETE FROM cr_report
     WHERE id = in_report_id AND entered_username = SESSION_USER
           AND submitted IS NOT TRUE AND approved IS NOT TRUE;
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_unapproved(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-delete-unapproved-in-report-id-integer"
             xreflabel="lsmb14reconciliation__delete_unapproved(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-delete-unapproved-in-report-id-integer-title">
       reconciliation__delete_unapproved(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-delete-unapproved-in-report-id-integer-titleabbrev">
       reconciliation__delete_unapproved(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       This function deletes any specified unapproved transaction.
        <programlisting>
BEGIN
    DELETE FROM cr_report_line
     WHERE report_id = in_report_id
           AND report_id IN (SELECT id FROM cr_report
                              WHERE approved IS NOT TRUE);
    DELETE FROM cr_report
     WHERE id = in_report_id AND approved IS NOT TRUE;
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_cleared_balance(in_chart_id integer) -->
    <section id="lsmb14.function.reconciliation-get-cleared-balance-in-chart-id-integer"
             xreflabel="lsmb14reconciliation__get_cleared_balance(in_chart_id integer)">
      <title id="lsmb14.function.reconciliation-get-cleared-balance-in-chart-id-integer-title">
       reconciliation__get_cleared_balance(in_chart_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-get-cleared-balance-in-chart-id-integer-titleabbrev">
       reconciliation__get_cleared_balance(in_chart_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets the cleared balance of the account specified by chart_id.
This is specified in normal format (i.e. positive numbers for debits for asset
and espense accounts, and positive numbers for credits in other accounts 

Note that currently contra accounts will show negative balances.
        <programlisting>
	select CASE WHEN c.category in(&#39;A&#39;, &#39;E&#39;) THEN sum(ac.amount) * -1 ELSE
		sum(ac.amount) END
	FROM account c
	JOIN acc_trans ac ON (ac.chart_id = c.id)
	JOIN (select id from ar where approved
		union
		select id from ap where approved
		union
		select id from gl where approved) g on (g.id = ac.trans_id)
	WHERE c.id = $1 AND ac.cleared is true and ac.approved is true
		GROUP BY c.id, c.category;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_current_balance(in_date integer, in_account_id date) -->
    <section id="lsmb14.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date"
             xreflabel="lsmb14reconciliation__get_current_balance(in_date integer, in_account_id date)">
      <title id="lsmb14.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date-title">
       reconciliation__get_current_balance(in_date integer, in_account_id date)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date-titleabbrev">
       reconciliation__get_current_balance(in_date integer, in_account_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets the current balance of all approved transactions against a specific 
account.  For asset and expense accounts this is the debit balance, for others
this is the credit balance.
        <programlisting>
DECLARE outval NUMERIC;
BEGIN
	SELECT CASE WHEN (select category FROM account WHERE id = in_account_id)
			IN (&#39;A&#39;, &#39;E&#39;) THEN sum(a.amount) * -1
		ELSE sum(a.amount) END
	FROM acc_trans a
	JOIN (
		SELECT id FROM ar
		WHERE approved is true
		UNION
		SELECT id FROM ap
		WHERE approved is true
		UNION
		SELECT id FROM gl
		WHERE approved is true
	) gl ON a.trans_id = gl.id
	WHERE a.approved IS TRUE 
		AND a.chart_id = in_account_id
		AND a.transdate &lt;= in_date;

	RETURN outval;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_total(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-get-total-in-report-id-integer"
             xreflabel="lsmb14reconciliation__get_total(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-get-total-in-report-id-integer-title">
       reconciliation__get_total(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-get-total-in-report-id-integer-titleabbrev">
       reconciliation__get_total(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves all header info from the reconciliation report.
        <programlisting>

    DECLARE
        row cr_report;
    BEGIN
    
        SELECT * INTO row FROM cr_report 
        where id = in_report_id 
        AND scn = -1;
        
        IF NOT FOUND THEN -- I think this is a fairly major error condition
            RAISE EXCEPTION &#39;Bad report id.&#39;;
        ELSE
            return next row;
        END IF;
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean) -->
    <section id="lsmb14.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean"
             xreflabel="lsmb14reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)">
      <title id="lsmb14.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean-title">
       reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean-titleabbrev">
       reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts creates a new report and returns the id.
        <programlisting>

    INSERT INTO cr_report(chart_id, their_total, end_date, recon_fx) 
    values ($1, $2, $3, $4);
    SELECT currval(&#39;cr_report_id_seq&#39;)::int;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric) -->
    <section id="lsmb14.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric"
             xreflabel="lsmb14reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)">
      <title id="lsmb14.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric-title">
       reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric-titleabbrev">
       reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Ensures that the list of pending transactions in the report is up to date. 
        <programlisting>
    
    DECLARE
        gl_row RECORD;
        t_recon_fx BOOL;
    BEGIN
                SELECT recon_fx INTO t_recon_fx FROM cr_report WHERE id = in_report_id;
 
		INSERT INTO cr_report_line (report_id, scn, their_balance, 
			our_balance, &quot;user&quot;, voucher_id, ledger_id, post_date)
		SELECT in_report_id, 
		       CASE WHEN ac.source IS NULL OR ac.source = &#39;&#39; 
                            THEN gl.ref
                            ELSE ac.source END,
		       0, 
		       sum(amount / CASE WHEN t_recon_fx IS NOT TRUE OR gl.table = &#39;gl&#39;
                                         THEN 1
                                         WHEN t_recon_fx and gl.table = &#39;ap&#39; 
                                         THEN ex.sell
                                         WHEN t_recon_fx and gl.table = &#39;ar&#39; 
                                         THEN ex.buy
                                    END) AS amount,
				(select entity_id from users 
				where username = CURRENT_USER),
			ac.voucher_id, min(ac.entry_id), ac.transdate
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, curr, 
                             transdate, &#39;ar&#39; as table 
                        FROM ar where approved
			UNION
		      select id, entity_credit_account::text, curr, 
                             transdate, &#39;ap&#39; as table 
                        FROM ap WHERE approved
			UNION
		      select id, reference, &#39;&#39;, 
                             transdate, &#39;gl&#39; as table 
                        FROM gl WHERE approved) gl 
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)))
                LEFT JOIN exchangerate ex ON gl.transdate = ex.transdate
		WHERE ac.cleared IS FALSE
			AND ac.approved IS TRUE
			AND ac.chart_id = in_chart_id
			AND ac.transdate &lt;= in_end_date
                        AND ((t_recon_fx is not true 
                                and ac.fx_transaction is not true) 
                            OR (t_recon_fx is true 
                                AND (gl.table &lt;&gt; &#39;gl&#39; OR ac.fx_transaction
                                                      IS TRUE))) 
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table, 
                        case when gl.table = &#39;gl&#39; then gl.id else 1 end
		HAVING count(rl.id) = 0;

		UPDATE cr_report set updated = now(),
			their_total = coalesce(in_their_total, their_total)
		where id = in_report_id;
    RETURN in_report_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_approve(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-report-approve-in-report-id-integer"
             xreflabel="lsmb14reconciliation__report_approve(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-report-approve-in-report-id-integer-title">
       reconciliation__report_approve(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-report-approve-in-report-id-integer-titleabbrev">
       reconciliation__report_approve(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Marks the report approved and marks all cleared transactions in it cleared.
        <programlisting>
    
    -- Does some basic checks before allowing the approval to go through; 
    -- moves the approval to &quot;cr_report_line&quot;, I guess, or some other &quot;final&quot; table.
    --
    -- Pending may just be a single flag in the database to mark that it is
    -- not finalized. Will need to discuss with Chris.
    
    DECLARE
        current_row RECORD;
        completed cr_report_line;
        total_errors INT;
        in_user TEXT;
	ac_entries int[];
    BEGIN
        in_user := current_user;
        
        -- so far, so good. Different user, and no errors remain. Therefore, 
        -- we can move it to completed reports.
        --
        -- User may not be necessary - I would think it better to use the 
        -- in_user, to note who approved the report, than the user who
        -- filed it. This may require clunkier syntax..
        
        -- 
	ac_entries := &#39;{}&#39;;
        update cr_report set approved = &#39;t&#39;,
		approved_by = person__get_my_entity_id(),
		approved_username = SESSION_USER
	where id = in_report_id;

	FOR current_row IN 
		SELECT compound_array(entries) AS entries FROM (
			select as_array(ac.entry_id) as entries
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, &#39;ar&#39; as table FROM ar
			UNION
		      select id, entity_credit_account::text, &#39;ap&#39; as table FROM ap
			UNION
		      select id, reference, &#39;gl&#39; as table FROM gl) gl
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)) and rl.cleared is true)
		WHERE ac.cleared IS FALSE
			AND ac.chart_id = (select chart_id from cr_report where id = in_report_id)
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table
		HAVING count(rl.report_id) &gt; 0) a
	LOOP
		ac_entries := ac_entries || current_row.entries;
	END LOOP;

	UPDATE acc_trans SET cleared = TRUE 
	where entry_id = any(ac_entries);
        
        return 1;        
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_details(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-report-details-in-report-id-integer"
             xreflabel="lsmb14reconciliation__report_details(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-report-details-in-report-id-integer-title">
       reconciliation__report_details(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-report-details-in-report-id-integer-titleabbrev">
       reconciliation__report_details(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the details of the report. 
        <programlisting>

    DECLARE
        row cr_report_line;
    BEGIN    
        FOR row IN 
		select * from cr_report_line where report_id = in_report_id 
		order by scn, post_date
	LOOP
        
            RETURN NEXT row;
        
        END LOOP;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_details_payee(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-report-details-payee-in-report-id-integer"
             xreflabel="lsmb14reconciliation__report_details_payee(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-report-details-payee-in-report-id-integer-title">
       reconciliation__report_details_payee(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-report-details-payee-in-report-id-integer-titleabbrev">
       reconciliation__report_details_payee(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF recon_payee</seg>
        </seglistitem>
       </segmentedlist>
 
        Pulls the payee information for the reconciliation report.
        <programlisting>
   DECLARE
        row recon_payee;
    BEGIN    
        FOR row IN 
        	select * from recon_payee where report_id = in_report_id 
        	order by scn, post_date
        LOOP
          RETURN NEXT row;
        END LOOP;    
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_summary(in_report_id integer) -->
    <section id="lsmb14.function.reconciliation-report-summary-in-report-id-integer"
             xreflabel="lsmb14reconciliation__report_summary(in_report_id integer)">
      <title id="lsmb14.function.reconciliation-report-summary-in-report-id-integer-title">
       reconciliation__report_summary(in_report_id integer)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-report-summary-in-report-id-integer-titleabbrev">
       reconciliation__report_summary(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

    DECLARE
        row cr_report;
    BEGIN    
        select * into row from cr_report where id = in_report_id;
        
        RETURN row;
        
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__save_set(in_line_ids integer, in_report_id integer[]) -->
    <section id="lsmb14.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY"
             xreflabel="lsmb14reconciliation__save_set(in_line_ids integer, in_report_id integer[])">
      <title id="lsmb14.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY-title">
       reconciliation__save_set(in_line_ids integer, in_report_id integer[])
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY-titleabbrev">
       reconciliation__save_set(in_line_ids integer, in_report_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Sets which lines of the report are cleared.
        <programlisting>
BEGIN
	UPDATE cr_report_line SET cleared = false
	WHERE report_id = in_report_id;

	UPDATE cr_report_line SET cleared = true
	WHERE report_id = in_report_id AND id = ANY(in_line_ids);
	RETURN found;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean) -->
    <section id="lsmb14.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean"
             xreflabel="lsmb14reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)">
      <title id="lsmb14.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean-title">
       reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean-titleabbrev">
       reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for reconciliation reports.
NULLs match all values.
in_date_to and in_date_from give a range of reports.  All other inputs are
exact matches.

        <programlisting>
DECLARE report cr_report;
BEGIN
	FOR report IN
		SELECT r.* FROM cr_report r
		JOIN account c ON (r.chart_id = c.id)
		WHERE 
			(in_date_from IS NULL OR in_date_from &lt;= end_date) and
			(in_date_to IS NULL OR in_date_to &gt;= end_date) AND
			(in_balance_from IS NULL 
				or in_balance_from &lt;= their_total ) AND
			(in_balance_to IS NULL 
				OR in_balance_to &gt;= their_total) AND
			(in_chart_id IS NULL OR in_chart_id = chart_id) AND
			(in_submitted IS NULL or in_submitted = submitted) AND
			(in_approved IS NULL OR in_approved = approved) AND
			(r.deleted IS FALSE)
		ORDER BY c.accno, end_date, their_total
	LOOP
		RETURN NEXT report;
	END LOOP; 
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__submit_set(in_line_ids integer, in_report_id integer[]) -->
    <section id="lsmb14.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY"
             xreflabel="lsmb14reconciliation__submit_set(in_line_ids integer, in_report_id integer[])">
      <title id="lsmb14.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY-title">
       reconciliation__submit_set(in_line_ids integer, in_report_id integer[])
      </title>
      <titleabbrev id="lsmb14.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY-titleabbrev">
       reconciliation__submit_set(in_line_ids integer, in_report_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Submits a reconciliation report for approval. 
in_line_ids is used to specify which report lines are cleared, finalizing the
report.
        <programlisting>
BEGIN
	UPDATE cr_report set submitted = true where id = in_report_id;
	PERFORM reconciliation__save_set(in_report_id, in_line_ids);

	RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text) -->
    <section id="lsmb14.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text"
             xreflabel="lsmb14report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)">
      <title id="lsmb14.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text-title">
       report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)
      </title>
      <titleabbrev id="lsmb14.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text-titleabbrev">
       report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF cash_summary_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT a.id, a.accno, a.is_heading, a.description, t.label, 
       sum(CASE WHEN ac.amount &lt; 0 THEN ac.amount * -1 ELSE NULL END),
       sum(CASE WHEN ac.amount &gt; 0 THEN ac.amount ELSE NULL END)
  FROM (select id, accno, false as is_heading, description FROM account
       UNION
        SELECT id, accno, true, description FROM account_heading) a
  LEFT
  JOIN acc_trans ac ON ac.chart_id = a.id 
  LEFT
  JOIN (select id, case when table_name ilike &#39;ar&#39; THEN &#39;rcpt&#39;
                        when table_name ilike &#39;ap&#39; THEN &#39;pmt&#39;
                        when table_name ilike &#39;gl&#39; THEN &#39;xfer&#39;
                    END AS label
          FROM transactions) t ON t.id = ac.trans_id
 WHERE accno BETWEEN $3 AND $4
        and ac.transdate BETWEEN $1 AND $2
GROUP BY a.id, a.accno, a.is_heading, a.description, t.label
ORDER BY accno;

</programlisting>
      </para>
    </section>

<!-- Function report__coa() -->
    <section id="lsmb14.function.report-coa"
             xreflabel="lsmb14report__coa()">
      <title id="lsmb14.function.report-coa-title">
       report__coa()
      </title>
      <titleabbrev id="lsmb14.function.report-coa-titleabbrev">
       report__coa()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF coa_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

WITH ac (chart_id, amount) AS (
     SELECT chart_id, CASE WHEN acc_trans.approved and gl.approved THEN amount
                           ELSE 0 
                       END
       FROM acc_trans
       JOIN (select id, approved from ar union all
             select id, approved from ap union all
             select id, approved from gl) gl ON gl.id = acc_trans.trans_id
),
l(account_id, link) AS (
     SELECT account_id, array_to_string(array_agg(description), &#39;:&#39;)
       FROM account_link
   GROUP BY account_id
)
SELECT a.id, a.is_heading, a.accno, a.description, a.gifi_accno, 
       CASE WHEN sum(ac.amount) &lt; 0 THEN sum(amount) * -1 ELSE null::numeric
        END,
       CASE WHEN sum(ac.amount) &gt; 0 THEN sum(amount) ELSE null::numeric END,
       count(ac.*), l.link
  FROM (SELECT id,false as is_heading, accno, description, gifi_accno
          FROM account
         UNION
        SELECT id, true, accno, description, null::text 
          FROM account_heading) a

 LEFT JOIN ac ON ac.chart_id = a.id AND not a.is_heading
 LEFT JOIN l ON l.account_id = a.id AND NOT a.is_heading
  GROUP BY a.id, a.is_heading, a.accno, a.description, a.gifi_accno, l.link
  ORDER BY a.accno;

</programlisting>
      </para>
    </section>

<!-- Function report__general_balance(in_date_to date, in_date_from date) -->
    <section id="lsmb14.function.report-general-balance-in-date-to-date-in-date-from-date"
             xreflabel="lsmb14report__general_balance(in_date_to date, in_date_from date)">
      <title id="lsmb14.function.report-general-balance-in-date-to-date-in-date-from-date-title">
       report__general_balance(in_date_to date, in_date_from date)
      </title>
      <titleabbrev id="lsmb14.function.report-general-balance-in-date-to-date-in-date-from-date-titleabbrev">
       report__general_balance(in_date_to date, in_date_from date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF general_balance_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

SELECT a.id, a.accno, a.description,
      sum(CASE WHEN ac.transdate &lt; $1 THEN abs(amount) ELSE null END),
      sum(CASE WHEN ac.transdate &gt;= $1 AND ac.amount &lt; 0 
               THEN ac.amount * -1 ELSE null END),
      SUM(CASE WHEN ac.transdate &gt;= $1 AND ac.amount &gt; 0
               THEN ac.amount ELSE null END),
      SUM(ABS(ac.amount))
 FROM account a 
 LEFT
 JOIN acc_trans ac ON ac.chart_id = a.id
 LEFT 
 JOIN (select id, approved from ar UNION
       SELECT id, approved from ap UNION
       SELECT id, approved FROM gl) gl ON ac.trans_id = gl.id
WHERE gl.approved and ac.approved
      and ac.transdate &lt;= $2 
GROUP BY a.id, a.accno, a.description
ORDER BY a.accno;

</programlisting>
      </para>
    </section>

<!-- Function report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[]) -->
    <section id="lsmb14.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY"
             xreflabel="lsmb14report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])">
      <title id="lsmb14.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY-title">
       report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])
      </title>
      <titleabbrev id="lsmb14.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY-titleabbrev">
       report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF gl_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
         retval gl_report_item;
         t_balance numeric;
         t_chart_id int;
BEGIN

IF in_from_date IS NULL THEN
   t_balance := 0;
ELSIF in_accno IS NOT NULL THEN
   SELECT id INTO t_chart_id FROM account WHERE accno  = in_accno;
   t_balance := account__obtain_balance(in_from_date , 
                                       (select id from account 
                                         where accno = in_accno));
ELSE
   t_balance := null;
END IF;

FOR retval IN
       WITH RECURSIVE bu_tree (id, path) AS (
            SELECT id, id::text AS path
              FROM business_unit
             WHERE parent_id is null
            UNION
            SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id
              FROM business_unit bu
              JOIN bu_tree ON bu_tree.id = bu.parent_id
            )
       SELECT g.id, g.type, g.invoice, g.reference, g.description, ac.transdate,
              ac.source, ac.amount, c.accno, c.gifi_accno, 
              g.till, ac.cleared, ac.memo, c.description AS accname, 
              ac.chart_id, ac.entry_id, 
              sum(ac.amount) over (rows unbounded preceding) + t_balance 
                as running_balance,
              compound_array(ARRAY[ARRAY[bac.class_id, bac.bu_id]])
         FROM (select id, &#39;gl&#39; as type, false as invoice, reference, 
                      description, approved,
                      null::text as till 
                 FROM gl
               UNION
               SELECT ar.id, &#39;ar&#39;, invoice, invnumber, e.name, approved, till
                 FROM ar
                 JOIN entity_credit_account eca ON ar.entity_credit_account
                      = eca.id
                 JOIN entity e ON e.id = eca.entity_id
               UNION
               SELECT ap.id, &#39;ap&#39;, invoice, invnumber, e.name, approved,
                      null as till
                 FROM ap
                 JOIN entity_credit_account eca ON ap.entity_credit_account 
                      = eca.id
                 JOIN entity e ON e.id = eca.entity_id) g
         JOIN acc_trans ac ON ac.trans_id = g.id
         JOIN account c ON ac.chart_id = c.id
    LEFT JOIN business_unit_ac bac ON ac.entry_id = bac.entry_id 
    LEFT JOIN bu_tree ON bac.bu_id = bu_tree.id
        WHERE (g.reference ilike in_reference || &#39;%&#39; or in_reference is null)
              AND (c.accno = in_accno OR in_accno IS NULL)
              AND (ac.source ilike &#39;%&#39; || in_source || &#39;%&#39; 
                   OR in_source is null)
              AND (ac.memo ilike &#39;%&#39; || in_memo || &#39;%&#39; OR in_memo is null)
             AND (in_description IS NULL OR
                  g.description
                  @@
                  plainto_tsquery(get_default_lang()::regconfig, in_description))
              AND (transdate BETWEEN in_from_date AND in_to_date
                   OR (transdate &gt;= in_from_date AND  in_to_date IS NULL)
                   OR (transdate &lt;= in_to_date AND in_from_date IS NULL)
                   OR (in_to_date IS NULL AND in_from_date IS NULL))
              AND (in_approved is false OR (g.approved AND ac.approved))
              AND (in_from_amount IS NULL OR ac.amount &gt;= in_from_amount)
              AND (in_to_amount IS NULL OR ac.amount &lt;= in_to_amount)
              AND (in_category = c.category OR in_category IS NULL)
     GROUP BY g.id, g.type, g.invoice, g.reference, g.description, ac.transdate,
              ac.source, ac.amount, c.accno, c.gifi_accno,
              g.till, ac.cleared, ac.memo, c.description,
              ac.chart_id, ac.entry_id, ac.trans_id
       HAVING in_business_units is null or in_business_units 
                &lt;@ compound_array(string_to_array(bu_tree.path, &#39;,&#39;)::int[])
     ORDER BY ac.transdate, ac.trans_id, c.accno
LOOP
   RETURN NEXT retval;
END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean) -->
    <section id="lsmb14.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean"
             xreflabel="lsmb14report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)">
      <title id="lsmb14.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-title">
       report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-titleabbrev">
       report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF report_aging_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	item report_aging_item;
BEGIN
	FOR item IN
                  WITH RECURSIVE bu_tree (id, path) AS (
                SELECT id, id::text AS path
                  FROM business_unit
                 WHERE id = any(in_business_units)
                 UNION
                SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id
                  FROM business_unit bu
                  JOIN bu_tree ON bu_tree.id = bu.parent_id
                       )
		SELECT c.entity_id, c.meta_number, e.name,
		       e.name as contact_name, 
	               a.invnumber, a.transdate, a.till, a.ordnumber, 
		       a.ponumber, a.notes, 
		       CASE WHEN a.age/30 = 0
		                 THEN (a.sign * sum(ac.amount)) 
                            ELSE 0 END
		            as c0, 
		       CASE WHEN a.age/30 = 1
		                 THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c30, 
		       CASE WHEN a.age/30 = 2
		            THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c60, 
		       CASE WHEN a.age/30 &gt; 2
		            THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c90, 
		       a.duedate, a.id, a.curr,
		       COALESCE((SELECT sell FROM exchangerate ex
		         WHERE a.curr = ex.curr
		              AND ex.transdate = a.transdate), 1)
		       AS exchangerate,
			(SELECT compound_array(ARRAY[[p.partnumber,
					i.description, i.qty::text]])
				FROM parts p 
				JOIN invoice i ON (i.parts_id = p.id)
				WHERE i.trans_id = a.id) AS line_items,
                   (coalesce(in_to_date, now())::date - a.transdate) as age
		  FROM (select id, invnumber, till, ordnumber, amount, duedate,
                               curr, ponumber, notes, entity_credit_account,
                               -1 AS sign, transdate,
                               CASE WHEN in_use_duedate 
                                    THEN coalesce(in_to_date, now())::date
                                         - duedate
                                    ELSE coalesce(in_to_date, now())::date
                                         - transdate 
                               END as age
                          FROM ar
                         WHERE in_entity_class = 2
                         UNION 
                        SELECT id, invnumber, null, ordnumber, amount, duedate,
                               curr, ponumber, notes, entity_credit_account,
                               1 as sign, transdate,
                               CASE WHEN in_use_duedate 
                                    THEN coalesce(in_to_date, now())::date
                                         - duedate
                                    ELSE coalesce(in_to_date, now())::date
                                         - transdate 
                               END as age
                          FROM ap
                         WHERE in_entity_class = 1) a
                  JOIN acc_trans ac ON ac.trans_id = a.id
                  JOIN account acc ON ac.chart_id = acc.id
                  JOIN account_link acl ON acl.account_id = acc.id
                       AND ((in_entity_class = 1 
                              AND acl.description = &#39;AP&#39;)
                           OR (in_entity_class = 2
                              AND acl.description = &#39;AR&#39;))
		  JOIN entity_credit_account c 
                       ON a.entity_credit_account = c.id
		  JOIN entity e ON (e.id = c.entity_id)
             LEFT JOIN business_unit_ac buac ON ac.entry_id = buac.entry_id
             LEFT JOIN bu_tree ON buac.bu_id = bu_tree.id
	     LEFT JOIN entity_to_location e2l 
                       ON e.id = e2l.entity_id 
                       AND e2l.location_class = 3
             LEFT JOIN location l ON l.id = e2l.location_id
	     LEFT JOIN country ON (country.id = l.country_id)
                 WHERE (e.id = in_entity_id OR in_entity_id IS NULL)
                       AND (in_accno IS NULL or acc.accno = in_accno)
              GROUP BY c.entity_id, c.meta_number, e.name,
                       l.line_one, l.line_two, l.line_three,
                       l.city, l.state, l.mail_code, country.name,
                       a.invnumber, a.transdate, a.till, a.ordnumber,
                       a.ponumber, a.notes, a.amount, a.sign,
                       a.duedate, a.id, a.curr, a.age
                HAVING in_business_units is null or in_business_units 
                       &lt;@ compound_array(string_to_array(bu_tree.path, 
                                         &#39;,&#39;)::int[])
	      ORDER BY entity_id, curr, transdate, invnumber
	LOOP
		return next item;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean) -->
    <section id="lsmb14.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean"
             xreflabel="lsmb14report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)">
      <title id="lsmb14.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-title">
       report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-titleabbrev">
       report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF report_aging_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT entity_id, account_number, name, contact_name, null::text, null::date, 
       null::text, null::text, null::text, null::text, 
       sum(c0), sum(c30), sum(c60), sum(c90), null::date, null::int, curr,
       null::numeric, null::text[], null::int
  FROM report__invoice_aging_detail($1, $2, $3, $4, $5, $6)
 GROUP BY entity_id, account_number, name, contact_name, curr
 ORDER BY account_number
</programlisting>
      </para>
    </section>

<!-- Function report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean) -->
    <section id="lsmb14.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean"
             xreflabel="lsmb14report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)">
      <title id="lsmb14.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean-title">
       report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)
      </title>
      <titleabbrev id="lsmb14.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean-titleabbrev">
       report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF trial_balance_line</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a simple routine to generate trial balances for the full
company, for a project, or for a department.
        <programlisting>
DECLARE out_row trial_balance_line;
BEGIN
	IF in_department_id IS NULL THEN
		FOR out_row IN
			SELECT c.id, c.accno, c.description, 
				SUM(CASE WHEN ac.transdate &lt; in_datefrom 
				              AND c.category IN (&#39;I&#39;, &#39;L&#39;, &#39;Q&#39;)
				    THEN ac.amount
				    ELSE ac.amount * -1
				    END), 
			        SUM(CASE WHEN ac.transdate &gt;= in_date_from 
				              AND ac.amount &gt; 0 
			            THEN ac.amount
			            ELSE 0 END),
			        SUM(CASE WHEN ac.transdate &gt;= in_date_from 
				              AND ac.amount &lt; 0
			            THEN ac.amount
			            ELSE 0 END) * -1,
				SUM(CASE WHEN ac.transdate &gt;= in_date_from
					AND c.charttype IN (&#39;I&#39;)
				    THEN ac.amount
				    WHEN ac.transdate &gt;= in_date_from
				              AND c.category IN (&#39;I&#39;, &#39;L&#39;, &#39;Q&#39;)
				    THEN ac.amount
				    ELSE ac.amount * -1
				    END)
				FROM acc_trans ac
				JOIN (select id, approved FROM ap
					UNION ALL 
					select id, approved FROM gl
					UNION ALL
					select id, approved FROM ar) g
					ON (g.id = ac.trans_id)
				JOIN chart c ON (c.id = ac.chart_id)
				WHERE ac.transdate &lt;= in_date_to
					AND ac.approved AND g.approved
					AND (in_project_id IS NULL 
						OR in_project_id = ac.project_id)
				GROUP BY c.id, c.accno, c.description
				ORDER BY c.accno
				
		LOOP
			RETURN NEXT out_row;
		END LOOP;
	ELSE 
		FOR out_row IN
			SELECT 1
		LOOP
			RETURN NEXT out_row;
		END LOOP;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function save_taxform(in_taxform_name integer, in_country_code text) -->
    <section id="lsmb14.function.save-taxform-in-taxform-name-integer-in-country-code-text"
             xreflabel="lsmb14save_taxform(in_taxform_name integer, in_country_code text)">
      <title id="lsmb14.function.save-taxform-in-taxform-name-integer-in-country-code-text-title">
       save_taxform(in_taxform_name integer, in_country_code text)
      </title>
      <titleabbrev id="lsmb14.function.save-taxform-in-taxform-name-integer-in-country-code-text-titleabbrev">
       save_taxform(in_taxform_name integer, in_country_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves tax form information. Returns true or raises exception.
        <programlisting>
BEGIN
	INSERT INTO country_tax_form(country_id, form_name) 
	values (in_country_code, in_taxform_name);

	RETURN true;
END;
</programlisting>
      </para>
    </section>

<!-- Function session_check(in_token integer, in_session_id text) -->
    <section id="lsmb14.function.session-check-in-token-integer-in-session-id-text"
             xreflabel="lsmb14session_check(in_token integer, in_session_id text)">
      <title id="lsmb14.function.session-check-in-token-integer-in-session-id-text-title">
       session_check(in_token integer, in_session_id text)
      </title>
      <titleabbrev id="lsmb14.function.session-check-in-token-integer-in-session-id-text-titleabbrev">
       session_check(in_token integer, in_session_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>session</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a session row.  If no session exists, it returns null
        <programlisting>
DECLARE out_row session%ROWTYPE;
BEGIN
	DELETE FROM session
	 WHERE last_used &lt; now() - coalesce((SELECT value FROM defaults
                                    WHERE setting_key = &#39;session_timeout&#39;)::interval,
	                            &#39;90 minutes&#39;::interval);
        UPDATE session 
           SET last_used = now()
         WHERE session_id = in_session_id
               AND token = in_token
	       AND users_id = (select id from users 
			where username = SESSION_USER);
	IF FOUND THEN
		SELECT * INTO out_row FROM session WHERE session_id = in_session_id;
	ELSE
		DELETE FROM SESSION 
		WHERE users_id IN (select id from users
                        where username = SESSION_USER); 
		-- the above query also releases all discretionary locks by the
                -- session

               PERFORM * 
                  FROM defaults
                 WHERE setting_key = &#39;auto_logout&#39; and value = &#39;1&#39;;

                IF FOUND THEN
                    RAISE NOTICE &#39;auto logout&#39;;
                    RETURN NULL;
                ELSE
                    INSERT INTO session (users_id, token)
                    SELECT id, md5(random()::text)
                      FROM users 
                     WHERE username = SESSION_USER;

                    SELECT * INTO out_row FROM SESSION 
                     WHERE users_id = (select id from users
                                             where username = SESSION_USER);
                    RETURN out_row;
               END IF;
	END IF;
	RETURN out_row;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting__get_currencies() -->
    <section id="lsmb14.function.setting-get-currencies"
             xreflabel="lsmb14setting__get_currencies()">
      <title id="lsmb14.function.setting-get-currencies-title">
       setting__get_currencies()
      </title>
      <titleabbrev id="lsmb14.function.setting-get-currencies-titleabbrev">
       setting__get_currencies()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an array of currencies from the defaults table.
        <programlisting>
SELECT string_to_array(value, &#39;:&#39;) from defaults where setting_key = &#39;curr&#39;;
</programlisting>
      </para>
    </section>

<!-- Function setting__set(in_value character varying, in_setting_key character varying) -->
    <section id="lsmb14.function.setting-set-in-value-character-varying-in-setting-key-character-varying"
             xreflabel="lsmb14setting__set(in_value character varying, in_setting_key character varying)">
      <title id="lsmb14.function.setting-set-in-value-character-varying-in-setting-key-character-varying-title">
       setting__set(in_value character varying, in_setting_key character varying)
      </title>
      <titleabbrev id="lsmb14.function.setting-set-in-value-character-varying-in-setting-key-character-varying-titleabbrev">
       setting__set(in_value character varying, in_setting_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        sets a value in the defaults thable and returns true if successful.
        <programlisting>
BEGIN
	UPDATE defaults SET value = in_value WHERE setting_key = in_setting_key;
        IF NOT FOUND THEN
             INSERT INTO defaults (setting_key, value) 
                  VALUES (in_setting_key, in_value);
        END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_get(in_key character varying) -->
    <section id="lsmb14.function.setting-get-in-key-character-varying"
             xreflabel="lsmb14setting_get(in_key character varying)">
      <title id="lsmb14.function.setting-get-in-key-character-varying-title">
       setting_get(in_key character varying)
      </title>
      <titleabbrev id="lsmb14.function.setting-get-in-key-character-varying-titleabbrev">
       setting_get(in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>defaults</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the value of the setting in the defaults table.
        <programlisting>
SELECT * FROM defaults WHERE setting_key = $1;
</programlisting>
      </para>
    </section>

<!-- Function setting_get_default_accounts() -->
    <section id="lsmb14.function.setting-get-default-accounts"
             xreflabel="lsmb14setting_get_default_accounts()">
      <title id="lsmb14.function.setting-get-default-accounts-title">
       setting_get_default_accounts()
      </title>
      <titleabbrev id="lsmb14.function.setting-get-default-accounts-titleabbrev">
       setting_get_default_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF defaults</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of settings for default accounts.
        <programlisting>
DECLARE
	account defaults%ROWTYPE;
BEGIN
	FOR account IN 
		SELECT * FROM defaults 
		WHERE setting_key like &#39;%accno_id&#39;
                ORDER BY setting_key
	LOOP
		RETURN NEXT account;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_increment(in_key character varying) -->
    <section id="lsmb14.function.setting-increment-in-key-character-varying"
             xreflabel="lsmb14setting_increment(in_key character varying)">
      <title id="lsmb14.function.setting-increment-in-key-character-varying-title">
       setting_increment(in_key character varying)
      </title>
      <titleabbrev id="lsmb14.function.setting-increment-in-key-character-varying-titleabbrev">
       setting_increment(in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>character varying</seg>
        </seglistitem>
       </segmentedlist>
 
       This function takes a value for a sequence in the defaults table and increments
it.  Leading zeroes and spaces are preserved as placeholders.  Currently &lt;?lsmb
parsing is not supported in this routine though it may be added at a later date.

        <programlisting>
DECLARE
	base_value VARCHAR;
	raw_value VARCHAR;
	increment INTEGER;
	inc_length INTEGER;
	new_value VARCHAR;
BEGIN
	SELECT value INTO raw_value FROM defaults 
	WHERE setting_key = in_key
	FOR UPDATE;

	SELECT substring(raw_value from  &#39;(&#39; || E&#39;\\&#39; || &#39;d*)(&#39; || E&#39;\\&#39; || &#39;D*|&lt;&#39; || E&#39;\\&#39; || &#39;?lsmb [^&lt;&gt;] &#39; || E&#39;\\&#39; || &#39;?&gt;)*$&#39;)
	INTO base_value;

	IF base_value like &#39;0%&#39; THEN
		increment := base_value::integer + 1;
		SELECT char_length(increment::text) INTO inc_length;

		SELECT overlay(base_value placing increment::varchar
			from (select char_length(base_value) 
				- inc_length + 1) for inc_length)
		INTO new_value;
	ELSE
		new_value := base_value::integer + 1;
	END IF;
	SELECT regexp_replace(raw_value, base_value, new_value) INTO new_value;
	UPDATE defaults SET value = new_value WHERE setting_key = in_key;

	return new_value;	
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__get(in_form_id integer) -->
    <section id="lsmb14.function.tax-form-get-in-form-id-integer"
             xreflabel="lsmb14tax_form__get(in_form_id integer)">
      <title id="lsmb14.function.tax-form-get-in-form-id-integer-title">
       tax_form__get(in_form_id integer)
      </title>
      <titleabbrev id="lsmb14.function.tax-form-get-in-form-id-integer-titleabbrev">
       tax_form__get(in_form_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves specified tax form information from the database.
        <programlisting>
SELECT * FROM country_tax_form where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__list_all() -->
    <section id="lsmb14.function.tax-form-list-all"
             xreflabel="lsmb14tax_form__list_all()">
      <title id="lsmb14.function.tax-form-list-all-title">
       tax_form__list_all()
      </title>
      <titleabbrev id="lsmb14.function.tax-form-list-all-titleabbrev">
       tax_form__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of all tax forms, ordered by country_id and id
        <programlisting>
SELECT * FROM country_tax_form ORDER BY country_id, id;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__list_ext() -->
    <section id="lsmb14.function.tax-form-list-ext"
             xreflabel="lsmb14tax_form__list_ext()">
      <title id="lsmb14.function.tax-form-list-ext-title">
       tax_form__list_ext()
      </title>
      <titleabbrev id="lsmb14.function.tax-form-list-ext-titleabbrev">
       tax_form__list_ext()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF taxform_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of tax forms with an added field, country_name, to specify the
name of the country.
        <programlisting>
SELECT t.id, t.form_name, t.country_id, c.name, t.default_reportable
  FROM country_tax_form t
  JOIN country c ON c.id = t.country_id
 ORDER BY c.name, t.form_name;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean) -->
    <section id="lsmb14.function.tax-form-save-in-default-reportable-integer-in-form-name-integer-in-country-id-text-in-id-boolean"
             xreflabel="lsmb14tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean)">
      <title id="lsmb14.function.tax-form-save-in-default-reportable-integer-in-form-name-integer-in-country-id-text-in-id-boolean-title">
       tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean)
      </title>
      <titleabbrev id="lsmb14.function.tax-form-save-in-default-reportable-integer-in-form-name-integer-in-country-id-text-in-id-boolean-titleabbrev">
       tax_form__save(in_default_reportable integer, in_form_name integer, in_country_id text, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves tax form information to the database.
        <programlisting>
BEGIN
        UPDATE country_tax_form 
           SET country_id = in_country_id,
               form_name =in_form_name,
               default_reportable = coalesce(in_default_reportable,false)
         WHERE id = in_id;

        IF FOUND THEN
           RETURN in_id;
        END IF;

	insert into country_tax_form(country_id,form_name, default_reportable) 
	values (in_country_id, in_form_name, 
                coalesce(in_default_reportable, false));

	RETURN currval(&#39;country_tax_form_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text) -->
    <section id="lsmb14.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text"
             xreflabel="lsmb14tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)">
      <title id="lsmb14.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-title">
       tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </title>
      <titleabbrev id="lsmb14.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-titleabbrev">
       tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_detail_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides a list of invoices and transactions that a report hits.  This 
is intended to allow an organization to adjust what is reported on the 1099 
before printing them.
        <programlisting>
DECLARE
	out_row tax_form_report_detail_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 then 0 
                              when relation = &#39;acc_trans&#39;
                          THEN ac.reportable_amount * pmt.amount
                                / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 then 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount * pmt.amount
                               / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     SUM(CASE WHEN gl.amount = 0 THEN 0 
                              ELSE ac.reportable_amount * pmt.amount
                               / gl.amount 
                              END
                         * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end 
                         * CASE WHEN relation = &#39;invoice&#39; THEN -1 ELSE 1 END),
                     gl.invnumber, gl.duedate::text, gl.id
                FROM (select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ar&#39; as class
                        FROM ar 
                       UNION 
                      select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ap&#39; as class
                        FROM ap
                     ) gl 
                JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                   LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                   LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id)
		JOIN entity_credit_account ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
                JOIN (SELECT ac.trans_id, sum(ac.amount) as amount,
                             as_array(entry_id) as entry_ids, 
                             as_array(chart_id) as chart_ids,
                             count(*) as num
                        FROM acc_trans ac
                       where chart_id in (select account_id
                                            from account_link
                                           where description like &#39;%paid&#39;)
                          AND transdate BETWEEN in_begin AND in_end
                     group by ac.trans_id
                     ) pmt ON  (pmt.trans_id = gl.id)
		WHERE country_tax_form.id = in_tax_form_id AND meta_number = in_meta_number
		GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, gl.invnumber, gl.duedate, gl.id, entity_credit_account.id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date) -->
    <section id="lsmb14.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date"
             xreflabel="lsmb14tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)">
      <title id="lsmb14.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date-title">
       tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)
      </title>
      <titleabbrev id="lsmb14.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date-titleabbrev">
       tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       This provides the total reportable value per vendor.  As per 1099 forms, these
are cash-basis documents and show amounts paid.
        <programlisting>
DECLARE
	out_row tax_form_report_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;acc_trans&#39; 
                          THEN ac.reportable_amount * pmt.amount
                                / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount * pmt.amount
                               / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                          ELSE ac.reportable_amount * pmt.amount
                                / gl.amount
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end
                      * CASE WHEN ac.relation = &#39;invoice&#39; then -1 else 1 end)
                         
		FROM (select id, transdate, entity_credit_account, invoice, 
                             amount, &#39;ar&#39; as class FROM ar 
                       UNION 
                      select id, transdate, entity_credit_account, invoice, 
                              amount, &#39;ap&#39; as class from ap
                     ) gl
               JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                    LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                    LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id 
                             AND ((gl.invoice is true and ac.relation=&#39;invoice&#39;)
                                  OR (gl.invoice is false 
                                     and ac.relation=&#39;acc_trans&#39;)))
                JOIN (SELECT ac.trans_id, sum(ac.amount) as amount,
                             as_array(entry_id) as entry_ids, 
                             as_array(chart_id) as chart_ids,
                             count(*) as num
                        FROM acc_trans ac
                       where chart_id in (select account_id
                                            from account_link
                                           where description like &#39;%paid&#39;)
                          AND transdate BETWEEN in_begin AND in_end
                     group by ac.trans_id
                     ) pmt ON  (pmt.trans_id = gl.id)
		JOIN entity_credit_account 
                  ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
               WHERE country_tax_form.id = in_tax_form_id
             GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, entity_credit_account.id
    LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tg_enforce_perms_eclass() -->
    <section id="lsmb14.function.tg-enforce-perms-eclass"
             xreflabel="lsmb14tg_enforce_perms_eclass()">
      <title id="lsmb14.function.tg-enforce-perms-eclass-title">
       tg_enforce_perms_eclass()
      </title>
      <titleabbrev id="lsmb14.function.tg-enforce-perms-eclass-titleabbrev">
       tg_enforce_perms_eclass()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
   r_eclass entity_class;
   roll_pfx text;
BEGIN
IF TG_OP = &#39;DELETE&#39; THEN
   RETURN OLD;
ELSE 
   SELECT value INTO roll_pfx FROM defaults WHERE setting_key = &#39;roll_prefix&#39;;
   SELECT * INTO r_eclass from entity_class WHERE id = NEW.entity_class;
   IF pg_has_role(SESSION_USER, coalesce(roll_pfx, 
                                         &#39;lsmb_&#39; || current_database() || &#39;__&#39;)
                                || &#39;contact_class_&#39; || lower(regexp_replace(
                                                        r_eclass.class, 
                                                        &#39; &#39;, 
                                                        &#39;_&#39;)), &#39;USAGE&#39;)
   THEN
      RETURN NEW;
   ELSE
      RAISE EXCEPTION &#39;Access Denied for class&#39;;
   END IF;
END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function to_args(in_args text[], in_base text[]) -->
    <section id="lsmb14.function.to-args-in-args-textARRAY-in-base-textARRAY"
             xreflabel="lsmb14to_args(in_args text[], in_base text[])">
      <title id="lsmb14.function.to-args-in-args-textARRAY-in-base-textARRAY-title">
       to_args(in_args text[], in_base text[])
      </title>
      <titleabbrev id="lsmb14.function.to-args-in-args-textARRAY-in-base-textARRAY-titleabbrev">
       to_args(in_args text[], in_base text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes two arguments.  The first is a one-dimensional array 
representing the  base state of the argument array.  The second is a two 
element array of {key, value}.

If either of the args is null, it returns the first argument.  Otherwise it 
returns the first initial array, concatenated with key || &apos;=&apos; || value.

It primarily exists for the to_args aggregate.

        <programlisting>
SELECT CASE WHEN $2[1] IS NULL OR $2[2] IS NULL THEN $1 
            ELSE $1 || ($2[1]::text || &#39;=&#39; || $2[2]::text)
       END;
</programlisting>
      </para>
    </section>

<!-- Function to_args(text[]) -->
    <section id="lsmb14.function.to-args-textARRAY"
             xreflabel="lsmb14to_args(text[])">
      <title id="lsmb14.function.to-args-textARRAY-title">
       to_args(text[])
      </title>
      <titleabbrev id="lsmb14.function.to-args-textARRAY-titleabbrev">
       to_args(text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
        Turns a setof ARRAY[key,value] into an 
ARRAY[key||&apos;=&apos;||value, key||&apos;=&apos;||value,...]

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function track_global_sequence() -->
    <section id="lsmb14.function.track-global-sequence"
             xreflabel="lsmb14track_global_sequence()">
      <title id="lsmb14.function.track-global-sequence-title">
       track_global_sequence()
      </title>
      <titleabbrev id="lsmb14.function.track-global-sequence-titleabbrev">
       track_global_sequence()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This trigger is used to track the id sequence entries across the 
transactions table, and with the ar, ap, and gl tables.  This is necessary 
because these have not been properly refactored yet.

        <programlisting>
BEGIN
	IF tg_op = &#39;INSERT&#39; THEN
		INSERT INTO transactions (id, table_name, approved) 
		VALUES (new.id, TG_RELNAME, new.approved);
	ELSEIF tg_op = &#39;UPDATE&#39; THEN
		IF new.id = old.id AND new.approved = old.approved THEN
			return new;
		ELSE
			UPDATE transactions SET id = new.id, 
                                                approved = new.approved
                         WHERE id = old.id;
		END IF;
	ELSE 
		DELETE FROM transactions WHERE id = old.id;
	END IF;
	RETURN new;
END;
</programlisting>
      </para>
    </section>

<!-- Function trigger_parts_short() -->
    <section id="lsmb14.function.trigger-parts-short"
             xreflabel="lsmb14trigger_parts_short()">
      <title id="lsmb14.function.trigger-parts-short-title">
       trigger_parts_short()
      </title>
      <titleabbrev id="lsmb14.function.trigger-parts-short-titleabbrev">
       trigger_parts_short()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  IF NEW.onhand &gt;= NEW.rop THEN
    NOTIFY parts_short;
  END IF;
  RETURN NEW;
END;
</programlisting>
      </para>
    </section>

<!-- Function unlock(in_id integer) -->
    <section id="lsmb14.function.unlock-in-id-integer"
             xreflabel="lsmb14unlock(in_id integer)">
      <title id="lsmb14.function.unlock-in-id-integer-title">
       unlock(in_id integer)
      </title>
      <titleabbrev id="lsmb14.function.unlock-in-id-integer-titleabbrev">
       unlock(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Releases a pessimistic locks against a transaction, if that transaciton, as 
identified by in_id exists, and if  it is locked by the current session. 
These locks are again only advisory, and the application may choose to handle 
them or not.

Returns true if the transaction was unlocked by this routine, false 
otherwise.
        <programlisting>
BEGIN
    UPDATE transactions SET locked_by = NULL WHERE id = in_id 
           AND locked_by IN (SELECT session_id FROM session WHERE users_id =
		(SELECT id FROM users WHERE username = SESSION_USER));
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function unlock_all() -->
    <section id="lsmb14.function.unlock-all"
             xreflabel="lsmb14unlock_all()">
      <title id="lsmb14.function.unlock-all-title">
       unlock_all()
      </title>
      <titleabbrev id="lsmb14.function.unlock-all-titleabbrev">
       unlock_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Releases all pessimistic locks against transactions.  These locks are again
only advisory, and the application may choose to handle them or not.

Returns true if any transactions were unlocked, false otherwise.
        <programlisting>
BEGIN
    UPDATE transactions SET locked_by = NULL 
    where locked_by IN 
          (select session_id from session WHERE users_id = 
                  (SELECT id FROM users WHERE username = SESSION_USER));

    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__change_password(in_new_password text) -->
    <section id="lsmb14.function.user-change-password-in-new-password-text"
             xreflabel="lsmb14user__change_password(in_new_password text)">
      <title id="lsmb14.function.user-change-password-in-new-password-text-title">
       user__change_password(in_new_password text)
      </title>
      <titleabbrev id="lsmb14.function.user-change-password-in-new-password-text-titleabbrev">
       user__change_password(in_new_password text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Alloes a user to change his or her own password.  The password is set to 
expire setting_get(&apos;password_duration&apos;) days after the password change.
        <programlisting>
DECLARE
	t_expires timestamp;
        t_password_duration text;
BEGIN
    SELECT value INTO t_password_duration FROM defaults 
     WHERE setting_key = &#39;password_duration&#39;;
    IF t_password_duration IS NULL or t_password_duration=&#39;&#39; THEN
        t_expires := &#39;infinity&#39;;
    ELSE
        t_expires := now() 
                     + (t_password_duration::numeric::text || &#39; days&#39;)::interval;
    END IF;


    UPDATE users SET notify_password = DEFAULT where username = SESSION_USER;

    EXECUTE &#39;ALTER USER &#39; || quote_ident(SESSION_USER) || 
            &#39; with ENCRYPTED password &#39; || quote_literal(in_new_password) ||
                 &#39; VALID UNTIL &#39;|| quote_literal(t_expires);
    return 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__check_my_expiration() -->
    <section id="lsmb14.function.user-check-my-expiration"
             xreflabel="lsmb14user__check_my_expiration()">
      <title id="lsmb14.function.user-check-my-expiration-title">
       user__check_my_expiration()
      </title>
      <titleabbrev id="lsmb14.function.user-check-my-expiration-titleabbrev">
       user__check_my_expiration()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>interval</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the time when password of the current logged in user is set to 
expire.
        <programlisting>
DECLARE
    outval interval;
BEGIN
    SELECT CASE WHEN isfinite(rolvaliduntil) is not true THEN &#39;1 year&#39;::interval
                ELSE rolvaliduntil - now() END AS expiration INTO outval 
    FROM pg_roles WHERE rolname = SESSION_USER;
    RETURN outval;
end;
</programlisting>
      </para>
    </section>

<!-- Function user__expires_soon() -->
    <section id="lsmb14.function.user-expires-soon"
             xreflabel="lsmb14user__expires_soon()">
      <title id="lsmb14.function.user-expires-soon-title">
       user__expires_soon()
      </title>
      <titleabbrev id="lsmb14.function.user-expires-soon-titleabbrev">
       user__expires_soon()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the password of the current logged in user is set to expire 
within on week.
        <programlisting>
   SELECT user__check_my_expiration() &lt; &#39;1 week&#39;;
</programlisting>
      </para>
    </section>

<!-- Function user__get_all_users() -->
    <section id="lsmb14.function.user-get-all-users"
             xreflabel="lsmb14user__get_all_users()">
      <title id="lsmb14.function.user-get-all-users-title">
       user__get_all_users()
      </title>
      <titleabbrev id="lsmb14.function.user-get-all-users-titleabbrev">
       user__get_all_users()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF user_listable</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    select * from user_listable;
    
</programlisting>
      </para>
    </section>

<!-- Function user__get_preferences(in_user_id integer) -->
    <section id="lsmb14.function.user-get-preferences-in-user-id-integer"
             xreflabel="lsmb14user__get_preferences(in_user_id integer)">
      <title id="lsmb14.function.user-get-preferences-in-user-id-integer-title">
       user__get_preferences(in_user_id integer)
      </title>
      <titleabbrev id="lsmb14.function.user-get-preferences-in-user-id-integer-titleabbrev">
       user__get_preferences(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF user_preference</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the preferences row for the user.
        <programlisting>
    
declare
    v_row user_preference;
BEGIN
    select * into v_row from user_preference where id = in_user_id;
    
    IF NOT FOUND THEN
    
        RAISE EXCEPTION &#39;Could not find user preferences for id %&#39;, in_user_id;
    ELSE
        return next v_row;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text) -->
    <section id="lsmb14.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text"
             xreflabel="lsmb14user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)">
      <title id="lsmb14.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text-title">
       user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)
      </title>
      <titleabbrev id="lsmb14.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text-titleabbrev">
       user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves user preferences.  Returns true if successful, false if no preferences
were found to update.
        <programlisting>
BEGIN
    UPDATE user_preference
    SET dateformat = in_dateformat,
        numberformat = in_numberformat,
        language = in_language,
        stylesheet = in_stylesheet,
        printer = in_printer
    WHERE id = (select id from users where username = SESSION_USER);
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher__delete(in_voucher_id integer) -->
    <section id="lsmb14.function.voucher-delete-in-voucher-id-integer"
             xreflabel="lsmb14voucher__delete(in_voucher_id integer)">
      <title id="lsmb14.function.voucher-delete-in-voucher-id-integer-title">
       voucher__delete(in_voucher_id integer)
      </title>
      <titleabbrev id="lsmb14.function.voucher-delete-in-voucher-id-integer-titleabbrev">
       voucher__delete(in_voucher_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the specified voucher from the batch.
        <programlisting>
DECLARE 
	voucher_row RECORD;
BEGIN
	SELECT * INTO voucher_row FROM voucher WHERE id = in_voucher_id;
	IF voucher_row.batch_class IN (1, 2, 5) THEN
        DELETE FROM ac_tax_form WHERE entry_id IN (
               SELECT entry_id
                 FROM acc_trans
               WHERE trans_id = voucher_row.trans_id);
 
		DELETE FROM acc_trans WHERE trans_id = voucher_row.trans_id;
		DELETE FROM ar WHERE id = voucher_row.trans_id;
		DELETE FROM ap WHERE id = voucher_row.trans_id;
		DELETE FROM gl WHERE id = voucher_row.trans_id;
		DELETE FROM voucher WHERE id = voucher_row.id;
		-- DELETE FROM transactions WHERE id = voucher_row.trans_id;
	ELSE 
		update ar set paid = amount + 
			(select sum(amount) from acc_trans 
			join chart ON (acc_trans.chart_id = chart.id)
			where link = &#39;AR&#39; AND trans_id = ar.id
				AND (voucher_id IS NULL 
				OR voucher_id &lt;&gt; voucher_row.id))
		where id in (select trans_id from acc_trans 
				where voucher_id = voucher_row.id);

		update ap set paid = amount - (select sum(amount) from acc_trans 
			join chart ON (acc_trans.chart_id = chart.id)
			where link = &#39;AP&#39; AND trans_id = ap.id
				AND (voucher_id IS NULL 
				OR voucher_id &lt;&gt; voucher_row.id))
		where id in (select trans_id from acc_trans 
				where voucher_id = voucher_row.id);
                DELETE FROM ac_tax_form WHERE entry_id IN
                       (select entry_id from acc_trans 
                         where voucher_id = voucher_row.id);

		DELETE FROM acc_trans where voucher_id = voucher_row.id;
	END IF;
	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher__list(in_batch_id integer) -->
    <section id="lsmb14.function.voucher-list-in-batch-id-integer"
             xreflabel="lsmb14voucher__list(in_batch_id integer)">
      <title id="lsmb14.function.voucher-list-in-batch-id-integer-title">
       voucher__list(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb14.function.voucher-list-in-batch-id-integer-titleabbrev">
       voucher__list(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF voucher_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a list of vouchers and amounts attached to the batch.
        <programlisting>
declare voucher_item record;
BEGIN
    	FOR voucher_item IN
		SELECT v.id, a.invoice, a.invnumber, e.name, 
			v.batch_id, v.trans_id, 
			a.amount, a.transdate, &#39;Payable&#39;
		FROM voucher v
		JOIN ap a ON (v.trans_id = a.id)
		JOIN entity_credit_account eca 
			ON (eca.id = a.entity_credit_account)
		JOIN entity e ON (eca.entity_id = e.id)
		WHERE v.batch_id = in_batch_id 
			AND v.batch_class = (select id from batch_class 
					WHERE class = &#39;ap&#39;)
		UNION
		SELECT v.id, a.invoice, a.invnumber, e.name, 
			v.batch_id, v.trans_id, 
			a.amount, a.transdate, &#39;Receivable&#39;
		FROM voucher v
		JOIN ar a ON (v.trans_id = a.id)
		JOIN entity_credit_account eca 
			ON (eca.id = a.entity_credit_account)
		JOIN entity e ON (eca.entity_id = e.id)
		WHERE v.batch_id = in_batch_id 
			AND v.batch_class = (select id from batch_class 
					WHERE class = &#39;ar&#39;)
		UNION ALL
		-- TODO:  Add the class labels to the class table.
		SELECT v.id, false, a.source, 
			cr.meta_number || &#39;--&#39;  || co.legal_name , 
			v.batch_id, v.trans_id, 
			sum(CASE WHEN bc.class LIKE &#39;payment%&#39; THEN a.amount * -1
			     ELSE a.amount  END), a.transdate, 
			CASE WHEN bc.class = &#39;payment&#39; THEN &#39;Payment&#39;
			     WHEN bc.class = &#39;payment_reversal&#39; 
			     THEN &#39;Payment Reversal&#39;
			END
		FROM voucher v
		JOIN acc_trans a ON (v.id = a.voucher_id)
                JOIN batch_class bc ON (bc.id = v.batch_class)
		JOIN chart c ON (a.chart_id = c.id)
		JOIN ap ON (ap.id = a.trans_id)
		JOIN entity_credit_account cr 
			ON (ap.entity_credit_account = cr.id)
		JOIN company co ON (cr.entity_id = co.entity_id)
		WHERE v.batch_id = in_batch_id 
			AND a.voucher_id = v.id
			AND (bc.class like &#39;payment%&#39; AND c.link = &#39;AP&#39;)
		GROUP BY v.id, a.source, cr.meta_number, co.legal_name ,
                        v.batch_id, v.trans_id, a.transdate, bc.class

		UNION ALL
		SELECT v.id, false, a.source, a.memo, 
			v.batch_id, v.trans_id, 
			CASE WHEN bc.class LIKE &#39;receipt%&#39; THEN sum(a.amount) * -1
			     ELSE sum(a.amount)  END, a.transdate, 
			CASE WHEN bc.class = &#39;receipt&#39; THEN &#39;Receipt&#39;
			     WHEN bc.class = &#39;receipt_reversal&#39; 
			     THEN &#39;Receipt Reversal&#39;
			END
		FROM voucher v
		JOIN acc_trans a ON (v.id = a.voucher_id)
                JOIN batch_class bc ON (bc.id = v.batch_class)
		JOIN chart c ON (a.chart_id = c.id)
		JOIN ar ON (ar.id = a.trans_id)
		JOIN entity_credit_account cr 
			ON (ar.entity_credit_account = cr.id)
		JOIN company co ON (cr.entity_id = co.entity_id)
		WHERE v.batch_id = in_batch_id 
			AND a.voucher_id = v.id
			AND (bc.class like &#39;receipt%&#39; AND c.link = &#39;AR&#39;)
		GROUP BY v.id, a.source, cr.meta_number, co.legal_name ,
                        a.memo, v.batch_id, v.trans_id, a.transdate, bc.class
		UNION ALL
		SELECT v.id, false, g.reference, g.description, 
			v.batch_id, v.trans_id,
			sum(a.amount), g.transdate, &#39;GL&#39;
		FROM voucher v
		JOIN gl g ON (g.id = v.trans_id)
		JOIN acc_trans a ON (v.trans_id = a.trans_id)
		WHERE a.amount &gt; 0
			AND v.batch_id = in_batch_id
			AND v.batch_class IN (select id from batch_class 
					where class = &#39;gl&#39;)
		GROUP BY v.id, g.reference, g.description, v.batch_id, 
			v.trans_id, g.transdate
		ORDER BY 7, 1
	LOOP
		RETURN NEXT voucher_item;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher_get_batch(in_batch_id integer) -->
    <section id="lsmb14.function.voucher-get-batch-in-batch-id-integer"
             xreflabel="lsmb14voucher_get_batch(in_batch_id integer)">
      <title id="lsmb14.function.voucher-get-batch-in-batch-id-integer-title">
       voucher_get_batch(in_batch_id integer)
      </title>
      <titleabbrev id="lsmb14.function.voucher-get-batch-in-batch-id-integer-titleabbrev">
       voucher_get_batch(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>batch</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves basic batch information based on batch_id.
        <programlisting>
DECLARE
	batch_out batch%ROWTYPE;
BEGIN
	SELECT * INTO batch_out FROM batch b WHERE b.id = in_batch_id;
	RETURN batch_out;
END;
</programlisting>
      </para>
    </section>

<!-- Function warehouse__list_all() -->
    <section id="lsmb14.function.warehouse-list-all"
             xreflabel="lsmb14warehouse__list_all()">
      <title id="lsmb14.function.warehouse-list-all-title">
       warehouse__list_all()
      </title>
      <titleabbrev id="lsmb14.function.warehouse-list-all-titleabbrev">
       warehouse__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF warehouse</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM warehouse order by description;
</programlisting>
      </para>
    </section>

  </chapter>

  <chapter id="public.schema"
           xreflabel="public">
    <title>Schema public</title>
    <para></para>


      <section id="public.table.ac-tax-form"
               xreflabel="public.ac_tax_form">
        <title id="public.table.ac-tax-form-title">
         Table:
         
         <structname>ac_tax_form</structname>
        </title>
 

        <para>
           Mapping journal_line to country_tax_form for reporting purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ac_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.acc-trans"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.acc-trans"
               xreflabel="public.acc_trans">
        <title id="public.table.acc-trans-title">
         Table:
         
         <structname>acc_trans</structname>
        </title>
 

        <para>
          This table stores line items for financial transactions.  Please note that
payments in 1.3 are not full-fledged transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>acc_trans</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Document Source identifier for individual line items, usually used 
for payments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fx_transaction</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>memo</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reconciled_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.voucher"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on acc_trans</title>

          <varlistentry>
            <term>ac_transdate_year_idx</term>
            <listitem><para>date_part(&apos;YEAR&apos;::text, transdate)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>acc_trans_voucher_id_idx</term>
            <listitem><para>voucher_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.ac_tax_form via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.ac-tax-form"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-ac"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payment-links"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.account"
               xreflabel="public.account">
        <title id="public.table.account-title">
         Table:
         
         <structname>account</structname>
        </title>
 

        <para>
           This table stores the main account info.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_temp</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 Only affects equity accounts.  If set, close at end of year. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>category</structfield></term>
              <listitem><para>
                <type>character(1)</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gifi_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>heading</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contra</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.account-checkpoint"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.account-link"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.budget-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.cr-coa-to-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.cr-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.parts"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.partstax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-deduction-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-income-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.trial-balance-account-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.account-checkpoint"
               xreflabel="public.account_checkpoint">
        <title id="public.table.account-checkpoint-title">
         Table:
         
         <structname>account_checkpoint</structname>
        </title>
 

        <para>
           This table holds account balances at various dates.  Transactions MUST NOT
be posted prior to the latest end_date in this table, and no unapproved 
transactions (vouchers or drafts) can remain in the closed period.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_checkpoint</structname>
            </title>


            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>debits</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credits</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.account-heading"
               xreflabel="public.account_heading">
        <title id="public.table.account-heading-title">
         Table:
         
         <structname>account_heading</structname>
        </title>
 

        <para>
          
This table holds the account headings in the system.  Each account must belong 
to a heading, and a heading can belong to another heading.  In this way it is 
possible to nest accounts for reporting purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_heading</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.account-heading"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.trial-balance-heading-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.account-link"
               xreflabel="public.account_link">
        <title id="public.table.account-link-title">
         Table:
         
         <structname>account_link</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_link</structname>
            </title>


            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account-link-description"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.account-link-description"
               xreflabel="public.account_link_description">
        <title id="public.table.account-link-description-title">
         Table:
         
         <structname>account_link_description</structname>
        </title>
 

        <para>
           This is a lookup table which provide basic information as to categories and
dropdowns of accounts.  In general summary accounts cannot belong to more than 
one category (an AR summary account cannot appear in other dropdowns for 
example).  Custom fields are not overwritten when the account is edited from
the front-end.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>account_link_description</structname>
            </title>


            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>summary</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>custom</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.account_link via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.account-link"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.ap"
               xreflabel="public.ap">
        <title id="public.table.ap-title">
         Table:
         
         <structname>ap</structname>
        </title>
 

        <para>
           Summary/header information for AP transactions and vendor invoices.
Note that some constraints here are hard to enforce because we haven not gotten 
to rewriting the relevant code here.
HV TODO drop entity_id

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ap</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Text identifier for the invoice.  Must be unique.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 This stores the total amount (including taxes) for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 Total amount excluding taxes for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>paid</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>datepaid</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>duedate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 True if the transaction tracks goods/services purchase using the invoice
table.  False otherwise.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

              <para>
                 3 letters to identify the currency.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are displayed on the invoice when printed or emailed
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

              <para>
                Person who created the transaction
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>till</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Quotation Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are not displayed when the invoice is printed or emailed and
may be updated without reposting hte invocie.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Purchase Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

              <para>
                Only show in financial reports if true.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                If true numbers are displayed after multiplying by -1
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

              <para>
                 Not exposed to the UI, but can be set to prevent an invoice from showing up
for payment or in outstanding reports.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

              <para>
                 reference for the vendor account used.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on ap</title>

          <varlistentry>
            <term>ap_check</term>
            <listitem><para>CHECK ((((amount IS NULL) AND (curr IS NULL)) OR ((amount IS NOT NULL) AND (curr IS NOT NULL))))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.ar"
               xreflabel="public.ar">
        <title id="public.table.ar-title">
         Table:
         
         <structname>ar</structname>
        </title>
 

        <para>
           Summary/header information for AR transactions and sales invoices.
Note that some constraints here are hard to enforce because we haven not gotten 
to rewriting the relevant code here.
HV TODO drop entity_id

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>ar</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invnumber</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>










              </para>

              <para>
                 Text identifier for the invoice.  Must be unique.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 This stores the total amount (including taxes) for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                 Total amount excluding taxes for the transaction.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>paid</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>datepaid</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>duedate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 True if the transaction tracks goods/services purchase using the invoice
table.  False otherwise.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are displayed on the invoice when printed or emailed
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

              <para>
                 3 letters to identify the currency.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

              <para>
                Person who created the transaction
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>till</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Quotation Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                These notes are not displayed when the invoice is printed or emailed and
may be updated without reposting hte invocie.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Purchase Order Number
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                If true numbers are displayed after multiplying by -1
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

              <para>
                Only show in financial reports if true.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

              <para>
                 reference for the customer account used.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

              <para>
                 Not exposed to the UI, but can be set to prevent an invoice from showing up
for payment or in outstanding reports.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_return</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on ar</title>

          <varlistentry>
            <term>ar_check</term>
            <listitem><para>CHECK ((((amount IS NULL) AND (curr IS NULL)) OR ((amount IS NOT NULL) AND (curr IS NOT NULL))))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.assembly"
               xreflabel="public.assembly">
        <title id="public.table.assembly-title">
         Table:
         
         <structname>assembly</structname>
        </title>
 

        <para>
          Holds mapping for parts that are members of assemblies.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>assembly</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>




              </para>

              <para>
                This is the id of the assembly the part is being mapped to.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>




              </para>

              <para>
                ID of part that is a member of the assembly.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bom</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>adj</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on assembly</title>

          <varlistentry>
            <term>assembly_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.asset-class"
               xreflabel="public.asset_class">
        <title id="public.table.asset-class-title">
         Table:
         
         <structname>asset_class</structname>
        </title>
 

        <para>
          
The account fields here set the defaults for the individual asset items.  They
are non-authoritative.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dep_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>method</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-dep-method"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.asset-dep-method"
               xreflabel="public.asset_dep_method">
        <title id="public.table.asset-dep-method-title">
         Table:
         
         <structname>asset_dep_method</structname>
        </title>
 

        <para>
           Stores asset depreciation methods, and their relevant stored procedures.

The fixed asset system is such depreciation methods can be plugged in via this
table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_dep_method</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>method</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 These are keyed to specific stored procedures.  Currently only &quot;straight_line&quot; is supported
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sproc</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                The sproc mentioned here is a stored procedure which must have the following
arguments: (in_asset_ids int[],  in_report_date date, in_report_id int).

Here in_asset_ids are the assets to be depreciated, in_report_date is the date
of the report, and in_report_id is the id of the report.  The sproc MUST
insert the relevant lines into asset_report_line. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit_label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_name</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.asset-unit-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_class via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-class"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.asset-disposal-method"
               xreflabel="public.asset_disposal_method">
        <title id="public.table.asset-disposal-method-title">
         Table:
         
         <structname>asset_disposal_method</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_disposal_method</structname>
            </title>


            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>multiple</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_label</structfield></term>
              <listitem><para>
                <type>character(1)</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on asset_disposal_method</title>

          <varlistentry>
            <term>asset_disposal_method_multiple_check</term>
            <listitem><para>CHECK ((multiple = ANY (ARRAY[1, 0, (-1)])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_rl_to_disposal_method via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.asset-item"
               xreflabel="public.asset_item">
        <title id="public.table.asset-item-title">
         Table:
         
         <structname>asset_item</structname>
        </title>
 

        <para>
           Stores details of asset items.  The account fields here are authoritative,
while the ones in the asset_class table are defaults.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_item</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tag</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

              <para>
                 This can be plugged into other routines to generate it automatically via ALTER TABLE .... SET DEFAULT.....
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>purchase_value</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salvage_value</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>usable_life</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>purchase_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_depreciation</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.warehouse"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.eca-invoice"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dep_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>exp_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_by</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>









                <literal>REFERENCES</literal> <xref linkend="public.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.asset-note"
               xreflabel="public.asset_note">
        <title id="public.table.asset-note-title">
         Table:
         
         <structname>asset_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 4</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.asset-item"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on asset_note</title>

          <varlistentry>
            <term>asset_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 4))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.asset-report"
               xreflabel="public.asset_report">
        <title id="public.table.asset-report-title">
         Table:
         
         <structname>asset_report</structname>
        </title>
 

        <para>
           Asset reports are discrete sets of depreciation or disposal transctions,
and each one may be turned into no more than one GL transaction.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gl_id</structfield></term>
              <listitem><para>
                <type>bigint</type>








                      <literal>UNIQUE</literal>









                <literal>REFERENCES</literal> <xref linkend="public.table.journal-entry"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_class</structfield></term>
              <listitem><para>
                <type>bigint</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_class</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-report-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>bigint</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>bigint</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>depreciated_qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dont_approve</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>submitted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-rl-to-disposal-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.asset-report-class"
               xreflabel="public.asset_report_class">
        <title id="public.table.asset-report-class-title">
         Table:
         
         <structname>asset_report_class</structname>
        </title>
 

        <para>
            By default only four types of asset reports are supported.  In the future
others may be added.  Please correspond on the list before adding more types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.asset-report-line"
               xreflabel="public.asset_report_line">
        <title id="public.table.asset-report-line-title">
         Table:
         
         <structname>asset_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>asset_id</structfield></term>
              <listitem><para>
                <type>bigint</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>bigint</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.asset-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>department_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

              <para>
                 In case assets are moved between departments, we have to store this here.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>warehouse_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.warehouse"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.asset-rl-to-disposal-method"
               xreflabel="public.asset_rl_to_disposal_method">
        <title id="public.table.asset-rl-to-disposal-method-title">
         Table:
         
         <structname>asset_rl_to_disposal_method</structname>
        </title>
 

        <para>
           Maps disposal method to line items in the asset disposal report.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_rl_to_disposal_method</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.asset-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>asset_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-item"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>disposal_method_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.asset-disposal-method"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>percent_disposed</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.asset-unit-class"
               xreflabel="public.asset_unit_class">
        <title id="public.table.asset-unit-class-title">
         Table:
         
         <structname>asset_unit_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>asset_unit_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_dep_method via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-dep-method"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.audittrail"
               xreflabel="public.audittrail">
        <title id="public.table.audittrail-title">
         Table:
         
         <structname>audittrail</structname>
        </title>
 

        <para>
           This stores information on who entered or updated rows in the ar, ap, or gl
tables.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>audittrail</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tablename</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>action</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on audittrail</title>

          <varlistentry>
            <term>audittrail_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.batch"
               xreflabel="public.batch">
        <title id="public.table.batch-title">
         Table:
         
         <structname>batch</structname>
        </title>
 

        <para>
           Stores batch header info.  Batches are groups of vouchers that are posted
together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>batch</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.batch-class"/>


              </para>

              <para>
                 Note that this field is largely used for sorting the vouchers.  A given batch is NOT restricted to this type.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_on</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.session"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_on</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on batch</title>

          <varlistentry>
            <term>batch_control_code_check</term>
            <listitem><para>CHECK ((length(control_code) &gt; 0))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.voucher via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.batch-class"
               xreflabel="public.batch_class">
        <title id="public.table.batch-class-title">
         Table:
         
         <structname>batch_class</structname>
        </title>
 

        <para>
           These values are hard-coded.  Please coordinate before adding standard
values. Values from 900 to 999 are reserved for local use.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>batch_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.batch via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.bu-class-to-module"
               xreflabel="public.bu_class_to_module">
        <title id="public.table.bu-class-to-module-title">
         Table:
         
         <structname>bu_class_to_module</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>bu_class_to_module</structname>
            </title>


            <varlistentry>
              <term><structfield>bu_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>module_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.lsmb-module"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.budget-info"
               xreflabel="public.budget_info">
        <title id="public.table.budget-info-title">
         Table:
         
         <structname>budget_info</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_info</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on budget_info</title>

          <varlistentry>
            <term>budget_info_check</term>
            <listitem><para>CHECK ((start_date &lt; end_date))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.budget_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.budget-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.budget-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.budget-to-business-unit"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.budget-line"
               xreflabel="public.budget_line">
        <title id="public.table.budget-line-title">
         Table:
         
         <structname>budget_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_line</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.budget-info"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.budget-note"
               xreflabel="public.budget_note">
        <title id="public.table.budget-note-title">
         Table:
         
         <structname>budget_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 6</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.budget-info"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on budget_note</title>

          <varlistentry>
            <term>budget_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 6))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.budget-to-business-unit"
               xreflabel="public.budget_to_business_unit">
        <title id="public.table.budget-to-business-unit-title">
         Table:
         
         <structname>budget_to_business_unit</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>budget_to_business_unit</structname>
            </title>


            <varlistentry>
              <term><structfield>budget_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE</literal>



                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.budget-info"/>






              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.business"
               xreflabel="public.business">
        <title id="public.table.business-title">
         Table:
         
         <structname>business</structname>
        </title>
 

        <para>
          Groups of Customers assigned joint discounts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.business-unit"
               xreflabel="public.business_unit">
        <title id="public.table.business-unit-title">
         Table:
         
         <structname>business_unit</structname>
        </title>
 

        <para>
           Tracks Projects, Departments, Funds, Etc.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE#1</literal>



                <literal>PRIMARY KEY</literal>















              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#2</literal>









                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>








                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE#2</literal>










              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>start_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.budget-to-business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-ac"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-inv"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-jl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-oitem"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-translation"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.jcitems"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.job"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.business-unit-ac"
               xreflabel="public.business_unit_ac">
        <title id="public.table.business-unit-ac-title">
         Table:
         
         <structname>business_unit_ac</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_ac</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.acc-trans"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>



                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.business-unit-class"
               xreflabel="public.business_unit_class">
        <title id="public.table.business-unit-class-title">
         Table:
         
         <structname>business_unit_class</structname>
        </title>
 

        <para>
           Consolidates projects and departments, and allows this to be extended for
funds accounting and other purposes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordering</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.bu_class_to_module via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.bu-class-to-module"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.budget-to-business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-ac"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-inv"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-jl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit-oitem"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.business-unit-inv"
               xreflabel="public.business_unit_inv">
        <title id="public.table.business-unit-inv-title">
         Table:
         
         <structname>business_unit_inv</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_inv</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.invoice"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>



                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.business-unit-jl"
               xreflabel="public.business_unit_jl">
        <title id="public.table.business-unit-jl-title">
         Table:
         
         <structname>business_unit_jl</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_jl</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.journal-line"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.business-unit-oitem"
               xreflabel="public.business_unit_oitem">
        <title id="public.table.business-unit-oitem-title">
         Table:
         
         <structname>business_unit_oitem</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_oitem</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.orderitems"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit-class"/>



                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.business-unit-translation"
               xreflabel="public.business_unit_translation">
        <title id="public.table.business-unit-translation-title">
         Table:
         
         <structname>business_unit_translation</structname>
        </title>
 

        <para>
           Translation information for projects, departments, etc.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>business_unit_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.view.cash-impact"
               xreflabel="public.cash_impact">
        <title id="public.view.cash-impact-title">
         View:
         
         <structname>cash_impact</structname>
        </title>
 

        <para>
           This view is used by cash basis reports to determine the fraction of a
transaction to be counted.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cash_impact</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>portion</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rel</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view cash_impact</title>
         <programlisting>
(
SELECT gl.id
     , 1::numeric AS portion
     ,&apos;gl&apos;::text AS rel
     , gl.transdate 
  FROM gl 
UNION ALLSELECT gl.id
     , CASE WHEN 
     (gl.amount = 
           (0)::numeric
     ) THEN 
     (0)::numeric WHEN 
     (gl.transdate = ac.transdate) THEN 
     (
           (1)::numeric + 
           (sum
                 (ac.amount) / gl.amount
           )
     ) ELSE 
     (
           (1)::numeric - 
           (
                 (gl.amount - sum
                       (ac.amount)
                 ) / gl.amount
           )
     ) END AS portion
     ,&apos;ar&apos;::text AS rel
     , ac.transdate 
  FROM (
           (ar gl 
              JOIN acc_trans ac 
                ON (
                       (ac.trans_id = gl.id)
                 )
           )
        JOIN account_link al 
          ON (
                 (
                       (ac.chart_id = al.account_id)
                     AND (al.description = &apos;AR&apos;::text)
                 )
           )
     )
GROUP BY gl.id
     , gl.amount
     , ac.transdate
)
UNION ALLSELECT gl.id
, CASE WHEN 
(gl.amount = 
     (0)::numeric
) THEN 
(0)::numeric WHEN 
(gl.transdate = ac.transdate) THEN 
(
     (1)::numeric - 
     (sum
           (ac.amount) / gl.amount
     )
) ELSE 
(
     (1)::numeric - 
     (
           (gl.amount + sum
                 (ac.amount)
           ) / gl.amount
     )
) END AS portion
,&apos;ap&apos;::text AS rel
, ac.transdate 
FROM (
     (ap gl 
        JOIN acc_trans ac 
          ON (
                 (ac.trans_id = gl.id)
           )
     )
  JOIN account_link al 
    ON (
           (
                 (ac.chart_id = al.account_id)
               AND (al.description = &apos;AP&apos;::text)
           )
     )
)
GROUP BY gl.id
, gl.amount
, ac.transdate;</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.view.chart"
               xreflabel="public.chart">
        <title id="public.view.chart-title">
         View:
         
         <structname>chart</structname>
        </title>
 

        <para>
          Compatibility chart for 1.2 and earlier.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>chart</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>charttype</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>category</structfield></term>
              <listitem><para>
                <type>bpchar</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>link</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_heading</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gifi_accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contra</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view chart</title>
         <programlisting>
SELECT account_heading.id
, account_heading.accno
, account_heading.description
,&apos;H&apos;::text AS charttype
, NULL::bpchar AS category
, NULL::text AS link
, NULL::integer AS account_heading
, NULL::text AS gifi_accno
, false AS contra
, false AS tax 
FROM account_heading 
UNIONSELECT c.id
, c.accno
, c.description
,&apos;A&apos;::text AS charttype
, c.category
, concat_colon
(l.description) AS link
, c.heading AS account_heading
, c.gifi_accno
, c.contra
, c.tax 
FROM (account c 
LEFT JOIN account_link l 
    ON (
           (c.id = l.account_id)
     )
)
GROUP BY c.id
, c.accno
, c.description
, c.category
, c.heading
, c.gifi_accno
, c.contra
, c.tax;</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.company"
               xreflabel="public.company">
        <title id="public.table.company-title">
         Table:
         
         <structname>company</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>company</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>legal_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>tax_id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 In the US this would be a EIN. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales_tax_id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>license_number</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sic_code</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on company</title>

          <varlistentry>
            <term>company_legal_name_check</term>
            <listitem><para>CHECK ((legal_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.person_to_company via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.contact-class"
               xreflabel="public.contact_class">
        <title id="public.table.contact-class-title">
         Table:
         
         <structname>contact_class</structname>
        </title>
 

        <para>
           Stores type of contact information attached to companies and persons.
Please coordinate with others before adding new types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>contact_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on contact_class</title>

          <varlistentry>
            <term>contact_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.eca_to_contact via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.eca-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-to-contact"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.country"
               xreflabel="public.country">
        <title id="public.table.country-title">
         Table:
         
         <structname>country</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>country</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>short_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>itu</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 The ITU Telecommunication Standardization Sector code for calling internationally. For example, the US is 1, Great Britain is 44 
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on country</title>

          <varlistentry>
            <term>country_name_check</term>
            <listitem><para>CHECK ((name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>country_short_name_check</term>
            <listitem><para>CHECK ((short_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.country_tax_form via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.country-tax-form"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-deduction-class"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-income-class"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.country-tax-form"
               xreflabel="public.country_tax_form">
        <title id="public.table.country-tax-form-title">
         Table:
         
         <structname>country_tax_form</structname>
        </title>
 

        <para>
           This table was designed for holding information relating to reportable
sales or purchases, such as IRS 1099 forms and international equivalents.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>country_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.country"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>form_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_accrual</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.cr-coa-to-account"
               xreflabel="public.cr_coa_to_account">
        <title id="public.table.cr-coa-to-account-title">
         Table:
         
         <structname>cr_coa_to_account</structname>
        </title>
 

        <para>
           Provides name mapping for the cash reconciliation screen.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_coa_to_account</structname>
            </title>


            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.cr-report"
               xreflabel="public.cr_report">
        <title id="public.table.cr-report-title">
         Table:
         
         <structname>cr_report</structname>
        </title>
 

        <para>
          This table holds header data for cash reports.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_total</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>submitted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>end_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>updated</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT person__get_my_entity_id()</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_username</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deleted</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deleted_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_username</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>recon_fx</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on cr_report</title>

          <varlistentry>
            <term>cr_report_check</term>
            <listitem><para>CHECK (((deleted IS NOT TRUE) OR (approved IS NOT TRUE)))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.cr_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.cr-report-line"
               xreflabel="public.cr_report_line">
        <title id="public.table.cr-report-line-title">
         Table:
         
         <structname>cr_report_line</structname>
        </title>
 

        <para>
           This stores line item data on transaction lines and whether they are 
cleared.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>cr_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigserial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.cr-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>scn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the check number.  Maps to journal_entry.reference 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>our_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>errorcode</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>user</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>clear_time</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>insert_time</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ledger_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.acc-trans"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>overlook</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.custom-field-catalog"
               xreflabel="public.custom_field_catalog">
        <title id="public.table.custom-field-catalog-title">
         Table:
         
         <structname>custom_field_catalog</structname>
        </title>
 

        <para>
           Deprecated, use only with old code.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>custom_field_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>field_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.custom-table-catalog"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>field_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.custom-table-catalog"
               xreflabel="public.custom_table_catalog">
        <title id="public.table.custom-table-catalog-title">
         Table:
         
         <structname>custom_table_catalog</structname>
        </title>
 

        <para>
           Deprecated, use only with old code.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>custom_table_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>table_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>extends</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.custom_field_catalog via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.custom-field-catalog"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.defaults"
               xreflabel="public.defaults">
        <title id="public.table.defaults-title">
         Table:
         
         <structname>defaults</structname>
        </title>
 

        <para>
            This is a free-form table for managing application settings per company
database.  We use key-value modelling here because this most accurately maps 
the actual semantics of the data.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>defaults</structname>
            </title>


            <varlistentry>
              <term><structfield>setting_key</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>value</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.eca-invoice"
               xreflabel="public.eca_invoice">
        <title id="public.table.eca-invoice-title">
         Table:
         
         <structname>eca_invoice</structname>
        </title>
 

        <para>
           Replaces the rest of the ar and ap tables.
Also tracks payments and receipts. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_invoice</structname>
            </title>


            <varlistentry>
              <term><structfield>order_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                 Link to order it was created from
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>journal_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.journal-entry"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>on_hold</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 On hold invoices can not be paid, and overpayments that are on hold cannot 
be used to pay invoices.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reverse</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 When this is set to true, the invoice is shown with opposite normal numbers,
i.e. negatives appear as positives, and positives appear as negatives.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>due</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character(6)</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>force_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 When this is set to true, the invoice does not show up on outstanding reports
and cannot be paid.  Overpayments where this is set to true do not appear on 
outstanding reports and cannot be paid.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>order_number</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the order number of the other party.  So for a sales invoice, this 
would be a purchase order, and for a vendor invoice, this would be a sales 
order.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payment-map"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.eca-note"
               xreflabel="public.eca_note">
        <title id="public.table.eca-note-title">
         Table:
         
         <structname>eca_note</structname>
        </title>
 

        <para>
           Notes for entity_credit_account entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

              <para>
                 references entity_credit_account.id
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on eca_note</title>

          <varlistentry>
            <term>eca_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 3))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.eca-tax"
               xreflabel="public.eca_tax">
        <title id="public.table.eca-tax-title">
         Table:
         
         <structname>eca_tax</structname>
        </title>
 

        <para>
           Mapping customers and vendors to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_tax</structname>
            </title>


            <varlistentry>
              <term><structfield>eca_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.eca-to-contact"
               xreflabel="public.eca_to_contact">
        <title id="public.table.eca-to-contact-title">
         Table:
         
         <structname>eca_to_contact</structname>
        </title>
 

        <para>
           To keep track of the relationship between multiple contact methods and a single vendor or customer account. For generic 
contacts, use entity_to_contact instead.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on eca_to_contact</title>

          <varlistentry>
            <term>eca_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.eca-to-location"
               xreflabel="public.eca_to_location">
        <title id="public.table.eca-to-location-title">
         Table:
         
         <structname>eca_to_location</structname>
        </title>
 

        <para>
           This table is used for locations bound to contracts.  For generic contact
addresses, use entity_to_location instead 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>eca_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.location-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.employee-class"
               xreflabel="public.employee_class">
        <title id="public.table.employee-class-title">
         Table:
         
         <structname>employee_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_class</structname>
            </title>


            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.employee_to_ec via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.employee-to-ec"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.view.employee-search"
               xreflabel="public.employee_search">
        <title id="public.view.employee-search-title">
         View:
         
         <structname>employee_search</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_search</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view employee_search</title>
         <programlisting>
SELECT e.entity_id
, e.startdate
, e.enddate
, e.role
, e.ssn
, e.sales
, e.manager_id
, e.employeenumber
, e.dob
, em.name AS manager
, emn.note
, en.name 
FROM (
     (
           (
                 (entity_employee e 
               LEFT JOIN entity en 
                      ON (
                             (e.entity_id = en.id)
                       )
                 )
         LEFT JOIN entity_employee m 
                ON (
                       (e.manager_id = m.entity_id)
                 )
           )
   LEFT JOIN entity em 
          ON (
                 (em.id = m.entity_id)
           )
     )
LEFT JOIN entity_note emn 
    ON (
           (emn.ref_key = em.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.employee-to-ec"
               xreflabel="public.employee_to_ec">
        <title id="public.table.employee-to-ec-title">
         Table:
         
         <structname>employee_to_ec</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employee_to_ec</structname>
            </title>


            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ec_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.employee-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.view.employees"
               xreflabel="public.employees">
        <title id="public.view.employees-title">
         View:
         
         <structname>employees</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>employees</structname>
            </title>


            <varlistentry>
              <term><structfield>salutation</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>first_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view employees</title>
         <programlisting>
SELECT s.salutation
, p.first_name
, p.last_name
, ee.entity_id
, ee.startdate
, ee.enddate
, ee.role
, ee.ssn
, ee.sales
, ee.manager_id
, ee.employeenumber
, ee.dob 
FROM (
     (person p 
        JOIN entity_employee ee 
       USING (entity_id)
     )
LEFT JOIN salutation s 
    ON (
           (p.salutation_id = s.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.entity"
               xreflabel="public.entity">
        <title id="public.table.entity-title">
         Table:
         
         <structname>entity</structname>
        </title>
 

        <para>
           The primary entity table to map to all contacts 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                 This is the common name of an entity. If it was a person it may be Joshua Drake, a company Acme Corp. You may also choose to use a domain such as commandprompt.com 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_class</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-class"/>



                <literal>REFERENCES</literal> <xref linkend="public.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>control_code</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>



                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT setting_increment(&apos;entity_control&apos;::character varying)</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.country"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity</title>

          <varlistentry>
            <term>entity_name_check</term>
            <listitem><para>CHECK ((name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.budget-info"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.company"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.cr-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.cr-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-bank-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-employee"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-other-name"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-base"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-secondary-attachment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-entry"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-deduction"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-paid-timeoff"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-wage"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.person"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.transactions"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.users"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.entity-bank-account"
               xreflabel="public.entity_bank_account">
        <title id="public.table.entity-bank-account-title">
         Table:
         
         <structname>entity_bank_account</structname>
        </title>
 

        <para>
          This stores bank account information for both companies and persons.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_bank_account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bic</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 Banking Institution Code, such as routing number of SWIFT code.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>iban</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 International Bank Account Number.  used to store the actual account number
for the banking institution.
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.entity-class"
               xreflabel="public.entity_class">
        <title id="public.table.entity-class-title">
         Table:
         
         <structname>entity_class</structname>
        </title>
 

        <para>
           Defines the class type such as vendor, customer, contact, employee 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 The first 7 values are reserved and 
permanent.  Individuals who create new classes, however, should coordinate 
with others for ranges to use.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.country"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_class</title>

          <varlistentry>
            <term>entity_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity_class</title>

          <varlistentry>
            <term>entity_class_idx</term>
            <listitem><para>lower(class)</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.entity via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.entity"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.entity-credit-account"
               xreflabel="public.entity_credit_account">
        <title id="public.table.entity-credit-account-title">
         Table:
         
         <structname>entity_credit_account</structname>
        </title>
 

        <para>
          This table stores information relating to general relationships regarding 
moneys owed on invoice.  Invoices, whether AR or AP, must be attached to 
a record in this table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_credit_account</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pay_to_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount_terms</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>creditlimit</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>meta_number</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 This stores the human readable control code for the customer/vendor record.
This is typically called the customer/vendor &quot;account&quot; in the application.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>business_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>









                <literal>DEFAULT &apos;en&apos;::character varying</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.pricegroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>threshold</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>primary_contact</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ar_ap_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cash_account_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bank_account</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-bank-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxform_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.country-tax-form"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_credit_account</title>

          <varlistentry>
            <term>entity_credit_account_check</term>
            <listitem><para>CHECK (((ar_ap_account_id IS NOT NULL) OR (entity_id = 0)))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>entity_credit_account_entity_class_check</term>
            <listitem><para>CHECK ((entity_class = ANY (ARRAY[1, 2])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.business-unit"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-to-contact"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-eca"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.partscustomer"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.partsvendor"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payment"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.entity-employee"
               xreflabel="public.entity_employee">
        <title id="public.table.entity-employee-title">
         Table:
         
         <structname>entity_employee</structname>
        </title>
 

        <para>
           This contains employee-specific extensions to person/entity. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_employee</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>character varying(20)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ssn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sales</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>manager_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employeenumber</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dob</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.ap via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.employee-to-ec"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.inventory"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.entity-note"
               xreflabel="public.entity_note">
        <title id="public.table.entity-note-title">
         Table:
         
         <structname>entity_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_note</title>

          <varlistentry>
            <term>entity_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on entity_note</title>

          <varlistentry>
            <term>entity_note_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>entity_note_vectors_idx</term>
            <listitem><para>vector</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.entity-other-name"
               xreflabel="public.entity_other_name">
        <title id="public.table.entity-other-name-title">
         Table:
         
         <structname>entity_other_name</structname>
        </title>
 

        <para>
           Similar to company_other_name, a person
may be jd, Joshua Drake, linuxpoet... all are the same person.  Currently
unused in the front-end but will likely be added in future versions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_other_name</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>other_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_other_name</title>

          <varlistentry>
            <term>entity_other_name_other_name_check</term>
            <listitem><para>CHECK ((other_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.entity-to-contact"
               xreflabel="public.entity_to_contact">
        <title id="public.table.entity-to-contact-title">
         Table:
         
         <structname>entity_to_contact</structname>
        </title>
 

        <para>
           This table stores contact information for entities
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_to_contact</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.contact-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>contact</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on entity_to_contact</title>

          <varlistentry>
            <term>entity_to_contact_contact_check</term>
            <listitem><para>CHECK ((contact ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.entity-to-location"
               xreflabel="public.entity_to_location">
        <title id="public.table.entity-to-location-title">
         Table:
         
         <structname>entity_to_location</structname>
        </title>
 

        <para>
           This table is used for locations generic to companies.  For contract-bound
addresses, use eca_to_location instead 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>entity_to_location</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.location-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.exchangerate"
               xreflabel="public.exchangerate">
        <title id="public.table.exchangerate-title">
         Table:
         
         <structname>exchangerate</structname>
        </title>
 

        <para>
           When you receive money in a foreign currency, it is worth to you in your local currency
whatever you can get for it when you sell the acquired currency (sell rate).
When you have to pay someone in a foreign currency, the equivalent amount is the amount
you have to spend to acquire the foreign currency (buy rate).
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>exchangerate</structname>
            </title>


            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>buy</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sell</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on exchangerate</title>

          <varlistentry>
            <term>exchangerate_ct_key</term>
            <listitem><para>curr, transdate</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.file-base"
               xreflabel="public.file_base">
        <title id="public.table.file-base-title">
         Table:
         
         <structname>file_base</structname>
        </title>
 

        <para>
          Abstract table, holds no records.  Inheriting table store actual file
attachment data. Can be queried however to retrieve lists of all files. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_base</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.mime-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                This column inheriting tables is used to reference the database row for the
attachment.  Inheriting tables MUST set the foreign key here appropriately.

This can also be used to create classifications of other documents, such as by
source of automatic import (where the file is not yet attached) or
even standard,
long-lived documents.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-class"
               xreflabel="public.file_class">
        <title id="public.table.file-class-title">
         Table:
         
         <structname>file_class</structname>
        </title>
 

        <para>
           File classes are collections of files attached against rows in specific 
tables in the database.  They can be used in the future to implement other form 
of file attachment. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.file_base via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.file-base"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-secondary-attachment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-view-catalog"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.file-eca"
               xreflabel="public.file_eca">
        <title id="public.table.file-eca-title">
         Table:
         
         <structname>file_eca</structname>
        </title>
 

        <para>
           File attachments primarily attached to customer and vendor agreements.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_eca</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_eca</title>

          <varlistentry>
            <term>file_eca_file_class_check</term>
            <listitem><para>CHECK ((file_class = 5))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-entity"
               xreflabel="public.file_entity">
        <title id="public.table.file-entity-title">
         Table:
         
         <structname>file_entity</structname>
        </title>
 

        <para>
           File attachments primarily attached to entities.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_entity</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_entity</title>

          <varlistentry>
            <term>file_entity_file_class_check</term>
            <listitem><para>CHECK ((file_class = 4))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.view.file-links"
               xreflabel="public.file_links">
        <title id="public.view.file-links-title">
         View:
         
         <structname>file_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_links</title>
         <programlisting>
SELECT file_tx_links.file_id
, file_tx_links.ref_key
, file_tx_links.reference
, file_tx_links.type
, file_tx_links.dest_class
, file_tx_links.source_class
, file_tx_links.dest_ref 
FROM file_tx_links 
UNIONSELECT file_order_links.file_id
, file_order_links.ref_key
, file_order_links.reference
, file_order_links.oe_class AS type
, file_order_links.dest_class
, file_order_links.source_class
, file_order_links.dest_ref 
FROM file_order_links;</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.file-order"
               xreflabel="public.file_order">
        <title id="public.table.file-order-title">
         Table:
         
         <structname>file_order</structname>
        </title>
 

        <para>
           File attachments primarily attached to orders and quotations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order</title>

          <varlistentry>
            <term>file_order_file_class_check</term>
            <listitem><para>CHECK ((file_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.file_order_to_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.file-order-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-order-to-tx"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.view.file-order-links"
               xreflabel="public.file_order_links">
        <title id="public.view.file-order-links-title">
         View:
         
         <structname>file_order_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_order_links</title>
         <programlisting>
SELECT sl.file_id
, sl.ref_key
, oe.ordnumber AS reference
, oc.oe_class
, sl.dest_class
, sl.source_class
, sl.ref_key AS dest_ref 
FROM (
     (file_secondary_attachment sl 
        JOIN oe 
          ON (
                 (sl.ref_key = oe.id)
           )
     )
  JOIN oe_class oc 
    ON (
           (oe.oe_class_id = oc.id)
     )
)
WHERE (sl.source_class = 2);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.file-order-to-order"
               xreflabel="public.file_order_to_order">
        <title id="public.table.file-order-to-order-title">
         Table:
         
         <structname>file_order_to_order</structname>
        </title>
 

        <para>
           Secondary links from one order to another, for example to support order
consolidation.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_to_order</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.file-order"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order_to_order</title>

          <varlistentry>
            <term>file_order_to_order_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 2))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_order_to_order_source_class_check</term>
            <listitem><para>CHECK ((source_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-order-to-tx"
               xreflabel="public.file_order_to_tx">
        <title id="public.table.file-order-to-tx-title">
         Table:
         
         <structname>file_order_to_tx</structname>
        </title>
 

        <para>
           Secondary links from orders to transactions, for example to track files when
invoices are generated from orders.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_order_to_tx</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.file-order"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_order_to_tx</title>

          <varlistentry>
            <term>file_order_to_tx_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 1))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_order_to_tx_source_class_check</term>
            <listitem><para>CHECK ((source_class = 2))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-part"
               xreflabel="public.file_part">
        <title id="public.table.file-part-title">
         Table:
         
         <structname>file_part</structname>
        </title>
 

        <para>
           File attachments primarily attached to goods and services.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_part</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_part</title>

          <varlistentry>
            <term>file_part_file_class_check</term>
            <listitem><para>CHECK ((file_class = 3))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-secondary-attachment"
               xreflabel="public.file_secondary_attachment">
        <title id="public.table.file-secondary-attachment-title">
         Table:
         
         <structname>file_secondary_attachment</structname>
        </title>
 

        <para>
          Another abstract table.  This one will use rewrite rules to make inserts safe
because of the difficulty in managing inserts otherwise. Inheriting tables 
provide secondary links between the file and other database objects.

Due to the nature of database inheritance and unique constraints
in PostgreSQL, this must be partitioned in a star format.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_secondary_attachment</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.file-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-transaction"
               xreflabel="public.file_transaction">
        <title id="public.table.file-transaction-title">
         Table:
         
         <structname>file_transaction</structname>
        </title>
 

        <para>
           File attachments primarily attached to AR/AP/GL.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_transaction</structname>
            </title>


            <varlistentry>
              <term><structfield>content</structfield></term>
              <listitem><para>
                <type>bytea</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type_id</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>uploaded_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>



                <literal>DEFAULT nextval(&apos;file_base_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_transaction</title>

          <varlistentry>
            <term>file_transaction_file_class_check</term>
            <listitem><para>CHECK ((file_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.file_tx_to_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.file-tx-to-order"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.view.file-tx-links"
               xreflabel="public.file_tx_links">
        <title id="public.view.file-tx-links-title">
         View:
         
         <structname>file_tx_links</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_tx_links</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_ref</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view file_tx_links</title>
         <programlisting>
SELECT sl.file_id
, sl.ref_key
, gl.reference
, gl.type
, sl.dest_class
, sl.source_class
, sl.ref_key AS dest_ref 
FROM (file_secondary_attachment sl 
  JOIN (
           (
            SELECT gl.id
                 , gl.reference
                 ,&apos;gl&apos;::text AS type 
              FROM gl 
             UNIONSELECT ar.id
                 , ar.invnumber
                 , CASE WHEN ar.invoice THEN &apos;is&apos;::text ELSE &apos;ar&apos;::text END AS type 
              FROM ar
           )
       UNIONSELECT ap.id
           , ap.invnumber
           , CASE WHEN ap.invoice THEN &apos;ir&apos;::text ELSE &apos;ap&apos;::text END AS type 
        FROM ap
     ) gl 
    ON (
           (
                 (sl.ref_key = gl.id)
               AND (sl.source_class = 1)
           )
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.file-tx-to-order"
               xreflabel="public.file_tx_to_order">
        <title id="public.table.file-tx-to-order-title">
         Table:
         
         <structname>file_tx_to_order</structname>
        </title>
 

        <para>
           Secondary links from journal entries to orders.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_tx_to_order</structname>
            </title>


            <varlistentry>
              <term><structfield>file_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.file-transaction"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dest_class</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_by</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attached_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on file_tx_to_order</title>

          <varlistentry>
            <term>file_tx_to_order_dest_class_check</term>
            <listitem><para>CHECK ((dest_class = 2))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>file_tx_to_order_source_class_check</term>
            <listitem><para>CHECK ((source_class = 1))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.file-view-catalog"
               xreflabel="public.file_view_catalog">
        <title id="public.table.file-view-catalog-title">
         Table:
         
         <structname>file_view_catalog</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>file_view_catalog</structname>
            </title>


            <varlistentry>
              <term><structfield>file_class</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.file-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>view_name</structfield></term>
              <listitem><para>
                <type>text</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.gifi"
               xreflabel="public.gifi">
        <title id="public.table.gifi-title">
         Table:
         
         <structname>gifi</structname>
        </title>
 

        <para>
           GIFI labels for accounts, used in Canada and some EU countries for tax 
reporting
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>gifi</structname>
            </title>


            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.gl"
               xreflabel="public.gl">
        <title id="public.table.gl-title">
         Table:
         
         <structname>gl</structname>
        </title>
 

        <para>
           This table holds summary information for entries in the general journal.
Does not hold summary information in 1.3 for AR or AP entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>gl</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>


              </para>

              <para>
                 the person_id of the employee who created
the entry.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payment via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.yearend"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.inventory"
               xreflabel="public.inventory">
        <title id="public.table.inventory-title">
         Table:
         
         <structname>inventory</structname>
        </title>
 

        <para>
           This table contains inventory mappings to warehouses, not general inventory
management data.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory</structname>
            </title>


            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>warehouse_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>orderitems_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.inventory-report"
               xreflabel="public.inventory_report">
        <title id="public.table.inventory-report-title">
         Table:
         
         <structname>inventory_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>source</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ar_trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ap_trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.inventory_report_line via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.inventory-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.inventory-report-line"
               xreflabel="public.inventory_report_line">
        <title id="public.table.inventory-report-line-title">
         Table:
         
         <structname>inventory_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>inventory_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.inventory-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>counted</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>expected</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.invoice"
               xreflabel="public.invoice">
        <title id="public.table.invoice-title">
         Table:
         
         <structname>invoice</structname>
        </title>
 

        <para>
          Line items of invoices with goods/services attached.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                Positive is normal for sales invoices, negative for vendor invoices.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>allocated</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                Number of allocated items, negative relative to qty.
When qty + allocated = 0, then the item is fully used for purposes of COGS 
calculations.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>precision</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fxsellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>assemblyitem</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>deliverydate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on invoice</title>

          <varlistentry>
            <term>invoice_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>invoice_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.business_unit_inv via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.business-unit-inv"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.invoice-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.invoice-tax-form"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.invoice-note"
               xreflabel="public.invoice_note">
        <title id="public.table.invoice-note-title">
         Table:
         
         <structname>invoice_note</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.invoice"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on invoice_note</title>

          <varlistentry>
            <term>invoice_note_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>invoice_note_vectors_idx</term>
            <listitem><para>vector</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.invoice-tax-form"
               xreflabel="public.invoice_tax_form">
        <title id="public.table.invoice-tax-form-title">
         Table:
         
         <structname>invoice_tax_form</structname>
        </title>
 

        <para>
           Maping invoice to country_tax_form.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>invoice_tax_form</structname>
            </title>


            <varlistentry>
              <term><structfield>invoice_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.invoice"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reportable</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.jcitems"
               xreflabel="public.jcitems">
        <title id="public.table.jcitems-title">
         Table:
         
         <structname>jcitems</structname>
        </title>
 

        <para>
           Time and materials cards. 
Materials cards not implemented.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>jcitems</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>business_unit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>allocated</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>fxsellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>checkedin</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>checkedout</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>total</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>non_billable</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on jcitems</title>

          <varlistentry>
            <term>jcitems_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.jctype"
               xreflabel="public.jctype">
        <title id="public.table.jctype-title">
         Table:
         
         <structname>jctype</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>jctype</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_service</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_timecard</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.job"
               xreflabel="public.job">
        <title id="public.table.job-title">
         Table:
         
         <structname>job</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>job</structname>
            </title>


            <varlistentry>
              <term><structfield>bu_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.business-unit"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

              <para>
                 Job costing/manufacturing here not implemented.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>production</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>completed</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.journal-entry"
               xreflabel="public.journal_entry">
        <title id="public.table.journal-entry-title">
         Table:
         
         <structname>journal_entry</structname>
        </title>
 

        <para>
          
This tale records the header information for each transaction.  It replaces 
parts of the following tables:  acc_trans, ar, ap, gl, transactions.

Note now all ar/ap transactions are also journal entries.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_entry</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 Invoice number or journal entry number.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.session"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>journal</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.journal-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>effective_start</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 For transactions whose effects are spread out over a period of time, this is
the effective start date for the transaction.  To be used by add-ons for 
automating adjustments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>effective_end</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 For transactions whose effects are spread out over a period of time, this is
the effective end date for the transaction.  To be used by add-ons for 
automating adjustments.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>currency</structfield></term>
              <listitem><para>
                <type>character(3)</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>is_template</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 Set true for template transactions.  Templates can never be approved but can
be copied into new transactions and are useful for recurrances. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entered_by</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on journal_entry</title>

          <varlistentry>
            <term>journal_entry_check</term>
            <listitem><para>CHECK (((is_template IS FALSE) OR (approved IS FALSE)))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.eca-invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-order-to-tx"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-note"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.new-shipto"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.journal-line"
               xreflabel="public.journal_line">
        <title id="public.table.journal-line-title">
         Table:
         
         <structname>journal_line</structname>
        </title>
 

        <para>
           Replaces acc_trans as the main account transaction line table.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>journal_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 Still needed both for legacy data and in case reconciliation data must 
eventually be purged.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reconciliation_report</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.cr-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_type</structfield></term>
              <listitem><para>
                <type>text</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account-link-description"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on journal_line</title>

          <varlistentry>
            <term>journal_line_amount_check</term>
            <listitem><para>CHECK ((amount &lt;&gt; &apos;NaN&apos;::numeric))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.business_unit_jl via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.business-unit-jl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payment-map"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.tax-extended"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.journal-note"
               xreflabel="public.journal_note">
        <title id="public.table.journal-note-title">
         Table:
         
         <structname>journal_note</structname>
        </title>
 

        <para>
           This stores notes attached to journal entries, including payments and
invoices.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;note_id_seq&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>internal_only</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT false</literal>



              </para>

              <para>
                 When set to true, does not show up in notes list for invoice templates
              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on journal_note</title>

          <varlistentry>
            <term>journal_note_note_class_check</term>
            <listitem><para>CHECK ((note_class = 5))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.journal-type"
               xreflabel="public.journal_type">
        <title id="public.table.journal-type-title">
         Table:
         
         <structname>journal_type</structname>
        </title>
 

        <para>
           This table describes the journal entry type of the transaction.  The 
following values are hard coded by default:
1:  General journal
2:  Sales (AR)
3:  Purchases (AP)
4:  Receipts
5:  Payments


        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>journal_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.journal_entry via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.journal-entry"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.language"
               xreflabel="public.language">
        <title id="public.table.language-title">
         Table:
         
         <structname>language</structname>
        </title>
 

        <para>
           Languages for manual translations and so forth.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>language</structname>
            </title>


            <varlistentry>
              <term><structfield>code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.eca_invoice via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.eca-invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.user-preference"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.location"
               xreflabel="public.location">
        <title id="public.table.location-title">
         Table:
         
         <structname>location</structname>
        </title>
 

        <para>
          
This table stores addresses, such as shipto and bill to addresses.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>location</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_one</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_two</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>line_three</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>city</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>state</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.country"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mail_code</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>inactive_date</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>active</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT true</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on location</title>

          <varlistentry>
            <term>location_city_check</term>
            <listitem><para>CHECK ((city ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_line_one_check</term>
            <listitem><para>CHECK ((line_one ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_mail_code_check</term>
            <listitem><para>CHECK ((mail_code ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>location_state_check</term>
            <listitem><para>CHECK ((state ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.eca_to_location via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.new-shipto"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.location-class"
               xreflabel="public.location_class">
        <title id="public.table.location-class-title">
         Table:
         
         <structname>location_class</structname>
        </title>
 

        <para>
          
Individuals seeking to add new location classes should coordinate with others.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>location_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>authoritative</structfield></term>
              <listitem><para>
                <type>boolean</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on location_class</title>

          <varlistentry>
            <term>location_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.eca_to_location via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.eca-to-location"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-to-location"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.lsmb-group"
               xreflabel="public.lsmb_group">
        <title id="public.table.lsmb-group-title">
         Table:
         
         <structname>lsmb_group</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_group</structname>
            </title>


            <varlistentry>
              <term><structfield>role_name</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.lsmb_group_grants via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.lsmb-group-grants"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.lsmb-group-grants"
               xreflabel="public.lsmb_group_grants">
        <title id="public.table.lsmb-group-grants-title">
         Table:
         
         <structname>lsmb_group_grants</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_group_grants</structname>
            </title>


            <varlistentry>
              <term><structfield>group_name</structfield></term>
              <listitem><para>
                <type>text</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.lsmb-group"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>granted_role</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.lsmb-module"
               xreflabel="public.lsmb_module">
        <title id="public.table.lsmb-module-title">
         Table:
         
         <structname>lsmb_module</structname>
        </title>
 

        <para>
           This stores categories functionality into modules.  Addons may add rows here, but 
the id should be hardcoded.  As always 900-1000 will be reserved for internal use, 
and negative numbers will be reserved for testing.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_module</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.bu_class_to_module via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.bu-class-to-module"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.lsmb-roles"
               xreflabel="public.lsmb_roles">
        <title id="public.table.lsmb-roles-title">
         Table:
         
         <structname>lsmb_roles</structname>
        </title>
 

        <para>
           Tracks role assignments in the front end.  Not sure why we need this.  Will
rethink for 1.4.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>lsmb_roles</structname>
            </title>


            <varlistentry>
              <term><structfield>user_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.makemodel"
               xreflabel="public.makemodel">
        <title id="public.table.makemodel-title">
         Table:
         
         <structname>makemodel</structname>
        </title>
 

        <para>
           A single parts entry can have multiple make/model entries.  These
store manufacturer/model number info.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>makemodel</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>barcode</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>make</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>model</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on makemodel</title>

          <varlistentry>
            <term>makemodel_make_key</term>
            <listitem><para>lower(make)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>makemodel_model_key</term>
            <listitem><para>lower(model)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>makemodel_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.menu-acl"
               xreflabel="public.menu_acl">
        <title id="public.table.menu-acl-title">
         Table:
         
         <structname>menu_acl</structname>
        </title>
 

        <para>
          Provides access control list entries for menu nodes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_acl</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>role_name</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>acl_type</structfield></term>
              <listitem><para>
                <type>character varying</type>







              </para>

              <para>
                 Nodes are hidden unless a role is found of which the user is a member, and
where the acl_type for that role type and node is set to &apos;allow&apos; and no acl is 
found for any role of which the user is a member, where the acl_type is set to
&apos;deny&apos;.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>node_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on menu_acl</title>

          <varlistentry>
            <term>menu_acl_acl_type_check</term>
            <listitem><para>CHECK ((((acl_type)::text = &apos;allow&apos;::text) OR ((acl_type)::text = &apos;deny&apos;::text)))</para></listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.menu-attribute"
               xreflabel="public.menu_attribute">
        <title id="public.table.menu-attribute-title">
         Table:
         
         <structname>menu_attribute</structname>
        </title>
 

        <para>
           This table stores the callback information for each menu item.  The 
attributes are stored in key/value modelling because of the fact that this
best matches the semantic structure of the information.

Each node should have EITHER a menu or a module attribute, menu for a menu with 
sub-items, module for an executiable script.  The module attribute identifies
the perl script to be run.  The action attribute identifies the entry point.

Beyond this, any other attributes that should be passed in can be done as other
attributes.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_attribute</structname>
            </title>


            <varlistentry>
              <term><structfield>node_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>attribute</structfield></term>
              <listitem><para>
                <type>character varying</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>value</structfield></term>
              <listitem><para>
                <type>character varying</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.view.menu-friendly"
               xreflabel="public.menu_friendly">
        <title id="public.view.menu-friendly-title">
         View:
         
         <structname>menu_friendly</structname>
        </title>
 

        <para>
           A nice human-readable view for investigating the menu tree.  Does not
show menu attributes or acls.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_friendly</structname>
            </title>


            <varlistentry>
              <term><structfield>level</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>path</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>position</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view menu_friendly</title>
         <programlisting>WITH RECURSIVE tree
(path
     , id
     , parent
     , level
     , positions
) AS 
(
SELECT (menu_node.id)::text AS path
     , menu_node.id
     , menu_node.parent
     , 0 AS level
     , (menu_node.&quot;position&quot;)::text AS &quot;position&quot;
  FROM menu_node 
 WHERE (menu_node.parent IS NULL)
 UNIONSELECT (
           (t.path || 
               &apos;,&apos;::text
           ) || 
           (n.id)::text
     )
     , n.id
     , n.parent
     , (t.level + 1)
     , (
           (t.positions || 
               &apos;,&apos;::text
           ) || n.&quot;position&quot;
     )
  FROM (menu_node n 
        JOIN tree t 
          ON (
                 (t.id = n.parent)
           )
     )
)
SELECT t.level
, t.path
, (repeat
     (&apos; &apos;::text
           , (2 * t.level)
     ) || 
     (n.label)::text
) AS label
, n.id
, n.&quot;position&quot;
FROM (tree t 
  JOIN menu_node n 
 USING (id)
)
ORDER BY (string_to_array
     (t.positions
           ,&apos;,&apos;::text
     )
)::integer[];</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.menu-node"
               xreflabel="public.menu_node">
        <title id="public.table.menu-node-title">
         Table:
         
         <structname>menu_node</structname>
        </title>
 

        <para>
          This table stores the tree structure of the menu.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>menu_node</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>character varying</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>









                <literal>REFERENCES</literal> <xref linkend="public.table.menu-node"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>position</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.menu_acl via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.menu-acl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.menu-attribute"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.menu-node"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.mime-type"
               xreflabel="public.mime_type">
        <title id="public.table.mime-type-title">
         Table:
         
         <structname>mime_type</structname>
        </title>
 

        <para>
           This is a lookup table for storing MIME types.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>mime_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>mime_type</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>invoice_include</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.file_base via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.file-base"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.new-shipto"
               xreflabel="public.new_shipto">
        <title id="public.table.new-shipto-title">
         Table:
         
         <structname>new_shipto</structname>
        </title>
 

        <para>
           Tracks ship_to information for orders and invoices.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>new_shipto</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.journal-entry"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.oe"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.location"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.note"
               xreflabel="public.note">
        <title id="public.table.note-title">
         Table:
         
         <structname>note</structname>
        </title>
 

        <para>
           This is an abstract table which should have zero rows.  It is inherited by
other tables for specific notes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>note</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.note-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>note</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                Body of note.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>vector</structfield></term>
              <listitem><para>
                <type>tsvector</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;&apos;::tsvector</literal>



              </para>

              <para>
                tsvector for full text indexing, requires 
both setting up tsearch dictionaries and adding triggers to use at present.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>text</type>





                <literal>DEFAULT &quot;session_user&quot;()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ref_key</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 Subclassed tables use this column as a foreign key against the table storing
the record a note is attached to.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>subject</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.note-class"
               xreflabel="public.note_class">
        <title id="public.table.note-class-title">
         Table:
         
         <structname>note_class</structname>
        </title>
 

        <para>
           Coordinate with others before adding entries. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>note_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>class</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on note_class</title>

          <varlistentry>
            <term>note_class_class_check</term>
            <listitem><para>CHECK ((class ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.note via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.note"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.oe"
               xreflabel="public.oe">
        <title id="public.table.oe-title">
         Table:
         
         <structname>oe</structname>
        </title>
 

        <para>
           Header information for:
* Sales orders
* Purchase Orders
* Quotations
* Requests for Quotation

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>oe</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ordnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>netamount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reqdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxincluded</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shippingpoint</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>closed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quotation</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>quonumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>intnotes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>shipvia</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ponumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>terms</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.oe-class"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on oe</title>

          <varlistentry>
            <term>oe_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>oe_ordnumber_key</term>
            <listitem><para>ordnumber</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>oe_transdate_key</term>
            <listitem><para>transdate</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.file_order via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.file-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-order-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-tx-to-order"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.new-shipto"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.oe-class"
               xreflabel="public.oe_class">
        <title id="public.table.oe-class-title">
         Table:
         
         <structname>oe_class</structname>
        </title>
 

        <para>
           Hardwired classifications for orders and quotations. 
Coordinate before adding.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>oe_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>smallint</type>




                      <literal>UNIQUE</literal>










              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oe_class</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on oe_class</title>

          <varlistentry>
            <term>oe_class_id_check</term>
            <listitem><para>CHECK ((id = ANY (ARRAY[1, 2, 3, 4])))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.oe via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.oe"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.open-forms"
               xreflabel="public.open_forms">
        <title id="public.table.open-forms-title">
         Table:
         
         <structname>open_forms</structname>
        </title>
 

        <para>
           This is our primary anti-xsrf measure, as this allows us to require a full
round trip to the web server in order to save data.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>open_forms</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>session_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.session"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.orderitems"
               xreflabel="public.orderitems">
        <title id="public.table.orderitems-title">
         Table:
         
         <structname>orderitems</structname>
        </title>
 

        <para>
           Line items for sales/purchase orders and quotations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>orderitems</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>precision</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reqdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ship</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>serialnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on orderitems</title>

          <varlistentry>
            <term>orderitems_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>orderitems_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.business_unit_oitem via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.business-unit-oitem"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.view.overpayments"
               xreflabel="public.overpayments">
        <title id="public.view.overpayments-title">
         View:
         
         <structname>overpayments</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>overpayments</structname>
            </title>


            <varlistentry>
              <term><structfield>payment_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_class</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_closed</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>accno</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>available</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>legal_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>discount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>meta_number</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view overpayments</title>
         <programlisting>
SELECT p.id AS payment_id
, p.reference AS payment_reference
, p.payment_class
, p.closed AS payment_closed
, p.payment_date
, ac.chart_id
, c.accno
, c.description AS chart_description
, abs
(sum
     (ac.amount)
) AS available
, cmp.legal_name
, eca.id AS entity_credit_id
, eca.entity_id
, eca.discount
, eca.meta_number 
FROM (
     (
           (
                 (
                       (payment p 
                          JOIN payment_links pl 
                            ON (
                                   (pl.payment_id = p.id)
                             )
                       )
                    JOIN acc_trans ac 
                      ON (
                             (ac.entry_id = pl.entry_id)
                       )
                 )
              JOIN chart c 
                ON (
                       (c.id = ac.chart_id)
                 )
           )
        JOIN entity_credit_account eca 
          ON (
                 (eca.id = p.entity_credit_id)
           )
     )
  JOIN company cmp 
    ON (
           (cmp.entity_id = eca.entity_id)
     )
)
WHERE (
     (
           (p.gl_id IS NOT NULL)
         AND (
                 (pl.type = 2)
                OR (pl.type = 0)
           )
     )
   AND (c.link ~~ &apos;%overpayment%&apos;::text)
)
GROUP BY p.id
, c.accno
, p.reference
, p.payment_class
, p.closed
, p.payment_date
, ac.chart_id
, c.description
, cmp.legal_name
, eca.id
, eca.entity_id
, eca.discount
, eca.meta_number;</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.parts"
               xreflabel="public.parts">
        <title id="public.table.parts-title">
         Table:
         
         <structname>parts</structname>
        </title>
 

        <para>
          This stores detail information about goods and services.  The type of part
is currently defined according to the following rules:
* If assembly is true, then an assembly
* If inventory_accno_id, income_accno_id, and expense_accno_id are not null then
  a part.
* If inventory_accno_id is null but the other two are not, then a service.
* Otherwise, a labor/overhead entry.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>parts</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(5)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>listprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>lastcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>priceupdate</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>weight</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>onhand</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>makemodel</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>assembly</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>alternate</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rop</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

              <para>
                Re-order point.  Used to select parts for short inventory report.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>inventory_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>income_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>expense_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>returns_accno_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bin</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Text identifier for where a part is stored.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>obsolete</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>bom</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                Show on Bill of Materials.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>image</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

              <para>
                Hyperlink to product image.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>drawing</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>microfiche</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partsgroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>avgcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on parts</title>

          <varlistentry>
            <term>parts_description_key</term>
            <listitem><para>lower(description)</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>parts_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>parts_partnumber_key</term>
            <listitem><para>lower(partnumber)</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.assembly via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.assembly"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-part"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.inventory-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.parts-translation"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.partstax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.parts-translation"
               xreflabel="public.parts_translation">
        <title id="public.table.parts-translation-title">
         Table:
         
         <structname>parts_translation</structname>
        </title>
 

        <para>
           Translation information for parts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>parts_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.partscustomer"
               xreflabel="public.partscustomer">
        <title id="public.table.partscustomer-title">
         Table:
         
         <structname>partscustomer</structname>
        </title>
 

        <para>
           Tracks per-customer pricing.  Discounts can be offered for periods of time
and for pricegroups as well as per customer
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partscustomer</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.pricegroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricebreak</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sellprice</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validfrom</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validto</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.partsgroup"
               xreflabel="public.partsgroup">
        <title id="public.table.partsgroup-title">
         Table:
         
         <structname>partsgroup</structname>
        </title>
 

        <para>
           Groups of parts for Point of Sale screen.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsgroup</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partsgroup</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parent</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.partsgroup"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partsgroup</title>

          <varlistentry>
            <term>partsgroup_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.partsgroup via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.partsgroup"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.partsgroup-translation"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.partsgroup-translation"
               xreflabel="public.partsgroup_translation">
        <title id="public.table.partsgroup-translation-title">
         Table:
         
         <structname>partsgroup_translation</structname>
        </title>
 

        <para>
           Translation information for partsgroups.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsgroup_translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.partsgroup"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.partstax"
               xreflabel="public.partstax">
        <title id="public.table.partstax-title">
         Table:
         
         <structname>partstax</structname>
        </title>
 

        <para>
           Mapping of parts to taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partstax</structname>
            </title>


            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.parts"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxcategory_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.taxcategory"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partstax</title>

          <varlistentry>
            <term>partstax_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.partsvendor"
               xreflabel="public.partsvendor">
        <title id="public.table.partsvendor-title">
         Table:
         
         <structname>partsvendor</structname>
        </title>
 

        <para>
           Tracks vendor&apos;s pricing, as well as vendor&apos;s part number, lead time 
required and currency.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>partsvendor</structname>
            </title>


            <varlistentry>
              <term><structfield>credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>parts_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>partnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>leadtime</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>lastcost</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>curr</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on partsvendor</title>

          <varlistentry>
            <term>partsvendor_parts_id_key</term>
            <listitem><para>parts_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.payment"
               xreflabel="public.payment">
        <title id="public.table.payment-title">
         Table:
         
         <structname>payment</structname>
        </title>
 

        <para>
           This table will store the main data on a payment, prepayment, overpayment, et
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                 This field will store the code for both receipts and payment order  
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>gl_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.gl"/>


              </para>

              <para>
                 A payment should always be linked to a GL movement 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_class</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>





                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>closed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

              <para>
                 This will store the current state of a payment/receipt order 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-credit-account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>currency</structfield></term>
              <listitem><para>
                <type>character(3)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notes</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on payment</title>

          <varlistentry>
            <term>payment_id_idx</term>
            <listitem><para>id</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.payment_links via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payment-links"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payment-links"
               xreflabel="public.payment_links">
        <title id="public.table.payment-links-title">
         Table:
         
         <structname>payment_links</structname>
        </title>
 

        <para>
            
 An explanation to the type field.
 * A type 0 means the link is referencing an ar/ap  and was created
   using an overpayment movement after the receipt was created 
 * A type 1 means the link is referencing an ar/ap and  was made 
   on the payment creation, its not the product of an overpayment movement 
 * A type 2 means the link is not referencing an ar/ap and its the product
   of the overpayment logic 

 With this ideas in order we can do the following

 To get the payment amount we will sum the entries with type &gt; 0.
 To get the linked amount we will sum the entries with type &lt; 2.
 The overpayment account can be obtained from the entries with type = 2.

 This reasoning is hacky and i hope it can dissapear when we get to 1.4 - D.M.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_links</structname>
            </title>


            <varlistentry>
              <term><structfield>payment_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.payment"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.acc-trans"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payment-map"
               xreflabel="public.payment_map">
        <title id="public.table.payment-map-title">
         Table:
         
         <structname>payment_map</structname>
        </title>
 

        <para>
           This maps the payment journal entry to the
invoices it pays.  A couple notes here:
1)  There is no requirement tht the payment &quot;invoice&quot; be linked to the same
entity_credit_account as the paid invoice.  People can pay eachothers invoices
if LedgerSMB supports this at an app level.
2)  This now means that payments are first class transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_map</structname>
            </title>


            <varlistentry>
              <term><structfield>line_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.journal-line"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pays</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.eca-invoice"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payment-type"
               xreflabel="public.payment_type">
        <title id="public.table.payment-type-title">
         Table:
         
         <structname>payment_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payment_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payroll-deduction"
               xreflabel="public.payroll_deduction">
        <title id="public.table.payroll-deduction-title">
         Table:
         
         <structname>payroll_deduction</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_deduction</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-deduction-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payroll-deduction-class"
               xreflabel="public.payroll_deduction_class">
        <title id="public.table.payroll-deduction-class-title">
         Table:
         
         <structname>payroll_deduction_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_deduction_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>



                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.country"/>






              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_deduction_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-deduction-type"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-deduction-type"
               xreflabel="public.payroll_deduction_type">
        <title id="public.table.payroll-deduction-type-title">
         Table:
         
         <structname>payroll_deduction_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_deduction_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pdc_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-deduction-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-deduction-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>calc_percent</structfield></term>
              <listitem><para>
                <type>boolean</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_deduction via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-deduction"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-employee-class"
               xreflabel="public.payroll_employee_class">
        <title id="public.table.payroll-employee-class-title">
         Table:
         
         <structname>payroll_employee_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_employee_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_employee_class_to_income_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-employee-class-to-income-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-employee-class-to-income-type"
               xreflabel="public.payroll_employee_class_to_income_type">
        <title id="public.table.payroll-employee-class-to-income-type-title">
         Table:
         
         <structname>payroll_employee_class_to_income_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_employee_class_to_income_type</structname>
            </title>


            <varlistentry>
              <term><structfield>ec_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-employee-class"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>it_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-income-type"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payroll-income-category"
               xreflabel="public.payroll_income_category">
        <title id="public.table.payroll-income-category-title">
         Table:
         
         <structname>payroll_income_category</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_income_category</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payroll-income-class"
               xreflabel="public.payroll_income_class">
        <title id="public.table.payroll-income-class-title">
         Table:
         
         <structname>payroll_income_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_income_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>




                      <literal>UNIQUE#1</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE#1</literal>



                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.country"/>






              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_income_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-income-type"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-income-type"
               xreflabel="public.payroll_income_type">
        <title id="public.table.payroll-income-type-title">
         Table:
         
         <structname>payroll_income_type</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_income_type</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pic_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-income-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>country_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-income-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>default_amount</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_employee_class_to_income_type via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-employee-class-to-income-type"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-report-line"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-wage"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-paid-timeoff"
               xreflabel="public.payroll_paid_timeoff">
        <title id="public.table.payroll-paid-timeoff-title">
         Table:
         
         <structname>payroll_paid_timeoff</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_paid_timeoff</structname>
            </title>


            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pto_class_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-pto-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>amount</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payroll-pto-class"
               xreflabel="public.payroll_pto_class">
        <title id="public.table.payroll-pto-class-title">
         Table:
         
         <structname>payroll_pto_class</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_pto_class</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_paid_timeoff via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-paid-timeoff"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-report"
               xreflabel="public.payroll_report">
        <title id="public.table.payroll-report-title">
         Table:
         
         <structname>payroll_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ec_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-employee-class"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment_date</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity-employee"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.payroll_paid_timeoff via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.payroll-paid-timeoff"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payroll-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.payroll-report-line"
               xreflabel="public.payroll_report_line">
        <title id="public.table.payroll-report-line-title">
         Table:
         
         <structname>payroll_report_line</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_report_line</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-report"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>employee_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>it_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-income-type"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>qty</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.payroll-wage"
               xreflabel="public.payroll_wage">
        <title id="public.table.payroll-wage-title">
         Table:
         
         <structname>payroll_wage</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>payroll_wage</structname>
            </title>


            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>type_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.payroll-income-type"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.view.periods"
               xreflabel="public.periods">
        <title id="public.view.periods-title">
         View:
         
         <structname>periods</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>periods</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>label</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_to</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_from</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view periods</title>
         <programlisting>
SELECT&apos;ytd&apos;::text AS id
,&apos;Year to Date&apos;::text AS label
, (now
     ()
)::date AS date_to
, (
     (
           (date_part
                 (&apos;year&apos;::text
                       , now
                       ()
                 )
           )::text || &apos;-01-01&apos;::text
     )
)::date AS date_from 
UNIONSELECT&apos;last_year&apos;::text AS id
,&apos;Last Year&apos;::text AS label
, (
     (
           (
                 (date_part
                       (&apos;YEAR&apos;::text
                             , now
                             ()
                       ) - 
                       (1)::double precision
                 )
           )::text || &apos;-12-31&apos;::text
     )
)::date AS date_to
, (
     (
           (
                 (date_part
                       (&apos;YEAR&apos;::text
                             , now
                             ()
                       ) - 
                       (1)::double precision
                 )
           )::text || &apos;-01-01&apos;::text
     )
)::date AS date_from;</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.person"
               xreflabel="public.person">
        <title id="public.table.person-title">
         Table:
         
         <structname>person</structname>
        </title>
 

        <para>
           Every person, must have an entity to derive a common or display name. The correct way to get class information on a person would be person.entity_id-&gt;entity_class_to_entity.entity_id. 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>








                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salutation_id</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.salutation"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>first_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>middle_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_name</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT (&apos;now&apos;::text)::date</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on person</title>

          <varlistentry>
            <term>person_first_name_check</term>
            <listitem><para>CHECK ((first_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>person_last_name_check</term>
            <listitem><para>CHECK ((last_name ~ &apos;[[:alnum:]_]&apos;::text))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.audittrail via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.audittrail"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.gl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.jcitems"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.oe"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.payment"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.person-to-company"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.person-to-company"
               xreflabel="public.person_to_company">
        <title id="public.table.person-to-company-title">
         Table:
         
         <structname>person_to_company</structname>
        </title>
 

        <para>
           currently unused in the front-end, but can be used to map persons
to companies.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>person_to_company</structname>
            </title>


            <varlistentry>
              <term><structfield>location_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.location"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>person_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.person"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>company_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.company"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.pricegroup"
               xreflabel="public.pricegroup">
        <title id="public.table.pricegroup-title">
         Table:
         
         <structname>pricegroup</structname>
        </title>
 

        <para>
           Pricegroups are groups of customers who are assigned prices and discounts
together.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>pricegroup</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pricegroup</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on pricegroup</title>

          <varlistentry>
            <term>pricegroup_id_key</term>
            <listitem><para>id</para></listitem>
          </varlistentry>



          <varlistentry>
            <term>pricegroup_pricegroup_key</term>
            <listitem><para>pricegroup</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.entity_credit_account via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.entity-credit-account"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.partscustomer"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.view.recon-payee"
               xreflabel="public.recon_payee">
        <title id="public.view.recon-payee-title">
         View:
         
         <structname>recon_payee</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>recon_payee</structname>
            </title>


            <varlistentry>
              <term><structfield>payee</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>bigint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>scn</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>their_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>our_balance</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>errorcode</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>user</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>clear_time</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>insert_time</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>trans_type</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>post_date</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ledger_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>voucher_id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>overlook</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>cleared</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view recon_payee</title>
         <programlisting>
SELECT n.name AS payee
, rr.id
, rr.report_id
, rr.scn
, rr.their_balance
, rr.our_balance
, rr.errorcode
, rr.&quot;user&quot;
, rr.clear_time
, rr.insert_time
, rr.trans_type
, rr.post_date
, rr.ledger_id
, ac.voucher_id
, rr.overlook
, rr.cleared 
FROM (
     (
           (cr_report_line rr 
         LEFT JOIN acc_trans ac 
                ON (
                       (rr.ledger_id = ac.entry_id)
                 )
           )
   LEFT JOIN gl 
          ON (
                 (ac.trans_id = gl.id)
           )
     )
LEFT JOIN (
           (
            SELECT ap.id
                 , e.name 
              FROM (
                       (ap 
                          JOIN entity_credit_account eca 
                            ON (
                                   (ap.entity_credit_account = eca.id)
                             )
                       )
                    JOIN entity e 
                      ON (
                             (eca.entity_id = e.id)
                       )
                 )
             UNIONSELECT ar.id
                 , e.name 
              FROM (
                       (ar 
                          JOIN entity_credit_account eca 
                            ON (
                                   (ar.entity_credit_account = eca.id)
                             )
                       )
                    JOIN entity e 
                      ON (
                             (eca.entity_id = e.id)
                       )
                 )
           )
       UNIONSELECT gl.id
           , gl.description 
        FROM gl
     ) n 
    ON (
           (n.id = ac.trans_id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.recurring"
               xreflabel="public.recurring">
        <title id="public.table.recurring-title">
         Table:
         
         <structname>recurring</structname>
        </title>
 

        <para>
           Stores recurring information on transactions which will recur in the future.
Note that this means that only fully posted transactions can recur. 
I would highly recommend depricating this table and working instead on extending
the template transaction addon to handle recurring information.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurring</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT nextval(&apos;id&apos;::regclass)</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>startdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>nextdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>enddate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>repeat</structfield></term>
              <listitem><para>
                <type>smallint</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>unit</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>howmany</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>payment</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.recurringemail"
               xreflabel="public.recurringemail">
        <title id="public.table.recurringemail-title">
         Table:
         
         <structname>recurringemail</structname>
        </title>
 

        <para>
          Email  to be sent out when recurring transaction is posted.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurringemail</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>format</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>message</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.recurringprint"
               xreflabel="public.recurringprint">
        <title id="public.table.recurringprint-title">
         Table:
         
         <structname>recurringprint</structname>
        </title>
 

        <para>
           Template, printer etc. to print to when recurring transaction posts.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>recurringprint</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>format</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printer</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.view.role-view"
               xreflabel="public.role_view">
        <title id="public.view.role-view-title">
         View:
         
         <structname>role_view</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>role_view</structname>
            </title>


            <varlistentry>
              <term><structfield>roleid</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>member</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>grantor</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>admin_option</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolname</structfield></term>
              <listitem><para>
                <type>name</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolsuper</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolinherit</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcreaterole</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcreatedb</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcatupdate</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolcanlogin</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolreplication</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolconnlimit</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolpassword</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolvaliduntil</structfield></term>
              <listitem><para>
                <type>timestamp with time zone</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rolconfig</structfield></term>
              <listitem><para>
                <type>text[]</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>oid</structfield></term>
              <listitem><para>
                <type>oid</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view role_view</title>
         <programlisting>
SELECT m.roleid
, m.member
, m.grantor
, m.admin_option
, a.rolname
, a.rolsuper
, a.rolinherit
, a.rolcreaterole
, a.rolcreatedb
, a.rolcatupdate
, a.rolcanlogin
, a.rolreplication
, a.rolconnlimit
, a.rolpassword
, a.rolvaliduntil
, a.rolconfig
, a.oid 
FROM (pg_auth_members m 
  JOIN pg_roles a 
    ON (
           (m.roleid = a.oid)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.salutation"
               xreflabel="public.salutation">
        <title id="public.table.salutation-title">
         Table:
         
         <structname>salutation</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>salutation</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>salutation</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.person via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.person"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.session"
               xreflabel="public.session">
        <title id="public.table.session-title">
         Table:
         
         <structname>session</structname>
        </title>
 

        <para>
           This table is used to track sessions on a database level across page 
requests (discretionary locks,open forms for anti-xsrf measures).
Because of the way LedgerSMB authentication works currently we do 
not time out authentication when the session times out.  We do time out 
highly pessimistic locks used for large batch payment workflows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>session</structname>
            </title>


            <varlistentry>
              <term><structfield>session_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>token</structfield></term>
              <listitem><para>
                <type>character varying(32)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>last_used</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>





                <literal>DEFAULT now()</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>ttl</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT 3600</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>users_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.users"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notify_pasword</structfield></term>
              <listitem><para>
                <type>interval</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;7 days&apos;::interval</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>



        <variablelist>
          <title>Constraints on session</title>

          <varlistentry>
            <term>session_token_check</term>
            <listitem><para>CHECK ((length((token)::text) = 32))</para></listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.batch via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.batch"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.journal-entry"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.open-forms"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.transactions"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.sic"
               xreflabel="public.sic">
        <title id="public.table.sic-title">
         Table:
         
         <structname>sic</structname>
        </title>
 

        <para>
          
This can be used SIC codes or any equivalent, such as ISIC, NAICS, etc.

        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>sic</structname>
            </title>


            <varlistentry>
              <term><structfield>code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>sictype</structfield></term>
              <listitem><para>
                <type>character(1)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.status"
               xreflabel="public.status">
        <title id="public.table.status-title">
         Table:
         
         <structname>status</structname>
        </title>
 

        <para>
           Whether AR/AP transactions and invoices have been emailed and/or printed 
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>status</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>formname</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>emailed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>spoolfile</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on status</title>

          <varlistentry>
            <term>status_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.tax"
               xreflabel="public.tax">
        <title id="public.table.tax-title">
         Table:
         
         <structname>tax</structname>
        </title>
 

        <para>
          Information on tax rates.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tax</structname>
            </title>


            <varlistentry>
              <term><structfield>chart_id</structfield></term>
              <listitem><para>
                <type>integer</type>










                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>



                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>minvalue</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>maxvalue</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxnumber</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>validto</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>


                <literal>PRIMARY KEY</literal>









                <literal>DEFAULT &apos;infinity&apos;::timestamp without time zone</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>pass</structfield></term>
              <listitem><para>
                <type>integer</type>



                <literal>NOT NULL</literal>





              </para>

              <para>
                This is an integer indicating the pass of the tax. This is to support 
cumultative sales tax rules (for example, Quebec charging taxes on the federal
taxes collected).
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>



                <literal>DEFAULT 1</literal>




                <literal>REFERENCES</literal> <xref linkend="public.table.taxmodule"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.tax-extended"
               xreflabel="public.tax_extended">
        <title id="public.table.tax-extended-title">
         Table:
         
         <structname>tax_extended</structname>
        </title>
 

        <para>
           This stores extended information for manual tax calculations.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tax_extended</structname>
            </title>


            <varlistentry>
              <term><structfield>tax_basis</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>rate</structfield></term>
              <listitem><para>
                <type>numeric</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entry_id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.journal-line"/>




              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.taxcategory"
               xreflabel="public.taxcategory">
        <title id="public.table.taxcategory-title">
         Table:
         
         <structname>taxcategory</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>taxcategory</structname>
            </title>


            <varlistentry>
              <term><structfield>taxcategory_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxcategoryname</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.taxmodule"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.partstax via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.partstax"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.taxmodule"
               xreflabel="public.taxmodule">
        <title id="public.table.taxmodule-title">
         Table:
         
         <structname>taxmodule</structname>
        </title>
 

        <para>
          This is used to store information on tax modules.  the module name is used
to determine the Perl class for the taxes.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>taxmodule</structname>
            </title>


            <varlistentry>
              <term><structfield>taxmodule_id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>taxmodulename</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.tax via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.tax"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.taxcategory"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.transactions"
               xreflabel="public.transactions">
        <title id="public.table.transactions-title">
         Table:
         
         <structname>transactions</structname>
        </title>
 

        <para>
           This table provides referential integrity between AR, AP, GL tables on one
hand and acc_trans on the other, pending the refactoring of those tables.  It
also is used to provide discretionary locking of financial transactions across 
database connections, for example in batch payment workflows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>transactions</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table_name</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>locked_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.session"/>


              </para>

              <para>
                 This should only be used in pessimistic locking measures as required by large
batch work flows. 
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_by</structfield></term>
              <listitem><para>
                <type>integer</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved_at</structfield></term>
              <listitem><para>
                <type>timestamp without time zone</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on transactions</title>

          <varlistentry>
            <term>transactions_locked_by_i</term>
            <listitem><para>locked_by</para></listitem>
          </varlistentry>

        </variablelist>





        <itemizedlist>
          <title>
            Tables referencing public.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.acc-trans"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.ap"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.ar"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.file-transaction"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.gl"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.invoice"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.voucher"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.translation"
               xreflabel="public.translation">
        <title id="public.table.translation-title">
         Table:
         
         <structname>translation</structname>
        </title>
 

        <para>
          abstract table for manual translation data. Should have zero rows.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>translation</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language_code</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>





        <variablelist>
          <title>Indexes on translation</title>

          <varlistentry>
            <term>translation_trans_id_key</term>
            <listitem><para>trans_id</para></listitem>
          </varlistentry>

        </variablelist>








      </para>
    </section>

      <section id="public.table.trial-balance"
               xreflabel="public.trial_balance">
        <title id="public.table.trial-balance-title">
         Table:
         
         <structname>trial_balance</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_from</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>date_to</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>





              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>yearend</structfield></term>
              <listitem><para>
                <type>text</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.trial-balance-yearend-types"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.trial_balance__account_to_report via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.trial-balance-account-to-report"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.trial-balance-heading-to-report"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.trial-balance-account-to-report"
               xreflabel="public.trial_balance__account_to_report">
        <title id="public.table.trial-balance-account-to-report-title">
         Table:
         
         <structname>trial_balance__account_to_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__account_to_report</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.trial-balance"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>account_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.trial-balance-heading-to-report"
               xreflabel="public.trial_balance__heading_to_report">
        <title id="public.table.trial-balance-heading-to-report-title">
         Table:
         
         <structname>trial_balance__heading_to_report</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__heading_to_report</structname>
            </title>


            <varlistentry>
              <term><structfield>report_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.trial-balance"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>heading_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.account-heading"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.trial-balance-yearend-types"
               xreflabel="public.trial_balance__yearend_types">
        <title id="public.table.trial-balance-yearend-types-title">
         Table:
         
         <structname>trial_balance__yearend_types</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>trial_balance__yearend_types</structname>
            </title>


            <varlistentry>
              <term><structfield>type</structfield></term>
              <listitem><para>
                <type>text</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.trial_balance via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.trial-balance"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.view.tx-report"
               xreflabel="public.tx_report">
        <title id="public.view.tx-report-title">
         View:
         
         <structname>tx_report</structname>
        </title>
 

        <para>
           This view provides join and approval information for transactions.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>tx_report</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reference</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_credit_account</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>table</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>approved</structfield></term>
              <listitem><para>
                <type>boolean</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view tx_report</title>
         <programlisting>
(
SELECT gl.id
     , gl.reference
     , NULL::integer AS entity_credit_account
     ,&apos;gl&apos;::text AS &quot;table&quot;
     , gl.approved 
  FROM gl 
UNION ALLSELECT ap.id
     , ap.invnumber AS reference
     , ap.entity_credit_account
     ,&apos;ap&apos;::text AS &quot;table&quot;
     , ap.approved 
  FROM ap
)
UNION ALLSELECT ar.id
, ar.invnumber AS reference
, ar.entity_credit_account
,&apos;ar&apos;::text AS &quot;table&quot;
, ar.approved 
FROM ar;</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.view.user-listable"
               xreflabel="public.user_listable">
        <title id="public.view.user-listable-title">
         View:
         
         <structname>user_listable</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>user_listable</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>username</structfield></term>
              <listitem><para>
                <type>character varying(30)</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>created</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>








        <figure>
         <title>Definition of view user_listable</title>
         <programlisting>
SELECT u.id
, u.username
, e.created 
FROM (entity e 
  JOIN users u 
    ON (
           (u.entity_id = e.id)
     )
);</programlisting>
        </figure>



      </para>
    </section>

      <section id="public.table.user-preference"
               xreflabel="public.user_preference">
        <title id="public.table.user-preference-title">
         Table:
         
         <structname>user_preference</structname>
        </title>
 

        <para>
           This table sets the basic preferences for formats, languages, printers, and user-selected stylesheets.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>user_preference</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>integer</type>






                <literal>PRIMARY KEY</literal>












                <literal>REFERENCES</literal> <xref linkend="public.table.users"/>




              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>language</structfield></term>
              <listitem><para>
                <type>character varying(6)</type>












                <literal>REFERENCES</literal> <xref linkend="public.table.language"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>stylesheet</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;ledgersmb.css&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>printer</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>dateformat</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;yyyy-mm-dd&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>numberformat</structfield></term>
              <listitem><para>
                <type>text</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;1000.00&apos;::text</literal>



              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>

      <section id="public.table.users"
               xreflabel="public.users">
        <title id="public.table.users-title">
         Table:
         
         <structname>users</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>users</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>




                      <literal>UNIQUE</literal>




                <literal>NOT NULL</literal>







              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>username</structfield></term>
              <listitem><para>
                <type>character varying(30)</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>notify_password</structfield></term>
              <listitem><para>
                <type>interval</type>



                <literal>NOT NULL</literal>



                <literal>DEFAULT &apos;7 days&apos;::interval</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>entity_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.entity"/>


              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.lsmb_roles via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.lsmb-roles"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.session"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.user-preference"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.voucher"
               xreflabel="public.voucher">
        <title id="public.table.voucher-title">
         Table:
         
         <structname>voucher</structname>
        </title>
 

        <para>
          Mapping transactions to batches for batch approval.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>voucher</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.transactions"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_id</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.batch"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

              <para>
                 This is simply a surrogate key for easy reference.
              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>batch_class</structfield></term>
              <listitem><para>
                <type>integer</type>







                <literal>NOT NULL</literal>






                <literal>REFERENCES</literal> <xref linkend="public.table.batch-class"/>


              </para>

              <para>
                 This is the authoritative class of the 
voucher. 
              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.acc_trans via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.acc-trans"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.warehouse"
               xreflabel="public.warehouse">
        <title id="public.table.warehouse-title">
         Table:
         
         <structname>warehouse</structname>
        </title>
 


        <para>
          <variablelist>
            <title>
              Structure of <structname>warehouse</structname>
            </title>


            <varlistentry>
              <term><structfield>id</structfield></term>
              <listitem><para>
                <type>serial</type>


                <literal>PRIMARY KEY</literal>













              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>description</structfield></term>
              <listitem><para>
                <type>text</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>







        <itemizedlist>
          <title>
            Tables referencing public.asset_item via Foreign Key Constraints
          </title>

          <listitem>
            <para>
              <xref linkend="public.table.asset-item"/>
            </para>
          </listitem>



          <listitem>
            <para>
              <xref linkend="public.table.asset-report-line"/>
            </para>
          </listitem>

        </itemizedlist>






      </para>
    </section>

      <section id="public.table.yearend"
               xreflabel="public.yearend">
        <title id="public.table.yearend-title">
         Table:
         
         <structname>yearend</structname>
        </title>
 

        <para>
           An extension to the journal_entry table to track transactionsactions which close out 
the books at yearend.
        </para>


        <para>
          <variablelist>
            <title>
              Structure of <structname>yearend</structname>
            </title>


            <varlistentry>
              <term><structfield>trans_id</structfield></term>
              <listitem><para>
                <type>integer</type>


                <literal>PRIMARY KEY</literal>


















                <literal>REFERENCES</literal> <xref linkend="public.table.gl"/>


              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>reversed</structfield></term>
              <listitem><para>
                <type>boolean</type>





                <literal>DEFAULT false</literal>



              </para>

            </listitem>
          </varlistentry>

            <varlistentry>
              <term><structfield>transdate</structfield></term>
              <listitem><para>
                <type>date</type>







              </para>

            </listitem>
          </varlistentry>

        </variablelist>










      </para>
    </section>



<!-- Function _entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer) -->
    <section id="public.function.-entity-location-save-in-country-id-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer"
             xreflabel="public_entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)">
      <title id="public.function.-entity-location-save-in-country-id-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer-title">
       _entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.-entity-location-save-in-country-id-integer-in-mail-code-integer-in-state-integer-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-text-in-entity-id-integer-titleabbrev">
       _entity_location_save(in_country_id integer, in_mail_code integer, in_state integer, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Private method for storing locations to an entity.  Do not call directly.
Returns the location id that was inserted or updated.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
	t_company_id int;
    BEGIN
	SELECT id INTO t_company_id
	FROM company WHERE entity_id = in_entity_id;

	DELETE FROM entity_to_location
	WHERE entity_id = in_entity_id
		AND location_class = in_location_class
		AND location_id = in_location_id;

	SELECT location_save(NULL, in_line_one, in_line_two, in_line_three, in_city,
		in_state, in_mail_code, in_country_id) 
	INTO l_id;

	INSERT INTO entity_to_location
		(entity_id, location_class, location_id)
	VALUES  (in_entity_id, in_location_class, l_id);

	RETURN l_id;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function account__delete(in_id integer) -->
    <section id="public.function.account-delete-in-id-integer"
             xreflabel="publicaccount__delete(in_id integer)">
      <title id="public.function.account-delete-in-id-integer-title">
       account__delete(in_id integer)
      </title>
      <titleabbrev id="public.function.account-delete-in-id-integer-titleabbrev">
       account__delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes an account with the id specified.  If the account has 
transactions associated with it, it will fail and raise a foreign key constraint.

        <programlisting>
BEGIN
DELETE FROM account_link WHERE account_id = in_id;
DELETE FROM account WHERE id = in_id;
RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__get_by_link_desc(in_description text) -->
    <section id="public.function.account-get-by-link-desc-in-description-text"
             xreflabel="publicaccount__get_by_link_desc(in_description text)">
      <title id="public.function.account-get-by-link-desc-in-description-text-title">
       account__get_by_link_desc(in_description text)
      </title>
      <titleabbrev id="public.function.account-get-by-link-desc-in-description-text-titleabbrev">
       account__get_by_link_desc(in_description text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets a list of accounts with a specific link description set.  For example,
for a dropdown list.
        <programlisting>
SELECT * FROM account
WHERE id IN (SELECT account_id FROM account_link WHERE description = $1);
</programlisting>
      </para>
    </section>

<!-- Function account__get_from_accno(in_accno text) -->
    <section id="public.function.account-get-from-accno-in-accno-text"
             xreflabel="publicaccount__get_from_accno(in_accno text)">
      <title id="public.function.account-get-from-accno-in-accno-text-title">
       account__get_from_accno(in_accno text)
      </title>
      <titleabbrev id="public.function.account-get-from-accno-in-accno-text-titleabbrev">
       account__get_from_accno(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the account where the accno field matches (excatly) the 
in_accno provided.
        <programlisting>
     select * from account where accno = $1;
</programlisting>
      </para>
    </section>

<!-- Function account__get_taxes() -->
    <section id="public.function.account-get-taxes"
             xreflabel="publicaccount__get_taxes()">
      <title id="public.function.account-get-taxes-title">
       account__get_taxes()
      </title>
      <titleabbrev id="public.function.account-get-taxes-titleabbrev">
       account__get_taxes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns set of accounts where the tax attribute is true.
        <programlisting>
SELECT * FROM account 
 WHERE tax is true
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function account__is_recon(in_accno text) -->
    <section id="public.function.account-is-recon-in-accno-text"
             xreflabel="publicaccount__is_recon(in_accno text)">
      <title id="public.function.account-is-recon-in-accno-text-title">
       account__is_recon(in_accno text)
      </title>
      <titleabbrev id="public.function.account-is-recon-in-accno-text-titleabbrev">
       account__is_recon(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if account is set up for reconciliation, false otherwise.
Note that returns false on invalid account number too
        <programlisting> SELECT count(*) &gt; 0 
     FROM cr_coa_to_account c2a
     JOIN account ON account.id = c2a.chart_id 
    WHERE accno = $1; </programlisting>
      </para>
    </section>

<!-- Function account__list_by_heading() -->
    <section id="public.function.account-list-by-heading"
             xreflabel="publicaccount__list_by_heading()">
      <title id="public.function.account-list-by-heading-title">
       account__list_by_heading()
      </title>
      <titleabbrev id="public.function.account-list-by-heading-titleabbrev">
       account__list_by_heading()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM account ORDER BY heading;
</programlisting>
      </para>
    </section>

<!-- Function account__obtain_balance(in_account_id date, in_transdate integer) -->
    <section id="public.function.account-obtain-balance-in-account-id-date-in-transdate-integer"
             xreflabel="publicaccount__obtain_balance(in_account_id date, in_transdate integer)">
      <title id="public.function.account-obtain-balance-in-account-id-date-in-transdate-integer-title">
       account__obtain_balance(in_account_id date, in_transdate integer)
      </title>
      <titleabbrev id="public.function.account-obtain-balance-in-account-id-date-in-transdate-integer-titleabbrev">
       account__obtain_balance(in_account_id date, in_transdate integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the account balance at a given point in time, calculating forward 
from most recent check point.
        <programlisting>
DECLARE balance numeric;
BEGIN
	SELECT coalesce(sum(ac.amount) + cp.amount, sum(ac.amount))
	INTO balance
	FROM acc_trans ac
	JOIN (select id, approved from ar union
		select id, approved from ap union
		select id, approved from gl) a ON (a.id = ac.trans_id)
	LEFT JOIN (select account_id, end_date, amount from account_checkpoint
		WHERE account_id = in_account_id AND end_date &lt; in_transdate
		ORDER BY end_date desc limit 1
	) cp ON (cp.account_id = ac.chart_id)
	WHERE ac.chart_id = in_account_id 
		AND ac.transdate &gt; coalesce(cp.end_date, ac.transdate - &#39;1 day&#39;::interval)
		and ac.approved and a.approved
		and ac.transdate &lt;= in_transdate
	GROUP BY cp.amount, ac.chart_id;

	RETURN balance;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean) -->
    <section id="public.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean"
             xreflabel="publicaccount__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)">
      <title id="public.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean-title">
       account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)
      </title>
      <titleabbrev id="public.function.account-save-in-is-temp-integer-in-obsolete-text-in-link-text-in-tax-bpchar-in-contra-text-in-heading-integer-in-gifi-accno-boolean-in-category-boolean-in-description-textARRAY-in-accno-boolean-in-id-boolean-titleabbrev">
       account__save(in_is_temp integer, in_obsolete text, in_link text, in_tax bpchar, in_contra text, in_heading integer, in_gifi_accno boolean, in_category boolean, in_description text[], in_accno boolean, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This deletes existing account_link entries, where the 
account_link.description is not designated as a custom one in the 
account_link_description table.

If no account heading is provided, the account heading which has an accno field
closest to but prior (by collation order) is used.

Then it saves the account information, and rebuilds the account_link records 
based on the in_link array.

        <programlisting>
DECLARE 
	t_heading_id int;
	t_link record;
	t_id int;
        t_tax bool;
BEGIN

    SELECT count(*) &gt; 0 INTO t_tax FROM tax WHERE in_id = chart_id;
    t_tax := t_tax OR in_tax;
	-- check to ensure summary accounts are exclusive
        -- necessary for proper handling by legacy code
    FOR t_link IN SELECT description FROM account_link_description 
    WHERE summary=&#39;t&#39;
	LOOP
		IF t_link.description = ANY (in_link) and array_upper(in_link, 1) &gt; 1 THEN
			RAISE EXCEPTION &#39;Invalid link settings:  Summary&#39;;
		END IF;
	END LOOP;
	-- heading settings
	IF in_heading IS NULL THEN
		SELECT id INTO t_heading_id FROM account_heading 
		WHERE accno &lt; in_accno order by accno desc limit 1;
	ELSE
		t_heading_id := in_heading;
	END IF;

    -- don&#39;t remove custom links.
	DELETE FROM account_link 
	WHERE account_id = in_id 
              and description in ( select description 
                                    from  account_link_description
                                    where custom = &#39;f&#39;);

	UPDATE account 
	SET accno = in_accno,
		description = in_description,
		category = in_category,
		gifi_accno = in_gifi_accno,
		heading = t_heading_id,
		contra = in_contra,
                obsolete = in_obsolete,
                tax = t_tax,
                is_temp = in_is_temp
	WHERE id = in_id;

	IF FOUND THEN
		t_id := in_id;
	ELSE
                -- can&#39;t obsolete on insert, but this can be changed if users
                -- request it --CT
		INSERT INTO account (accno, description, category, gifi_accno,
			heading, contra, tax, is_temp)
		VALUES (in_accno, in_description, in_category, in_gifi_accno,
			t_heading_id, in_contra, in_tax, in_is_temp);

		t_id := currval(&#39;account_id_seq&#39;);
	END IF;

	FOR t_link IN 
		select in_link[generate_series] AS val
		FROM generate_series(array_lower(in_link, 1), 
			array_upper(in_link, 1))
	LOOP
		INSERT INTO account_link (account_id, description)
		VALUES (t_id, t_link.val);
	END LOOP;

	
	RETURN t_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date) -->
    <section id="public.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date"
             xreflabel="publicaccount__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)">
      <title id="public.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date-title">
       account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)
      </title>
      <titleabbrev id="public.function.account-save-tax-in-old-validto-integer-in-taxmodule-id-date-in-pass-numeric-in-taxnumber-numeric-in-maxvalue-numeric-in-minvalue-text-in-rate-integer-in-validto-integer-in-chart-id-date-titleabbrev">
       account__save_tax(in_old_validto integer, in_taxmodule_id date, in_pass numeric, in_taxnumber numeric, in_maxvalue numeric, in_minvalue text, in_rate integer, in_validto integer, in_chart_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This saves tax rates.
        <programlisting>
BEGIN
	UPDATE tax SET validto = in_validto,
               rate = in_rate,
               minvalue = in_minvalue,
               maxvalue = in_maxvalue,
               taxnumber = in_taxnumber,
               pass = in_pass,
               taxmodule_id = in_taxmodule_id
         WHERE chart_id = in_chart_id and validto = in_old_validto;

         IF FOUND THEN
             return true;
         END IF;

         INSERT INTO tax(chart_id, validto, rate, minvalue, maxvalue, taxnumber,
                        pass, taxmodule_id)
         VALUES (in_chart_id, in_validto, in_rate, in_minvalue, in_maxvalue, 
                in_taxnumber, in_pass, in_taxmodule_id);

         RETURN TRUE;

END;
</programlisting>
      </para>
    </section>

<!-- Function account_get(in_id integer) -->
    <section id="public.function.account-get-in-id-integer"
             xreflabel="publicaccount_get(in_id integer)">
      <title id="public.function.account-get-in-id-integer-title">
       account_get(in_id integer)
      </title>
      <titleabbrev id="public.function.account-get-in-id-integer-titleabbrev">
       account_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns an entry from the chart view which matches the id requested, and which
is an account, not a heading.
        <programlisting>
SELECT * from chart where id = $1 and charttype = &#39;A&#39;;
</programlisting>
      </para>
    </section>

<!-- Function account_has_transactions(in_id integer) -->
    <section id="public.function.account-has-transactions-in-id-integer"
             xreflabel="publicaccount_has_transactions(in_id integer)">
      <title id="public.function.account-has-transactions-in-id-integer-title">
       account_has_transactions(in_id integer)
      </title>
      <titleabbrev id="public.function.account-has-transactions-in-id-integer-titleabbrev">
       account_has_transactions(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Checks to see if any transactions use this account.  If so, returns true.
If not, returns false.
        <programlisting>
BEGIN
	PERFORM trans_id FROM acc_trans WHERE chart_id = in_id LIMIT 1;
	IF FOUND THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function account_heading__list() -->
    <section id="public.function.account-heading-list"
             xreflabel="publicaccount_heading__list()">
      <title id="public.function.account-heading-list-title">
       account_heading__list()
      </title>
      <titleabbrev id="public.function.account-heading-list-titleabbrev">
       account_heading__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_heading</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all account headings, currently ordered by account number.

        <programlisting> SELECT * FROM account_heading order by accno; </programlisting>
      </para>
    </section>

<!-- Function account_heading_get(in_id integer) -->
    <section id="public.function.account-heading-get-in-id-integer"
             xreflabel="publicaccount_heading_get(in_id integer)">
      <title id="public.function.account-heading-get-in-id-integer-title">
       account_heading_get(in_id integer)
      </title>
      <titleabbrev id="public.function.account-heading-get-in-id-integer-titleabbrev">
       account_heading_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>chart</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns an entry from the chart view which matches the id requested, and which
is a heading, not an account.
        <programlisting>
DECLARE
	account chart%ROWTYPE;
BEGIN
	SELECT * INTO account FROM chart WHERE id = in_id AND charttype = &#39;H&#39;;
	RETURN account;
END;
</programlisting>
      </para>
    </section>

<!-- Function account_heading_list() -->
    <section id="public.function.account-heading-list"
             xreflabel="publicaccount_heading_list()">
      <title id="public.function.account-heading-list-title">
       account_heading_list()
      </title>
      <titleabbrev id="public.function.account-heading-list-titleabbrev">
       account_heading_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_heading</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all existing account headings.
        <programlisting>
SELECT * FROM account_heading order by accno;
</programlisting>
      </para>
    </section>

<!-- Function account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer) -->
    <section id="public.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer"
             xreflabel="publicaccount_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)">
      <title id="public.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer-title">
       account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)
      </title>
      <titleabbrev id="public.function.account-heading-save-in-parent-integer-in-description-text-in-accno-text-in-id-integer-titleabbrev">
       account_heading_save(in_parent integer, in_description text, in_accno text, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an account heading. 
        <programlisting>
BEGIN
	UPDATE account_heading
	SET accno = in_accno,
		description = in_description,
		parent_id = in_parent
	WHERE id = in_id;

	IF FOUND THEN
		RETURN in_id;
	END IF;
	INSERT INTO account_heading (accno, description, parent_id)
	VALUES (in_accno, in_description, in_parent);

	RETURN currval(&#39;account_heading_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying) -->
    <section id="public.function.add-custom-field-field-datatype-character-varying-new-field-name-character-varying-table-name-character-varying"
             xreflabel="publicadd_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying)">
      <title id="public.function.add-custom-field-field-datatype-character-varying-new-field-name-character-varying-table-name-character-varying-title">
       add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying)
      </title>
      <titleabbrev id="public.function.add-custom-field-field-datatype-character-varying-new-field-name-character-varying-table-name-character-varying-titleabbrev">
       add_custom_field(field_datatype character varying, new_field_name character varying, table_name character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
	perform TABLE_ID FROM custom_table_catalog 
		WHERE extends = table_name;
	IF NOT FOUND THEN
		BEGIN
			INSERT INTO custom_table_catalog (extends) 
				VALUES (table_name);
			EXECUTE &#39;CREATE TABLE &#39; || 
                               quote_ident(&#39;custom_&#39; ||table_name) ||
				&#39; (row_id INT PRIMARY KEY)&#39;;
		EXCEPTION WHEN duplicate_table THEN
			-- do nothing
		END;
	END IF;
	INSERT INTO custom_field_catalog (field_name, table_id)
	values (new_field_name, (SELECT table_id 
                                        FROM custom_table_catalog
		WHERE extends = table_name));
	EXECUTE &#39;ALTER TABLE &#39;|| quote_ident(&#39;custom_&#39;||table_name) || 
                &#39; ADD COLUMN &#39; || quote_ident(new_field_name) || &#39; &#39; || 
                  quote_ident(field_datatype);
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__add_function_to_group(in_role text, in_func text) -->
    <section id="public.function.admin-add-function-to-group-in-role-text-in-func-text"
             xreflabel="publicadmin__add_function_to_group(in_role text, in_func text)">
      <title id="public.function.admin-add-function-to-group-in-role-text-in-func-text-title">
       admin__add_function_to_group(in_role text, in_func text)
      </title>
      <titleabbrev id="public.function.admin-add-function-to-group-in-role-text-in-func-text-titleabbrev">
       admin__add_function_to_group(in_role text, in_func text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions to a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;GRANT EXECUTE ON FUNCTION &#39;|| quote_ident(in_func) ||&#39; to &#39;|| quote_ident(in_role);
        
        EXECUTE stmt;
        
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__add_group_to_role(in_role_name text, in_group_name text) -->
    <section id="public.function.admin-add-group-to-role-in-role-name-text-in-group-name-text"
             xreflabel="publicadmin__add_group_to_role(in_role_name text, in_group_name text)">
      <title id="public.function.admin-add-group-to-role-in-role-name-text-in-group-name-text-title">
       admin__add_group_to_role(in_role_name text, in_group_name text)
      </title>
      <titleabbrev id="public.function.admin-add-group-to-role-in-role-name-text-in-group-name-text-titleabbrev">
       admin__add_group_to_role(in_role_name text, in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This function inserts the arguments into lsmb_group_grants for future
reference and issues the db-level grant.  It then returns true if there are no
exceptions.
        <programlisting> 
BEGIN
   PERFORM * FROM lsmb_group_grants 
     WHERE group_name = in_group_name AND
           granted_role = in_role_name;

 IF NOT FOUND THEN
   INSERT INTO lsmb_group_grants(group_name, granted_role) 
   VALUES (in_group_name, in_role_name);
 END IF;

   EXECUTE &#39;GRANT &#39; || quote_ident(in_role_name) || &#39; TO &#39; ||
           quote_literal(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name);
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__add_user_to_role(in_role text, in_username text) -->
    <section id="public.function.admin-add-user-to-role-in-role-text-in-username-text"
             xreflabel="publicadmin__add_user_to_role(in_role text, in_username text)">
      <title id="public.function.admin-add-user-to-role-in-role-text-in-username-text-title">
       admin__add_user_to_role(in_role text, in_username text)
      </title>
      <titleabbrev id="public.function.admin-add-user-to-role-in-role-text-in-username-text-titleabbrev">
       admin__add_user_to_role(in_role text, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot grant permissions to a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;GRANT &#39;|| quote_ident(in_role) ||&#39; to &#39;|| quote_ident(in_username);
        
        EXECUTE stmt;
        insert into lsmb_roles (user_id, role) 
        SELECT id, in_role from users where username = in_username;
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__create_group(in_group_name text) -->
    <section id="public.function.admin-create-group-in-group-name-text"
             xreflabel="publicadmin__create_group(in_group_name text)">
      <title id="public.function.admin-create-group-in-group-name-text-title">
       admin__create_group(in_group_name text)
      </title>
      <titleabbrev id="public.function.admin-create-group-in-group-name-text-titleabbrev">
       admin__create_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    DECLARE
        
        stmt text;
        t_dbname text;
    BEGIN
	t_dbname := current_database();
        stmt := &#39;create role &#39;|| quote_ident(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name);
        execute stmt;
        INSERT INTO lsmb_group (role_name) 
             values (quote_literal(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name));
        return 1;
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__delete_group(in_group_name text) -->
    <section id="public.function.admin-delete-group-in-group-name-text"
             xreflabel="publicadmin__delete_group(in_group_name text)">
      <title id="public.function.admin-delete-group-in-group-name-text-title">
       admin__delete_group(in_group_name text)
      </title>
      <titleabbrev id="public.function.admin-delete-group-in-group-name-text-titleabbrev">
       admin__delete_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        
    Deletes the input group from the database. Not designed to be used to 
    remove a login-capable user.

        <programlisting>
    
    DECLARE
        stmt text;
        a_role role_view;
        t_dbname text;
    BEGIN
        t_dbname := current_database();
        

        select * into a_role from role_view where rolname = in_group_name;
        
        if not found then
            return &#39;f&#39;::bool;
        else
            stmt := &#39;drop role lsmb_&#39; || quote_ident(t_dbname || &#39;__&#39; || in_group_name);
            execute stmt;
            return &#39;t&#39;::bool;
        end if;
    END;
</programlisting>
      </para>
    </section>

<!-- Function admin__delete_user(in_drop_role text, in_username boolean) -->
    <section id="public.function.admin-delete-user-in-drop-role-text-in-username-boolean"
             xreflabel="publicadmin__delete_user(in_drop_role text, in_username boolean)">
      <title id="public.function.admin-delete-user-in-drop-role-text-in-username-boolean-title">
       admin__delete_user(in_drop_role text, in_username boolean)
      </title>
      <titleabbrev id="public.function.admin-delete-user-in-drop-role-text-in-username-boolean-titleabbrev">
       admin__delete_user(in_drop_role text, in_username boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        
    Drops the provided user, as well as deletes the user configuration data.
It leaves the entity and person references.

If in_drop_role is set, it drops the role too.

        <programlisting>
    
    DECLARE
        stmt text;
        a_user users;
    BEGIN
    
        select * into a_user from users where username = in_username;
        
        IF NOT FOUND THEN
        
            raise exception &#39;User not found.&#39;;
        ELSIF FOUND THEN
            IF in_drop_role IS TRUE then 
                stmt := &#39; drop user &#39; || quote_ident(a_user.username);
                execute stmt;
            END IF;    
            -- also gets user_connection
            delete from user_preference where id = (
                   select id from users where entity_id = a_user.entity_id);
            delete from users where entity_id = a_user.entity_id;
            return 1;
        END IF;   
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__drop_session(in_session_id integer) -->
    <section id="public.function.admin-drop-session-in-session-id-integer"
             xreflabel="publicadmin__drop_session(in_session_id integer)">
      <title id="public.function.admin-drop-session-in-session-id-integer-title">
       admin__drop_session(in_session_id integer)
      </title>
      <titleabbrev id="public.function.admin-drop-session-in-session-id-integer-titleabbrev">
       admin__drop_session(in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Drops the session identified, releasing all locks held.
        <programlisting>
BEGIN
	DELETE FROM &quot;session&quot; WHERE session_id = in_session_id;
	RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__get_roles() -->
    <section id="public.function.admin-get-roles"
             xreflabel="publicadmin__get_roles()">
      <title id="public.function.admin-get-roles-title">
       admin__get_roles()
      </title>
      <titleabbrev id="public.function.admin-get-roles-titleabbrev">
       admin__get_roles()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF pg_roles</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
    v_rol record;
    t_dbname text;
BEGIN
    t_dbname := current_database();
    FOR v_rol in 
        SELECT *
        from 
            pg_roles
        where 
            rolname ~ (&#39;^lsmb_&#39; || t_dbname || &#39;__&#39;) 
            and rolcanlogin is false
        order by rolname ASC
    LOOP
        RETURN NEXT v_rol;
    END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function admin__get_roles_for_user(in_user_id integer) -->
    <section id="public.function.admin-get-roles-for-user-in-user-id-integer"
             xreflabel="publicadmin__get_roles_for_user(in_user_id integer)">
      <title id="public.function.admin-get-roles-for-user-in-user-id-integer-title">
       admin__get_roles_for_user(in_user_id integer)
      </title>
      <titleabbrev id="public.function.admin-get-roles-for-user-in-user-id-integer-titleabbrev">
       admin__get_roles_for_user(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF text</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of roles that  a user is a part of.
        <programlisting>
    
    declare
        u_role record;
        a_user users;
    begin
        select * into a_user from admin__get_user(in_user_id);
        
        FOR u_role IN 
        select r.rolname 
        from 
            pg_roles r,
            (select 
                m.roleid 
             from 
                pg_auth_members m, pg_roles b 
             where 
                m.member = b.oid 
             and 
                b.rolname = a_user.username
            ) as ar
         where 
            r.oid = ar.roleid
         LOOP
        
            RETURN NEXT u_role.rolname::text;
        
        END LOOP;
        RETURN;
    end;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__get_user(in_entity_id integer) -->
    <section id="public.function.admin-get-user-in-entity-id-integer"
             xreflabel="publicadmin__get_user(in_entity_id integer)">
      <title id="public.function.admin-get-user-in-entity-id-integer-title">
       admin__get_user(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.admin-get-user-in-entity-id-integer-titleabbrev">
       admin__get_user(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) user specified by the id.
        <programlisting>
    
    DECLARE
        a_user users;
    BEGIN
        
        select * into a_user from users where entity_id = in_entity_id;
        return next a_user;
        return;
    
    END;    
</programlisting>
      </para>
    </section>

<!-- Function admin__is_group(in_group_name text) -->
    <section id="public.function.admin-is-group-in-group-name-text"
             xreflabel="publicadmin__is_group(in_group_name text)">
      <title id="public.function.admin-is-group-in-group-name-text-title">
       admin__is_group(in_group_name text)
      </title>
      <titleabbrev id="public.function.admin-is-group-in-group-name-text-titleabbrev">
       admin__is_group(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    -- This needs some work.  CT 
    DECLARE
        
        existant_role pg_roles;
        stmt text;
        
    BEGIN
        select * into existant_role from pg_roles 
        where rolname = in_group_name AND rolcanlogin is false;
        
        if not found then
            return &#39;f&#39;::bool;
            
        else
            return &#39;t&#39;::bool;
        end if;            
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__is_user(in_user text) -->
    <section id="public.function.admin-is-user-in-user-text"
             xreflabel="publicadmin__is_user(in_user text)">
      <title id="public.function.admin-is-user-in-user-text-title">
       admin__is_user(in_user text)
      </title>
      <titleabbrev id="public.function.admin-is-user-in-user-text-titleabbrev">
       admin__is_user(in_user text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if user is set up in LedgerSMB.  False otherwise.
        <programlisting>
    BEGIN
    
        PERFORM * from users where username = in_user;
        RETURN found;     
    
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__list_group_grants(in_group_name text) -->
    <section id="public.function.admin-list-group-grants-in-group-name-text"
             xreflabel="publicadmin__list_group_grants(in_group_name text)">
      <title id="public.function.admin-list-group-grants-in-group-name-text-title">
       admin__list_group_grants(in_group_name text)
      </title>
      <titleabbrev id="public.function.admin-list-group-grants-in-group-name-text-titleabbrev">
       admin__list_group_grants(in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF lsmb_group_grants</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM lsmb_group_grants WHERE group_name = $1
ORDER BY granted_role;
</programlisting>
      </para>
    </section>

<!-- Function admin__list_sessions() -->
    <section id="public.function.admin-list-sessions"
             xreflabel="publicadmin__list_sessions()">
      <title id="public.function.admin-list-sessions-title">
       admin__list_sessions()
      </title>
      <titleabbrev id="public.function.admin-list-sessions-titleabbrev">
       admin__list_sessions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF session_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all active sessions.
        <programlisting>
SELECT s.session_id, u.username, s.last_used, count(t.id)
FROM &quot;session&quot; s
JOIN users u ON (s.users_id = u.id)
LEFT JOIN transactions t ON (t.locked_by = s.session_id)
GROUP BY s.session_id, u.username, s.last_used
ORDER BY u.username;
</programlisting>
      </para>
    </section>

<!-- Function admin__remove_function_from_group(in_role text, in_func text) -->
    <section id="public.function.admin-remove-function-from-group-in-role-text-in-func-text"
             xreflabel="publicadmin__remove_function_from_group(in_role text, in_func text)">
      <title id="public.function.admin-remove-function-from-group-in-role-text-in-func-text-title">
       admin__remove_function_from_group(in_role text, in_func text)
      </title>
      <titleabbrev id="public.function.admin-remove-function-from-group-in-role-text-in-func-text-titleabbrev">
       admin__remove_function_from_group(in_role text, in_func text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions of non-existant role $.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions from a non-existant function.&#39;;
        END IF;
        
        stmt := &#39;REVOKE EXECUTE ON FUNCTION &#39;|| quote_ident(in_func) ||&#39; FROM &#39;|| quote_ident(in_role);
        
        EXECUTE stmt;
        
        return 1;    
    END;
    
    
</programlisting>
      </para>
    </section>

<!-- Function admin__remove_group_from_role(in_role_name text, in_group_name text) -->
    <section id="public.function.admin-remove-group-from-role-in-role-name-text-in-group-name-text"
             xreflabel="publicadmin__remove_group_from_role(in_role_name text, in_group_name text)">
      <title id="public.function.admin-remove-group-from-role-in-role-name-text-in-group-name-text-title">
       admin__remove_group_from_role(in_role_name text, in_group_name text)
      </title>
      <titleabbrev id="public.function.admin-remove-group-from-role-in-role-name-text-in-group-name-text-titleabbrev">
       admin__remove_group_from_role(in_role_name text, in_group_name text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
Returns true if the grant record was found and deleted, false otherwise.
Issues db-level revoke in all cases.
        <programlisting>
BEGIN

   EXECUTE &#39;REVOKE &#39; || quote_ident(in_role_name) || &#39; FROM &#39; ||
           quote_literal(&#39;lsmb_&#39; || t_dbname || &#39;__&#39; || in_group_name);

   DELETE FROM lsmb_group_grants 
    WHERE group_name = in_group_name AND granted_role = in_role_name;

   RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function admin__remove_user_from_role(in_role text, in_username text) -->
    <section id="public.function.admin-remove-user-from-role-in-role-text-in-username-text"
             xreflabel="publicadmin__remove_user_from_role(in_role text, in_username text)">
      <title id="public.function.admin-remove-user-from-role-in-role-text-in-username-text-title">
       admin__remove_user_from_role(in_role text, in_username text)
      </title>
      <titleabbrev id="public.function.admin-remove-user-from-role-in-role-text-in-username-text-titleabbrev">
       admin__remove_user_from_role(in_role text, in_username text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    declare
        stmt TEXT;
        a_role name;
        a_user name;
    BEGIN
    
        -- Issue the grant
        select rolname into a_role from pg_roles where rolname = in_role;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions of a non-existant role.&#39;;
        END IF;
        
        select rolname into a_user from pg_roles where rolname = in_username;
        
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Cannot revoke permissions from a non-existant user.&#39;;
        END IF;
        
        stmt := &#39;REVOKE &#39;|| quote_ident(in_role) ||&#39; FROM &#39;|| quote_ident(in_username);
        
        EXECUTE stmt;
        
        return 1;    
    END;
    
</programlisting>
      </para>
    </section>

<!-- Function admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean) -->
    <section id="public.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean"
             xreflabel="publicadmin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)">
      <title id="public.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean-title">
       admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)
      </title>
      <titleabbrev id="public.function.admin-save-user-in-import-integer-in-password-integer-in-username-text-in-entity-id-text-in-id-boolean-titleabbrev">
       admin__save_user(in_import integer, in_password integer, in_username text, in_entity_id text, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates a user and relevant records in LedgerSMB and PostgreSQL.
        <programlisting>
    DECLARE
    
        a_user users;
        v_user_id int;
        p_id int;
        l_id int;
        stmt text;
        t_is_role bool;
        t_is_user bool;
    BEGIN
        -- WARNING TO PROGRAMMERS:  This function runs as the definer and runs
        -- utility statements via EXECUTE.
        -- PLEASE BE VERY CAREFUL ABOUT SQL-INJECTION INSIDE THIS FUNCTION.

       PERFORM rolname FROM pg_roles WHERE rolname = in_username;
       t_is_role := found;
       t_is_user := admin__is_user(in_username);

       IF t_is_role is true and t_is_user is false and in_import is false THEN
          RAISE EXCEPTION &#39;Duplicate user&#39;;
        END IF;

        if t_is_role and in_password is not null then
                execute &#39;ALTER USER &#39; || quote_ident( in_username ) || 
                     &#39; WITH ENCRYPTED PASSWORD &#39; || quote_literal (in_password)
                     || $e$ valid until $e$ || 
                      quote_literal(now() + &#39;1 day&#39;::interval);
        elsif in_import is false AND t_is_user is false 
              AND in_password IS NULL THEN
                RAISE EXCEPTION &#39;No password&#39;;
        elsif  t_is_role is false and in_import IS FALSE THEN
            -- create an actual user
                execute &#39;CREATE USER &#39; || quote_ident( in_username ) || 
                     &#39; WITH ENCRYPTED PASSWORD &#39; || quote_literal (in_password)
                     || $e$ valid until $e$ || quote_literal(now() + &#39;1 day&#39;::interval);
       END IF;         
        
        select * into a_user from users lu where lu.id = in_id;
        IF FOUND THEN 
            return a_user.id;
        ELSE
            -- Insert cycle
            
            --- The entity is expected to already BE created. See admin.pm.
            
            
            v_user_id := nextval(&#39;users_id_seq&#39;);
            insert into users (id, username, entity_id) VALUES (
                v_user_id,
                in_username,
                in_entity_id
            );
            
            insert into user_preference (id) values (v_user_id);

            IF NOT exists(SELECT * FROM entity_employee WHERE entity_id = in_entity_id) THEN
                INSERT into entity_employee (entity_id) values (in_entity_id);
            END IF;
            -- Finally, issue the create user statement
            
            return v_user_id ;

            
        
        END IF;
    
    END;
</programlisting>
      </para>
    </section>

<!-- Function admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date) -->
    <section id="public.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date"
             xreflabel="publicadmin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)">
      <title id="public.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date-title">
       admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)
      </title>
      <titleabbrev id="public.function.admin-search-users-in-dob-text-in-ssn-text-in-last-name-text-in-first-name-text-in-username-date-titleabbrev">
       admin__search_users(in_dob text, in_ssn text, in_last_name text, in_first_name text, in_username date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF user_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of users matching search criteria.  Nulls match all values.
only username is not an exact match.
        <programlisting>
DECLARE t_return_row user_result;
BEGIN
	FOR t_return_row IN
		SELECT u.id, u.username, p.first_name, p.last_name, e.ssn, e.dob
		FROM users u
		JOIN person p ON (u.entity_id = p.entity_id)
		JOIN entity_employee e ON (e.entity_id = p.entity_id)
		WHERE u.username LIKE &#39;%&#39; || coalesce(in_username,&#39;&#39;) || &#39;%&#39; AND
			(p.first_name = in_first_name or in_first_name is null)
			AND (p.last_name = in_last_name or in_last_name is null)
			AND (in_ssn is NULL or in_ssn = e.ssn) 
			AND (e.dob = in_dob::date or in_dob is NULL)
	LOOP
		RETURN NEXT t_return_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function as_array(anyelement) -->
    <section id="public.function.as-array-anyelement"
             xreflabel="publicas_array(anyelement)">
      <title id="public.function.as-array-anyelement-title">
       as_array(anyelement)
      </title>
      <titleabbrev id="public.function.as-array-anyelement-titleabbrev">
       as_array(anyelement)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>anyarray</seg>
        </seglistitem>
       </segmentedlist>
 
        A basic array aggregate to take elements and return a one-dimensional array.

Example:  SELECT as_array(id) from entity_class;

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function asset__get(in_tag integer, in_id text) -->
    <section id="public.function.asset-get-in-tag-integer-in-id-text"
             xreflabel="publicasset__get(in_tag integer, in_id text)">
      <title id="public.function.asset-get-in-tag-integer-in-id-text-title">
       asset__get(in_tag integer, in_id text)
      </title>
      <titleabbrev id="public.function.asset-get-in-tag-integer-in-id-text-titleabbrev">
       asset__get(in_tag integer, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a given asset either by id or tag.  Both are complete matches.

Note that the behavior is undefined if both id and tag are provided.
        <programlisting>
DECLARE ret_val asset_item;
BEGIN
	SELECT * into ret_val from asset_item WHERE id = in_id OR in_tag = tag
        ORDER BY id desc limit 1;
	return ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__import_from_disposal(in_id integer) -->
    <section id="public.function.asset-import-from-disposal-in-id-integer"
             xreflabel="publicasset__import_from_disposal(in_id integer)">
      <title id="public.function.asset-import-from-disposal-in-id-integer-title">
       asset__import_from_disposal(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-import-from-disposal-in-id-integer-titleabbrev">
       asset__import_from_disposal(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Imports items from partial disposal reports. This function should not be
called dirctly by programmers but rather through the other disposal approval
api&apos;s.
        <programlisting>
DECLARE t_report asset_report;
        t_import asset_report;
BEGIN

    SELECT * INTO t_report from asset_report where id = in_id;

    if t_report.report_class &lt;&gt; 4 THEN RETURN FALSE;
    END IF;

    SELECT * 
      INTO t_import 
      FROM  asset_report__begin_import 
            (t_report.asset_class::int, t_report.report_date);

    PERFORM asset_report__import(
	ai.description,
	ai.tag,
	ai.purchase_value * rld.percent_disposed / 100,
	ai.salvage_value * rld.percent_disposed / 100,
	ai.usable_life,
	ai.purchase_date,
        ai.start_depreciation,
	ai.location_id,
	ai.department_id,
	ai.asset_account_id,
	ai.dep_account_id,
	ai.exp_account_id,
	ai.asset_class_id,
        ai.invoice_id,
        t_import.id,
        r.accum_depreciation * rld.percent_disposed / 100,
        TRUE)
    FROM asset_item ai
    JOIN asset_report__get_disposal(t_report.id) r  ON (ai.id = r.id)
    JOIN asset_report_line rl ON (rl.asset_id = ai.id AND rl.report_id = in_id)
    join asset_rl_to_disposal_method rld 
         ON (rl.report_id = rld.report_id and ai.id = rld.asset_id)
   where rld.percent_disposed is null or percent_disposed &lt; 100;
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer) -->
    <section id="public.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer"
             xreflabel="publicasset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)">
      <title id="public.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-title">
       asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </title>
      <titleabbrev id="public.function.asset-save-in-exp-account-id-integer-in-dep-account-id-integer-in-asset-account-id-text-in-invoice-id-text-in-department-id-date-in-warehouse-id-numeric-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-date-in-purchase-value-integer-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-titleabbrev">
       asset__save(in_exp_account_id integer, in_dep_account_id integer, in_asset_account_id text, in_invoice_id text, in_department_id date, in_warehouse_id numeric, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life date, in_purchase_value integer, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the asset with the information provided.  If the id is provided, 
overwrites the record with the id.  Otherwise, or if that record is not found,
inserts.  Returns the row inserted or updated.

        <programlisting>
DECLARE ret_val asset_item;
BEGIN
	UPDATE asset_item
	SET asset_class_id = in_asset_class,
		description = in_description,
		tag = in_tag,
		purchase_date = in_purchase_date,
		purchase_value = in_purchase_value,
		usable_life = in_usable_life,
		location_id = in_warehouse_id,
		department_id = in_department_id,
		invoice_id = in_invoice_id,
		salvage_value = in_salvage_value,
                asset_account_id = in_asset_account_id,
                exp_account_id = in_exp_account_id,
                start_depreciation = 
                         coalesce(in_start_depreciation, in_purchase_date),
                dep_account_id = in_dep_account_id
	WHERE id = in_id;
	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_item WHERE id = in_id;
		return ret_val;
	END IF;

	INSERT INTO asset_item (asset_class_id, description, tag, purchase_date,
		purchase_value, usable_life, salvage_value, department_id,
		location_id, invoice_id, asset_account_id, dep_account_id,
                start_depreciation, exp_account_id)
	VALUES (in_asset_class, in_description, in_tag, in_purchase_date,
		in_purchase_value, in_usable_life, in_salvage_value,
		in_department_id, in_warehouse_id, in_invoice_id,
                in_asset_account_id, in_dep_account_id,
                coalesce(in_start_depreciation, in_purchase_date),
                in_exp_account_id);

	SELECT * INTO ret_val FROM asset_item 
	WHERE id = currval(&#39;asset_item_id_seq&#39;);
	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric) -->
    <section id="public.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric"
             xreflabel="publicasset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)">
      <title id="public.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric-title">
       asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)
      </title>
      <titleabbrev id="public.function.asset-search-in-salvage-value-integer-in-usable-life-text-in-purchase-value-text-in-purchase-date-date-in-tag-numeric-in-description-numeric-in-asset-class-numeric-titleabbrev">
       asset__search(in_salvage_value integer, in_usable_life text, in_purchase_value text, in_purchase_date date, in_tag numeric, in_description numeric, in_asset_class numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
       Searches for assets.  Nulls match all records.  Asset class is exact,
as is purchase date, purchase value, and salvage value. Tag and description
are partial matches.
        <programlisting>
DECLARE out_val asset_item;
BEGIN
	FOR out_val IN
		SELECT * FROM asset_item
		WHERE (in_asset_class is null 
			or asset_class_id = in_asset_class)
			AND (in_description is null or description 
				LIKE &#39;%&#39; || in_description || &#39;%&#39;)
			and (in_tag is not null or tag like &#39;%&#39;||in_tag||&#39;%&#39;)
			AND (in_purchase_date is null 
				or purchase_date = in_purchase_date)
			AND (in_purchase_value is null
				or in_purchase_value = purchase_value)
			AND (in_usable_life is null
				or in_usable_life = usable_life)
			AND (in_salvage_value is null
				OR in_salvage_value = salvage_value)
	LOOP
		RETURN NEXT out_val;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get(in_id integer) -->
    <section id="public.function.asset-class-get-in-id-integer"
             xreflabel="publicasset_class__get(in_id integer)">
      <title id="public.function.asset-class-get-in-id-integer-title">
       asset_class__get(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-class-get-in-id-integer-titleabbrev">
       asset_class__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        returns the row from asset_class identified by in_id.
        <programlisting>
DECLARE ret_val asset_class;
BEGIN 
	SELECT * INTO ret_val FROM asset_class WHERE id = in_id;
	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_asset_accounts() -->
    <section id="public.function.asset-class-get-asset-accounts"
             xreflabel="publicasset_class__get_asset_accounts()">
      <title id="public.function.asset-class-get-asset-accounts-title">
       asset_class__get_asset_accounts()
      </title>
      <titleabbrev id="public.function.asset-class-get-asset-accounts-titleabbrev">
       asset_class__get_asset_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of fixed asset accounts, ordered by account number
        <programlisting>
SELECT * FROM account 
WHERE id IN 
	(select account_id from account_link where description = &#39;Fixed_Asset&#39;)
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_accounts() -->
    <section id="public.function.asset-class-get-dep-accounts"
             xreflabel="publicasset_class__get_dep_accounts()">
      <title id="public.function.asset-class-get-dep-accounts-title">
       asset_class__get_dep_accounts()
      </title>
      <titleabbrev id="public.function.asset-class-get-dep-accounts-titleabbrev">
       asset_class__get_dep_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of asset depreciation accounts, ordered by account number
        <programlisting>
SELECT * FROM account 
WHERE id IN 
	(select account_id from account_link where description = &#39;Asset_Dep&#39;)
ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_method(in_asset_class integer) -->
    <section id="public.function.asset-class-get-dep-method-in-asset-class-integer"
             xreflabel="publicasset_class__get_dep_method(in_asset_class integer)">
      <title id="public.function.asset-class-get-dep-method-in-asset-class-integer-title">
       asset_class__get_dep_method(in_asset_class integer)
      </title>
      <titleabbrev id="public.function.asset-class-get-dep-method-in-asset-class-integer-titleabbrev">
       asset_class__get_dep_method(in_asset_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_dep_method</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the depreciation method associated with the asset class.
        <programlisting>
SELECT * from asset_dep_method 
WHERE id = (select method from asset_class where id = $1);
</programlisting>
      </para>
    </section>

<!-- Function asset_class__get_dep_methods() -->
    <section id="public.function.asset-class-get-dep-methods"
             xreflabel="publicasset_class__get_dep_methods()">
      <title id="public.function.asset-class-get-dep-methods-title">
       asset_class__get_dep_methods()
      </title>
      <titleabbrev id="public.function.asset-class-get-dep-methods-titleabbrev">
       asset_class__get_dep_methods()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_dep_method</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of asset_dep_methods ordered by the method label.
        <programlisting>
SELECT * FROM asset_dep_method ORDER BY method;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__list() -->
    <section id="public.function.asset-class-list"
             xreflabel="publicasset_class__list()">
      <title id="public.function.asset-class-list-title">
       asset_class__list()
      </title>
      <titleabbrev id="public.function.asset-class-list-titleabbrev">
       asset_class__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an alphabetical list of asset classes.
        <programlisting>
SELECT * FROM asset_class ORDER BY label;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text) -->
    <section id="public.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text"
             xreflabel="publicasset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)">
      <title id="public.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text-title">
       asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)
      </title>
      <titleabbrev id="public.function.asset-class-save-in-unit-label-integer-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-in-id-text-titleabbrev">
       asset_class__save(in_unit_label integer, in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves this data as an asset_class record.  If in_id is NULL or is not found
in the table, inserts a new row.  Returns the row saved.
        <programlisting>
DECLARE ret_val asset_class;
BEGIN
	UPDATE asset_class 
	SET asset_account_id = in_asset_account_id,
		dep_account_id = in_dep_account_id,
		method = in_method,
		label = in_label
	WHERE id = in_id;

	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_class where id = in_id;
		RETURN ret_val;
	END IF;

	INSERT INTO asset_class (asset_account_id, dep_account_id, method,
		label)
	VALUES (in_asset_account_id, in_dep_account_id, in_method, 
		in_label);

	SELECT * INTO ret_val FROM asset_class 
	WHERE id = currval(&#39;asset_class_id_seq&#39;);

	RETURN ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text) -->
    <section id="public.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text"
             xreflabel="publicasset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)">
      <title id="public.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-title">
       asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)
      </title>
      <titleabbrev id="public.function.asset-class-search-in-label-integer-in-method-integer-in-dep-account-id-integer-in-asset-account-id-text-titleabbrev">
       asset_class__search(in_label integer, in_method integer, in_dep_account_id integer, in_asset_account_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_class_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of matching asset classes.  The account id&apos;s are exact matches
as is the method, but the label is a partial match.  NULL&apos;s match all.
        <programlisting>
DECLARE out_var asset_class_result;
BEGIN
	FOR out_var IN
		SELECT ac.id, ac.asset_account_id, aa.accno, aa.description, 
			ad.accno, ad.description, m.method, ac.method,
			ac.label
		FROM asset_class ac
		JOIN account aa ON (aa.id = ac.asset_account_id)
		JOIN account ad ON (ad.id = ac.dep_account_id)
		JOIN asset_dep_method m ON (ac.method = m.id)
		WHERE 
			(in_asset_account_id is null 
				or in_asset_account_id = ac.asset_account_id)
			AND (in_dep_account_id is null OR
				in_dep_account_id = ac.dep_account_id)
			AND (in_method is null OR in_method = ac.method)
			AND (in_label IS NULL OR ac.label LIKE 
				&#39;%&#39; || in_label || &#39;%&#39;)
               ORDER BY label
	LOOP
		RETURN NEXT out_var;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric) -->
    <section id="public.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric"
             xreflabel="publicasset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)">
      <title id="public.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric-title">
       asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)
      </title>
      <titleabbrev id="public.function.asset-dep-straight-line-base-in-dep-to-date-numeric-in-basis-numeric-in-used-numeric-in-life-numeric-in-base-life-numeric-titleabbrev">
       asset_dep__straight_line_base(in_dep_to_date numeric, in_basis numeric, in_used numeric, in_life numeric, in_base_life numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This function is a basic function which does the actual calculation for 
straight line depreciation.
        <programlisting>
SELECT CASE WHEN $3/$1 * $4 &lt; $4 - $5 THEN $3/$1 * $4 
            ELSE $4 - $5
            END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric) -->
    <section id="public.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric"
             xreflabel="publicasset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)">
      <title id="public.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric-title">
       asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)
      </title>
      <titleabbrev id="public.function.asset-dep-used-months-in-usable-life-date-in-dep-date-date-in-last-dep-numeric-titleabbrev">
       asset_dep__used_months(in_usable_life date, in_dep_date date, in_last_dep numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks the interval between the two dates, and if longer than the 
usable life, returns the months in that interval.  Otherwise returns the 
usable life.
        <programlisting>
select CASE WHEN extract(&#39;MONTHS&#39; FROM (date_trunc(&#39;day&#39;, $2) - date_trunc(&#39;day&#39;, $1))) 
                 &gt; $3
            THEN $3
            ELSE extract(&#39;MONTHS&#39; FROM (date_trunc(&#39;day&#39;, $2) - date_trunc(&#39;day&#39;, $1)))::numeric
            END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date) -->
    <section id="public.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date"
             xreflabel="publicasset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)">
      <title id="public.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date-title">
       asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)
      </title>
      <titleabbrev id="public.function.asset-dep-get-usable-life-yr-in-dep-date-numeric-in-start-date-date-in-usable-life-date-titleabbrev">
       asset_dep_get_usable_life_yr(in_dep_date numeric, in_start_date date, in_usable_life date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       If the interval is less than 0 then 0.  If the interval is greater than the 
usable life, then the usable life.  Otherwise, return the interval as a 
fractional year.
        <programlisting>
   SELECT CASE WHEN $3 IS NULL or get_fractional_year($2, $3) &gt; $1 
               then $1
               WHEN get_fractional_year($2, $3) &lt; 0
               THEN 0
               ELSE get_fractional_year($2, $3)
          END;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="public.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="publicasset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="public.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="public.function.asset-dep-straight-line-month-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_month(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Performs straight line depreciation, selecting depreciation amounts, etc. 
into a report for further review and approval.  Usable life is in months, and
depreciation is an equal amount every month.
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life,
                  ai.usable_life --months
                  - months_passed(coalesce(start_depreciation, purchase_date),
                                  coalesce(max(report_date),
                                           start_depreciation,
                                           purchase_date)),
                  months_passed(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="public.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="publicasset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="public.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="public.function.asset-dep-straight-line-yr-d-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_yr_d(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life, -- years
                  ai.usable_life - 
                  get_fractional_year(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                       coalesce(start_depreciation,
                                         purchase_date)),
                  get_fractional_year(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer) -->
    <section id="public.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer"
             xreflabel="publicasset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)">
      <title id="public.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-title">
       asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </title>
      <titleabbrev id="public.function.asset-dep-straight-line-yr-m-in-report-id-integerARRAY-in-report-date-date-in-asset-ids-integer-titleabbrev">
       asset_dep_straight_line_yr_m(in_report_id integer[], in_report_date date, in_asset_ids integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Performs straight line depreciation on a set of selected assets, selecting
the depreciation values into a report.

Assumes the usable life is measured in years, and is depreciated eavenly every
month.
        <programlisting>
     INSERT INTO asset_report_line (asset_id, report_id, amount, department_id, 
                                   warehouse_id)
     SELECT ai.id, $3, 
            asset_dep__straight_line_base(
                  ai.usable_life * 12,
                  ai.usable_life * 12 --months
                  - months_passed(coalesce(start_depreciation, purchase_date),
                                  coalesce(max(report_date),
                                           start_depreciation,
                                           purchase_date)),
                  months_passed(coalesce(max(report_date),
                                         start_depreciation,
                                         purchase_date),
                                $2),
                  purchase_value - salvage_value,
                  coalesce(sum(l.amount), 0)), 
            ai.department_id, ai.location_id
       FROM asset_item ai
  LEFT JOIN asset_report_line l ON (l.asset_id = ai.id)
  LEFT JOIN asset_report r ON (l.report_id = r.id)
      WHERE ai.id = ANY($1) 
   GROUP BY ai.id, ai.start_depreciation, ai.purchase_date, ai.purchase_value,
            ai.salvage_value, ai.department_id, ai.location_id, ai.usable_life;
                                                      
    UPDATE asset_report SET report_class = 1 WHERE id = $3;

    select true;
</programlisting>
      </para>
    </section>

<!-- Function asset_depreciation__approve(in_expense_acct integer, in_report_id integer) -->
    <section id="public.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer"
             xreflabel="publicasset_depreciation__approve(in_expense_acct integer, in_report_id integer)">
      <title id="public.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer-title">
       asset_depreciation__approve(in_expense_acct integer, in_report_id integer)
      </title>
      <titleabbrev id="public.function.asset-depreciation-approve-in-expense-acct-integer-in-report-id-integer-titleabbrev">
       asset_depreciation__approve(in_expense_acct integer, in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Approves an asset depreciation report and creats the GL draft.
        <programlisting>
declare retval asset_report;
begin

retval := asset_report__record_approve(in_report_id);

INSERT INTO gl (reference, description, approved)
select &#39;Asset Report &#39; || in_id, &#39;Asset Depreciation Report for &#39; || report_date,
       false
 FROM asset_report where id = in_id;

INSERT INTO acc_trans (amount, chart_id, transdate, approved, trans_id)
SELECT l.amount, a.dep_account_id, r.report_date, true, currval(&#39;id&#39;)
  FROM asset_report r
  JOIN asset_report_line l ON (r.id = l.report_id)
  JOIN asset_item a ON (a.id = l.asset_id)
 WHERE r.id = in_id;

INSERT INTO acc_trans (amount, chart_id, transdate, approved, trans_id)
SELECT sum(l.amount) * -1, in_expense_acct, r.report_date, approved, 
       currval(&#39;id&#39;)
  FROM asset_report r
  JOIN asset_report_line l ON (r.id = l.report_id)
  JOIN asset_item a ON (a.id = l.asset_id)
 WHERE r.id = in_id
 GROUP BY r.report_date;


return retval;

end;
</programlisting>
      </para>
    </section>

<!-- Function asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer) -->
    <section id="public.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer"
             xreflabel="publicasset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)">
      <title id="public.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-title">
       asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)
      </title>
      <titleabbrev id="public.function.asset-disposal-approve-in-asset-acct-integer-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-titleabbrev">
       asset_disposal__approve(in_asset_acct integer, in_loss_acct integer, in_gain_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        This approves the asset_report for disposals, creating relevant GL drafts.

If the report is a partial disposal report, imports remaining percentages as new
asset items.
        <programlisting>
DECLARE 
   retval asset_report;
   iter record;
   t_disposed_percent numeric;
begin
-- this code is fairly opaque and needs more documentation that would be 
-- otherwise optimal. This is mostly due to the fact that we have fairly
-- repetitive insert/select routines and the fact that the accounting 
-- requirements are not immediately intuitive.  Inserts marked functionally along
-- with typical debit/credit designations.  Note debits are always negative.


retval := asset_report__record_approve(in_id);
if retval.report_class = 2 then
     t_disposed_percent := 100;
end if;

INSERT INTO gl (reference, description, approved, transdate)
select &#39;Asset Report &#39; || in_id, &#39;Asset Disposal Report for &#39; || report_date,
       false, report_date
 FROM asset_report where id = in_id;

-- REMOVING ASSETS FROM ACCOUNT (Credit)
insert into acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), a.asset_account_id, 
       a.purchase_value 
       * (coalesce(t_disposed_percent, m.percent_disposed)/100), 
       true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 WHERE r.id = in_id;

-- REMOVING ACCUM DEP. (Debit)
INSERT into acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), a.dep_account_id, 
       sum(dl.amount) * -1 
       * (coalesce(t_disposed_percent, m.percent_disposed)/100), 
       true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_report_line dl ON (l.asset_id = dl.asset_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 JOIN  asset_report dr ON (dl.report_id = dr.id 
                           and dr.report_class = 1
                           and dr.approved_at is not null)
 WHERE r.id = in_id
group by a.dep_account_id, m.percent_disposed, r.report_date;

-- INSERT asset/proceeds (Debit, credit for negative values)
INSERT INTO acc_trans (trans_id, chart_id, amount, approved, transdate)
SELECT currval(&#39;id&#39;), in_asset_acct, coalesce(l.amount, 0) * -1, true, r.report_date
 FROM  asset_item a
 JOIN  asset_report_line l ON (l.asset_id = a.id)
 JOIN  asset_report r ON (r.id = l.report_id)
 JOIN  asset_rl_to_disposal_method m 
        ON (l.report_id = m.report_id and l.asset_id = m.asset_id)
 WHERE r.id = in_id;

-- INSERT GAIN/LOSS (Credit for gain, debit for loss)
INSERT INTO acc_trans(trans_id, chart_id, amount, approved, transdate)
select currval(&#39;id&#39;), 
            CASE WHEN sum(amount) &gt; 0 THEN in_loss_acct
            else in_gain_acct
        END,
        sum(amount) * -1 , true, 
        retval.report_date
  FROM acc_trans
  WHERE trans_id = currval(&#39;id&#39;);

IF retval.report_class = 4 then
   PERFORM asset__import_from_disposal(retval.id);
end if;

return retval;
end;
</programlisting>
      </para>
    </section>

<!-- Function asset_item__add_note(in_note integer, in_subject text, in_id text) -->
    <section id="public.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text"
             xreflabel="publicasset_item__add_note(in_note integer, in_subject text, in_id text)">
      <title id="public.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text-title">
       asset_item__add_note(in_note integer, in_subject text, in_id text)
      </title>
      <titleabbrev id="public.function.asset-item-add-note-in-note-integer-in-subject-text-in-id-text-titleabbrev">
       asset_item__add_note(in_note integer, in_subject text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Adds a note to an asset item
        <programlisting>
INSERT INTO asset_note (ref_key, subject, note) values ($1, $2, $3);
SELECT * FROM asset_note WHERE id = currval(&#39;note_id_seq&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer) -->
    <section id="public.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer"
             xreflabel="publicasset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)">
      <title id="public.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-title">
       asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </title>
      <titleabbrev id="public.function.asset-item-search-in-dep-account-id-integer-in-asset-account-id-integer-in-invoice-id-text-in-department-id-text-in-warehouse-id-date-in-start-depreciation-numeric-in-salvage-value-numeric-in-usable-life-numeric-in-purchase-value-date-in-purchase-date-integer-in-tag-integer-in-description-integer-in-asset-class-integer-in-id-integer-titleabbrev">
       asset_item__search(in_dep_account_id integer, in_asset_account_id integer, in_invoice_id text, in_department_id text, in_warehouse_id date, in_start_depreciation numeric, in_salvage_value numeric, in_usable_life numeric, in_purchase_value date, in_purchase_date integer, in_tag integer, in_description integer, in_asset_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of matching asset items.  Nulls match all records.
Tag and description allow for partial match.  All other matches are exact.
        <programlisting>
DECLARE retval asset_item;
BEGIN
    FOR retval IN
         SELECT * FROM asset_item
          WHERE (id = in_id or in_id is null)
                and (asset_class_id = in_asset_class or in_asset_class is null)
                and (description like &#39;%&#39;||in_description||&#39;%&#39;
                     or in_description is null)
                and (tag like &#39;%&#39; || in_tag || &#39;%&#39; or in_tag is null)
                and (purchase_value = in_purchase_value 
                    or in_purchase_value is null)
                and (in_purchase_date = purchase_date 
                    or in_purchase_date is null)
                and (start_depreciation = in_start_depreciation
                    or in_start_depreciation is null)
                and (in_warehouse_id = location_id OR in_warehouse_id is null)
                and (department_id = in_department_id 
                    or in_department_id is null)
                and (in_invoice_id = invoice_id OR in_invoice_id IS NULL)
                and (asset_account_id = in_asset_account_id
                    or in_asset_account_id is null)
                and (dep_account_id = in_dep_account_id
                    or in_dep_account_id is null)
   LOOP
       return next retval;
   end loop;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_nbv_report() -->
    <section id="public.function.asset-nbv-report"
             xreflabel="publicasset_nbv_report()">
      <title id="public.function.asset-nbv-report-title">
       asset_nbv_report()
      </title>
      <titleabbrev id="public.function.asset-nbv-report-titleabbrev">
       asset_nbv_report()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_nbv_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the current net book value report.
        <programlisting>
   SELECT ai.id, ai.tag, ai.description, coalesce(ai.start_depreciation, ai.purchase_date),
          adm.short_name, ai.usable_life 
           - months_passed(coalesce(ai.start_depreciation, ai.purchase_date),
                                  coalesce(max(r.report_date),
                                           ai.start_depreciation,
                                           ai.purchase_date))/ 12,
          ai.purchase_value - ai.salvage_value, ai.salvage_value, max(r.report_date),
          sum(rl.amount), ai.purchase_value - sum(rl.amount) 
     FROM asset_item ai
     JOIN asset_class ac ON (ai.asset_class_id = ac.id)
     JOIN asset_dep_method adm ON (adm.id = ac.method)
LEFT JOIN asset_report_line rl ON (ai.id = rl.asset_id)
LEFT JOIN asset_report r on (rl.report_id = r.id)
    WHERE r.id IS NULL OR r.approved_at IS NOT NULL
 GROUP BY ai.id, ai.tag, ai.description, ai.start_depreciation, ai.purchase_date,
          adm.short_name, ai.usable_life, ai.purchase_value, salvage_value
   HAVING (NOT 2 = ANY(as_array(r.report_class))) 
          AND (NOT 4 = ANY(as_array(r.report_class)))
          OR max(r.report_class) IS NULL
 ORDER BY ai.id, ai.tag, ai.description;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer) -->
    <section id="public.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer"
             xreflabel="publicasset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)">
      <title id="public.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer-title">
       asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-approve-in-loss-acct-integer-in-gain-acct-integer-in-expense-acct-integer-in-id-integer-titleabbrev">
       asset_report__approve(in_loss_acct integer, in_gain_acct integer, in_expense_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        This function approves an asset report (whether depreciation or disposal).
Also generates relevant GL drafts for review and posting.
        <programlisting>
DECLARE ret_val asset_report;
BEGIN
        UPDATE asset_report 
           SET approved_at = now(),
               approved_by = person__get_my_entity_id()
         where id = in_id;
	SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
        if ret_val.dont_approve is not true then 
                if ret_val.report_class = 1 THEN
                    PERFORM asset_report__generate_gl(in_id, in_expense_acct);
                ELSIF ret_val.report_class = 2 THEN
                    PERFORM asset_report__disposal_gl(
                                 in_id, in_gain_acct, in_loss_acct);
                ELSIF ret_val.report_class = 4 THEN
                    PERFORM asset_disposal__approve(in_id, in_gain_acct, in_loss_acct, (select asset_account_id from asset_class 
                                                                                         where id = ret_val.asset_class)
                                                   );
                ELSE RAISE EXCEPTION &#39;Invalid report class&#39;;
                END IF;
        end if;
	SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
	RETURN ret_val;
end;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer) -->
    <section id="public.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer"
             xreflabel="publicasset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)">
      <title id="public.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer-title">
       asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)
      </title>
      <titleabbrev id="public.function.asset-report-begin-disposal-in-report-class-integer-in-report-date-date-in-asset-class-integer-titleabbrev">
       asset_report__begin_disposal(in_report_class integer, in_report_date date, in_asset_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates the asset report recofd for the asset disposal report.
        <programlisting>
DECLARE retval asset_report;

begin

INSERT INTO asset_report (asset_class, report_date, entered_at, entered_by, 
            report_class)
     VALUES (in_asset_class, in_report_date, now(), person__get_my_entity_id(), 
            in_report_class);

SELECT * INTO retval FROM asset_report where id = currval(&#39;asset_report_id_seq&#39;);

return retval;

end;

</programlisting>
      </para>
    </section>

<!-- Function asset_report__begin_import(in_report_date integer, in_asset_class date) -->
    <section id="public.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date"
             xreflabel="publicasset_report__begin_import(in_report_date integer, in_asset_class date)">
      <title id="public.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date-title">
       asset_report__begin_import(in_report_date integer, in_asset_class date)
      </title>
      <titleabbrev id="public.function.asset-report-begin-import-in-report-date-integer-in-asset-class-date-titleabbrev">
       asset_report__begin_import(in_report_date integer, in_asset_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates the outline of an asset import report
        <programlisting>
INSERT INTO asset_report (asset_class, report_date, entered_at, entered_by, 
            report_class, dont_approve)
     VALUES ($1, $2, now(), person__get_my_entity_id(), 
            3, true);

SELECT * FROM asset_report where id = currval(&#39;asset_report_id_seq&#39;);

</programlisting>
      </para>
    </section>

<!-- Function asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer) -->
    <section id="public.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer"
             xreflabel="publicasset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)">
      <title id="public.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-title">
       asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-disposal-gl-in-loss-acct-integer-in-gain-acct-integer-in-id-integer-titleabbrev">
       asset_report__disposal_gl(in_loss_acct integer, in_gain_acct integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates GL transactions for ful disposal reports.
        <programlisting>
  INSERT 
    INTO gl (reference, description, transdate, approved)
  SELECT setting_increment(&#39;glnumber&#39;), &#39;Asset Report &#39; || asset_report.id,
		report_date, false
    FROM asset_report 
    JOIN asset_report_line ON (asset_report.id = asset_report_line.report_id)
    JOIN asset_item        ON (asset_report_line.asset_id = asset_item.id)
   WHERE asset_report.id = $1
GROUP BY asset_report.id, asset_report.report_date;

  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT a.dep_account_id, currval(&#39;id&#39;)::int, sum(r.accum_depreciation) * -1,
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item a ON (r.id = a.id)
GROUP BY a.dep_account_id, r.disposed_on;

  -- GAIN is negative since it is a debit
  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT case when sum(r.gain_loss) &gt; 0 THEN $3 else $2 end,
         currval(&#39;id&#39;)::int, sum(r.gain_loss),
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item ai ON (r.id = ai.id)
GROUP BY r.disposed_on;

  INSERT
    INTO acc_trans (chart_id, trans_id, amount, approved, transdate)
  SELECT a.asset_account_id, currval(&#39;id&#39;)::int, sum(r.purchase_value),
         TRUE, r.disposed_on
    FROM asset_report__get_disposal($1) r
    JOIN asset_item a ON (r.id = a.id)
GROUP BY a.asset_account_id, r.disposed_on;


  SELECT TRUE;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric) -->
    <section id="public.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric"
             xreflabel="publicasset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)">
      <title id="public.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric-title">
       asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)
      </title>
      <titleabbrev id="public.function.asset-report-dispose-in-percent-disposed-integer-in-dm-integer-in-amount-numeric-in-asset-id-integer-in-id-numeric-titleabbrev">
       asset_report__dispose(in_percent_disposed integer, in_dm integer, in_amount numeric, in_asset_id integer, in_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Disposes of an asset.  in_dm is the disposal method id.
        <programlisting>
BEGIN
    INSERT 
      INTO asset_report_line (report_id, asset_id, amount)
    values (in_id, in_asset_id, in_amount);

    INSERT 
      INTO asset_rl_to_disposal_method 
           (report_id, asset_id, disposal_method_id, percent_disposed)
    VALUES (in_id, in_asset_id, in_dm, in_percent_disposed);

    RETURN TRUE;
    END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date) -->
    <section id="public.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date"
             xreflabel="publicasset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)">
      <title id="public.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date-title">
       asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)
      </title>
      <titleabbrev id="public.function.asset-report-generate-in-report-date-boolean-in-asset-class-integer-in-depreciation-date-titleabbrev">
       asset_report__generate(in_report_date boolean, in_asset_class integer, in_depreciation date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates lines to select/deselect for the asset report (depreciation or
disposal).
        <programlisting>
   SELECT ai.*
     FROM asset_item ai
     JOIN asset_class ac ON (ai.asset_class_id = ac.id)
LEFT JOIN asset_report_line arl ON (arl.asset_id = ai.id)
LEFT JOIN asset_report ar ON (arl.report_id = ar.id)
    WHERE COALESCE(ai.start_depreciation, ai.purchase_date) &lt;= $3 AND ac.id = $2
          AND obsolete_by IS NULL
 GROUP BY ai.id, ai.tag, ai.description, ai.purchase_value, ai.usable_life,
          ai.purchase_date, ai.location_id, ai.invoice_id, ai.asset_account_id,
          ai.dep_account_id, ai.asset_class_id, ai.start_depreciation,
          ai.salvage_value, ai.department_id, ai.exp_account_id, ai.obsolete_by
   HAVING (count(ar.report_class) = 0 OR    
          (2 &lt;&gt; ALL(as_array(ar.report_class)) 
          and 4 &lt;&gt; ALL(as_array(ar.report_class))))
          AND ((ai.purchase_value - coalesce(sum(arl.amount), 0) 
               &gt; ai.salvage_value) and ai.obsolete_by is null)
               OR $1 is not true;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__generate_gl(in_accum_account_id integer, in_report_id integer) -->
    <section id="public.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer"
             xreflabel="publicasset_report__generate_gl(in_accum_account_id integer, in_report_id integer)">
      <title id="public.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer-title">
       asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-generate-gl-in-accum-account-id-integer-in-report-id-integer-titleabbrev">
       asset_report__generate_gl(in_accum_account_id integer, in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates a GL transaction when the Asset report is approved.

Currently this creates GL drafts, not approved transctions

        <programlisting>
DECLARE 
	t_report_dept record;
	t_dep_amount numeric;

Begin
	INSERT INTO gl (reference, description, transdate, approved)
	SELECT setting_increment(&#39;glnumber&#39;), &#39;Asset Report &#39; || asset_report.id,
		report_date, false
	FROM asset_report 
	JOIN asset_report_line 
		ON (asset_report.id = asset_report_line.report_id)
	JOIN asset_item 
		ON (asset_report_line.asset_id = asset_item.id)
	WHERE asset_report.id = in_report_id
	GROUP BY asset_report.id, asset_report.report_date;

	INSERT INTO acc_trans (trans_id, chart_id, transdate, approved, amount)
	SELECT gl.id, a.exp_account_id, r.report_date, true, sum(amount) * -1
	FROM asset_report r
	JOIN asset_report_line l ON (r.id = l.report_id)
	JOIN asset_item a ON (l.asset_id = a.id)
	JOIN gl ON (gl.description = &#39;Asset Report &#39; || l.report_id)
	WHERE r.id = in_report_id
	GROUP BY gl.id, r.report_date, a.exp_account_id;

	INSERT INTO acc_trans (trans_id, chart_id, transdate, approved, amount)
	SELECT gl.id, a.dep_account_id, r.report_date, true, sum(amount)
	FROM asset_report r
	JOIN asset_report_line l ON (r.id = l.report_id)
	JOIN asset_item a ON (l.asset_id = a.id)
	JOIN gl ON (gl.description = &#39;Asset Report &#39; || l.report_id) 
	WHERE r.id = in_report_id
	GROUP BY gl.id, a.dep_account_id, r.report_date, a.tag, a.description;

	RETURN in_report_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get(in_id integer) -->
    <section id="public.function.asset-report-get-in-id-integer"
             xreflabel="publicasset_report__get(in_id integer)">
      <title id="public.function.asset-report-get-in-id-integer-title">
       asset_report__get(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-get-in-id-integer-titleabbrev">
       asset_report__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the asset_report line identified by id.
        <programlisting>
select * from asset_report where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_disposal(in_id integer) -->
    <section id="public.function.asset-report-get-disposal-in-id-integer"
             xreflabel="publicasset_report__get_disposal(in_id integer)">
      <title id="public.function.asset-report-get-disposal-in-id-integer-title">
       asset_report__get_disposal(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-get-disposal-in-id-integer-titleabbrev">
       asset_report__get_disposal(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_disposal_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of lines of disposed assets in a disposal report, specified
by the report id.
        <programlisting>
   SELECT ai.id, ai.tag, ai.description, ai.start_depreciation, r.report_date,
          dm.short_label, ai.purchase_value, 
          sum (CASE WHEN pr.report_class in (1,3) THEN prl.amount ELSE 0 END) 
          as accum_dep,
          l.amount, 
          ai.purchase_value - sum(CASE WHEN pr.report_class in (1,3) 
                                       THEN prl.amount 
                                       ELSE 0 
                                   END) as adjusted_basis,
          l.amount - ai.purchase_value + sum(CASE WHEN pr.report_class in (1,3)
                                                  THEN prl.amount 
                                                  ELSE 0 
                                              END) as gain_loss
     FROM asset_item ai
     JOIN asset_report_line l   ON (l.report_id = $1 AND ai.id = l.asset_id)
     JOIN asset_report r        ON (l.report_id = r.id)
LEFT JOIN asset_rl_to_disposal_method adm 
                             USING (report_id, asset_id)
     JOIN asset_disposal_method dm
                                ON (adm.disposal_method_id = dm.id)
LEFT JOIN asset_report_line prl ON (prl.report_id &lt;&gt; $1 
                                   AND ai.id = prl.asset_id)
LEFT JOIN asset_report pr       ON (prl.report_id = pr.id)
 GROUP BY ai.id, ai.tag, ai.description, ai.start_depreciation, r.report_date,
          ai.purchase_value, l.amount, dm.short_label
 ORDER BY ai.id, ai.tag;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_disposal_methods() -->
    <section id="public.function.asset-report-get-disposal-methods"
             xreflabel="publicasset_report__get_disposal_methods()">
      <title id="public.function.asset-report-get-disposal-methods-title">
       asset_report__get_disposal_methods()
      </title>
      <titleabbrev id="public.function.asset-report-get-disposal-methods-titleabbrev">
       asset_report__get_disposal_methods()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_disposal_method</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of asset_disposal_method items ordered by label.
        <programlisting>
SELECT * FROM asset_disposal_method order by label;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_expense_accts() -->
    <section id="public.function.asset-report-get-expense-accts"
             xreflabel="publicasset_report__get_expense_accts()">
      <title id="public.function.asset-report-get-expense-accts-title">
       asset_report__get_expense_accts()
      </title>
      <titleabbrev id="public.function.asset-report-get-expense-accts-titleabbrev">
       asset_report__get_expense_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all asset expense reports.
        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_expense&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_gain_accts() -->
    <section id="public.function.asset-report-get-gain-accts"
             xreflabel="publicasset_report__get_gain_accts()">
      <title id="public.function.asset-report-get-gain-accts-title">
       asset_report__get_gain_accts()
      </title>
      <titleabbrev id="public.function.asset-report-get-gain-accts-titleabbrev">
       asset_report__get_gain_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of gain accounts for asset depreciation and disposal reports.

        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_gain&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_lines(in_id integer) -->
    <section id="public.function.asset-report-get-lines-in-id-integer"
             xreflabel="publicasset_report__get_lines(in_id integer)">
      <title id="public.function.asset-report-get-lines-in-id-integer-title">
       asset_report__get_lines(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-get-lines-in-id-integer-titleabbrev">
       asset_report__get_lines(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_report_line_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the lines of an asset depreciation report.
        <programlisting>
   select ai.tag, coalesce(ai.start_depreciation, ai.purchase_date), ai.purchase_value, m.short_name, 
          ai.usable_life, 
          ai.purchase_value - ai.salvage_value, max(pr.report_date),
          sum(case when pr.report_date &lt; r.report_date then prl.amount
                   else 0
                end), 
          rl.amount, 
          sum (case when extract(year from pr.report_date)
                         = extract(year from r.report_date)
                         AND pr.report_date &lt; r.report_date
                    then prl.amount
                    else 0
                end), 
          sum(prl.amount), 
          ai.description, ai.purchase_date
     FROM asset_item ai
     JOIN asset_class c ON (ai.asset_class_id = c.id)
     JOIN asset_dep_method m ON (c.method = m.id)
     JOIN asset_report_line rl ON (rl.asset_id = ai.id)
     JOIN asset_report r ON (rl.report_id = r.id)
LEFT JOIN asset_report_line prl ON (prl.asset_id = ai.id)
LEFT JOIN asset_report pr ON (prl.report_id = pr.id)
    WHERE rl.report_id = $1
 GROUP BY ai.tag, ai.start_depreciation, ai.purchase_value, m.short_name,
          ai.usable_life, ai.salvage_value, r.report_date, rl.amount,
          ai.description, ai.purchase_date;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__get_loss_accts() -->
    <section id="public.function.asset-report-get-loss-accts"
             xreflabel="publicasset_report__get_loss_accts()">
      <title id="public.function.asset-report-get-loss-accts-title">
       asset_report__get_loss_accts()
      </title>
      <titleabbrev id="public.function.asset-report-get-loss-accts-titleabbrev">
       asset_report__get_loss_accts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of loss accounts for asset depreciation and disposal reports.

        <programlisting>
    SELECT * FROM account__get_by_link_desc(&#39;asset_loss&#39;);
</programlisting>
      </para>
    </section>

<!-- Function asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean) -->
    <section id="public.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean"
             xreflabel="publicasset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)">
      <title id="public.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean-title">
       asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)
      </title>
      <titleabbrev id="public.function.asset-report-import-in-obsolete-other-text-in-accum-dep-text-in-dep-report-id-numeric-in-invoice-id-numeric-in-asset-class-id-numeric-in-exp-account-id-date-in-dep-account-id-date-in-asset-account-id-integer-in-department-id-integer-in-location-id-integer-in-start-depreciation-integer-in-purchase-date-integer-in-usable-life-integer-in-salvage-value-integer-in-purchase-value-integer-in-tag-numeric-in-description-boolean-titleabbrev">
       asset_report__import(in_obsolete_other text, in_accum_dep text, in_dep_report_id numeric, in_invoice_id numeric, in_asset_class_id numeric, in_exp_account_id date, in_dep_account_id date, in_asset_account_id integer, in_department_id integer, in_location_id integer, in_start_depreciation integer, in_purchase_date integer, in_usable_life integer, in_salvage_value integer, in_purchase_value integer, in_tag numeric, in_description boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Imports an asset with the supplied information.  If in_obsolete_other is
false, this creates a new depreciable asset.  If it is true, it sets up the 
other asset as obsolete.  This is the way partial disposal reports are handled.

        <programlisting>

SET CONSTRAINTS asset_item_obsolete_by_fkey DEFERRED;
-- This fails a deferrable fkey constraint but avoids a partial unique index
-- so in this case, the foreign key is deferred for the duration of this 
-- specific stored proc call.

UPDATE asset_item
   SET obsolete_by = -1 
 WHERE tag = $2 and $17 is true;

INSERT 
  INTO asset_report_line 
       (report_id, asset_id, amount, department_id, warehouse_id)
select $15, id, $16, department_id, location_id
  from asset__save
       (NULL, $13, $1, $2, $6, $3, $5, coalesce($4, 0), $7, $8, $9, $14, $10, $11, $12);

UPDATE asset_item 
   SET obsolete_by = currval(&#39;asset_item_id_seq&#39;)
 WHERE obsolete_by = -1;

-- enforce fkeys now and raise exception if fail
SET CONSTRAINTS asset_item_obsolete_by_fkey IMMEDIATE;
SELECT true;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__record_approve(in_id integer) -->
    <section id="public.function.asset-report-record-approve-in-id-integer"
             xreflabel="publicasset_report__record_approve(in_id integer)">
      <title id="public.function.asset-report-record-approve-in-id-integer-title">
       asset_report__record_approve(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-record-approve-in-id-integer-titleabbrev">
       asset_report__record_approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
       Marks the asset_report record approved.  Not generally recommended to call
directly.
        <programlisting>
UPDATE asset_report 
   set approved_by = person__get_my_entity_id(),
       approved_at = now()
 where id = $1;

select * from asset_report where id = $1;

</programlisting>
      </para>
    </section>

<!-- Function asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean) -->
    <section id="public.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean"
             xreflabel="publicasset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)">
      <title id="public.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean-title">
       asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)
      </title>
      <titleabbrev id="public.function.asset-report-save-in-submit-integer-in-asset-class-date-in-report-class-integer-in-report-date-integer-in-id-boolean-titleabbrev">
       asset_report__save(in_submit integer, in_asset_class date, in_report_class integer, in_report_date integer, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>asset_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Creates or updates an asset report with the information presented.  Note that
approval values are not set here, and that one cannot unsubmit a report though
this function.
        <programlisting>
DECLARE 
	ret_val asset_report;
	item record;
	method_text text;
BEGIN
	UPDATE asset_report 
	set asset_class = in_asset_class,
		report_class = in_report_class,
		report_date = in_report_date,
		submitted = (in_submit or submitted)
	WHERE id = in_id;

	IF FOUND THEN
		SELECT * INTO ret_val FROM asset_report WHERE id = in_id;
	ELSE 
		INSERT INTO asset_report(report_class, asset_class, report_date,
			submitted)
		values (in_report_class, in_asset_class, in_report_date, 
			coalesce(in_submit, true));

		SELECT * INTO ret_val FROM asset_report 
		WHERE id = currval(&#39;asset_report_id_seq&#39;);
                
	END IF;
        RETURN ret_val;

END;
</programlisting>
      </para>
    </section>

<!-- Function asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer) -->
    <section id="public.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer"
             xreflabel="publicasset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)">
      <title id="public.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer-title">
       asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)
      </title>
      <titleabbrev id="public.function.asset-report-search-in-entered-by-date-in-approved-date-in-asset-class-integer-in-end-date-boolean-in-start-date-integer-titleabbrev">
       asset_report__search(in_entered_by date, in_approved date, in_asset_class integer, in_end_date boolean, in_start_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF asset_report_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for asset reports.  Nulls match all rows.  Approved, asset class, 
and entered_by are exact matches.  Start_date and end_date define the beginning
and end of the search date. 
        <programlisting>

  SELECT r.id, r.report_date, r.gl_id, r.asset_class, r.report_class, 
         r.entered_by, r.approved_by, r.entered_at, r.approved_at, 
         r.depreciated_qty, r.dont_approve, r.submitted, sum(l.amount)
    FROM asset_report r
    JOIN asset_report_line l ON (l.report_id = r.id)
   where ($1 is null or $1 &lt;= report_date)
         and ($2 is null or $2 &gt;= report_date)
         and ($3 is null or $3 = asset_class)
         and ($4 is null 
              or ($4 is true and approved_by is not null)
              or ($4 is false and approved_by is null))
         and ($5 is null or $5 = entered_by)
GROUP BY r.id, r.report_date, r.gl_id, r.asset_class, r.report_class,
         r.entered_by, r.approved_by, r.entered_at, r.approved_at,
         r.depreciated_qty, r.dont_approve, r.submitted;
</programlisting>
      </para>
    </section>

<!-- Function asset_report_partial_disposal_details(in_id integer) -->
    <section id="public.function.asset-report-partial-disposal-details-in-id-integer"
             xreflabel="publicasset_report_partial_disposal_details(in_id integer)">
      <title id="public.function.asset-report-partial-disposal-details-in-id-integer-title">
       asset_report_partial_disposal_details(in_id integer)
      </title>
      <titleabbrev id="public.function.asset-report-partial-disposal-details-in-id-integer-titleabbrev">
       asset_report_partial_disposal_details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF partial_disposal_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the partial disposal details for a partial disposal report.
        <programlisting>
SELECT ai.id, ai.tag, ai.start_depreciation, ai.purchase_value, ai.description,
       ar.report_date, arld.percent_disposed, 
       (arld.percent_disposed / 100) * ai.purchase_value, 
       100 - arld.percent_disposed,
       ((100 - arld.percent_disposed)/100) * ai.purchase_value
  FROM asset_item ai
  JOIN asset_report_line l ON (ai.id = l.asset_id)
  JOIN asset_report ar ON (ar.id = l.report_id)
  JOIN asset_rl_to_disposal_method arld
       ON  ((arld.report_id, arld.asset_id) = (l.report_id, l.asset_id))
 WHERE ar.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function avgcost(integer) -->
    <section id="public.function.avgcost-integer"
             xreflabel="publicavgcost(integer)">
      <title id="public.function.avgcost-integer-title">
       avgcost(integer)
      </title>
      <titleabbrev id="public.function.avgcost-integer-titleabbrev">
       avgcost(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE

v_cost float;
v_qty float;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost, v_qty SUM(i.sellprice * i.qty), SUM(i.qty)
  FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id;
  
  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

  IF NOT v_qty IS NULL THEN
    IF v_qty = 0 THEN
      v_cost := 0;
    ELSE
      v_cost := v_cost/v_qty;
    END IF;
  END IF;

RETURN v_cost;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch__search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean) -->
    <section id="public.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean"
             xreflabel="publicbatch__search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)">
      <title id="public.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-title">
       batch__search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </title>
      <titleabbrev id="public.function.batch-search-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-date-to-date-in-date-from-date-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-titleabbrev">
       batch__search(in_approved integer, in_amount_lt text, in_amount_gt integer, in_date_to date, in_date_from date, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of batches and amounts processed on the batch.

Nulls match all values.
in_date_from and in_date_to specify date ranges.
in_description is a partial match.
All other criteria are exact matches.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
		SELECT b.id, c.class, b.control_code, b.description, u.username,
			b.created_on, b.default_date,
			sum(
				CASE WHEN vc.id = 5 AND al.amount &lt; 0 -- GL
				     THEN al.amount 
				     WHEN vc.id  = 1
				     THEN ap.amount 
				     WHEN vc.id = 2
                                     THEN ap.amount
				     ELSE 0
                                END) AS transaction_total,
			sum(
				CASE WHEN alc.link = &#39;AR&#39; AND vc.id IN (6, 7)
				     THEN al.amount
				     WHEN alc.link = &#39;AP&#39; AND vc.id IN (3, 4)
				     THEN al.amount * -1
				     ELSE 0
				END
			   ) AS payment_total
		FROM batch b
		JOIN batch_class c ON (b.batch_class_id = c.id)
		LEFT JOIN users u ON (u.entity_id = b.created_by)
		LEFT JOIN voucher v ON (v.batch_id = b.id)
		LEFT JOIN batch_class vc ON (v.batch_class = vc.id)
		LEFT JOIN ar ON (vc.id = 2 AND v.trans_id = ar.id)
		LEFT JOIN ap ON (vc.id = 1 AND v.trans_id = ap.id)
		LEFT JOIN acc_trans al ON 
			((vc.id = 5 AND v.trans_id = al.trans_id) OR
				(vc.id IN (3, 4, 6, 7) 
					AND al.voucher_id = v.id))
		LEFT JOIN chart alc ON (al.chart_id = alc.id)
		WHERE (c.id = in_class_id OR in_class_id IS NULL) AND 
			(b.description LIKE 
				&#39;%&#39; || in_description || &#39;%&#39; OR
				in_description IS NULL) AND
			(in_created_by_eid = b.created_by OR
				in_created_by_eid IS NULL) AND
			((in_approved = false OR in_approved IS NULL AND
				approved_on IS NULL) OR
				(in_approved = true AND approved_on IS NOT NULL)
			) 
			and (in_date_from IS NULL 
				or b.default_date &gt;= in_date_from)
			and (in_date_to IS NULL
				or b.default_date &lt;= in_date_to)
		GROUP BY b.id, c.class, b.description, u.username, b.created_on,
			b.control_code, b.default_date
		HAVING  
			(in_amount_gt IS NULL OR
			sum(coalesce(ar.amount - ar.paid, ap.amount - ap.paid, 
				al.amount)) 
			&gt;= in_amount_gt) 
			AND 
			(in_amount_lt IS NULL OR
			sum(coalesce(ar.amount - ar.paid, ap.amount - ap.paid, 
				al.amount))
			&lt;= in_amount_lt)
		ORDER BY b.control_code, b.description
		
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date) -->
    <section id="public.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date"
             xreflabel="publicbatch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)">
      <title id="public.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date-title">
       batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)
      </title>
      <titleabbrev id="public.function.batch-create-in-batch-date-text-in-batch-class-text-in-description-text-in-batch-number-date-titleabbrev">
       batch_create(in_batch_date text, in_batch_class text, in_description text, in_batch_number date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts the batch into the table.
        <programlisting>
BEGIN
	INSERT INTO 
		batch (batch_class_id, default_date, description, control_code,
			created_by)
	VALUES ((SELECT id FROM batch_class WHERE class = in_batch_class),
		in_batch_date, in_description, in_batch_number, 
			(select entity_id FROM users WHERE username = session_user));

	return currval(&#39;batch_id_seq&#39;);
END;	
</programlisting>
      </para>
    </section>

<!-- Function batch_delete(in_batch_id integer) -->
    <section id="public.function.batch-delete-in-batch-id-integer"
             xreflabel="publicbatch_delete(in_batch_id integer)">
      <title id="public.function.batch-delete-in-batch-id-integer-title">
       batch_delete(in_batch_id integer)
      </title>
      <titleabbrev id="public.function.batch-delete-in-batch-id-integer-titleabbrev">
       batch_delete(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        If the batch is found and unapproved, deletes it and returns 1.
Otherwise raises an exception.
        <programlisting>
DECLARE 
	t_transaction_ids int[];
BEGIN
	-- Adjust AR/AP tables for payment and payment reversal vouchers
	-- voucher_id is only set in acc_trans on payment/receipt vouchers and
	-- their reversals. -CT
        perform * from batch where id = in_batch_id and approved_on IS NULL;
        IF NOT FOUND THEN
            RAISE EXCEPTION &#39;Batch not found&#39;;
        END IF; 
	update ar set paid = amount + 
		(select sum(amount) from acc_trans 
		join chart ON (acc_trans.chart_id = chart.id)
		where link = &#39;AR&#39; AND trans_id = ar.id
			AND (voucher_id IS NULL OR voucher_id NOT IN 
				(select id from voucher 
				WHERE batch_id = in_batch_id))) 
	where id in (select trans_id from acc_trans where voucher_id IN 
		(select id from voucher where batch_id = in_batch_id));

	update ap set paid = amount - (select sum(amount) from acc_trans 
		join chart ON (acc_trans.chart_id = chart.id)
		where link = &#39;AP&#39; AND trans_id = ap.id
			AND (voucher_id IS NULL OR voucher_id NOT IN 
				(select id from voucher 
				WHERE batch_id = in_batch_id))) 
	where id in (select trans_id from acc_trans where voucher_id IN 
		(select id from voucher where batch_id = in_batch_id));

        DELETE FROM ac_tax_form WHERE entry_id IN
               (select entry_id from acc_trans where voucher_id in
                       (select id from voucher where batch_id = in_batch_id)
               );

	DELETE FROM acc_trans WHERE voucher_id IN 
		(select id FROM voucher where batch_id = in_batch_id);

	-- The rest of this function involves the deletion of actual
	-- transactions, vouchers, and batches, and jobs which are in progress.
	-- -CT
	SELECT as_array(trans_id) INTO t_transaction_ids
	FROM voucher WHERE batch_id = in_batch_id AND batch_class IN (1, 2, 5);

        DELETE FROM ac_tax_form WHERE entry_id in
               (select entry_id from acc_trans 
                 where trans_id = any(t_transaction_ids));

	DELETE FROM acc_trans WHERE trans_id = ANY(t_transaction_ids);
	DELETE FROM ap WHERE id = ANY(t_transaction_ids);
	DELETE FROM gl WHERE id = ANY(t_transaction_ids);
	DELETE FROM voucher WHERE batch_id = in_batch_id;
	DELETE FROM batch WHERE id = in_batch_id;
	DELETE FROM transactions WHERE id = ANY(t_transaction_ids);

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_get_class_id(in_type text) -->
    <section id="public.function.batch-get-class-id-in-type-text"
             xreflabel="publicbatch_get_class_id(in_type text)">
      <title id="public.function.batch-get-class-id-in-type-text-title">
       batch_get_class_id(in_type text)
      </title>
      <titleabbrev id="public.function.batch-get-class-id-in-type-text-titleabbrev">
       batch_get_class_id(in_type text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        returns the batch class id associated with the in_type label provided.
        <programlisting>
SELECT id FROM batch_class WHERE class = $1;
</programlisting>
      </para>
    </section>

<!-- Function batch_get_users() -->
    <section id="public.function.batch-get-users"
             xreflabel="publicbatch_get_users()">
      <title id="public.function.batch-get-users-title">
       batch_get_users()
      </title>
      <titleabbrev id="public.function.batch-get-users-titleabbrev">
       batch_get_users()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a sim[ple set of user objects.  This should be renamed so that 
it is more obvious it is a general purpose function.
        <programlisting>
DECLARE out_record users%ROWTYPE;
BEGIN
	FOR out_record IN
		SELECT * from users WHERE entity_id IN (select created_by from batch)
	LOOP
		RETURN NEXT out_record;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_list_classes() -->
    <section id="public.function.batch-list-classes"
             xreflabel="publicbatch_list_classes()">
      <title id="public.function.batch-list-classes-title">
       batch_list_classes()
      </title>
      <titleabbrev id="public.function.batch-list-classes-titleabbrev">
       batch_list_classes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all batch classes.
        <programlisting>
DECLARE out_val record;
BEGIN
	FOR out_val IN select * from batch_class order by id
 	LOOP
		return next out_val;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_post(in_batch_id integer) -->
    <section id="public.function.batch-post-in-batch-id-integer"
             xreflabel="publicbatch_post(in_batch_id integer)">
      <title id="public.function.batch-post-in-batch-id-integer-title">
       batch_post(in_batch_id integer)
      </title>
      <titleabbrev id="public.function.batch-post-in-batch-id-integer-titleabbrev">
       batch_post(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts the specified batch to the books.  Only posted batches should show up
on standard financial reports.
        <programlisting>
BEGIN
	UPDATE ar SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 2);
	
	UPDATE ap SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 1);

	UPDATE gl SET approved = true 
	WHERE id IN (select trans_id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class = 5);

	UPDATE acc_trans SET approved = true 
	WHERE voucher_id IN (select id FROM voucher 
		WHERE batch_id = in_batch_id
		AND batch_class IN (3, 4, 6, 7));

	UPDATE batch 
	SET approved_on = now(),
		approved_by = (select entity_id FROM users 
			WHERE username = SESSION_USER)
	WHERE id = in_batch_id;

	RETURN now()::date;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean) -->
    <section id="public.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean"
             xreflabel="publicbatch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)">
      <title id="public.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-title">
       batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </title>
      <titleabbrev id="public.function.batch-search-empty-in-approved-integer-in-amount-lt-text-in-amount-gt-integer-in-created-by-eid-numeric-in-description-numeric-in-class-id-boolean-titleabbrev">
       batch_search_empty(in_approved integer, in_amount_lt text, in_amount_gt integer, in_created_by_eid numeric, in_description numeric, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a full search for the batches, listing them by amount processed.
in_amount_gt and in_amount_lt provide a range to search for.
in_description is a partial match field.
Other fields are exact matches.

NULLs match all values.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
               SELECT b.id, c.class, b.control_code, b.description, u.username,
                        b.created_on, b.default_date, 0, 0
                FROM batch b
                JOIN batch_class c ON (b.batch_class_id = c.id)
                JOIN users u ON (u.entity_id = b.created_by)
                LEFT JOIN voucher v ON (v.batch_id = b.id) 
               where v.id is null
                     and(u.entity_id = in_created_by_eid 
                     or in_created_by_eid is null) and
                     (in_description is null or b.description 
                     like &#39;%&#39;  || in_description || &#39;%&#39;) and
                     (in_class_id is null or c.id = in_class_id)
            GROUP BY b.id, c.class, b.description, u.username, b.created_on, 
                     b.control_code, b.default_date
            ORDER BY b.control_code, b.description

		
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean) -->
    <section id="public.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean"
             xreflabel="publicbatch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)">
      <title id="public.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean-title">
       batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)
      </title>
      <titleabbrev id="public.function.batch-search-mini-in-approved-integer-in-created-by-eid-text-in-description-integer-in-class-id-boolean-titleabbrev">
       batch_search_mini(in_approved integer, in_created_by_eid text, in_description integer, in_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF batch_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This performs a simple search of open batches created by the entity_id
in question.  This is used to pull up batches that were currently used so that
they can be picked up and more vouchers added.

NULLs match all values.
in_description is a partial match
All other inouts are exact matches.

        <programlisting>
DECLARE out_value batch_list_item;
BEGIN
	FOR out_value IN
		SELECT b.id, c.class, b.control_code, b.description, u.username,
			b.created_on, b.default_date, NULL
		FROM batch b
		JOIN batch_class c ON (b.batch_class_id = c.id)
		LEFT JOIN users u ON (u.entity_id = b.created_by)
		WHERE (c.id = in_class_id OR in_class_id IS NULL) AND 
			(b.description LIKE 
				&#39;%&#39; || in_description || &#39;%&#39; OR
				in_description IS NULL) AND
			(in_created_by_eid = b.created_by OR
				in_created_by_eid IS NULL) AND
			((in_approved = false OR in_approved IS NULL AND
				approved_on IS NULL) OR
				(in_approved = true AND approved_on IS NOT NULL)
			)
		GROUP BY b.id, c.class, b.description, u.username, b.created_on,
			b.control_code, b.default_date
	LOOP
		RETURN NEXT out_value;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__approve(in_id integer) -->
    <section id="public.function.budget-approve-in-id-integer"
             xreflabel="publicbudget__approve(in_id integer)">
      <title id="public.function.budget-approve-in-id-integer-title">
       budget__approve(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-approve-in-id-integer-titleabbrev">
       budget__approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
UPDATE budget_info 
   set approved_at = now(), approved_by = person__get_my_entity_id()
 WHERE id = $1;

SELECT budget__get_info($1);
</programlisting>
      </para>
    </section>

<!-- Function budget__get_business_units(in_id integer) -->
    <section id="public.function.budget-get-business-units-in-id-integer"
             xreflabel="publicbudget__get_business_units(in_id integer)">
      <title id="public.function.budget-get-business-units-in-id-integer-title">
       budget__get_business_units(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-get-business-units-in-id-integer-titleabbrev">
       budget__get_business_units(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> select bu.*
     FROM business_unit bu
     JOIN budget_to_business_unit b2bu ON b2bu.bu_id = bu.id
     JOIN budget_info bi ON bi.id = b2bu.budget_id
    WHERE bi.id = $1
 ORDER BY bu.class_id;
</programlisting>
      </para>
    </section>

<!-- Function budget__get_details(in_id integer) -->
    <section id="public.function.budget-get-details-in-id-integer"
             xreflabel="publicbudget__get_details(in_id integer)">
      <title id="public.function.budget-get-details-in-id-integer-title">
       budget__get_details(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-get-details-in-id-integer-titleabbrev">
       budget__get_details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_line</seg>
        </seglistitem>
       </segmentedlist>
 
        This retrieves the budget lines associated with a budget.
        <programlisting>
  SELECT * FROM budget_line where budget_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function budget__get_info(in_id integer) -->
    <section id="public.function.budget-get-info-in-id-integer"
             xreflabel="publicbudget__get_info(in_id integer)">
      <title id="public.function.budget-get-info-in-id-integer-title">
       budget__get_info(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-get-info-in-id-integer-titleabbrev">
       budget__get_info(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        Selects the budget info. 
        <programlisting> 
select bi.id, bi.start_date, bi.end_date, bi.reference, bi.description, 
       bi.entered_by, bi.approved_by, bi.obsolete_by, bi.entered_at, 
       bi.approved_at, bi.obsolete_at, 
       ee.name, ae.name, oe.name
  from budget_info bi
  JOIN entity ee ON bi.entered_by = ee.id
  LEFT JOIN entity ae ON bi.approved_by = ae.id
  LEFT JOIN entity oe ON bi.obsolete_by = oe.id
 where bi.id = $1; 
</programlisting>
      </para>
    </section>

<!-- Function budget__get_notes(in_id integer) -->
    <section id="public.function.budget-get-notes-in-id-integer"
             xreflabel="publicbudget__get_notes(in_id integer)">
      <title id="public.function.budget-get-notes-in-id-integer-title">
       budget__get_notes(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-get-notes-in-id-integer-titleabbrev">
       budget__get_notes(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all notes associated with a budget, by default in the order they 
were created.
        <programlisting> 
SELECT * FROM budget_note WHERE ref_key = $1
 ORDER BY created;
</programlisting>
      </para>
    </section>

<!-- Function budget__mark_obsolete(in_id integer) -->
    <section id="public.function.budget-mark-obsolete-in-id-integer"
             xreflabel="publicbudget__mark_obsolete(in_id integer)">
      <title id="public.function.budget-mark-obsolete-in-id-integer-title">
       budget__mark_obsolete(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-mark-obsolete-in-id-integer-titleabbrev">
       budget__mark_obsolete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        Marks a budget as obsolete 
        <programlisting>
UPDATE budget_info 
   set obsolete_by = person__get_my_entity_id(), obsolete_at = now()
 WHERE id = $1 and approved_by is not null;
SELECT budget__get_info($1)
</programlisting>
      </para>
    </section>

<!-- Function budget__reject(in_id integer) -->
    <section id="public.function.budget-reject-in-id-integer"
             xreflabel="publicbudget__reject(in_id integer)">
      <title id="public.function.budget-reject-in-id-integer-title">
       budget__reject(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-reject-in-id-integer-titleabbrev">
       budget__reject(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes unapproved budgets only.
        <programlisting>
BEGIN

DELETE FROM budget_line 
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_to_project
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_to_department
 WHERE budget_id IN (SELECT id from budget_info 
                      WHERE id = in_id AND approved_by IS NULL);

DELETE FROM budget_info WHERE id = in_id AND approved_by IS NULL;

RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_details(in_details integer, in_id text[]) -->
    <section id="public.function.budget-save-details-in-details-integer-in-id-textARRAY"
             xreflabel="publicbudget__save_details(in_details integer, in_id text[])">
      <title id="public.function.budget-save-details-in-details-integer-in-id-textARRAY-title">
       budget__save_details(in_details integer, in_id text[])
      </title>
      <titleabbrev id="public.function.budget-save-details-in-details-integer-in-id-textARRAY-titleabbrev">
       budget__save_details(in_details integer, in_id text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        This saves the line items for the budget.  in_details is an array n long
where each entry is {int account_id, text description, numeric amount}.  The
in_id parameter is the budget_id.
        <programlisting>
DECLARE
   loop_count int;
   retval budget_info_ext;
BEGIN
    FOR loop_count in   
        array_lower(in_details, 1) ..
        array_upper(in_details, 1)
    LOOP
        INSERT INTO budget_line 
                    (budget_id, 
                     account_id, 
                     description, 
                     amount)
             VALUES (in_id, 
                     in_details[loop_count][1]::int, 
                     in_details[loop_count][2], 
                     in_details[loop_count][3]::numeric);
    END LOOP;
    retval := budget__get_info(in_id);
    return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[]) -->
    <section id="public.function.budget-save-info-in-business-units-integer-in-description-date-in-reference-date-in-end-date-text-in-start-date-text-in-id-integerARRAY"
             xreflabel="publicbudget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[])">
      <title id="public.function.budget-save-info-in-business-units-integer-in-description-date-in-reference-date-in-end-date-text-in-start-date-text-in-id-integerARRAY-title">
       budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[])
      </title>
      <titleabbrev id="public.function.budget-save-info-in-business-units-integer-in-description-date-in-reference-date-in-end-date-text-in-start-date-text-in-id-integerARRAY-titleabbrev">
       budget__save_info(in_business_units integer, in_description date, in_reference date, in_end_date text, in_start_date text, in_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves the extended budget info passed through to the function.  See the 
comment on type budget_info_ext for more information.
        <programlisting>
DECLARE 
   retval budget_info_ext;
   t_id int;
BEGIN

   PERFORM * FROM budget_info WHERE id = in_id and approved_by is not null;
   IF FOUND THEN
       RAISE EXCEPTION &#39;report approved&#39;;
   END IF;

  UPDATE budget_info
     SET start_date = in_start_date,
         end_date = in_end_date,
         reference = in_reference,
         description = in_description
   WHERE id = in_id and approved_by is null;
  IF FOUND THEN
      t_id := in_id;
  ELSE
       INSERT INTO budget_info (start_date, end_date, reference, description)
            VALUES (in_start_date, in_end_date, in_reference, in_description);
       t_id = currval(&#39;budget_info_id_seq&#39;);

       INSERT INTO budget_to_business_unit(budget_id, bu_id, bu_class)
       SELECT t_id, id, class_id
         FROM business_unit
        WHERE id = ANY(in_business_units);
  END IF;
  retval := budget__get_info(t_id);
  return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function budget__save_note(in_note integer, in_subject text, in_id text) -->
    <section id="public.function.budget-save-note-in-note-integer-in-subject-text-in-id-text"
             xreflabel="publicbudget__save_note(in_note integer, in_subject text, in_id text)">
      <title id="public.function.budget-save-note-in-note-integer-in-subject-text-in-id-text-title">
       budget__save_note(in_note integer, in_subject text, in_id text)
      </title>
      <titleabbrev id="public.function.budget-save-note-in-note-integer-in-subject-text-in-id-text-titleabbrev">
       budget__save_note(in_note integer, in_subject text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>budget_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a note attached to a budget.
        <programlisting>
INSERT INTO budget_note (subject, note, ref_key) 
     values ($2, $3, $1);

SELECT * FROM budget_note WHERE id = currval(&#39;note_id_seq&#39;::regclass);
</programlisting>
      </para>
    </section>

<!-- Function budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean) -->
    <section id="public.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-business-units-date-in-obsolete-by-text-in-approved-by-text-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integerARRAY-in-end-date-boolean-in-start-date-boolean"
             xreflabel="publicbudget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean)">
      <title id="public.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-business-units-date-in-obsolete-by-text-in-approved-by-text-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integerARRAY-in-end-date-boolean-in-start-date-boolean-title">
       budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean)
      </title>
      <titleabbrev id="public.function.budget-search-in-is-obsolete-date-in-is-approved-date-in-business-units-date-in-obsolete-by-text-in-approved-by-text-in-entered-by-integer-in-description-integer-in-reference-integer-in-includes-date-integerARRAY-in-end-date-boolean-in-start-date-boolean-titleabbrev">
       budget__search(in_is_obsolete date, in_is_approved date, in_business_units date, in_obsolete_by text, in_approved_by text, in_entered_by integer, in_description integer, in_reference integer, in_includes_date integer[], in_end_date boolean, in_start_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_info_ext</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a general search for budgets
        <programlisting>
select bi.id, bi.start_date, bi.end_date, bi.reference, bi.description, 
       bi.entered_by, bi.approved_by, bi.obsolete_by, bi.entered_at, 
       bi.approved_at, bi.obsolete_at, 
       ee.name, ae.name, oe.name
  from budget_info bi 
  JOIN entity ee ON bi.entered_by = ee.id
  LEFT JOIN entity ae ON bi.approved_by = ae.id
  LEFT JOIN entity oe ON bi.obsolete_by = oe.id
 WHERE (start_date = $1 or $1 is null) AND ($2 = end_date or $2 is null) 
       AND ($3 BETWEEN start_date AND end_date or $2 is null)
       AND ($4 ilike reference || &#39;%&#39; or $4 is null) 
       AND (bi.description @@ plainto_tsquery($5) or $5 is null) 
       AND ($6 = entered_by or $6 is null) 
       AND ($7 = approved_by or $7 is null) 
       AND ($8 = obsolete_by or $8 is null) 
       AND ($10 IS NULL OR ($10 = (approved_by IS NOT NULL)))
       AND ($11 IS NULL OR ($11 = (obsolete_by IS NOT NULL)))
 ORDER BY reference;
</programlisting>
      </para>
    </section>

<!-- Function budget__variance_report(in_id integer) -->
    <section id="public.function.budget-variance-report-in-id-integer"
             xreflabel="publicbudget__variance_report(in_id integer)">
      <title id="public.function.budget-variance-report-in-id-integer-title">
       budget__variance_report(in_id integer)
      </title>
      <titleabbrev id="public.function.budget-variance-report-in-id-integer-titleabbrev">
       budget__variance_report(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF budget_variance_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a variance report for budget with an id of in_id.
        <programlisting>
   WITH agg_account (amount, id, transdate)
        AS ( SELECT ac.amount *
                    CASE WHEN a.contra THEN -1 ELSE 1 END *
                    CASE WHEN a.category IN (&#39;A&#39;, &#39;E&#39;) THEN -1 ELSE 1 END
                    AS amount,
                    ac.chart_id, ac.transdate
               FROM acc_trans ac
               JOIN account a ON ac.chart_id = a.id
           )
   SELECT act.accno, act.description, act.id, b.description, b.amount,
          coalesce(sum(a.amount), 0), 
          b.amount - coalesce(sum(a.amount), 0) AS variance
     FROM budget_info bi
     JOIN budget_line b ON bi.id = b.budget_id
     JOIN account act ON act.id = b.account_id
LEFT JOIN agg_account a ON a.transdate BETWEEN bi.start_date and bi.end_date
                           AND a.id = b.account_id
    WHERE bi.id = $1
 GROUP BY act.accno, act.description, act.id, b.description, b.amount
 ORDER BY act.accno;
</programlisting>
      </para>
    </section>

<!-- Function business_type__list() -->
    <section id="public.function.business-type-list"
             xreflabel="publicbusiness_type__list()">
      <title id="public.function.business-type-list-title">
       business_type__list()
      </title>
      <titleabbrev id="public.function.business-type-list-titleabbrev">
       business_type__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF business</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of all business types. Ordered by description by default.
        <programlisting>
DECLARE out_row business%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM business ORDER BY description LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function business_unit__get(in_id integer) -->
    <section id="public.function.business-unit-get-in-id-integer"
             xreflabel="publicbusiness_unit__get(in_id integer)">
      <title id="public.function.business-unit-get-in-id-integer-title">
       business_unit__get(in_id integer)
      </title>
      <titleabbrev id="public.function.business-unit-get-in-id-integer-titleabbrev">
       business_unit__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM business_unit where id = $1; </programlisting>
      </para>
    </section>

<!-- Function business_unit__get_tree_for(in_id integer) -->
    <section id="public.function.business-unit-get-tree-for-in-id-integer"
             xreflabel="publicbusiness_unit__get_tree_for(in_id integer)">
      <title id="public.function.business-unit-get-tree-for-in-id-integer-title">
       business_unit__get_tree_for(in_id integer)
      </title>
      <titleabbrev id="public.function.business-unit-get-tree-for-in-id-integer-titleabbrev">
       business_unit__get_tree_for(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF business_unit_short</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns tree-related records with the root of the tree being 
the business unit of in_id.  
        <programlisting>
WITH RECURSIVE tree  (id, control_code, description,  start_date, end_date, 
                      parent_id, path, level)
AS (
   SELECT id, control_code, description, start_date, end_date, parent_id, 
          ARRAY[parent_id] AS path, 1 as level
     FROM business_unit WHERE $1 = id
    UNION
   SELECT t.id, t.control_code, t.description, t.start_date, t.end_date, 
          t.parent_id,   
          t.path || bu.id AS path, t.level + 1 as level
     FROM business_unit bu JOIN tree t ON t.parent_id = bu.id
)
SELECT * FROM tree ORDER BY path;
</programlisting>
      </para>
    </section>

<!-- Function business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean) -->
    <section id="public.function.business-unit-list-by-class-in-strict-credit-integer-in-credit-id-date-in-active-on-integer-in-business-unit-class-id-boolean"
             xreflabel="publicbusiness_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean)">
      <title id="public.function.business-unit-list-by-class-in-strict-credit-integer-in-credit-id-date-in-active-on-integer-in-business-unit-class-id-boolean-title">
       business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean)
      </title>
      <titleabbrev id="public.function.business-unit-list-by-class-in-strict-credit-integer-in-credit-id-date-in-active-on-integer-in-business-unit-class-id-boolean-titleabbrev">
       business_unit__list_by_class(in_strict_credit integer, in_credit_id date, in_active_on integer, in_business_unit_class_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
        This function retUrns a list of all units (projects, departments, funds, etc)
active on the in_active_on date, where in_credit_id matches the credit id of the
customer or vendor requested, and where in_business_uni_class_id is the class id
of the class of business units (1 for department, 2 for project, etc).

With the exception of in_business_unit_class_id, the null matches all records.

        <programlisting>
BEGIN
RETURN QUERY SELECT * FROM business_unit 
              WHERE (in_active_on BETWEEN coalesce(start_date, in_active_on) 
                                      AND coalesce(end_date, in_active_on) 
                      OR in_active_on IS NULL)
                    AND (in_credit_id = credit_id
                        OR (credit_id IS NULL and in_strict_credit IS NOT TRUE)
                        OR (in_credit_id IS NULL))
                    AND class_id = in_business_unit_class_id
           ORDER BY control_code;
END;
</programlisting>
      </para>
    </section>

<!-- Function business_unit__list_classes(in_module boolean, in_active text) -->
    <section id="public.function.business-unit-list-classes-in-module-boolean-in-active-text"
             xreflabel="publicbusiness_unit__list_classes(in_module boolean, in_active text)">
      <title id="public.function.business-unit-list-classes-in-module-boolean-in-active-text-title">
       business_unit__list_classes(in_module boolean, in_active text)
      </title>
      <titleabbrev id="public.function.business-unit-list-classes-in-module-boolean-in-active-text-titleabbrev">
       business_unit__list_classes(in_module boolean, in_active text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF business_unit_class</seg>
        </seglistitem>
       </segmentedlist>
 
        This function lists all business unit clases.  If in_active is true, then 
only active classes are listed.  If it is false then only inactive classes are
listed.  If it is null, then all classes are listed.
        <programlisting>

SELECT bc.* 
  FROM business_unit_class bc
 WHERE     (active = $1 OR $1 IS NULL)
       AND (id IN (select bu_class_id 
                     FROM bu_class_to_module bcm
                     JOIN lsmb_module mod ON mod.id = bcm.module_id
                    WHERE lower(label) = lower($2))
            OR $2 is null)
ORDER BY ordering;

</programlisting>
      </para>
    </section>

<!-- Function business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer) -->
    <section id="public.function.business-unit-save-in-credit-id-integer-in-parent-id-integer-in-end-date-text-in-start-date-text-in-description-date-in-control-code-date-in-class-id-integer-in-id-integer"
             xreflabel="publicbusiness_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer)">
      <title id="public.function.business-unit-save-in-credit-id-integer-in-parent-id-integer-in-end-date-text-in-start-date-text-in-description-date-in-control-code-date-in-class-id-integer-in-id-integer-title">
       business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer)
      </title>
      <titleabbrev id="public.function.business-unit-save-in-credit-id-integer-in-parent-id-integer-in-end-date-text-in-start-date-text-in-description-date-in-control-code-date-in-class-id-integer-in-id-integer-titleabbrev">
       business_unit__save(in_credit_id integer, in_parent_id integer, in_end_date text, in_start_date text, in_description date, in_control_code date, in_class_id integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval business_unit;
        t_id int;

BEGIN

UPDATE business_unit
   SET class_id = in_class_id,
       control_code = in_control_code,
       description = in_description,
       start_date = in_start_date,
       end_date = in_end_date,
       credit_id = in_credit_id
 WHERE id = in_id;


IF FOUND THEN
   t_id := in_id;
ELSE
   INSERT INTO business_unit 
          (class_id, control_code, description, start_date, end_date, parent_id,
           credit_id)
   VALUES (in_class_id, in_control_code, in_description, in_start_date, 
           in_end_date, in_parent_id, in_credit_id);
    t_id := currval(&#39;business_unit_id_seq&#39;);
END IF;

SELECT * INTO retval FROM business_unit WHERE id = t_id;

RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function business_unit_class__get_modules(in_id integer) -->
    <section id="public.function.business-unit-class-get-modules-in-id-integer"
             xreflabel="publicbusiness_unit_class__get_modules(in_id integer)">
      <title id="public.function.business-unit-class-get-modules-in-id-integer-title">
       business_unit_class__get_modules(in_id integer)
      </title>
      <titleabbrev id="public.function.business-unit-class-get-modules-in-id-integer-titleabbrev">
       business_unit_class__get_modules(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF lsmb_module</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM lsmb_module 
    WHERE id IN (select module_id from bu_class_to_module where bu_class_id = $1)
 ORDER BY id;
</programlisting>
      </para>
    </section>

<!-- Function business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer) -->
    <section id="public.function.business-unit-class-save-in-ordering-integer-in-active-text-in-label-boolean-in-id-integer"
             xreflabel="publicbusiness_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer)">
      <title id="public.function.business-unit-class-save-in-ordering-integer-in-active-text-in-label-boolean-in-id-integer-title">
       business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer)
      </title>
      <titleabbrev id="public.function.business-unit-class-save-in-ordering-integer-in-active-text-in-label-boolean-in-id-integer-titleabbrev">
       business_unit_class__save(in_ordering integer, in_active text, in_label boolean, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>business_unit_class</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval business_unit_class;
        t_id int;
BEGIN

t_id := in_id;
UPDATE business_unit_class
   SET label = in_label,
       active = in_active,
       ordering = in_ordering
 WHERE id = in_id;

IF NOT FOUND THEN

   INSERT INTO business_unit_class (label, active, ordering)
   VALUES (in_label, in_active, in_ordering);

   t_id := currval(&#39;business_unit_class_id_seq&#39;);

END IF;

SELECT * INTO retval FROM business_unit_class WHERE id = t_id;

RETURN retval;

END;

</programlisting>
      </para>
    </section>

<!-- Function business_unit_class__save_modules(in_mod_ids integer, in_id integer[]) -->
    <section id="public.function.business-unit-class-save-modules-in-mod-ids-integer-in-id-integerARRAY"
             xreflabel="publicbusiness_unit_class__save_modules(in_mod_ids integer, in_id integer[])">
      <title id="public.function.business-unit-class-save-modules-in-mod-ids-integer-in-id-integerARRAY-title">
       business_unit_class__save_modules(in_mod_ids integer, in_id integer[])
      </title>
      <titleabbrev id="public.function.business-unit-class-save-modules-in-mod-ids-integer-in-id-integerARRAY-titleabbrev">
       business_unit_class__save_modules(in_mod_ids integer, in_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DELETE FROM bu_class_to_module WHERE bu_class_id = $1;

INSERT INTO bu_class_to_module (bu_class_id, module_id)
SELECT $1, unnest
  FROM unnest($2);

SELECT true;
</programlisting>
      </para>
    </section>

<!-- Function business_unit_get(in_id integer) -->
    <section id="public.function.business-unit-get-in-id-integer"
             xreflabel="publicbusiness_unit_get(in_id integer)">
      <title id="public.function.business-unit-get-in-id-integer-title">
       business_unit_get(in_id integer)
      </title>
      <titleabbrev id="public.function.business-unit-get-in-id-integer-titleabbrev">
       business_unit_get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>business_unit</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM business_unit WHERE id = $1; </programlisting>
      </para>
    </section>

<!-- Function chart_get_ar_ap(in_account_class integer) -->
    <section id="public.function.chart-get-ar-ap-in-account-class-integer"
             xreflabel="publicchart_get_ar_ap(in_account_class integer)">
      <title id="public.function.chart-get-ar-ap-in-account-class-integer-title">
       chart_get_ar_ap(in_account_class integer)
      </title>
      <titleabbrev id="public.function.chart-get-ar-ap-in-account-class-integer-titleabbrev">
       chart_get_ar_ap(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the cash account acording with in_account_class which 
must be 1 or 2.

If in_account_class is 1 then it returns a list of AP accounts, and if 
in_account_class is 2, then a list of AR accounts.
        <programlisting>
DECLARE out_row chart%ROWTYPE;
BEGIN
	IF in_account_class NOT IN (1, 2) THEN
		RAISE EXCEPTION &#39;Bad Account Type&#39;;
	END IF;
       FOR out_row IN
               SELECT * FROM chart 
               WHERE link = CASE WHEN in_account_class = 1 THEN &#39;AP&#39;
                               WHEN in_account_class = 2 THEN &#39;AR&#39;
                               END
               ORDER BY accno
       LOOP
               RETURN NEXT out_row;
       END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_all() -->
    <section id="public.function.chart-list-all"
             xreflabel="publicchart_list_all()">
      <title id="public.function.chart-list-all-title">
       chart_list_all()
      </title>
      <titleabbrev id="public.function.chart-list-all-titleabbrev">
       chart_list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        Generates a list of chart view entries.
        <programlisting>
DECLARE out_row chart%ROWTYPE;
BEGIN
	FOR out_row IN 
		SELECT * FROM chart ORDER BY accno
	LOOP
		RETURN next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_cash(in_account_class integer) -->
    <section id="public.function.chart-list-cash-in-account-class-integer"
             xreflabel="publicchart_list_cash(in_account_class integer)">
      <title id="public.function.chart-list-cash-in-account-class-integer-title">
       chart_list_cash(in_account_class integer)
      </title>
      <titleabbrev id="public.function.chart-list-cash-in-account-class-integer-titleabbrev">
       chart_list_cash(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the overpayment accounts acording with 
in_account_class which must be 1 or 2.

If in_account_class is 1 it returns a list of AP cash accounts and 
if 2, AR cash accounts.
        <programlisting>
 DECLARE resultrow record;
         link_string text;
 BEGIN
         IF in_account_class = 1 THEN
            link_string := &#39;%AP_paid%&#39;;
         ELSE 
            link_string := &#39;%AR_paid%&#39;;
         END IF;
 
         FOR resultrow IN
           SELECT *  FROM chart
           WHERE link LIKE link_string
           ORDER BY accno
           LOOP
           return next resultrow;
         END LOOP;
 END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_discount(in_account_class integer) -->
    <section id="public.function.chart-list-discount-in-account-class-integer"
             xreflabel="publicchart_list_discount(in_account_class integer)">
      <title id="public.function.chart-list-discount-in-account-class-integer-title">
       chart_list_discount(in_account_class integer)
      </title>
      <titleabbrev id="public.function.chart-list-discount-in-account-class-integer-titleabbrev">
       chart_list_discount(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns the discount accounts acording with in_account_class 
which must be 1 or 2.

If in_account_class is 1, returns AP discount accounts, if 2, AR discount 
accounts.
        <programlisting>
DECLARE resultrow record;
        link_string text;
BEGIN
        IF in_account_class = 1 THEN
           link_string := &#39;%AP_discount%&#39;;
        ELSE
           link_string := &#39;%AR_discount%&#39;;
        END IF;

        FOR resultrow IN
          SELECT *  FROM chart
          WHERE link LIKE link_string
          ORDER BY accno
          LOOP
          return next resultrow;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_overpayment(in_account_class integer) -->
    <section id="public.function.chart-list-overpayment-in-account-class-integer"
             xreflabel="publicchart_list_overpayment(in_account_class integer)">
      <title id="public.function.chart-list-overpayment-in-account-class-integer-title">
       chart_list_overpayment(in_account_class integer)
      </title>
      <titleabbrev id="public.function.chart-list-overpayment-in-account-class-integer-titleabbrev">
       chart_list_overpayment(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF chart</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of AP_overpayment accounts if in_account_class is 1
Otherwise it returns a list of AR_overpayment accounts.
        <programlisting>
DECLARE resultrow record;
        link_string text;
BEGIN
        IF in_account_class = 1 THEN
           link_string := &#39;%AP_overpayment%&#39;;
        ELSE 
           link_string := &#39;%AR_overpayment%&#39;;
        END IF;

        FOR resultrow IN
          SELECT *  FROM chart
          WHERE link LIKE link_string
          ORDER BY accno
          LOOP
          return next resultrow;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function chart_list_search(in_link_desc text, in_search text) -->
    <section id="public.function.chart-list-search-in-link-desc-text-in-search-text"
             xreflabel="publicchart_list_search(in_link_desc text, in_search text)">
      <title id="public.function.chart-list-search-in-link-desc-text-in-search-text-title">
       chart_list_search(in_link_desc text, in_search text)
      </title>
      <titleabbrev id="public.function.chart-list-search-in-link-desc-text-in-search-text-titleabbrev">
       chart_list_search(in_link_desc text, in_search text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        This returns a list of account entries where the description or account 
number begins with in_search.

If in_link_desc is provided, the list is further filtered by which accounts are 
set to an account_link.description equal to that provided.
        <programlisting>
DECLARE out_row account%ROWTYPE;
BEGIN
	FOR out_row IN 
		SELECT * FROM account 
                 WHERE (accno ~* (&#39;^&#39;||in_search) 
                       OR description ~* (&#39;^&#39;||in_search))
                       AND (in_link_desc IS NULL 
                           or id in 
                          (select account_id from account_link 
                            where description = in_link_desc))
                       AND not obsolete
              ORDER BY accno
	LOOP
		RETURN next out_row;
	END LOOP;
END;</programlisting>
      </para>
    </section>

<!-- Function check_expiration() -->
    <section id="public.function.check-expiration"
             xreflabel="publiccheck_expiration()">
      <title id="public.function.check-expiration-title">
       check_expiration()
      </title>
      <titleabbrev id="public.function.check-expiration-titleabbrev">
       check_expiration()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks whether the user needs to be notified of a pending expiration of 
his/her password.  Returns true if needed, false if not.

The function also records the next time when the notification will again need to
be displayed. 
        <programlisting>
DECLARE test_result BOOL;
	expires_in interval;
	notify_again interval;
BEGIN
	expires_in := user__check_my_expiration();

	SELECT expires_in &lt; notify_password INTO test_result
	FROM users WHERE username = SESSION_USER;

	IF test_result THEN 
		IF expires_in &lt; &#39;1 week&#39; THEN
			notify_again := &#39;1 hour&#39;;
		ELSE
			notify_again := &#39;1 day&#39;;
		END IF;

		UPDATE users 
		SET notify_password = expires_in - notify_again
		WHERE username = SESSION_USER;
	END IF;
	RETURN test_result;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric) -->
    <section id="public.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric"
             xreflabel="publiccogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)">
      <title id="public.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric-title">
       cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)
      </title>
      <titleabbrev id="public.function.cogs-add-for-ap-in-lastcost-integer-in-qty-numeric-in-parts-id-numeric-titleabbrev">
       cogs__add_for_ap(in_lastcost integer, in_qty numeric, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_cp account_checkpoint;
        t_ar ar;
        t_avail numeric;
BEGIN


IF in_qty &gt; 0 THEN
   return cogs__reverse_ap(in_parts_id, in_qty * -1) * in_lastcost;
END IF;

SELECT * INTO t_cp FROM account_checkpoint ORDER BY end_date DESC LIMIT 1;

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN ar a ON a.id = i.trans_id
     WHERE qty + allocated &gt; 0 and parts_id  = in_parts_id
  ORDER BY a.transdate, a.id, i.id
LOOP
   t_avail := t_inv.qty + t_inv.allocated;
   SELECT * INTO t_ar FROM ar WHERE id = t_inv.trans_id;
   IF t_alloc &lt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return t_alloc;
   ELSIF (in_qty + t_alloc) * -1 &lt;=  t_avail  THEN
       UPDATE invoice SET allocated = allocated + (in_qty + t_alloc)
        WHERE id = t_inv.id;

       INSERT INTO acc_trans 
              (chart_id, transdate, amount, invoice_id, approved, trans_id)
       SELECT expense_accno_id, 
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, (in_qty + t_alloc) * in_lastcost, t_inv.id, true,
              t_inv.trans_id
         FROM parts 
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL
       UNION
       SELECT income_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, -1 * (in_qty + t_alloc) * in_lastcost, t_inv.id, true,
              t_inv.trans_id
         FROM parts 
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL;
                                    
       t_cogs := t_cogs + (in_qty + t_alloc) * in_lastcost;
       return in_qty * -1;
   ELSE
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_cogs := t_cogs + t_avail * in_lastcost;

       INSERT INTO acc_trans
              (chart_id, transdate, amount, invoice_id, approved, trans_id)
       SELECT expense_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END,  -1 * t_avail * in_lastcost, 
              t_inv.id, true, t_inv.trans_id
         FROM parts
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL
       UNION
       SELECT income_accno_id,
              CASE WHEN t_ar.transdate &gt; t_cp.end_date THEN t_ar.transdate
                   ELSE t_cp.end_date + &#39;1 day&#39;::interval
               END, -t_avail * in_lastcost, t_inv.id, true, t_inv.trans_id
         FROM parts
       WHERE  id = t_inv.parts_id AND inventory_accno_id IS NOT NULL
              AND expense_accno_id IS NOT NULL;
       t_alloc := t_alloc + t_avail;
       t_cogs := t_cogs + t_avail * in_lastcost;
   END IF;


END LOOP;

RETURN t_alloc;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ap_line(in_invoice_id integer) -->
    <section id="public.function.cogs-add-for-ap-line-in-invoice-id-integer"
             xreflabel="publiccogs__add_for_ap_line(in_invoice_id integer)">
      <title id="public.function.cogs-add-for-ap-line-in-invoice-id-integer-title">
       cogs__add_for_ap_line(in_invoice_id integer)
      </title>
      <titleabbrev id="public.function.cogs-add-for-ap-line-in-invoice-id-integer-titleabbrev">
       cogs__add_for_ap_line(in_invoice_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval numeric;
        r_cogs numeric[];
        t_inv invoice;
        t_adj numeric;
        t_ap  ap;
BEGIN

SELECT * INTO t_inv FROM invoice 
 WHERE id = in_invoice_id;

IF t_inv.qty + t_inv.allocated = 0 THEN
   return 0;
END IF;

SELECT * INTO t_ap FROM ap WHERE id = t_inv.trans_id;

IF t_inv.qty &lt; 0 THEN -- normal COGS

    SELECT cogs__add_for_ap(i.parts_id, i.qty + i.allocated, i.sellprice) 
      INTO retval
      FROM invoice i
      JOIN parts p ON p.id = i.parts_id
     WHERE i.id = $1;

    UPDATE invoice 
       SET allocated = allocated + retval
     WHERE id = $1;
ELSE -- reversal

   r_cogs := cogs__reverse_ap(t_inv.parts_id, t_inv.qty + t_inv.allocated);

   UPDATE invoice
      SET allocated = allocated + r_cogs[1]
    WHERE id = in_invoice_id;

   t_adj := t_inv.sellprice * r_cogs[1] + r_cogs[2];

   INSERT INTO acc_trans 
          (chart_id, trans_id, approved,  amount, transdate, invoice_id)
   SELECT p.inventory_accno_id, t_inv.trans_id, true, t_adj, t_ap.transdate, 
          in_invoice_id
     FROM parts p
    WHERE id = t_inv.parts_id
    UNION
   SELECT p.expense_accno_id, t_inv.trans_id, true, t_adj * -1, t_ap.transdate,
          in_invoice_id
     FROM parts p
    WHERE id = t_inv.parts_id;
   retval := r_cogs[1];
   raise notice &#39;cogs reversal returned %&#39;, r_cogs;

END IF;

RETURN retval;

END;

</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ar(in_qty integer, in_parts_id numeric) -->
    <section id="public.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric"
             xreflabel="publiccogs__add_for_ar(in_qty integer, in_parts_id numeric)">
      <title id="public.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric-title">
       cogs__add_for_ar(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="public.function.cogs-add-for-ar-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__add_for_ar(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
        This function accepts a parts_id and a quantity, and iterates through AP 
records in order, calculating COGS on a FIFO basis and returning it to the 
application to attach to the current transaction.

Return values are an array of {allocated, cogs}.

        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_avail numeric;
BEGIN


FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN (select id, approved, transdate from ap
             union
            select id, approved, transdate from gl) a ON a.id = i.trans_id
     WHERE qty + allocated &lt; 0 AND i.parts_id = in_parts_id
  ORDER BY a.transdate asc, a.id asc, i.id asc
LOOP
   t_avail := (t_inv.qty + t_inv.allocated) * -1;
   IF t_alloc &gt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty + t_alloc) &lt;= t_avail THEN
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       t_cogs := t_cogs + (in_qty - t_alloc) * t_inv.sellprice;
       t_alloc := in_qty;
       return ARRAY[t_alloc, t_cogs];
   ELSE
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_cogs := t_cogs + (t_avail * t_inv.sellprice);
       t_alloc := t_alloc + t_avail;
   END IF;
END LOOP;

RETURN ARRAY[t_alloc, t_cogs];

END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__add_for_ar_line(in_invoice_id integer) -->
    <section id="public.function.cogs-add-for-ar-line-in-invoice-id-integer"
             xreflabel="publiccogs__add_for_ar_line(in_invoice_id integer)">
      <title id="public.function.cogs-add-for-ar-line-in-invoice-id-integer-title">
       cogs__add_for_ar_line(in_invoice_id integer)
      </title>
      <titleabbrev id="public.function.cogs-add-for-ar-line-in-invoice-id-integer-titleabbrev">
       cogs__add_for_ar_line(in_invoice_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   t_cogs numeric[];
   t_inv invoice;
   t_part parts;
   t_ar ar;
   t_transdate date;
BEGIN

SELECT * INTO t_inv FROM invoice WHERE id = in_invoice_id;
SELECT * INTO t_part FROM parts WHERE id = t_inv.parts_id;
SELECT * INTO t_ar FROM ar WHERE id = t_inv.trans_id;

IF t_inv.qty + t_inv.allocated = 0 THEN
   return 0;
END IF;

IF t_inv.qty &gt; 0 THEN 
   t_cogs := cogs__add_for_ar(t_inv.parts_id, t_inv.qty + t_inv.allocated);
ELSE
   t_cogs := cogs__reverse_ar(t_inv.parts_id, t_inv.qty + t_inv.allocated);
END IF;


UPDATE invoice set allocated = allocated - t_cogs[1]
 WHERE id = in_invoice_id;

SELECT CASE WHEN t_ar.transdate &gt; max(end_date) THEN t_ar.transdate
            ELSE max(end_date) + &#39;1 day&#39;::interval
        END INTO t_transdate
  from account_checkpoint td; 
INSERT INTO acc_trans 
       (trans_id, chart_id, approved, amount, transdate,  invoice_id)
VALUES (t_inv.trans_id, CASE WHEN t_inv.qty &lt; 0 AND t_ar.is_return 
                           THEN t_part.returns_accno_id
                           ELSE t_part.expense_accno_id
                      END, TRUE, t_cogs[2] * -1, t_transdate, t_inv.id),
       (t_inv.trans_id, t_part.inventory_accno_id, TRUE, t_cogs[2], 
       t_transdate, t_inv.id);

RETURN t_cogs[1];

END;

</programlisting>
      </para>
    </section>

<!-- Function cogs__reverse_ap(in_qty integer, in_parts_id numeric) -->
    <section id="public.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric"
             xreflabel="publiccogs__reverse_ap(in_qty integer, in_parts_id numeric)">
      <title id="public.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric-title">
       cogs__reverse_ap(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="public.function.cogs-reverse-ap-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__reverse_ap(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
        This function iterates through invoice rows attached to ap transactions and 
allocates them on a first-in first-out basis.  The sort of pseudo-&quot;COGS&quot; value 
is returned to the application for further handling.
        <programlisting>
DECLARE t_alloc numeric :=0;
        t_inv invoice;
        t_cogs numeric :=0;
        retval numeric[];
BEGIN
RAISE NOTICE &#39;reversing AP: parts_id %, qty %&#39;, in_parts_id, in_qty;

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN ap a ON a.id = i.trans_id
     WHERE qty + allocated &lt; 0 AND parts_id = in_parts_id
  ORDER BY a.transdate, a.id, i.id
LOOP
   RAISE NOTICE &#39;id %, avail %, allocated %, requesting %&#39;, t_inv.id, t_inv.qty + t_inv.allocated, t_alloc, in_qty - t_alloc;
   IF t_alloc &gt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       return ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty - t_alloc) &lt;= -1 * (t_inv.qty + t_inv.allocated) THEN
       raise notice &#39;partial reversal&#39;;
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       return ARRAY[in_qty * -1, t_cogs + (in_qty - t_alloc) * t_inv.sellprice];
   ELSE
       raise notice &#39;total reversal&#39;;
       UPDATE invoice SET allocated = qty * -1
        WHERE id = t_inv.id;
       t_alloc := t_alloc - (t_inv.qty + t_inv.allocated);
       t_cogs := t_cogs - (t_inv.qty + t_inv.allocated) * t_inv.sellprice;
   END IF;
END LOOP;

RETURN ARRAY[t_alloc, t_cogs];

RAISE EXCEPTION &#39;TOO FEW TO ALLOCATE&#39;;
END;
</programlisting>
      </para>
    </section>

<!-- Function cogs__reverse_ar(in_qty integer, in_parts_id numeric) -->
    <section id="public.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric"
             xreflabel="publiccogs__reverse_ar(in_qty integer, in_parts_id numeric)">
      <title id="public.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric-title">
       cogs__reverse_ar(in_qty integer, in_parts_id numeric)
      </title>
      <titleabbrev id="public.function.cogs-reverse-ar-in-qty-integer-in-parts-id-numeric-titleabbrev">
       cogs__reverse_ar(in_qty integer, in_parts_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric[]</seg>
        </seglistitem>
       </segmentedlist>
 
       This function accepts a part id and quantity to reverse.  It then iterates 
backwards over AP related records, calculating COGS.  This does not save COGS
but rather returns it to the application to save.

Return values are an array of {allocated, cogs}.

        <programlisting>
DECLARE t_alloc numeric := 0;
        t_cogs numeric := 0;
        t_inv invoice;
        t_avail numeric;
BEGIN

FOR t_inv IN
    SELECT i.*
      FROM invoice i
      JOIN (select id, approved, transdate from ap 
            union
            select id, approved, transdate from gl) a ON a.id = i.trans_id
     WHERE allocated &gt; 0 and a.approved and parts_id = in_parts_id
  ORDER BY a.transdate DESC, a.id DESC, i.id DESC
LOOP
   t_avail := t_inv.allocated;
   IF t_alloc &lt; in_qty THEN
       RAISE EXCEPTION &#39;TOO MANY ALLOCATED&#39;;
   ELSIF t_alloc = in_qty THEN
       RETURN ARRAY[t_alloc, t_cogs];
   ELSIF (in_qty - t_alloc) * -1 &lt;=  t_inv.allocated THEN
       raise notice &#39;partial reversal&#39;;
       UPDATE invoice SET allocated = allocated + (in_qty - t_alloc)
        WHERE id = t_inv.id;
       t_cogs := t_cogs +  (in_qty - t_alloc) * t_inv.sellprice;
       return ARRAY[t_alloc + (in_qty - t_alloc), t_cogs];
   ELSE
       raise notice &#39;full reversal&#39;;
       UPDATE invoice SET allocated = 0
        WHERE id = t_inv.id;
       t_alloc := t_alloc + t_inv.allocated * -1;
       t_cogs := t_cogs + -1 * (t_inv.allocated) * t_inv.sellprice;
   END IF;
END LOOP;

RAISE EXCEPTION &#39;TOO FEW TO REVERSE&#39;;

END;
</programlisting>
      </para>
    </section>

<!-- Function company__get(in_entity_id integer) -->
    <section id="public.function.company-get-in-entity-id-integer"
             xreflabel="publiccompany__get(in_entity_id integer)">
      <title id="public.function.company-get-in-entity-id-integer-title">
       company__get(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.company-get-in-entity-id-integer-titleabbrev">
       company__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>company_entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all attributes for the company attached to the entity.
        <programlisting>
	SELECT c.entity_id, e.entity_class, c.legal_name, c.tax_id, c.sales_tax_id,
               c.license_number, c.sic_code, e.control_code, e.country_id 
          FROM company c
          JOIN entity e ON e.id = c.entity_id
         WHERE entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function company__get_all_accounts(in_entity_class integer, in_entity_id integer) -->
    <section id="public.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer"
             xreflabel="publiccompany__get_all_accounts(in_entity_class integer, in_entity_id integer)">
      <title id="public.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer-title">
       company__get_all_accounts(in_entity_class integer, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.company-get-all-accounts-in-entity-class-integer-in-entity-id-integer-titleabbrev">
       company__get_all_accounts(in_entity_class integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all entity credit accounts attached to that entity.
        <programlisting>
    
    SELECT * 
      FROM entity_credit_account 
     WHERE entity_id = $1
       AND entity_class = $2;
    
</programlisting>
      </para>
    </section>

<!-- Function company__get_by_cc(in_control_code text) -->
    <section id="public.function.company-get-by-cc-in-control-code-text"
             xreflabel="publiccompany__get_by_cc(in_control_code text)">
      <title id="public.function.company-get-by-cc-in-control-code-text-title">
       company__get_by_cc(in_control_code text)
      </title>
      <titleabbrev id="public.function.company-get-by-cc-in-control-code-text-titleabbrev">
       company__get_by_cc(in_control_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>company_entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity/company row attached to the control code. 
        <programlisting>
        SELECT c.entity_id, e.entity_class, c.legal_name, c.tax_id, c.sales_tax_id,
               c.license_number, c.sic_code, e.control_code, e.country_id
          FROM company c
          JOIN entity e ON e.id = c.entity_id
         WHERE e.control_code = $1;
</programlisting>
      </para>
    </section>

<!-- Function company__next_id() -->
    <section id="public.function.company-next-id"
             xreflabel="publiccompany__next_id()">
      <title id="public.function.company-next-id-title">
       company__next_id()
      </title>
      <titleabbrev id="public.function.company-next-id-titleabbrev">
       company__next_id()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>bigint</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    select nextval(&#39;company_id_seq&#39;);
    
</programlisting>
      </para>
    </section>

<!-- Function company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text) -->
    <section id="public.function.company-save-in-license-number-integer-in-sales-tax-id-text-in-country-id-integer-in-sic-code-text-in-entity-id-text-in-tax-id-integer-in-legal-name-text-in-entity-class-integer-in-control-code-text-in-id-text"
             xreflabel="publiccompany__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text)">
      <title id="public.function.company-save-in-license-number-integer-in-sales-tax-id-text-in-country-id-integer-in-sic-code-text-in-entity-id-text-in-tax-id-integer-in-legal-name-text-in-entity-class-integer-in-control-code-text-in-id-text-title">
       company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text)
      </title>
      <titleabbrev id="public.function.company-save-in-license-number-integer-in-sales-tax-id-text-in-country-id-integer-in-sic-code-text-in-entity-id-text-in-tax-id-integer-in-legal-name-text-in-entity-class-integer-in-control-code-text-in-id-text-titleabbrev">
       company__save(in_license_number integer, in_sales_tax_id text, in_country_id integer, in_sic_code text, in_entity_id text, in_tax_id integer, in_legal_name text, in_entity_class integer, in_control_code text, in_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>company</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a company.  Returns the id number of the record stored.
        <programlisting>
DECLARE t_entity_id INT;
	t_company_id INT;
	t_control_code TEXT;
        t_retval COMPANY;
BEGIN
	t_company_id := in_id;

	IF in_control_code IS NULL THEN
		t_control_code := setting_increment(&#39;company_control&#39;);
	ELSE
		t_control_code := in_control_code;
	END IF;

	UPDATE entity 
	SET name = in_legal_name, 
		entity_class = in_entity_class,
		control_code = in_control_code
	WHERE id = in_entity_id;

	IF FOUND THEN
		t_entity_id = in_entity_id;
	ELSE
		INSERT INTO entity (name, entity_class, control_code,country_id)
		VALUES (in_legal_name, in_entity_class, t_control_code,in_country_id);
		t_entity_id := currval(&#39;entity_id_seq&#39;);
	END IF;

	UPDATE company
	SET legal_name = in_legal_name,
		tax_id = in_tax_id,
		sic_code = in_sic_code,
                sales_tax_id = in_sales_tax_id,
                license_number = in_license_number
	WHERE id = t_company_id;


	IF NOT FOUND THEN
		INSERT INTO company(entity_id, legal_name, tax_id, sic_code,
                                    sales_tax_id, license_number)
		VALUES (t_entity_id, in_legal_name, in_tax_id, in_sic_code, 
                        in_sales_tax_id, in_license_number);

	END IF;
        SELECT * INTO t_retval FROM company WHERE entity_id = t_entity_id;
        RETURN t_retval;	
END;
</programlisting>
      </para>
    </section>

<!-- Function company_get_billing_info(in_id integer) -->
    <section id="public.function.company-get-billing-info-in-id-integer"
             xreflabel="publiccompany_get_billing_info(in_id integer)">
      <title id="public.function.company-get-billing-info-in-id-integer-title">
       company_get_billing_info(in_id integer)
      </title>
      <titleabbrev id="public.function.company-get-billing-info-in-id-integer-titleabbrev">
       company_get_billing_info(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>company_billing_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns billing information (billing name and address) for a given credit 
account.
        <programlisting>
DECLARE out_var company_billing_info;
	t_id INT;
BEGIN
	select coalesce(eca.pay_to_name, c.legal_name), eca.meta_number, 
		e.control_code, c.tax_id, a.line_one, a.line_two, a.line_three, 
		a.city, a.state, a.mail_code, cc.name
	into out_var
	FROM (select legal_name, tax_id, entity_id 
                FROM company
               UNION ALL
              SELECT last_name || &#39;, &#39; || first_name, null, entity_id 
                FROM person) c
	JOIN entity e ON (c.entity_id = e.id)
	JOIN entity_credit_account eca ON (eca.entity_id = e.id)
	LEFT JOIN eca_to_location cl ON (eca.id = cl.credit_id)
	LEFT JOIN location a ON (a.id = cl.location_id)
	LEFT JOIN country cc ON (cc.id = a.country_id)
	WHERE eca.id = in_id AND (location_class = 1 or location_class is null);

	RETURN out_var;
END;
</programlisting>
      </para>
    </section>

<!-- Function compound_array(anyarray) -->
    <section id="public.function.compound-array-anyarray"
             xreflabel="publiccompound_array(anyarray)">
      <title id="public.function.compound-array-anyarray-title">
       compound_array(anyarray)
      </title>
      <titleabbrev id="public.function.compound-array-anyarray-titleabbrev">
       compound_array(anyarray)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>anyarray</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an n dimensional array.

Example: SELECT as_array(ARRAY[id::text, class]) from contact_class

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function concat_colon(text) -->
    <section id="public.function.concat-colon-text"
             xreflabel="publicconcat_colon(text)">
      <title id="public.function.concat-colon-text-title">
       concat_colon(text)
      </title>
      <titleabbrev id="public.function.concat-colon-text-titleabbrev">
       concat_colon(text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a sumple aggregate to return values from the database in a 
colon-separated list.  Other programs probably should not rely on this since 
it is primarily included for the chart view.
        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function concat_colon(text, text) -->
    <section id="public.function.concat-colon-text-text"
             xreflabel="publicconcat_colon(text, text)">
      <title id="public.function.concat-colon-text-text-title">
       concat_colon(text, text)
      </title>
      <titleabbrev id="public.function.concat-colon-text-text-titleabbrev">
       concat_colon(text, text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes two arguments and creates a list out  of them.  It&apos;s useful 
as an aggregate base (see aggregate concat_colon).  However this is a temporary
function only and should not be relied upon.
        <programlisting>
select CASE WHEN $1 IS NULL THEN $2 ELSE $1 || &#39;:&#39; || $2 END;
</programlisting>
      </para>
    </section>

<!-- Function contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text) -->
    <section id="public.function.contact-search-in-notes-integer-in-control-code-text-in-name-part-textARRAY-in-business-id-text-in-active-date-to-text-in-active-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-date-in-address-date-in-meta-number-integer-in-contact-info-text-in-contact-text-in-entity-class-text"
             xreflabel="publiccontact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text)">
      <title id="public.function.contact-search-in-notes-integer-in-control-code-text-in-name-part-textARRAY-in-business-id-text-in-active-date-to-text-in-active-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-date-in-address-date-in-meta-number-integer-in-contact-info-text-in-contact-text-in-entity-class-text-title">
       contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text)
      </title>
      <titleabbrev id="public.function.contact-search-in-notes-integer-in-control-code-text-in-name-part-textARRAY-in-business-id-text-in-active-date-to-text-in-active-date-from-text-in-country-text-in-mail-code-text-in-state-text-in-city-date-in-address-date-in-meta-number-integer-in-contact-info-text-in-contact-text-in-entity-class-text-titleabbrev">
       contact__search(in_notes integer, in_control_code text, in_name_part text[], in_business_id text, in_active_date_to text, in_active_date_from text, in_country text, in_mail_code text, in_state text, in_city date, in_address date, in_meta_number integer, in_contact_info text, in_contact text, in_entity_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	out_row contact_search_result;
	loop_count int;
	t_contact_info text[];
BEGIN
	t_contact_info = in_contact_info;


	FOR out_row IN
		SELECT e.id, e.control_code, ec.id, ec.meta_number, 
			ec.description, ec.entity_class, 
			c.legal_name, c.sic_code, b.description , ec.curr::text
		FROM (select * from entity 
                       where control_code like in_control_code || &#39;%&#39;
                      union
                      select * from entity where in_control_code is null) e
		JOIN (SELECT legal_name, sic_code, entity_id 
                        FROM company 
                       WHERE legal_name @@ plainto_tsquery(in_name_part)
                      UNION ALL
                      SELECT legal_name, sic_code, entity_id
                        FROM company
                       WHERE in_name_part IS NULL
                      UNION ALL
                     SELECT coalesce(first_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(middle_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(last_name, &#39;&#39;), null, entity_id
                       FROM person
                      WHERE coalesce(first_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(middle_name, &#39;&#39;) || &#39; &#39;
                            || coalesce(last_name, &#39;&#39;) 
                             @@ plainto_tsquery(in_name_part)
                      UNION ALL
                     SELECT coalesce(first_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(middle_name, &#39;&#39;) || &#39; &#39; 
                            || coalesce(last_name, &#39;&#39;), null, entity_id
                       FROM person
                       WHERE in_name_part IS NULL) c ON (e.id = c.entity_id)
		LEFT JOIN entity_credit_account ec ON (ec.entity_id = e.id)
		LEFT JOIN business b ON (ec.business_id = b.id)
		WHERE coalesce(ec.entity_class,e.entity_class) = in_entity_class
			AND (c.entity_id IN (select entity_id 
                                               FROM entity_to_contact
                                              WHERE contact ILIKE 
                                                            ANY(t_contact_info))
				                    OR &#39;&#39; ILIKE 
                                                          ALL(t_contact_info)
                                                    OR t_contact_info IS NULL)
			
			AND ((in_address IS NULL AND in_city IS NULL 
					AND in_state IS NULL 
					AND in_country IS NULL)
				OR (c.entity_id IN 
				(select entity_id FROM entity_to_location
				WHERE location_id IN 
					(SELECT id FROM location
					WHERE (line_one @@ plainto_tsquery(
                                                              in_address)
                                               OR
					       line_two @@ plainto_tsquery(
                                                              in_address)
                                               OR
					       line_three @@ plainto_tsquery(
                                                              in_address))
						AND city ILIKE 
							&#39;%&#39; || 
							coalesce(in_city, &#39;&#39;) 
							|| &#39;%&#39;
						AND state ILIKE
							&#39;%&#39; || 
							coalesce(in_state, &#39;&#39;) 
							|| &#39;%&#39;
						AND mail_code ILIKE
							&#39;%&#39; || 
							coalesce(in_mail_code,
								&#39;&#39;)
							|| &#39;%&#39;
						AND country_id IN 
							(SELECT id FROM country
							WHERE name ilike
                                                              in_country
								OR short_name
								ilike 
								in_country)))))
			AND (ec.business_id = 
				coalesce(in_business_id, ec.business_id)
				OR (ec.business_id IS NULL 
					AND in_business_id IS NULL))
			AND (ec.startdate &lt;= coalesce(in_active_date_to, 
						ec.startdate)
				OR (ec.startdate IS NULL))
			AND (ec.enddate &gt;= coalesce(in_active_date_from, ec.enddate)
				OR (ec.enddate IS NULL))
	 		AND (ec.meta_number like in_meta_number || &#39;%&#39;
			     OR in_meta_number IS NULL)
                        AND (in_notes IS NULL OR e.id in (
                                     SELECT entity_id from entity_note
                                      WHERE note @@ plainto_tsquery(in_notes))
                                  OR ec.id IN (select ref_key FROM eca_note
                                     WHERE note @@ plainto_tsquery(in_notes)))
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function contact_class__list() -->
    <section id="public.function.contact-class-list"
             xreflabel="publiccontact_class__list()">
      <title id="public.function.contact-class-list-title">
       contact_class__list()
      </title>
      <titleabbrev id="public.function.contact-class-list-titleabbrev">
       contact_class__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contact classes ordered by ID.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM contact_class ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function cr_coa_to_account_save(in_description text, in_accno text) -->
    <section id="public.function.cr-coa-to-account-save-in-description-text-in-accno-text"
             xreflabel="publiccr_coa_to_account_save(in_description text, in_accno text)">
      <title id="public.function.cr-coa-to-account-save-in-description-text-in-accno-text-title">
       cr_coa_to_account_save(in_description text, in_accno text)
      </title>
      <titleabbrev id="public.function.cr-coa-to-account-save-in-description-text-in-accno-text-titleabbrev">
       cr_coa_to_account_save(in_description text, in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
        Provides default rules for setting reconciliation labels.  Currently 
saves a label of accno ||&apos;--&apos; || description.
        <programlisting>
    DECLARE
       v_chart_id int;
    BEGIN
        -- Check for existence of the account already
        PERFORM * FROM cr_coa_to_account WHERE account = in_accno;

        IF NOT FOUND THEN
           -- This is a new account. Insert the relevant data.
           SELECT id INTO v_chart_id FROM chart WHERE accno = in_accno;
           INSERT INTO cr_coa_to_account (chart_id, account) VALUES (v_chart_id, in_accno||&#39;--&#39;||in_description);
        END IF;
        -- Already found, no need to do anything. =) 
    END;
</programlisting>
      </para>
    </section>

<!-- Function cr_report_block_changing_approved() -->
    <section id="public.function.cr-report-block-changing-approved"
             xreflabel="publiccr_report_block_changing_approved()">
      <title id="public.function.cr-report-block-changing-approved-title">
       cr_report_block_changing_approved()
      </title>
      <titleabbrev id="public.function.cr-report-block-changing-approved-titleabbrev">
       cr_report_block_changing_approved()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a simple filter that prevents updating or deleting reconciliation
reports that have already been approved.  To purge old reconciliations you must
disable the block_change_when_approved trigger on cr_report.
        <programlisting>
BEGIN
   IF OLD.approved IS TRUE THEN
       RAISE EXCEPTION &#39;Report is approved.  Cannot change!&#39;;
   END IF;
   IF TG_OP = &#39;DELETE&#39; THEN
       RETURN OLD;
   ELSE
      RETURN NEW;
   END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer) -->
    <section id="public.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer"
             xreflabel="publiccurrency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)">
      <title id="public.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer-title">
       currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)
      </title>
      <titleabbrev id="public.function.currency-get-exchangerate-in-account-class-bpchar-in-date-date-in-currency-integer-titleabbrev">
       currency_get_exchangerate(in_account_class bpchar, in_date date, in_currency integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return the exchange rate of a given currency, date and exchange rate class (buy or sell). 
        <programlisting>
DECLARE 
    out_exrate exchangerate.buy%TYPE;
    default_currency char(3);
    
    BEGIN 
        SELECT * INTO default_currency  FROM defaults_get_defaultcurrency();
        IF default_currency = in_currency THEN
           RETURN 1;
        END IF; 
        IF in_account_class = 2 THEN
          SELECT buy INTO out_exrate 
          FROM exchangerate
          WHERE transdate = in_date AND curr = in_currency;
        ELSE 
          SELECT sell INTO out_exrate 
          FROM exchangerate
          WHERE transdate = in_date AND curr = in_currency;   
        END IF;
        RETURN out_exrate;
    END;
</programlisting>
      </para>
    </section>

<!-- Function customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer) -->
    <section id="public.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer"
             xreflabel="publiccustomer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)">
      <title id="public.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer-title">
       customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.customer-location-save-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-entity-id-integer-titleabbrev">
       customer_location_save(in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    BEGIN
    return _entity_location_save(
        in_entity_id, NULL,
        in_location_class, in_line_one, in_line_two, in_line_three,
        in_city, in_state, in_mail_code, in_country_id);
    END;

</programlisting>
      </para>
    </section>

<!-- Function date1() -->
    <section id="public.function.date1"
             xreflabel="publicdate1()">
      <title id="public.function.date1-title">
       date1()
      </title>
      <titleabbrev id="public.function.date1-titleabbrev">
       date1()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT (extract(&#39;YEAR&#39; from now())|| &#39;-12-01&#39;)::date;
</programlisting>
      </para>
    </section>

<!-- Function date2() -->
    <section id="public.function.date2"
             xreflabel="publicdate2()">
      <title id="public.function.date2-title">
       date2()
      </title>
      <titleabbrev id="public.function.date2-titleabbrev">
       date2()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT ((extract(&#39;YEAR&#39; from now())|| &#39;-12-01&#39;)::date
        + &#39;1 year&#39;::interval)::date;
</programlisting>
      </para>
    </section>

<!-- Function date_get_all_years() -->
    <section id="public.function.date-get-all-years"
             xreflabel="publicdate_get_all_years()">
      <title id="public.function.date-get-all-years-title">
       date_get_all_years()
      </title>
      <titleabbrev id="public.function.date-get-all-years-titleabbrev">
       date_get_all_years()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return each year inside transdate in transactions. 
Currently it uses a sparse index scan because the number of rows returned is 
very small and the table can be very large.
        <programlisting>
DECLARE next_record int;
BEGIN

SELECT MIN(EXTRACT (&#39;YEAR&#39; FROM transdate))::INT
INTO next_record
FROM acc_trans;

LOOP

  EXIT WHEN next_record IS NULL;
  RETURN NEXT next_record;
  SELECT MIN(EXTRACT (&#39;YEAR&#39; FROM transdate))::INT AS YEAR
  INTO next_record
  FROM acc_trans
  WHERE EXTRACT (&#39;YEAR&#39; FROM transdate) &gt; next_record;


END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function days_in_month(in_date date) -->
    <section id="public.function.days-in-month-in-date-date"
             xreflabel="publicdays_in_month(in_date date)">
      <title id="public.function.days-in-month-in-date-date-title">
       days_in_month(in_date date)
      </title>
      <titleabbrev id="public.function.days-in-month-in-date-date-titleabbrev">
       days_in_month(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of days in the month that includes in_date.
        <programlisting>
SELECT (extract(DOM FROM date_trunc(&#39;month&#39;, $1)
                         + &#39;1 month - 1 second&#39;::interval)
      )::int;

</programlisting>
      </para>
    </section>

<!-- Function deduction__list_for_entity(in_entity_id integer) -->
    <section id="public.function.deduction-list-for-entity-in-entity-id-integer"
             xreflabel="publicdeduction__list_for_entity(in_entity_id integer)">
      <title id="public.function.deduction-list-for-entity-in-entity-id-integer-title">
       deduction__list_for_entity(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.deduction-list-for-entity-in-entity-id-integer-titleabbrev">
       deduction__list_for_entity(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_deduction</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM payroll_deduction WHERE entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function deduction__list_types(in_country_id integer) -->
    <section id="public.function.deduction-list-types-in-country-id-integer"
             xreflabel="publicdeduction__list_types(in_country_id integer)">
      <title id="public.function.deduction-list-types-in-country-id-integer-title">
       deduction__list_types(in_country_id integer)
      </title>
      <titleabbrev id="public.function.deduction-list-types-in-country-id-integer-titleabbrev">
       deduction__list_types(in_country_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_deduction_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
SELECT * FROM payroll_deduction_type where country_id = $1
</programlisting>
      </para>
    </section>

<!-- Function deduction__save(in_type_id numeric, in_entity_id integer, in_rate integer) -->
    <section id="public.function.deduction-save-in-type-id-numeric-in-entity-id-integer-in-rate-integer"
             xreflabel="publicdeduction__save(in_type_id numeric, in_entity_id integer, in_rate integer)">
      <title id="public.function.deduction-save-in-type-id-numeric-in-entity-id-integer-in-rate-integer-title">
       deduction__save(in_type_id numeric, in_entity_id integer, in_rate integer)
      </title>
      <titleabbrev id="public.function.deduction-save-in-type-id-numeric-in-entity-id-integer-in-rate-integer-titleabbrev">
       deduction__save(in_type_id numeric, in_entity_id integer, in_rate integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payroll_deduction</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
BEGIN

UPDATE payroll_deduction
   SET rate = in_rate
 WHERE entity_id = in_entity_id and in_type_id;


IF NOT FOUND THEN
    INSERT INTO payroll_deduction (entity_id, type_id, rate)
    VALUES (in_entity_id, in_type_id, in_rate);
END IF;
  
RETURN QUERY SELECT * FROM payroll_deduction
             WHERE entity_id = in_entity_id and in_type_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function defaults_get_defaultcurrency() -->
    <section id="public.function.defaults-get-defaultcurrency"
             xreflabel="publicdefaults_get_defaultcurrency()">
      <title id="public.function.defaults-get-defaultcurrency-title">
       defaults_get_defaultcurrency()
      </title>
      <titleabbrev id="public.function.defaults-get-defaultcurrency-titleabbrev">
       defaults_get_defaultcurrency()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF bpchar</seg>
        </seglistitem>
       </segmentedlist>
 
        This function return the default currency asigned by the program. 
        <programlisting>
DECLARE defaultcurrency defaults.value%TYPE;
      BEGIN   
           SELECT INTO defaultcurrency substr(value,1,3)
           FROM defaults
           WHERE setting_key = &#39;curr&#39;;
           RETURN NEXT defaultcurrency;
      END;
</programlisting>
      </para>
    </section>

<!-- Function del_recurring() -->
    <section id="public.function.del-recurring"
             xreflabel="publicdel_recurring()">
      <title id="public.function.del-recurring-title">
       del_recurring()
      </title>
      <titleabbrev id="public.function.del-recurring-titleabbrev">
       del_recurring()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  DELETE FROM recurring WHERE id = old.id;
  DELETE FROM recurringemail WHERE id = old.id;
  DELETE FROM recurringprint WHERE id = old.id;
  RETURN NULL;
END;
</programlisting>
      </para>
    </section>

<!-- Function del_yearend() -->
    <section id="public.function.del-yearend"
             xreflabel="publicdel_yearend()">
      <title id="public.function.del-yearend-title">
       del_yearend()
      </title>
      <titleabbrev id="public.function.del-yearend-titleabbrev">
       del_yearend()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
begin
  delete from yearend where trans_id = old.id;
  return NULL;
end;
</programlisting>
      </para>
    </section>

<!-- Function draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric) -->
    <section id="public.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric"
             xreflabel="publicdraft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)">
      <title id="public.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric-title">
       draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)
      </title>
      <titleabbrev id="public.function.draft-search-in-amount-ge-text-in-amount-le-text-in-to-date-date-in-from-date-date-in-with-accno-numeric-in-type-numeric-titleabbrev">
       draft__search(in_amount_ge text, in_amount_le text, in_to_date date, in_from_date date, in_with_accno numeric, in_type numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF draft_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for drafts.  in_type may be any of &apos;ar&apos;, &apos;ap&apos;, or &apos;gl&apos;.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT trans.id, trans.transdate, trans.invoice, 
                       trans.reference, trans.description, 
			sum(case when lower(in_type) = &#39;ap&#39; AND chart.link = &#39;AP&#39;
				 THEN line.amount
				 WHEN lower(in_type) = &#39;ar&#39; AND chart.link = &#39;AR&#39;
				 THEN line.amount * -1
				 WHEN lower(in_type) = &#39;gl&#39; AND line.amount &gt; 0
				 THEN line.amount
			 	 ELSE 0
			    END) as amount
		FROM (
			SELECT id, transdate, reference, 
				description, false as invoice,
                                approved from gl
			WHERE lower(in_type) = &#39;gl&#39;
			UNION
			SELECT id, transdate, invnumber as reference, 
				(SELECT name FROM eca__get_entity(entity_credit_account)),
				invoice, approved from ap
			WHERE lower(in_type) = &#39;ap&#39;
			UNION
			SELECT id, transdate, invnumber as reference,
				description, 
				invoice, approved from ar
			WHERE lower(in_type) = &#39;ar&#39;
			) trans
		JOIN acc_trans line ON (trans.id = line.trans_id)
		JOIN chart ON (line.chart_id = chart.id and charttype = &#39;A&#39;)
           LEFT JOIN voucher v ON (v.trans_id = trans.id)
		WHERE (in_from_date IS NULL or trans.transdate &gt;= in_from_date)
			AND (in_to_date IS NULL 
				or trans.transdate &lt;= in_to_date)
			AND trans.approved IS FALSE
			AND v.id IS NULL
		GROUP BY trans.id, trans.transdate, trans.description, 
                         trans.reference, trans.invoice
		HAVING (in_with_accno IS NULL or in_with_accno = 
			ANY(as_array(chart.accno)))
		ORDER BY trans.reference
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function draft_approve(in_id integer) -->
    <section id="public.function.draft-approve-in-id-integer"
             xreflabel="publicdraft_approve(in_id integer)">
      <title id="public.function.draft-approve-in-id-integer-title">
       draft_approve(in_id integer)
      </title>
      <titleabbrev id="public.function.draft-approve-in-id-integer-titleabbrev">
       draft_approve(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the draft from the book.  Only will delete unapproved transactions.
Otherwise an exception is raised and the transaction terminated.
        <programlisting>
declare 
	t_table text;
begin
	SELECT table_name into t_table FROM transactions where id = in_id;

        IF (t_table = &#39;ar&#39;) THEN
                PERFORM cogs__add_for_ar_line(id) FROM invoice 
                  WHERE trans_id = in_id;
		UPDATE ar set approved = true where id = in_id;
	ELSIF (t_table = &#39;ap&#39;) THEN
                PERFORM cogs__add_for_ap_line(id) FROM invoice 
                  WHERE trans_id = in_id;
		UPDATE ap set approved = true where id = in_id;
	ELSIF (t_table = &#39;gl&#39;) THEN
		UPDATE gl set approved = true where id = in_id;
	ELSE
		raise exception &#39;Invalid table % in draft_approve for transaction %&#39;, t_table, in_id;
	END IF;

	IF NOT FOUND THEN
		RETURN FALSE;
	END IF;

	UPDATE transactions 
	SET approved_by = 
			(select entity_id FROM users 
			WHERE username = SESSION_USER), 
		approved_at = now() 
	WHERE id = in_id;

	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function draft_delete(in_id integer) -->
    <section id="public.function.draft-delete-in-id-integer"
             xreflabel="publicdraft_delete(in_id integer)">
      <title id="public.function.draft-delete-in-id-integer-title">
       draft_delete(in_id integer)
      </title>
      <titleabbrev id="public.function.draft-delete-in-id-integer-titleabbrev">
       draft_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
declare 
	t_table text;
begin
	DELETE FROM ac_tax_form 
	WHERE entry_id IN 
		(SELECT entry_id FROM acc_trans WHERE trans_id = in_id);

        DELETE FROM acc_trans WHERE trans_id = in_id;
	SELECT lower(table_name) into t_table FROM transactions where id = in_id;

        IF t_table = &#39;ar&#39; THEN
		DELETE FROM ar WHERE id = in_id AND approved IS FALSE;
	ELSIF t_table = &#39;ap&#39; THEN
		DELETE FROM ap WHERE id = in_id AND approved IS FALSE;
	ELSIF t_table = &#39;gl&#39; THEN
		DELETE FROM gl WHERE id = in_id AND approved IS FALSE;
	ELSE
		raise exception &#39;Invalid table % in draft_delete for transaction %&#39;, t_table, in_id;
	END IF;
	IF NOT FOUND THEN
		RAISE EXCEPTION &#39;Invalid transaction id %&#39;, in_id;
	END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function drop_custom_field(character varying, character varying) -->
    <section id="public.function.drop-custom-field-character-varying-character-varying"
             xreflabel="publicdrop_custom_field(character varying, character varying)">
      <title id="public.function.drop-custom-field-character-varying-character-varying-title">
       drop_custom_field(character varying, character varying)
      </title>
      <titleabbrev id="public.function.drop-custom-field-character-varying-character-varying-titleabbrev">
       drop_custom_field(character varying, character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
table_name ALIAS FOR $1;
custom_field_name ALIAS FOR $2;
BEGIN
	DELETE FROM custom_field_catalog 
	WHERE field_name = custom_field_name AND 
		table_id = (SELECT table_id FROM custom_table_catalog 
			WHERE extends = table_name);
	EXECUTE &#39;ALTER TABLE &#39; || quote_ident(&#39;custom_&#39; || table_name) || 
		&#39; DROP COLUMN &#39; || quote_ident(custom_field_name);
	RETURN TRUE;	
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text) -->
    <section id="public.function.eca-delete-contact-in-contact-integer-in-class-id-integer-in-credit-id-text"
             xreflabel="publiceca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text)">
      <title id="public.function.eca-delete-contact-in-contact-integer-in-class-id-integer-in-credit-id-text-title">
       eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text)
      </title>
      <titleabbrev id="public.function.eca-delete-contact-in-contact-integer-in-class-id-integer-in-credit-id-text-titleabbrev">
       eca__delete_contact(in_contact integer, in_class_id integer, in_credit_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if at least one record was deleted.  False if no records were
affected.
        <programlisting>
BEGIN

DELETE FROM eca_to_contact
 WHERE credit_id = in_credit_id and contact_class_id = in_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer) -->
    <section id="public.function.eca-delete-location-in-location-class-integer-in-id-integer-in-credit-id-integer"
             xreflabel="publiceca__delete_location(in_location_class integer, in_id integer, in_credit_id integer)">
      <title id="public.function.eca-delete-location-in-location-class-integer-in-id-integer-in-credit-id-integer-title">
       eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-delete-location-in-location-class-integer-in-id-integer-in-credit-id-integer-titleabbrev">
       eca__delete_location(in_location_class integer, in_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the record identified.  Returns true if successful, false if no record
found.
        <programlisting>
BEGIN

DELETE FROM eca_to_location
 WHERE credit_id = in_credit_id AND location_id = in_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function eca__delete_pricematrix(in_entry_id integer, in_credit_id integer) -->
    <section id="public.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer"
             xreflabel="publiceca__delete_pricematrix(in_entry_id integer, in_credit_id integer)">
      <title id="public.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer-title">
       eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-delete-pricematrix-in-entry-id-integer-in-credit-id-integer-titleabbrev">
       eca__delete_pricematrix(in_entry_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval bool;

BEGIN

retval := false;

DELETE FROM partsvendor 
 WHERE entry_id = in_entry_id 
       AND credit_id = in_credit_id;

retval := FOUND;

DELETE FROM partscustomer
 WHERE entry_id = in_entry_id
       AND credit_id = in_credit_id;

RETURN FOUND or retval;

END;
</programlisting>
      </para>
    </section>

<!-- Function eca__get_by_meta_number(in_entity_class text, in_meta_number integer) -->
    <section id="public.function.eca-get-by-meta-number-in-entity-class-text-in-meta-number-integer"
             xreflabel="publiceca__get_by_meta_number(in_entity_class text, in_meta_number integer)">
      <title id="public.function.eca-get-by-meta-number-in-entity-class-text-in-meta-number-integer-title">
       eca__get_by_meta_number(in_entity_class text, in_meta_number integer)
      </title>
      <titleabbrev id="public.function.eca-get-by-meta-number-in-entity-class-text-in-meta-number-integer-titleabbrev">
       eca__get_by_meta_number(in_entity_class text, in_meta_number integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM entity_credit_account
 WHERE entity_class = $2 AND meta_number = $1;
</programlisting>
      </para>
    </section>

<!-- Function eca__get_entity(in_credit_id integer) -->
    <section id="public.function.eca-get-entity-in-credit-id-integer"
             xreflabel="publiceca__get_entity(in_credit_id integer)">
      <title id="public.function.eca-get-entity-in-credit-id-integer-title">
       eca__get_entity(in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-get-entity-in-credit-id-integer-titleabbrev">
       eca__get_entity(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity to which the entity credit account is
attached.
        <programlisting>

declare
    v_row entity;
BEGIN
    SELECT entity.* INTO v_row FROM entity_credit_account JOIN entity ON entity_credit_account.entity_id = entity.id WHERE entity_credit_account.id = in_credit_id;
    IF NOT FOUND THEN
        raise exception &#39;Could not find entity with ID %&#39;, in_credit_id;
    ELSE
        return next v_row;
    END IF;
END;

</programlisting>
      </para>
    </section>

<!-- Function eca__get_pricematrix(in_credit_id integer) -->
    <section id="public.function.eca-get-pricematrix-in-credit-id-integer"
             xreflabel="publiceca__get_pricematrix(in_credit_id integer)">
      <title id="public.function.eca-get-pricematrix-in-credit-id-integer-title">
       eca__get_pricematrix(in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-get-pricematrix-in-credit-id-integer-titleabbrev">
       eca__get_pricematrix(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
        This returns the pricematrix for the customer or vendor 
(entity_credit_account identified by in_id), orderd by partnumber, validfrom

        <programlisting>

SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, pc.pricebreak,
       pc.sellprice, NULL, NULL::int, NULL, pc.validfrom, pc.validto, pc.curr,
       pc.entry_id
  FROM partscustomer pc
  JOIN parts p on pc.parts_id = p.id
  JOIN entity_credit_account eca ON pc.credit_id = eca.id
 WHERE pc.credit_id = $1 AND eca.entity_class = 2
 UNION
SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
       pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
       pv.entry_id
  FROM partsvendor pv
  JOIN parts p on pv.parts_id = p.id
  JOIN entity_credit_account eca ON pv.credit_id = eca.id
 WHERE pv.credit_id = $1 and eca.entity_class = 1
 ORDER BY partnumber, validfrom

</programlisting>
      </para>
    </section>

<!-- Function eca__get_pricematrix_by_pricegroup(in_credit_id integer) -->
    <section id="public.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer"
             xreflabel="publiceca__get_pricematrix_by_pricegroup(in_credit_id integer)">
      <title id="public.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer-title">
       eca__get_pricematrix_by_pricegroup(in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-get-pricematrix-by-pricegroup-in-credit-id-integer-titleabbrev">
       eca__get_pricematrix_by_pricegroup(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, pc.pricebreak,
       pc.sellprice, NULL::numeric, NULL::int, NULL::text, pc.validfrom, 
       pc.validto, pc.curr, pc.entry_id
  FROM partscustomer pc
  JOIN parts p on pc.parts_id = p.id
  JOIN entity_credit_account eca ON pc.pricegroup_id = eca.pricegroup_id
 WHERE eca.id = $1 AND eca.entity_class = 2
</programlisting>
      </para>
    </section>

<!-- Function eca__get_taxes(in_id integer) -->
    <section id="public.function.eca-get-taxes-in-id-integer"
             xreflabel="publiceca__get_taxes(in_id integer)">
      <title id="public.function.eca-get-taxes-in-id-integer-title">
       eca__get_taxes(in_id integer)
      </title>
      <titleabbrev id="public.function.eca-get-taxes-in-id-integer-titleabbrev">
       eca__get_taxes(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_tax</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of taxable account id&apos;s.
        <programlisting>
select * from eca_tax where eca_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean) -->
    <section id="public.function.eca-history-in-inc-closed-text-in-inc-open-text-in-entity-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean"
             xreflabel="publiceca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)">
      <title id="public.function.eca-history-in-inc-closed-text-in-inc-open-text-in-entity-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-title">
       eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </title>
      <titleabbrev id="public.function.eca-history-in-inc-closed-text-in-inc-open-text-in-entity-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-titleabbrev">
       eca__history(in_inc_closed text, in_inc_open text, in_entity_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_history_result</seg>
        </seglistitem>
       </segmentedlist>
 
       This produces a history detail report, i.e. a list of all products purchased by
a customer over a specific date range.  

meta_number is an exact match, as are in_open and inc_closed.  All other fields
allow for partial matches.  NULL matches all values.
        <programlisting>
     SELECT eca.id, e.name, eca.meta_number, 
            a.id as invoice_id, a.invnumber, a.curr::text, 
            p.id AS parts_id, p.partnumber, 
            i.description, i.qty, i.unit::text, i.sellprice, i.discount, 
            i.deliverydate, null::int as project_id, null::text as projectnumber,
            i.serialnumber, 
            case when $16 = 1 then ex.buy else ex.sell end as exchange_rate,
            ee.id as salesperson_id, 
            ep.last_name || &#39;, &#39; || ep.first_name as salesperson_name
     FROM (select * from entity_credit_account 
            where meta_number = $2
           UNION 
          select * from entity_credit_account WHERE $2 is null
          ) eca  -- broken into unions for performance
     join entity e on eca.entity_id = e.id
     JOIN (select  invnumber, curr, transdate, entity_credit_account, id,
                   person_id, notes
             FROM ar 
            where $16 = 2 and $13 = &#39;i&#39;
                  and (($17 and amount = paid) or ($18 and amount &lt;&gt; paid))
            UNION 
           select invnumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
             FROM ap 
            where $16 = 1 and $13 = &#39;i&#39;
                  and (($17 and amount = paid) or ($18 and amount &lt;&gt; paid))
           union 
           select ordnumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where ($16= 1 and oe.oe_class_id = 2 and $13 = &#39;o&#39; 
                  and quotation is not true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select ordnumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where ($16= 2 and oe.oe_class_id = 1 and $13 = &#39;o&#39;
                  and quotation is not true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select quonumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where($16= 1 and oe.oe_class_id = 4 and $13 = &#39;q&#39;
                and quotation is true)
                  and (($17 and not closed) or ($18 and closed))
           union 
           select quonumber, curr, transdate, entity_credit_account, id,
                  person_id, notes
           from oe 
           where($16= 2 and oe.oe_class_id = 4 and $13 = &#39;q&#39;
                 and quotation is true)
                  and (($17 and not closed) or ($18 and closed))
          ) a ON (a.entity_credit_account = eca.id) -- broken into unions 
                                                    -- for performance
     JOIN ( select id, trans_id, parts_id, qty, description, unit, discount,
                   deliverydate, serialnumber, sellprice
             FROM  invoice where $13 = &#39;i&#39;
            union 
            select id, trans_id, parts_id, qty, description, unit, discount,
                   reqdate, serialnumber, sellprice
             FROM orderitems where $13 &lt;&gt; &#39;i&#39;
          ) i on i.trans_id = a.id
     JOIN parts p ON (p.id = i.parts_id)
LEFT JOIN exchangerate ex ON (ex.transdate = a.transdate)
LEFT JOIN entity ee ON (a.person_id = ee.id)
LEFT JOIN person ep ON (ep.entity_id = ee.id)
    -- these filters don&#39;t perform as well on large databases
    WHERE (e.name ilike &#39;%&#39; || $1 || &#39;%&#39; or $1 is null)
          and ($3 is null or eca.id in 
                 (select credit_id from eca_to_contact
                   where contact ilike &#39;%&#39; || $3 || &#39;%&#39;))
--          and (($4 is null and $5 is null and $6 is null and $7 is null)
--               or eca.id in
--                  (select credit_id from eca_to_location 
--                    where location_id in
--                          (select id from location
--                            where ($4 is null or line_one ilike &#39;%&#39; || $4 || &#39;%&#39;
--                                   or line_two ilike &#39;%&#39; || $4 || &#39;%&#39;) 
--                                  and ($5 is null or city 
--                                                     ilike &#39;%&#39; || $5 || &#39;%&#39;)
--                                  and ($6 is null or state 
--                                                    ilike &#39;%&#39; || $6 || &#39;%&#39;)
--                                  and ($7 is null or mail_code 
--                                                    ilike &#39;%&#39; || $7 || &#39;%&#39;)
--                                  and ($10 is null or country_id = $10))
--                   )
--              )
--          and (a.transdate &gt;= $11 or $11 is null)
--          and (a.transdate &lt;= $12 or $12 is null)
--          and (eca.startdate &gt;= $14 or $14 is null)
--          and (eca.startdate &lt;= $15 or $15 is null)
--          and (a.notes @@ plainto_tsquery($9) or $9 is null)
 ORDER BY eca.meta_number;
</programlisting>
      </para>
    </section>

<!-- Function eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean) -->
    <section id="public.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean"
             xreflabel="publiceca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)">
      <title id="public.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-title">
       eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </title>
      <titleabbrev id="public.function.eca-history-summary-in-inc-closed-text-in-inc-open-text-in-account-class-text-in-start-to-text-in-start-from-text-in-type-text-in-to-date-text-in-from-date-text-in-country-id-text-in-notes-integer-in-salesperson-date-in-zip-date-in-state-bpchar-in-city-date-in-address-line-date-in-contact-info-integer-in-meta-number-boolean-in-name-boolean-titleabbrev">
       eca__history_summary(in_inc_closed text, in_inc_open text, in_account_class text, in_start_to text, in_start_from text, in_type text, in_to_date text, in_from_date text, in_country_id text, in_notes integer, in_salesperson date, in_zip date, in_state bpchar, in_city date, in_address_line date, in_contact_info integer, in_meta_number boolean, in_name boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF eca_history_result</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates a summary account (no quantities, just parts group by invoice).

meta_number must match exactly or be NULL.  inc_open and inc_closed are exact
matches too.  All other values specify ranges or may match partially.
        <programlisting>
SELECT id, name, meta_number, null::int, null::text, curr, parts_id, partnumber,
       description, sum(qty), unit, null::numeric, null::numeric, null::date, 
       null::int, null::text, null::text, null::numeric,
       null::int, null::text
FROM   eca__history($1, $2, $3, $4, $5, $6, $7, $8, $9,
                   $10, $11, $12, $13, $14, $15, $16, $17, $18)
 group by id, name, meta_number, curr, parts_id, partnumber, description, unit
 order by meta_number;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_contacts(in_credit_id integer) -->
    <section id="public.function.eca-list-contacts-in-credit-id-integer"
             xreflabel="publiceca__list_contacts(in_credit_id integer)">
      <title id="public.function.eca-list-contacts-in-credit-id-integer-title">
       eca__list_contacts(in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-list-contacts-in-credit-id-integer-titleabbrev">
       eca__list_contacts(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contact info attached to the entity credit account.
        <programlisting>
DECLARE out_row contact_list;
BEGIN
	FOR out_row IN
		SELECT cl.class, cl.id, c.description, c.contact
		FROM eca_to_contact c
		JOIN contact_class cl ON (c.contact_class_id = cl.id)
		WHERE credit_id = in_credit_id
	LOOP
		return next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_locations(in_credit_id integer) -->
    <section id="public.function.eca-list-locations-in-credit-id-integer"
             xreflabel="publiceca__list_locations(in_credit_id integer)">
      <title id="public.function.eca-list-locations-in-credit-id-integer-title">
       eca__list_locations(in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-list-locations-in-credit-id-integer-titleabbrev">
       eca__list_locations(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of locations attached to the credit account.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT l.id, l.line_one, l.line_two, l.line_three, l.city, 
			l.state, l.mail_code, c.id, c.name, lc.id, lc.class
		FROM location l
		JOIN eca_to_location ctl ON (ctl.location_id = l.id)
		JOIN location_class lc ON (ctl.location_class = lc.id)
		JOIN country c ON (c.id = l.country_id)
		WHERE ctl.credit_id = in_credit_id
		ORDER BY lc.id, l.id, c.name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__list_notes(in_credit_id integer) -->
    <section id="public.function.eca-list-notes-in-credit-id-integer"
             xreflabel="publiceca__list_notes(in_credit_id integer)">
      <title id="public.function.eca-list-notes-in-credit-id-integer-title">
       eca__list_notes(in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-list-notes-in-credit-id-integer-titleabbrev">
       eca__list_notes(in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF note</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of notes attached to the entity credit account.
        <programlisting>
DECLARE out_row record;
	t_entity_id int;
BEGIN
        -- ALERT: security definer function.  Be extra careful about EXECUTE
        -- in here. --CT
	SELECT entity_id INTO t_entity_id
	FROM entity_credit_account
	WHERE id = in_credit_id;

	FOR out_row IN
		SELECT *
		FROM note
		WHERE (note_class = 3 and ref_key = in_credit_id) or
			(note_class = 1 and ref_key = t_entity_id)
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer) -->
    <section id="public.function.eca-location-save-in-old-location-class-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-credit-id-integer"
             xreflabel="publiceca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer)">
      <title id="public.function.eca-location-save-in-old-location-class-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-credit-id-integer-title">
       eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-location-save-in-old-location-class-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-credit-id-integer-titleabbrev">
       eca__location_save(in_old_location_class integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location to an entity credit account. Returns id of saved record.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
        l_orig_id INT;
    BEGIN
       
        UPDATE eca_to_location
           SET location_class = in_location_class
         WHERE credit_id = in_credit_id
           AND location_class = in_old_location_class
           AND location_id = in_id;
           
         IF FOUND THEN
            SELECT location_save(
                in_id, 
                in_line_one, 
                in_line_two, 
                in_line_three, 
                in_city,
                in_state, 
                in_mail_code, 
                in_country_id
            )
        	INTO l_id; 
        ELSE
            SELECT location_save(
                NULL, 
                in_line_one, 
                in_line_two, 
                in_line_three, 
                in_city,
                in_state, 
                in_mail_code, 
                in_country_id
            )
        	INTO l_id; 
            INSERT INTO eca_to_location 
        		(credit_id, location_class, location_id)
        	VALUES  (in_credit_id, in_location_class, l_id);
        
        END IF;

	RETURN l_id;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer) -->
    <section id="public.function.eca-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-id-integer"
             xreflabel="publiceca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer)">
      <title id="public.function.eca-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-id-integer-title">
       eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer)
      </title>
      <titleabbrev id="public.function.eca-save-in-discount-account-id-integer-in-taxform-id-integer-in-pay-to-name-integer-in-cash-account-id-text-in-ar-ap-account-id-numeric-in-threshold-boolean-in-enddate-numeric-in-startdate-integer-in-curr-integer-in-pricegroup-id-character-varying-in-language-code-integer-in-business-id-character-varying-in-meta-number-integer-in-terms-bpchar-in-discount-terms-date-in-creditlimit-date-in-taxincluded-numeric-in-discount-integer-in-description-integer-in-entity-id-text-in-entity-class-integer-in-id-integer-titleabbrev">
       eca__save(in_discount_account_id integer, in_taxform_id integer, in_pay_to_name integer, in_cash_account_id text, in_ar_ap_account_id numeric, in_threshold boolean, in_enddate numeric, in_startdate integer, in_curr integer, in_pricegroup_id character varying, in_language_code integer, in_business_id character varying, in_meta_number integer, in_terms bpchar, in_discount_terms date, in_creditlimit date, in_taxincluded numeric, in_discount integer, in_description integer, in_entity_id text, in_entity_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity credit account.  Returns the id of the record saved.  
        <programlisting>
    
    DECLARE
        t_entity_class int;
        l_id int;
	t_meta_number text; 
	t_mn_default_key text;
    BEGIN
	-- TODO:  Move to mapping table.
            IF in_entity_class = 1 THEN
	       t_mn_default_key := &#39;vendornumber&#39;;
	    ELSIF in_entity_class = 2 THEN
	       t_mn_default_key := &#39;customernumber&#39;;
	    END IF;
	    IF in_meta_number IS NULL THEN
		t_meta_number := setting_increment(t_mn_default_key);
	    ELSE
		t_meta_number := in_meta_number;
	    END IF;
            update entity_credit_account SET
                discount = in_discount,
                taxincluded = in_taxincluded,
                creditlimit = in_creditlimit,
		description = in_description,
                terms = in_terms,
                ar_ap_account_id = in_ar_ap_account_id,
                cash_account_id = in_cash_account_id,
                discount_account_id = in_discount_account_id,
                meta_number = t_meta_number,
                business_id = in_business_id,
                language_code = in_language_code,
                pricegroup_id = in_pricegroup_id,
                curr = in_curr,
                startdate = in_startdate,
                enddate = in_enddate,
                threshold = in_threshold,
		discount_terms = in_discount_terms,
		pay_to_name = in_pay_to_name,
		taxform_id = in_taxform_id
            where id = in_id;
        
         IF FOUND THEN
            RETURN in_id;
         ELSE
            INSERT INTO entity_credit_account (
                entity_id,
                entity_class,
                discount, 
                description,
                taxincluded,
                creditlimit,
                terms,
                meta_number,
                business_id,
                language_code,
                pricegroup_id,
                curr,
                startdate,
                enddate,
                discount_terms,
                threshold,
		ar_ap_account_id,
                pay_to_name,
                taxform_id,
                cash_account_id,
                discount_account_id
            )
            VALUES (
                in_entity_id,
                in_entity_class,
                in_discount, 
                in_description,
                in_taxincluded,
                in_creditlimit,
                in_terms,
                t_meta_number,
                in_business_id,
                in_language_code,
                in_pricegroup_id,
                in_curr,
                in_startdate,
                in_enddate,
                in_discount_terms,
                in_threshold,
                in_ar_ap_account_id,
                in_pay_to_name,
                in_taxform_id,
		in_cash_account_id,
                in_discount_account_id
            );
            RETURN currval(&#39;entity_credit_account_id_seq&#39;);
       END IF;

    END;
    
</programlisting>
      </para>
    </section>

<!-- Function eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer) -->
    <section id="public.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-credit-id-integer"
             xreflabel="publiceca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer)">
      <title id="public.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-credit-id-integer-title">
       eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer)
      </title>
      <titleabbrev id="public.function.eca-save-contact-in-old-contact-class-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-credit-id-integer-titleabbrev">
       eca__save_contact(in_old_contact_class integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the contact record at the entity credit account level.  Returns 1.
        <programlisting>
DECLARE out_id int;
BEGIN

    PERFORM *
       FROM eca_to_contact
      WHERE credit_id = in_credit_id
        AND contact_class_id = in_old_contact_class
        AND contact = in_old_contact;
        
    IF FOUND THEN
        UPDATE eca_to_contact
           SET contact = in_contact,
               description = in_description,
               contact_class_id = in_class_id
         WHERE credit_id = in_credit_id
           AND contact_class_id = in_old_contact_class
           AND contact = in_old_contact;
    ELSE
        INSERT INTO eca_to_contact(credit_id, contact_class_id, 
                description, contact)
        VALUES (in_credit_id, in_class_id, in_description, in_contact);
        
    END IF;

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_notes(in_subject integer, in_note text, in_credit_id text) -->
    <section id="public.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text"
             xreflabel="publiceca__save_notes(in_subject integer, in_note text, in_credit_id text)">
      <title id="public.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text-title">
       eca__save_notes(in_subject integer, in_note text, in_credit_id text)
      </title>
      <titleabbrev id="public.function.eca-save-notes-in-subject-integer-in-note-text-in-credit-id-text-titleabbrev">
       eca__save_notes(in_subject integer, in_note text, in_credit_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity credit account-level note.  Such a note is valid for only one
credit account. Returns the id of the note.  
        <programlisting>
DECLARE out_id int;
BEGIN
	-- TODO, change this to create vector too
	INSERT INTO eca_note (ref_key, note_class, note, vector, subject)
	VALUES (in_credit_id, 3, in_note, &#39;&#39;, in_subject);

	SELECT currval(&#39;note_id_seq&#39;) INTO out_id;
	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer) -->
    <section id="public.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer"
             xreflabel="publiceca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)">
      <title id="public.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-title">
       eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </title>
      <titleabbrev id="public.function.eca-save-pricematrix-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-titleabbrev">
       eca__save_pricematrix(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   retval eca__pricematrix;
   t_insert bool;

BEGIN

t_insert := false;

PERFORM * FROM entity_credit_account 
  WHERE id = in_credit_id AND entity_class = 1;

IF FOUND THEN -- VENDOR
    UPDATE partsvendor
       SET lastcost = in_price,
           leadtime = in_lead_time,
           partnumber = in_partnumber,
           curr = in_curr
     WHERE credit_id = in_credit_id AND entry_id = in_entry_id;

    IF NOT FOUND THEN
        INSERT INTO partsvendor
               (parts_id, credit_id, lastcost, leadtime, partnumber, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_leadtime::int2, 
               in_partnumber, in_curr);
    END IF;

    SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
           pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
           pv.entry_id
      INTO retval
      FROM partsvendor pv
      JOIN parts p ON p.id = pv.parts_id
     WHERE parts_id = in_parts_id and credit_id = in_credit_id;

    RETURN retval;
END IF;

PERFORM * FROM entity_credit_account
  WHERE id = in_credit_id AND entity_class = 2;

IF FOUND THEN -- CUSTOMER
    UPDATE partscustomer
       SET pricebreak = in_pricebreak,
           sellprice  = in_price,
           validfrom  = in_validfrom,
           validto    = in_validto,
           curr       = in_curr
     WHERE entry_id = in_entry_id and credit_id = in_credit_id;

    IF NOT FOUND THEN
        INSERT INTO partscustomer
               (parts_id, credit_id, sellprice, validfrom, validto, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_validfrom, in_validto, 
                in_curr);

        t_insert := true;
    END IF;

    SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, 
           pc.pricebreak, pc.sellprice, NULL, NULL, NULL, pc.validfrom, 
           pc.validto, pc.curr, pc.entry_id
      INTO retval
      FROM partscustomer pc
      JOIN parts p on pc.parts_id = p.id
     WHERE entry_id = CASE WHEN t_insert 
                           THEN currval(&#39;partscustomer_entry_id_seq&#39;) 
                           ELSE in_entry_id 
                      END;
                           
    RETURN retval;

END IF;

RAISE EXCEPTION &#39;No valid entity credit account found&#39;;
   
END;
</programlisting>
      </para>
    </section>

<!-- Function eca__set_taxes(in_tax_ids integer, in_id integer[]) -->
    <section id="public.function.eca-set-taxes-in-tax-ids-integer-in-id-integerARRAY"
             xreflabel="publiceca__set_taxes(in_tax_ids integer, in_id integer[])">
      <title id="public.function.eca-set-taxes-in-tax-ids-integer-in-id-integerARRAY-title">
       eca__set_taxes(in_tax_ids integer, in_id integer[])
      </title>
      <titleabbrev id="public.function.eca-set-taxes-in-tax-ids-integer-in-id-integerARRAY-titleabbrev">
       eca__set_taxes(in_tax_ids integer, in_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Sets the tax values for the customer or vendor.

The entity credit account must exist before calling this function, and must
have a type of either 1 or 2.

        <programlisting>
DECLARE 
    eca entity_credit_account;
    iter int;
BEGIN
     IF in_tax_ids = &#39;{}&#39; THEN
         RETURN NULL;
     END IF;
     SELECT * FROM entity_credit_account into eca WHERE id = in_id;

     DELETE FROM eca_tax WHERE eca_id = in_id;
     FOR iter in array_lower(in_tax_ids, 1) .. array_upper(in_tax_ids, 1)
     LOOP
          INSERT INTO eca_tax (eca_id, chart_id)
          values (in_id, in_tax_ids[iter]);
     END LOOP;
     RETURN TRUE;
end;
</programlisting>
      </para>
    </section>

<!-- Function eca_bu_trigger() -->
    <section id="public.function.eca-bu-trigger"
             xreflabel="publiceca_bu_trigger()">
      <title id="public.function.eca-bu-trigger-title">
       eca_bu_trigger()
      </title>
      <titleabbrev id="public.function.eca-bu-trigger-titleabbrev">
       eca_bu_trigger()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  IF TG_OP = &#39;INSERT&#39; THEN
      INSERT INTO business_unit(class_id, description, credit_id)
      VALUES (7 - NEW.entity_class, NEW.meta_number, NEW.id);
  ELSIF TG_OP = &#39;UPDATE&#39; THEN
      IF new.meta_number &lt;&gt; old.meta_number THEN
         UPDATE business_unit SET description = new.meta_number
          WHERE class_id = 7 - NEW.entity_class
                AND credit_id = new.id;
      END IF;
  ELSIF TG_OP = &#39;DELETE&#39;THEN
      DELETE FROM business_unit WHERE class_id = 7 - NEW.entity_class
                  AND credit_id = old_id;
      RETURN OLD;
  END IF;
  RETURN NEW;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__all_managers() -->
    <section id="public.function.employee-all-managers"
             xreflabel="publicemployee__all_managers()">
      <title id="public.function.employee-all-managers-title">
       employee__all_managers()
      </title>
      <titleabbrev id="public.function.employee-all-managers-titleabbrev">
       employee__all_managers()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
   SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ee.role = &#39;manager&#39;
 ORDER BY ee.employeenumber;
</programlisting>
      </para>
    </section>

<!-- Function employee__all_salespeople() -->
    <section id="public.function.employee-all-salespeople"
             xreflabel="publicemployee__all_salespeople()">
      <title id="public.function.employee-all-salespeople-title">
       employee__all_salespeople()
      </title>
      <titleabbrev id="public.function.employee-all-salespeople-titleabbrev">
       employee__all_salespeople()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
   SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ee.sales
 ORDER BY ee.employeenumber;
</programlisting>
      </para>
    </section>

<!-- Function employee__get(in_entity_id integer) -->
    <section id="public.function.employee-get-in-entity-id-integer"
             xreflabel="publicemployee__get(in_entity_id integer)">
      <title id="public.function.employee-get-in-entity-id-integer-title">
       employee__get(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.employee-get-in-entity-id-integer-titleabbrev">
       employee__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an employee_result tuple with information specified by the entity_id.

        <programlisting>
   SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id,
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
     JOIN entity e ON (p.entity_id = e.id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE p.entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function employee__get_user(in_entity_id integer) -->
    <section id="public.function.employee-get-user-in-entity-id-integer"
             xreflabel="publicemployee__get_user(in_entity_id integer)">
      <title id="public.function.employee-get-user-in-entity-id-integer-title">
       employee__get_user(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.employee-get-user-in-entity-id-integer-titleabbrev">
       employee__get_user(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF users</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns username, user_id, etc. information if the employee is a user.
        <programlisting>SELECT * FROM users WHERE entity_id = $1;</programlisting>
      </para>
    </section>

<!-- Function employee__list_managers(in_id integer) -->
    <section id="public.function.employee-list-managers-in-id-integer"
             xreflabel="publicemployee__list_managers(in_id integer)">
      <title id="public.function.employee-list-managers-in-id-integer-title">
       employee__list_managers(in_id integer)
      </title>
      <titleabbrev id="public.function.employee-list-managers-in-id-integer-titleabbrev">
       employee__list_managers(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF employees</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of managers, that is employees with the &apos;manager&apos; role set.
        <programlisting>
DECLARE
	emp employees%ROWTYPE;
BEGIN
	FOR emp IN 
		SELECT 
		    e.salutation,
		    e.first_name,
		    e.last_name,
		    ee.* 
		FROM entity_employee ee
		JOIN entity e on e.id = ee.entity_id
		WHERE ee.sales = &#39;t&#39;::bool AND ee.role=&#39;manager&#39;
			AND ee.entity_id &lt;&gt; coalesce(in_id, -1)
		ORDER BY name
	LOOP
		RETURN NEXT emp;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text) -->
    <section id="public.function.employee-save-in-employeenumber-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text"
             xreflabel="publicemployee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)">
      <title id="public.function.employee-save-in-employeenumber-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text-title">
       employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)
      </title>
      <titleabbrev id="public.function.employee-save-in-employeenumber-integer-in-manager-id-date-in-sales-date-in-ssn-date-in-role-text-in-dob-text-in-end-date-boolean-in-start-date-integer-in-entity-id-text-titleabbrev">
       employee__save(in_employeenumber integer, in_manager_id date, in_sales date, in_ssn date, in_role text, in_dob text, in_end_date boolean, in_start_date integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an employeerecord with the specified information.
        <programlisting>
DECLARE out_id INT;
BEGIN
	UPDATE entity_employee 
	SET startdate = coalesce(in_start_date, now()::date),
		enddate = in_end_date,
		dob = in_dob,
		role = in_role,
		ssn = in_ssn,
		manager_id = in_manager_id,
		employeenumber = in_employeenumber
	WHERE entity_id = in_entity_id;

	out_id = in_entity_id;

	IF NOT FOUND THEN
		INSERT INTO entity_employee 
			(startdate, enddate, dob, role, ssn, manager_id, 
				employeenumber, entity_id)
		VALUES
			(coalesce(in_start_date, now()::date), in_end_date, 
                                in_dob, in_role, in_ssn,
				in_manager_id, in_employeenumber, 
                                in_entity_id);
		RETURN in_entity_id;
	END IF;
        RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text) -->
    <section id="public.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text"
             xreflabel="publicemployee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)">
      <title id="public.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text-title">
       employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)
      </title>
      <titleabbrev id="public.function.employee-search-in-notes-text-in-last-name-date-in-middle-name-date-in-first-name-text-in-startdate-to-text-in-startdate-from-text-in-employeenumber-text-titleabbrev">
       employee__search(in_notes text, in_last_name date, in_middle_name date, in_first_name text, in_startdate_to text, in_startdate_from text, in_employeenumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF employee_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of employee_result records matching the search criteria.

employeenumber is an exact match.  
stardate_from and startdate_to specify the start dates for employee searches
All others are partial matches.

NULLs match all values.
        <programlisting>
SELECT p.entity_id, e.control_code, p.id, s.salutation, s.id, 
          p.first_name, p.middle_name, p.last_name,
          ee.startdate, ee.enddate, ee.role, ee.ssn, ee.sales, ee.manager_id,
          mp.first_name, mp.last_name, ee.employeenumber, ee.dob, e.country_id
     FROM person p
     JOIN entity e ON p.entity_id = e.id
     JOIN entity_employee ee on (ee.entity_id = p.entity_id)
LEFT JOIN salutation s on (p.salutation_id = s.id)
LEFT JOIN person mp ON ee.manager_id = p.entity_id
    WHERE ($7 is null or p.entity_id in (select ref_key from entity_note
                                          WHERE note ilike &#39;%&#39; || $7 || &#39;%&#39;))
          and ($1 is null or $1 = ee.employeenumber)
          and ($2 is null or $2 &lt;= ee.startdate)
          and ($3 is null or $3 &gt;= ee.startdate)
          and ($4 is null or p.first_name ilike &#39;%&#39; || $4 || &#39;%&#39;)
          and ($5 is null or p.middle_name ilike &#39;%&#39; || $5 || &#39;%&#39;)
          and ($6 is null or p.last_name ilike &#39;%&#39; || $6 || &#39;%&#39;);
</programlisting>
      </para>
    </section>

<!-- Function employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean) -->
    <section id="public.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean"
             xreflabel="publicemployee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)">
      <title id="public.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean-title">
       employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)
      </title>
      <titleabbrev id="public.function.employee-search-in-sales-date-in-enddatefrom-date-in-enddateto-character-varying-in-notes-text-in-name-date-in-startdateto-date-in-startdatefrom-boolean-titleabbrev">
       employee_search(in_sales date, in_enddatefrom date, in_enddateto character varying, in_notes text, in_name date, in_startdateto date, in_startdatefrom boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF employee_search</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	emp employee_search%ROWTYPE;
BEGIN
	FOR emp IN
		SELECT * FROM employee_search
		WHERE coalesce(startdate, &#39;infinity&#39;::timestamp)
			&gt;= coalesce(in_startdateto, &#39;-infinity&#39;::timestamp)
			AND coalesce(startdate, &#39;-infinity&#39;::timestamp) &lt;=
				coalesce(in_startdatefrom, 
						&#39;infinity&#39;::timestamp)
			AND coalesce(enddate, &#39;-infinity&#39;::timestamp) &lt;= 
				coalesce(in_enddateto, &#39;infinity&#39;::timestamp)
			AND coalesce(enddate, &#39;infinity&#39;::timestamp) &gt;= 
				coalesce(in_enddatefrom, &#39;-infinity&#39;::timestamp)
			AND (name % in_name
			    OR note % in_notes)
			AND (sales = &#39;t&#39; OR coalesce(in_sales, &#39;f&#39;) = &#39;f&#39;)
	LOOP
		RETURN NEXT emp;
	END LOOP;
	return;
END;
</programlisting>
      </para>
    </section>

<!-- Function employee_set_location(in_location integer, in_employee integer) -->
    <section id="public.function.employee-set-location-in-location-integer-in-employee-integer"
             xreflabel="publicemployee_set_location(in_location integer, in_employee integer)">
      <title id="public.function.employee-set-location-in-location-integer-in-employee-integer-title">
       employee_set_location(in_location integer, in_employee integer)
      </title>
      <titleabbrev id="public.function.employee-set-location-in-location-integer-in-employee-integer-titleabbrev">
       employee_set_location(in_location integer, in_employee integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

    INSERT INTO entity_to_location (entity_id,location_id) 
    SELECT entity_id, $2
      FROM person WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function entity__delete_bank_account(in_id integer, in_entity_id integer) -->
    <section id="public.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer"
             xreflabel="publicentity__delete_bank_account(in_id integer, in_entity_id integer)">
      <title id="public.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer-title">
       entity__delete_bank_account(in_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-delete-bank-account-in-id-integer-in-entity-id-integer-titleabbrev">
       entity__delete_bank_account(in_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the bank account identitied by in_id if it is attached to the entity
identified by entity_id.  Returns true if a record is deleted, false if not.
        <programlisting>
BEGIN

UPDATE entity_credit_account SET bank_account = NULL
 WHERE entity_id = in_entity_id AND bank_account = in_id;

DELETE FROM entity_bank_account
 WHERE id = in_id AND entity_id = in_entity_id;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text) -->
    <section id="public.function.entity-delete-contact-in-contact-integer-in-class-id-integer-in-entity-id-text"
             xreflabel="publicentity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text)">
      <title id="public.function.entity-delete-contact-in-contact-integer-in-class-id-integer-in-entity-id-text-title">
       entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text)
      </title>
      <titleabbrev id="public.function.entity-delete-contact-in-contact-integer-in-class-id-integer-in-entity-id-text-titleabbrev">
       entity__delete_contact(in_contact integer, in_class_id integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if at least one record was deleted.  False if no records were 
affected.
        <programlisting>
BEGIN

DELETE FROM entity_to_contact
 WHERE entity_id = in_entity_id
       and contact_class_id = in_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer) -->
    <section id="public.function.entity-delete-location-in-location-class-integer-in-id-integer-in-entity-id-integer"
             xreflabel="publicentity__delete_location(in_location_class integer, in_id integer, in_entity_id integer)">
      <title id="public.function.entity-delete-location-in-location-class-integer-in-id-integer-in-entity-id-integer-title">
       entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-delete-location-in-location-class-integer-in-id-integer-in-entity-id-integer-titleabbrev">
       entity__delete_location(in_location_class integer, in_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the record identified.  Returns true if successful, false if no record
found.
        <programlisting>
BEGIN

DELETE FROM entity_to_location
 WHERE entity_id = in_entity_id AND location_id = in_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function entity__get(in_entity_id integer) -->
    <section id="public.function.entity-get-in-entity-id-integer"
             xreflabel="publicentity__get(in_entity_id integer)">
      <title id="public.function.entity-get-in-entity-id-integer-title">
       entity__get(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-get-in-entity-id-integer-titleabbrev">
       entity__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of (only one) entity record with the entity id.
        <programlisting>

declare
    v_row entity;
BEGIN
    -- Removing the exception when not found handling.  Applications are
    -- perfectly capable of handling whether an entity was not found.  No need
    -- for a database-level exception here. Moreover such results may be useful
    -- --CT

    SELECT * INTO v_row FROM entity WHERE id = in_entity_id;
    return next v_row;
END;

</programlisting>
      </para>
    </section>

<!-- Function entity__list_bank_account(in_entity_id integer) -->
    <section id="public.function.entity-list-bank-account-in-entity-id-integer"
             xreflabel="publicentity__list_bank_account(in_entity_id integer)">
      <title id="public.function.entity-list-bank-account-in-entity-id-integer-title">
       entity__list_bank_account(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-list-bank-account-in-entity-id-integer-titleabbrev">
       entity__list_bank_account(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_bank_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all bank accounts for the entity.
        <programlisting>
DECLARE out_row entity_bank_account%ROWTYPE;
BEGIN
	FOR out_row IN
		SELECT * from entity_bank_account where entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_classes() -->
    <section id="public.function.entity-list-classes"
             xreflabel="publicentity__list_classes()">
      <title id="public.function.entity-list-classes-title">
       entity__list_classes()
      </title>
      <titleabbrev id="public.function.entity-list-classes-titleabbrev">
       entity__list_classes()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of entity classes, ordered by assigned ids
        <programlisting>
DECLARE out_row entity_class;
BEGIN
	FOR out_row IN 
		SELECT * FROM entity_class
             LEFT JOIN defaults ON setting_key = &#39;roll_prefix&#39;
		WHERE active and pg_has_role(SESSION_USER, 
                                     coalesce(defaults.value, 
                                     &#39;lsmb_&#39; || current_database() || &#39;__&#39;) ||
                                     &#39;contact_class_&#39; ||
                                     lower(regexp_replace(class, &#39; &#39;, &#39;_&#39;)), 
                                     &#39;USAGE&#39;)
		ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_contacts(in_entity_id integer) -->
    <section id="public.function.entity-list-contacts-in-entity-id-integer"
             xreflabel="publicentity__list_contacts(in_entity_id integer)">
      <title id="public.function.entity-list-contacts-in-entity-id-integer-title">
       entity__list_contacts(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-list-contacts-in-entity-id-integer-titleabbrev">
       entity__list_contacts(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all contact info for the entity.
        <programlisting>
DECLARE out_row contact_list;
BEGIN
	FOR out_row IN
		SELECT cl.class, cl.id, c.description, c.contact
		FROM entity_to_contact c
		JOIN contact_class cl ON (c.contact_class_id = cl.id)
		WHERE c.entity_id = in_entity_id
	LOOP
		return next out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_credit(in_entity_class integer, in_entity_id integer) -->
    <section id="public.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer"
             xreflabel="publicentity__list_credit(in_entity_class integer, in_entity_id integer)">
      <title id="public.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer-title">
       entity__list_credit(in_entity_class integer, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-list-credit-in-entity-class-integer-in-entity-id-integer-titleabbrev">
       entity__list_credit(in_entity_class integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_credit_retrieve</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of entity credit account entries for the entity and of the
entity class.
        <programlisting>
DECLARE out_row entity_credit_retrieve;
BEGIN
	
	FOR out_row IN 
		SELECT  ec.id, e.id, ec.entity_class, ec.discount, 
                        ec.discount_terms,
			ec.taxincluded, ec.creditlimit, ec.terms, 
			ec.meta_number, ec.description, ec.business_id, 
			ec.language_code, 
			ec.pricegroup_id, ec.curr, ec.startdate, 
			ec.enddate, ec.ar_ap_account_id, ec.cash_account_id, 
                        ec.discount_account_id,
			ec.threshold, e.control_code, ec.id, ec.pay_to_name,
                        ec.taxform_id
		FROM entity e 
		JOIN entity_credit_account ec ON (e.id = ec.entity_id)
		WHERE e.id = in_entity_id
			AND ec.entity_class = 
				CASE WHEN in_entity_class = 3 THEN 2
				     WHEN in_entity_class IS NULL 
					THEN ec.entity_class
				ELSE in_entity_class END
	LOOP

		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_locations(in_entity_id integer) -->
    <section id="public.function.entity-list-locations-in-entity-id-integer"
             xreflabel="publicentity__list_locations(in_entity_id integer)">
      <title id="public.function.entity-list-locations-in-entity-id-integer-title">
       entity__list_locations(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-list-locations-in-entity-id-integer-titleabbrev">
       entity__list_locations(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists all locations for an entity.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT l.id, l.line_one, l.line_two, l.line_three, l.city, 
			l.state, l.mail_code, c.id, c.name, lc.id, lc.class
		FROM location l
		JOIN entity_to_location ctl ON (ctl.location_id = l.id)
		JOIN location_class lc ON (ctl.location_class = lc.id)
		JOIN country c ON (c.id = l.country_id)
		WHERE ctl.entity_id = in_entity_id
		ORDER BY lc.id, l.id, c.name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__list_notes(in_entity_id integer) -->
    <section id="public.function.entity-list-notes-in-entity-id-integer"
             xreflabel="publicentity__list_notes(in_entity_id integer)">
      <title id="public.function.entity-list-notes-in-entity-id-integer-title">
       entity__list_notes(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-list-notes-in-entity-id-integer-titleabbrev">
       entity__list_notes(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of notes (including content) attached to the entity.
        <programlisting>
DECLARE out_row record;
BEGIN
	FOR out_row IN
		SELECT *
		FROM entity_note
		WHERE ref_key = in_entity_id
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date) -->
    <section id="public.function.entity-location-save-in-created-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-entity-id-date"
             xreflabel="publicentity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date)">
      <title id="public.function.entity-location-save-in-created-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-entity-id-date-title">
       entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date)
      </title>
      <titleabbrev id="public.function.entity-location-save-in-created-integer-in-country-id-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-two-text-in-line-one-text-in-location-class-text-in-id-integer-in-entity-id-date-titleabbrev">
       entity__location_save(in_created integer, in_country_id integer, in_mail_code integer, in_state text, in_city text, in_line_two text, in_line_one text, in_location_class text, in_id integer, in_entity_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location to a company.  Returns the location id.
        <programlisting>
    BEGIN
    return _entity_location_save(
        in_entity_id, in_id,
        in_location_class, in_line_one, in_line_two, 
        &#39;&#39;, in_city , in_state, in_mail_code, in_country_id);
    END;

</programlisting>
      </para>
    </section>

<!-- Function entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer) -->
    <section id="public.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer"
             xreflabel="publicentity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)">
      <title id="public.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer-title">
       entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-save-bank-account-in-bank-account-id-integer-in-iban-integer-in-bic-text-in-credit-id-text-in-entity-id-integer-titleabbrev">
       entity__save_bank_account(in_bank_account_id integer, in_iban integer, in_bic text, in_credit_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves bank account to the credit account.
        <programlisting>
DECLARE out_id int;
BEGIN
        UPDATE entity_bank_account
           SET bic = in_bic,
               iban = in_iban
         WHERE id = in_bank_account_id;

        IF FOUND THEN
                out_id = in_bank_account_id;
        ELSE
	  	INSERT INTO entity_bank_account(entity_id, bic, iban)
		VALUES(in_entity_id, in_bic, in_iban);
	        SELECT CURRVAL(&#39;entity_bank_account_id_seq&#39;) INTO out_id ;
	END IF;

	IF in_credit_id IS NOT NULL THEN
		UPDATE entity_credit_account SET bank_account = out_id
		WHERE id = in_credit_id;
	END IF;

	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer) -->
    <section id="public.function.entity-save-contact-in-old-class-id-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-entity-id-integer"
             xreflabel="publicentity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer)">
      <title id="public.function.entity-save-contact-in-old-class-id-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-entity-id-integer-title">
       entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-save-contact-in-old-class-id-integer-in-old-contact-integer-in-contact-text-in-description-text-in-class-id-text-in-entity-id-integer-titleabbrev">
       entity__save_contact(in_old_class_id integer, in_old_contact integer, in_contact text, in_description text, in_class_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves company contact information.  The return value is meaningless. 
        <programlisting>
DECLARE out_id int;
BEGIN
        DELETE FROM entity_to_contact 
         WHERE entity_id = in_entity_id AND contact = in_old_contact 
               AND contact_class_id = in_old_class_id;

	INSERT INTO entity_to_contact 
               (entity_id, contact_class_id, description, contact)
	VALUES (in_entity_id, in_class_id, in_description, in_contact);

	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity__save_notes(in_subject integer, in_note text, in_entity_id text) -->
    <section id="public.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text"
             xreflabel="publicentity__save_notes(in_subject integer, in_note text, in_entity_id text)">
      <title id="public.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text-title">
       entity__save_notes(in_subject integer, in_note text, in_entity_id text)
      </title>
      <titleabbrev id="public.function.entity-save-notes-in-subject-integer-in-note-text-in-entity-id-text-titleabbrev">
       entity__save_notes(in_subject integer, in_note text, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves an entity-level note.  Such a note is valid for all credit accounts 
attached to that entity.  Returns the id of the note.  
        <programlisting>
DECLARE out_id int;
BEGIN
	-- TODO, change this to create vector too
	INSERT INTO entity_note (ref_key, note_class, entity_id, note, vector, subject)
	VALUES (in_entity_id, 1, in_entity_id, in_note, &#39;&#39;, in_subject);

	SELECT currval(&#39;note_id_seq&#39;) INTO out_id;
	RETURN out_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit__get(in_id integer) -->
    <section id="public.function.entity-credit-get-in-id-integer"
             xreflabel="publicentity_credit__get(in_id integer)">
      <title id="public.function.entity-credit-get-in-id-integer-title">
       entity_credit__get(in_id integer)
      </title>
      <titleabbrev id="public.function.entity-credit-get-in-id-integer-titleabbrev">
       entity_credit__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>entity_credit_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity credit account info.
        <programlisting>
SELECT * FROM entity_credit_account WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text) -->
    <section id="public.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text"
             xreflabel="publicentity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)">
      <title id="public.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text-title">
       entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)
      </title>
      <titleabbrev id="public.function.entity-credit-get-id-in-meta-number-integer-in-entity-class-integer-in-entity-id-text-titleabbrev">
       entity_credit_get_id(in_meta_number integer, in_entity_class integer, in_entity_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an entity credit id, based on entity_id, entity_class, 
and meta_number.  This is the preferred way to locate an account if all three of 
these are known
        <programlisting>
DECLARE out_var int;
BEGIN
	SELECT id INTO out_var FROM entity_credit_account
	WHERE entity_id = in_entity_id 
		AND in_entity_class = entity_class
		AND in_meta_number = meta_number;

	RETURN out_var;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer) -->
    <section id="public.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer"
             xreflabel="publicentity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)">
      <title id="public.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer-title">
       entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)
      </title>
      <titleabbrev id="public.function.entity-credit-get-id-by-meta-number-in-account-class-text-in-meta-number-integer-titleabbrev">
       entity_credit_get_id_by_meta_number(in_account_class text, in_meta_number integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the credit id from the meta_number and entity_class.
        <programlisting>
DECLARE out_credit_id int;
BEGIN
	SELECT id INTO out_credit_id 
	FROM entity_credit_account 
	WHERE meta_number = in_meta_number 
		AND entity_class = in_account_class;

	RETURN out_credit_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function entity_save(in_entity_class integer, in_name text, in_entity_id integer) -->
    <section id="public.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer"
             xreflabel="publicentity_save(in_entity_class integer, in_name text, in_entity_id integer)">
      <title id="public.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer-title">
       entity_save(in_entity_class integer, in_name text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.entity-save-in-entity-class-integer-in-name-text-in-entity-id-integer-titleabbrev">
       entity_save(in_entity_class integer, in_name text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Currently unused.  Left in because it is believed it may be helpful.

This saves an entity, with the control code being the next available via the 
defaults table.
        <programlisting>

    DECLARE
        e entity;
        e_id int;
        
    BEGIN
    
        select * into e from entity where id = in_entity_id;
        
        update 
            entity 
        SET
            name = in_name,
            entity_class = in_entity_class
        WHERE
            id = in_entity_id;
        IF NOT FOUND THEN
            -- do the insert magic.
            e_id = nextval(&#39;entity_id_seq&#39;);
            insert into entity (id, name, entity_class) values 
                (e_id,
                in_name,
                in_entity_class
                );
            return e_id;
        END IF;
        return in_entity_id;
            
    END;

</programlisting>
      </para>
    </section>

<!-- Function eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer) -->
    <section id="public.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer"
             xreflabel="publiceoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)">
      <title id="public.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-title">
       eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </title>
      <titleabbrev id="public.function.eoy-close-books-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-titleabbrev">
       eoy_close_books(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Zeroes accounts and then creates a checkpoint. in_end_date is the date when
the books are to be closed, in_reference and in_description become the 
reference and description of the gl transaction, and in_retention_acc_id is
the retained earnings account id.
        <programlisting>
BEGIN
	IF eoy_zero_accounts(in_end_date, in_reference, in_description, in_retention_acc_id) &gt; 0 THEN
		PERFORM eoy_create_checkpoint(in_end_date);
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_create_checkpoint(in_end_date date) -->
    <section id="public.function.eoy-create-checkpoint-in-end-date-date"
             xreflabel="publiceoy_create_checkpoint(in_end_date date)">
      <title id="public.function.eoy-create-checkpoint-in-end-date-date-title">
       eoy_create_checkpoint(in_end_date date)
      </title>
      <titleabbrev id="public.function.eoy-create-checkpoint-in-end-date-date-titleabbrev">
       eoy_create_checkpoint(in_end_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Creates checkpoints for each account at a specific date.  Books are considered
closed when they occur before the latest checkpoint timewise.  This means that
balances (and credit/debit amounts) can be calculated starting at a checkpoint
and moving forward (thus providing a mechanism for expunging old data while 
keeping balances correct at some future point).
        <programlisting>
DECLARE ret_val int;
	approval_check int;
	cp_date        date;
BEGIN
	IF in_end_date &gt; now()::date THEN
		RAISE EXCEPTION &#39;Invalid date:  Must be earlier than present&#39;;
	END IF;

	SELECT count(*) into approval_check
	FROM acc_trans ac
	JOIN (
		select id, approved, transdate FROM ar UNION
		SELECT id, approved, transdate FROM gl UNION
		SELECT id, approved, transdate FROM ap
	) gl ON (gl.id = ac.trans_id)
	WHERE (ac.approved IS NOT TRUE AND ac.transdate &lt;= in_end_date) 
		OR (gl.approved IS NOT TRUE AND gl.transdate &lt;= in_end_date);

	if approval_check &gt; 0 THEN
		RAISE EXCEPTION &#39;Unapproved transactions in closed period&#39;;
	END IF;
	
	SELECT max(end_date) INTO cp_date FROM account_checkpoint WHERE
	end_date &lt; in_end_date;

	INSERT INTO 
	account_checkpoint (end_date, account_id, amount, debits, credits)
    SELECT in_end_date, COALESCE(a.chart_id, cp.account_id),
	    COALESCE(SUM (a.amount),0) + coalesce(MAX (cp.amount), 0),
	    COALESCE(SUM (CASE WHEN (a.amount &lt; 0) THEN a.amount ELSE 0 END), 0) +
	     COALESCE( MIN (cp.debits), 0),
	    COALESCE(SUM (CASE WHEN (a.amount &gt; 0) THEN a.amount ELSE 0 END), 0) +
	     COALESCE( MAX (cp.credits), 0)
	FROM 
	(SELECT * FROM acc_trans WHERE transdate &lt;= in_end_date AND
	 transdate &gt; COALESCE(cp_date, &#39;1200-01-01&#39;)) a
	FULL OUTER JOIN (
		select account_id, end_date, amount, debits, credits 
		from account_checkpoint
		WHERE end_date = cp_date
		) cp on (a.chart_id = cp.account_id)
	group by COALESCE(a.chart_id, cp.account_id);

	SELECT count(*) INTO ret_val FROM account_checkpoint 
	where end_date = in_end_date;

	return ret_val;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_earnings_accounts() -->
    <section id="public.function.eoy-earnings-accounts"
             xreflabel="publiceoy_earnings_accounts()">
      <title id="public.function.eoy-earnings-accounts-title">
       eoy_earnings_accounts()
      </title>
      <titleabbrev id="public.function.eoy-earnings-accounts-titleabbrev">
       eoy_earnings_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists equity accounts for the retained earnings dropdown.
        <programlisting>
    SELECT * 
      FROM account
     WHERE category = &#39;Q&#39;
     ORDER BY accno;
</programlisting>
      </para>
    </section>

<!-- Function eoy_reopen_books(in_end_date date) -->
    <section id="public.function.eoy-reopen-books-in-end-date-date"
             xreflabel="publiceoy_reopen_books(in_end_date date)">
      <title id="public.function.eoy-reopen-books-in-end-date-date-title">
       eoy_reopen_books(in_end_date date)
      </title>
      <titleabbrev id="public.function.eoy-reopen-books-in-end-date-date-titleabbrev">
       eoy_reopen_books(in_end_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Removes checkpoints and reverses yearend transactions on in_end_date
        <programlisting>
BEGIN
	PERFORM count(*) FROM account_checkpoint WHERE end_date = in_end_date;

	IF NOT FOUND THEN
		RETURN FALSE;
	END IF;

	DELETE FROM account_checkpoint WHERE end_date = in_end_date;

	PERFORM count(*) FROM yearend 
	WHERE transdate = in_end_date and reversed is not true;

	IF FOUND THEN
		INSERT INTO gl (reference, description, approved)
		SELECT &#39;Reversing &#39; || reference, &#39;Reversing &#39; || description,
			true
		FROM gl WHERE id = (select trans_id from yearend 
			where transdate = in_end_date and reversed is not true);

		INSERT INTO acc_trans (chart_id, amount, transdate, trans_id,
			approved)
		SELECT chart_id, amount * -1, currval(&#39;id&#39;), true
		FROM acc_trans where trans_id = (select trans_id from yearend
			where transdate = in_end_date and reversed is not true);

		UPDATE yearend SET reversed = true where transdate = in_end_date
			and reversed is not true;
	END IF;

	DELETE FROM account_checkpoint WHERE end_date = in_end_date;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer) -->
    <section id="public.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer"
             xreflabel="publiceoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)">
      <title id="public.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-title">
       eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </title>
      <titleabbrev id="public.function.eoy-zero-accounts-in-retention-acc-id-date-in-description-text-in-reference-text-in-end-date-integer-titleabbrev">
       eoy_zero_accounts(in_retention_acc_id date, in_description text, in_reference text, in_end_date integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts a transaction which zeroes the income and expense accounts, moving the
net balance there into a retained earnings account identified by 
in_retention_acc_id.
        <programlisting>
DECLARE ret_val int;
BEGIN
	INSERT INTO gl (transdate, reference, description, approved)
	VALUES (in_end_date, in_reference, in_description, true);

	INSERT INTO yearend (trans_id, transdate) values (currval(&#39;id&#39;), in_end_date);
	INSERT INTO acc_trans (transdate, chart_id, trans_id, amount)
	SELECT in_end_date, a.chart_id, currval(&#39;id&#39;),
		(sum(a.amount) + coalesce(max(cp.amount), 0)) * -1
	FROM acc_trans a
	LEFT JOIN (
		select account_id, end_date, amount from account_checkpoint
		WHERE end_date = (select max(end_date) from account_checkpoint
				where end_date &lt; in_end_date)
		) cp on (a.chart_id = cp.account_id)
	JOIN account acc ON (acc.id = a.chart_id)
	WHERE a.transdate &lt;= in_end_date 
		AND a.transdate &gt; coalesce(cp.end_date, a.transdate - 1)
		AND (acc.category IN (&#39;I&#39;, &#39;E&#39;)
                      OR acc.category = &#39;Q&#39; AND acc.is_temp)
	GROUP BY a.chart_id;

	INSERT INTO acc_trans (transdate, trans_id, chart_id, amount)
	SELECT in_end_date, currval(&#39;id&#39;), in_retention_acc_id, 
		coalesce(sum(amount) * -1, 0)
	FROM acc_trans WHERE trans_id = currval(&#39;id&#39;);


	SELECT count(*) INTO ret_val from acc_trans 
	where trans_id = currval(&#39;id&#39;);

	RETURN ret_val;
end;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="public.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="publicfile__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="public.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="public.function.file-attach-to-eca-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_eca(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a good or service.  in_content OR id can be set.
Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to entity credit accounts.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_eca
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="public.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="publicfile__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="public.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="public.function.file-attach-to-entity-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_entity(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a contact or entity.  in_content OR id can be 
set. Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to entities
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_entity
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="public.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="publicfile__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="public.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="public.function.file-attach-to-order-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_order(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to an order.  in_content OR id can be set.
Setting both raises an exception.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Conflicting options file_id and content$e$;
       END IF;
       IF in_file_class = 1 THEN
           INSERT INTO file_tx_to_order        
                  (file_id, source_class, ref_key, dest_class, attached_by,
                  attached_at)
           VALUES (in_id, 1, in_ref_key, 2, person__get_my_entity_id(), now());
       ELSIF in_file_class = 2 THEN
           INSERT INTO file_order_to_order
                  (file_id, source_class, ref_key, dest_class, attached_by,
                  attached_at)
           VALUES (in_id, 2, in_ref_key, 2, person__get_my_entity_id(), now());
       ELSE 
           RAISE EXCEPTION $E$Invalid file class$E$;
       END IF;
       SELECT * INTO retval FROM file_base where id = in_id;
       RETURN retval;
   ELSE
       INSERT INTO file_order
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="public.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="publicfile__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="public.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="public.function.file-attach-to-part-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_part(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a good or service.  in_content OR id can be set.
Setting both raises an exception.

Note that currently links (setting id) is NOT supported because we dont have a
use case of linking files to parts
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       RAISE EXCEPTION &#39;links not implemented&#39;;
       RETURN retval;
   ELSE
       INSERT INTO file_part
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer) -->
    <section id="public.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer"
             xreflabel="publicfile__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)">
      <title id="public.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-title">
       file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </title>
      <titleabbrev id="public.function.file-attach-to-tx-in-file-class-bytea-in-ref-key-integer-in-id-text-in-description-text-in-file-name-integer-in-mime-type-id-integer-in-content-integer-titleabbrev">
       file__attach_to_tx(in_file_class bytea, in_ref_key integer, in_id text, in_description text, in_file_name integer, in_mime_type_id integer, in_content integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Attaches or links a file to a transaction.  in_content OR id can be set.
Setting both raises an exception.
        <programlisting>
DECLARE retval file_base;
BEGIN
   IF in_id IS NOT NULL THEN
       IF in_content THEN
          RAISE EXCEPTION $e$Can&#39;t specify id and content in attachment$e$;--&#39;
       END IF;
       INSERT INTO file_order_to_tx        
              (file_id, source_class, ref_key, dest_class, attached_by,
              attached_at)
       VALUES (in_id, 2, in_ref_key, 1, person__get_my_entity_id(), now());

       SELECT * INTO retval FROM file_base where id = in_id;
       RETURN retval;
   ELSE
       INSERT INTO file_transaction 
                   (content, mime_type_id, file_name, description, ref_key,
                   file_class, uploaded_by, uploaded_at)
            VALUES (in_content, in_mime_type_id, in_file_name, in_description,
                   in_ref_key, in_file_class, person__get_my_entity_id(), 
                   now());
        SELECT * INTO retval FROM file_base 
         where id = currval(&#39;file_base_id_seq&#39;);

        RETURN retval;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function file__get(in_file_class integer, in_id integer) -->
    <section id="public.function.file-get-in-file-class-integer-in-id-integer"
             xreflabel="publicfile__get(in_file_class integer, in_id integer)">
      <title id="public.function.file-get-in-file-class-integer-in-id-integer-title">
       file__get(in_file_class integer, in_id integer)
      </title>
      <titleabbrev id="public.function.file-get-in-file-class-integer-in-id-integer-titleabbrev">
       file__get(in_file_class integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>file_base</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves the file information specified including content.
        <programlisting>
SELECT * FROM file_base where id = $1 and file_class = $2;
</programlisting>
      </para>
    </section>

<!-- Function file__get_for_template(in_file_class integer, in_ref_key integer) -->
    <section id="public.function.file-get-for-template-in-file-class-integer-in-ref-key-integer"
             xreflabel="publicfile__get_for_template(in_file_class integer, in_ref_key integer)">
      <title id="public.function.file-get-for-template-in-file-class-integer-in-ref-key-integer-title">
       file__get_for_template(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="public.function.file-get-for-template-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__get_for_template(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 

SELECT m.mime_type, CASE WHEN f.file_class = 3 THEN ref_key ||&#39;-&#39;|| f.file_name
                         ELSE f.file_name END, 
       f.description, f.uploaded_by, e.name, 
       f.uploaded_at, f.id, f.ref_key, f.file_class,  f.content
  FROM mime_type m
  JOIN file_base f ON f.mime_type_id = m.id
  JOIN entity e ON f.uploaded_by = e.id
 WHERE f.ref_key = $1 and f.file_class = $2
       AND m.invoice_include 
       OR f.id IN (SELECT max(fb.id) 
                   FROM file_base fb
                   JOIN mime_type m ON fb.mime_type_id = m.id
                        AND m.mime_type ilike &#39;image%&#39;
                   JOIN invoice i ON i.trans_id = $1
                        AND i.parts_id = fb.ref_key
                  WHERE fb.file_class = 3)
</programlisting>
      </para>
    </section>

<!-- Function file__get_mime_type(in_mime_type_text integer, in_mime_type_id text) -->
    <section id="public.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text"
             xreflabel="publicfile__get_mime_type(in_mime_type_text integer, in_mime_type_id text)">
      <title id="public.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text-title">
       file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)
      </title>
      <titleabbrev id="public.function.file-get-mime-type-in-mime-type-text-integer-in-mime-type-id-text-titleabbrev">
       file__get_mime_type(in_mime_type_text integer, in_mime_type_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>mime_type</seg>
        </seglistitem>
       </segmentedlist>
 
       Retrieves mime type information associated with a file object.
        <programlisting>
select * from mime_type 
 where ($1 IS NULL OR id = $1) AND ($2 IS NULL OR mime_type = $2);
</programlisting>
      </para>
    </section>

<!-- Function file__list_by(in_file_class integer, in_ref_key integer) -->
    <section id="public.function.file-list-by-in-file-class-integer-in-ref-key-integer"
             xreflabel="publicfile__list_by(in_file_class integer, in_ref_key integer)">
      <title id="public.function.file-list-by-in-file-class-integer-in-ref-key-integer-title">
       file__list_by(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="public.function.file-list-by-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__list_by(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_list_item</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of files attached to a database object.  No content is 
retrieved.
        <programlisting>

SELECT m.mime_type, f.file_name, f.description, f.uploaded_by, e.name, 
       f.uploaded_at, f.id, f.ref_key, f.file_class, 
       case when m.mime_type = &#39;text/x-uri&#39; THEN f.content ELSE NULL END
  FROM mime_type m
  JOIN file_base f ON f.mime_type_id = m.id
  JOIN entity e ON f.uploaded_by = e.id
 WHERE f.ref_key = $1 and f.file_class = $2;

</programlisting>
      </para>
    </section>

<!-- Function file__list_links(in_file_class integer, in_ref_key integer) -->
    <section id="public.function.file-list-links-in-file-class-integer-in-ref-key-integer"
             xreflabel="publicfile__list_links(in_file_class integer, in_ref_key integer)">
      <title id="public.function.file-list-links-in-file-class-integer-in-ref-key-integer-title">
       file__list_links(in_file_class integer, in_ref_key integer)
      </title>
      <titleabbrev id="public.function.file-list-links-in-file-class-integer-in-ref-key-integer-titleabbrev">
       file__list_links(in_file_class integer, in_ref_key integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF file_links</seg>
        </seglistitem>
       </segmentedlist>
 
        This function retrieves a list of file attachments on a specified object.
        <programlisting> select * from file_links where ref_key = $1 and dest_class = $2;
</programlisting>
      </para>
    </section>

<!-- Function file_links_vrebuild() -->
    <section id="public.function.file-links-vrebuild"
             xreflabel="publicfile_links_vrebuild()">
      <title id="public.function.file-links-vrebuild-title">
       file_links_vrebuild()
      </title>
      <titleabbrev id="public.function.file-links-vrebuild-titleabbrev">
       file_links_vrebuild()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   viewline file_view_catalog%rowtype;
   stmt text;
BEGIN
   stmt := &#39;&#39;;
   FOR viewline IN
       select * from file_view_catalog
   LOOP
       IF stmt = &#39;&#39; THEN
           stmt := &#39;SELECT * FROM &#39; || quote_ident(viewline.view_name) || &#39;
&#39;;
       ELSE
           stmt := stmt || &#39; UNION
SELECT * FROM &#39;|| quote_ident(viewline.view_name) || &#39;
&#39;;
       END IF; 
   END LOOP;
   EXECUTE &#39;CREATE OR REPLACE VIEW file_links AS
&#39; || stmt;
   RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function form_check(in_form_id integer, in_session_id integer) -->
    <section id="public.function.form-check-in-form-id-integer-in-session-id-integer"
             xreflabel="publicform_check(in_form_id integer, in_session_id integer)">
      <title id="public.function.form-check-in-form-id-integer-in-session-id-integer-title">
       form_check(in_form_id integer, in_session_id integer)
      </title>
      <titleabbrev id="public.function.form-check-in-form-id-integer-in-session-id-integer-titleabbrev">
       form_check(in_form_id integer, in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        This checks to see if an open form (record in open_forms) exists with 
the form_id and session_id provided.  Returns true if exists, false if not.
        <programlisting>
SELECT count(*) = 1 
  FROM open_forms f
  JOIN &quot;session&quot; s USING (session_id)
  JOIN users u ON (s.users_id = u.id)
 WHERE f.session_id = $1 and f.id = $2 and u.username = SESSION_USER;
</programlisting>
      </para>
    </section>

<!-- Function form_close(in_form_id integer, in_session_id integer) -->
    <section id="public.function.form-close-in-form-id-integer-in-session-id-integer"
             xreflabel="publicform_close(in_form_id integer, in_session_id integer)">
      <title id="public.function.form-close-in-form-id-integer-in-session-id-integer-title">
       form_close(in_form_id integer, in_session_id integer)
      </title>
      <titleabbrev id="public.function.form-close-in-form-id-integer-in-session-id-integer-titleabbrev">
       form_close(in_form_id integer, in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Closes out the form by deleting it from the open_forms table.

Returns true if found, false if not.

        <programlisting>
DECLARE form_test bool;
BEGIN
	form_test := form_check(in_session_id, in_form_id);

	IF form_test is true THEN 
		DELETE FROM open_forms 
		WHERE session_id = in_session_id AND id = in_form_id;

		RETURN TRUE;

	ELSE RETURN FALSE;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function form_open(in_session_id integer) -->
    <section id="public.function.form-open-in-session-id-integer"
             xreflabel="publicform_open(in_session_id integer)">
      <title id="public.function.form-open-in-session-id-integer-title">
       form_open(in_session_id integer)
      </title>
      <titleabbrev id="public.function.form-open-in-session-id-integer-titleabbrev">
       form_open(in_session_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This opens a form, and returns the id of the form opened.
        <programlisting>
DECLARE usertest bool;
BEGIN
        SELECT count(*) = 1 INTO usertest FROM session 
         WHERE session_id = in_session_id 
               AND users_id IN (select id from users 
                                WHERE username = SESSION_USER);

        IF usertest is not true THEN
            RAISE EXCEPTION &#39;Invalid session&#39;;
        END IF;
      
	INSERT INTO open_forms (session_id) VALUES (in_session_id);
	RETURN currval(&#39;open_forms_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function get_default_lang() -->
    <section id="public.function.get-default-lang"
             xreflabel="publicget_default_lang()">
      <title id="public.function.get-default-lang-title">
       get_default_lang()
      </title>
      <titleabbrev id="public.function.get-default-lang-titleabbrev">
       get_default_lang()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT coalesce((select description FROM language 
    WHERE code = (SELECT substring(value, 1, 2) FROM defaults
                   WHERE setting_key = &#39;default_language&#39;)), &#39;english&#39;);
</programlisting>
      </para>
    </section>

<!-- Function get_fractional_month(in_date_second date, in_date_first date) -->
    <section id="public.function.get-fractional-month-in-date-second-date-in-date-first-date"
             xreflabel="publicget_fractional_month(in_date_second date, in_date_first date)">
      <title id="public.function.get-fractional-month-in-date-second-date-in-date-first-date-title">
       get_fractional_month(in_date_second date, in_date_first date)
      </title>
      <titleabbrev id="public.function.get-fractional-month-in-date-second-date-in-date-first-date-titleabbrev">
       get_fractional_month(in_date_second date, in_date_first date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of months between two dates in numeric form.
        <programlisting>
SELECT CASE WHEN is_same_month($1, $2)
            THEN ($2 - $1)::numeric
                 / days_in_month($1)
            ELSE (get_fractional_month(
                   $1, (date_trunc(&#39;MONTH&#39;, $1) 
                       + &#39;1 month - 1 second&#39;::interval)::date)
                 + get_fractional_month(date_trunc(&#39;MONTH&#39;, $2)::date, $2)
                 + (extract (&#39;YEAR&#39; from $2) - extract (&#39;YEAR&#39; from $1) * 12)
                 + extract (&#39;MONTH&#39; from $1) - extract (&#39;MONTH&#39; from $2) 
                 - 1)::numeric
            END;
</programlisting>
      </para>
    </section>

<!-- Function get_fractional_year(in_date_to date, in_date_from date) -->
    <section id="public.function.get-fractional-year-in-date-to-date-in-date-from-date"
             xreflabel="publicget_fractional_year(in_date_to date, in_date_from date)">
      <title id="public.function.get-fractional-year-in-date-to-date-in-date-from-date-title">
       get_fractional_year(in_date_to date, in_date_from date)
      </title>
      <titleabbrev id="public.function.get-fractional-year-in-date-to-date-in-date-from-date-titleabbrev">
       get_fractional_year(in_date_to date, in_date_from date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the decimal representation of the fractional year.
        <programlisting>
   select ($2 - $1
            - leap_days(next_leap_year_calc($1, false), 
                       next_leap_year_calc($2, true)))
            /365::numeric;
</programlisting>
      </para>
    </section>

<!-- Function get_link_descriptions() -->
    <section id="public.function.get-link-descriptions"
             xreflabel="publicget_link_descriptions()">
      <title id="public.function.get-link-descriptions-title">
       get_link_descriptions()
      </title>
      <titleabbrev id="public.function.get-link-descriptions-titleabbrev">
       get_link_descriptions()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF account_link_description</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets a set of all valid account_link descriptions.
        <programlisting>
    SELECT * FROM account_link_description;
</programlisting>
      </para>
    </section>

<!-- Function gl_audit_trail_append() -->
    <section id="public.function.gl-audit-trail-append"
             xreflabel="publicgl_audit_trail_append()">
      <title id="public.function.gl-audit-trail-append-title">
       gl_audit_trail_append()
      </title>
      <titleabbrev id="public.function.gl-audit-trail-append-titleabbrev">
       gl_audit_trail_append()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides centralized support for insertions into audittrail.

        <programlisting>
DECLARE
   t_reference text;
   t_row RECORD;
BEGIN

IF TG_OP = &#39;INSERT&#39; then
   t_row := NEW;
ELSE
   t_row := OLD;
END IF;

IF TG_RELNAME IN (&#39;ar&#39;, &#39;ap&#39;) THEN
    t_reference := t_row.invnumber;
ELSE 
    t_reference := t_row.reference;
END IF;

INSERT INTO audittrail (trans_id,tablename,reference, action, person_id)
values (t_row.id,TG_RELNAME,t_reference, TG_OP, person__get_my_entity_id());

return null; -- AFTER TRIGGER ONLY, SAFE
END;
</programlisting>
      </para>
    </section>

<!-- Function in_tree(in_search_array integer, in_node_id public.tree_record[]) -->
    <section id="public.function.in-tree-in-search-array-integer-in-node-id-public.tree-recordARRAY"
             xreflabel="publicin_tree(in_search_array integer, in_node_id public.tree_record[])">
      <title id="public.function.in-tree-in-search-array-integer-in-node-id-public.tree-recordARRAY-title">
       in_tree(in_search_array integer, in_node_id public.tree_record[])
      </title>
      <titleabbrev id="public.function.in-tree-in-search-array-integer-in-node-id-public.tree-recordARRAY-titleabbrev">
       in_tree(in_search_array integer, in_node_id public.tree_record[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT CASE WHEN count(*) &gt; 0 THEN true ELSE false END
  FROM unnest($2) r
 WHERE t @&gt; array[$1];
</programlisting>
      </para>
    </section>

<!-- Function in_tree(in_search_array integer[], in_node_id public.tree_record[]) -->
    <section id="public.function.in-tree-in-search-array-integerARRAY-in-node-id-public.tree-recordARRAY"
             xreflabel="publicin_tree(in_search_array integer[], in_node_id public.tree_record[])">
      <title id="public.function.in-tree-in-search-array-integerARRAY-in-node-id-public.tree-recordARRAY-title">
       in_tree(in_search_array integer[], in_node_id public.tree_record[])
      </title>
      <titleabbrev id="public.function.in-tree-in-search-array-integerARRAY-in-node-id-public.tree-recordARRAY-titleabbrev">
       in_tree(in_search_array integer[], in_node_id public.tree_record[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT bool_and(in_tree(e, $2))
  FROM unnest($1) e;
</programlisting>
      </para>
    </section>

<!-- Function inventory_adj__details(in_id integer) -->
    <section id="public.function.inventory-adj-details-in-id-integer"
             xreflabel="publicinventory_adj__details(in_id integer)">
      <title id="public.function.inventory-adj-details-in-id-integer-title">
       inventory_adj__details(in_id integer)
      </title>
      <titleabbrev id="public.function.inventory-adj-details-in-id-integer-titleabbrev">
       inventory_adj__details(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF inventory_adjustment_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 

   SELECT l.parts_id, p.partnumber, p.description, l.counted, l.expected, 
          l.counted - l.expected
     FROM inventory_report_line l
     JOIN parts p ON l.parts_id = p.id
    WHERE l.report_id = $1;

</programlisting>
      </para>
    </section>

<!-- Function inventory_adj__get(in_id integer) -->
    <section id="public.function.inventory-adj-get-in-id-integer"
             xreflabel="publicinventory_adj__get(in_id integer)">
      <title id="public.function.inventory-adj-get-in-id-integer-title">
       inventory_adj__get(in_id integer)
      </title>
      <titleabbrev id="public.function.inventory-adj-get-in-id-integer-titleabbrev">
       inventory_adj__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF inventory_adjustment_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

   SELECT r.id, r.transdate, r.source, r.ar_trans_id, r.ap_trans_id,
          ar.invnumber, ap.invnumber
     FROM inventory_report r
     JOIN inventory_report_line l ON l.report_id = r.id 
LEFT JOIN ar ON ar.id = r.ar_trans_id
LEFT JOIN ap ON ap.id = r.ap_trans_id
    WHERE r.id = $1;

</programlisting>
      </para>
    </section>

<!-- Function inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text) -->
    <section id="public.function.inventory-adj-search-in-source-date-in-partnumber-date-in-to-date-text-in-from-date-text"
             xreflabel="publicinventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text)">
      <title id="public.function.inventory-adj-search-in-source-date-in-partnumber-date-in-to-date-text-in-from-date-text-title">
       inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text)
      </title>
      <titleabbrev id="public.function.inventory-adj-search-in-source-date-in-partnumber-date-in-to-date-text-in-from-date-text-titleabbrev">
       inventory_adj__search(in_source date, in_partnumber date, in_to_date text, in_from_date text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF inventory_adjustment_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

   SELECT r.id, r.transdate, r.source, r.ar_trans_id, r.ap_trans_id,
          ar.invnumber, ap.invnumber
     FROM inventory_report r
     JOIN inventory_report_line l ON l.report_id = r.id 
     JOIN parts p ON l.parts_id = p.id
LEFT JOIN ar ON ar.id = r.ar_trans_id
LEFT JOIN ap ON ap.id = r.ap_trans_id
    WHERE ($1 is null or $1 &lt;= r.transdate) AND
          ($2 is null OR $2 &gt;= r.transdate) AND
          ($3 IS NULL OR plainto_tsquery($3) @@ tsvector(p.partnumber)) AND
          ($4 IS NULL OR source LIKE $4 || &#39;%&#39;);
 
</programlisting>
      </para>
    </section>

<!-- Function invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text) -->
    <section id="public.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text"
             xreflabel="publicinvoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)">
      <title id="public.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text-title">
       invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)
      </title>
      <titleabbrev id="public.function.invoice-get-by-vendor-number-in-invoice-number-text-in-meta-nunber-text-titleabbrev">
       invoice__get_by_vendor_number(in_invoice_number text, in_meta_nunber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>ap</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval ap;
BEGIN
	SELECT * INTO retval FROM ap WHERE entity_credit_id = 
		(select id from entity_credit_account where entity_class = 1
		AND meta_number = in_meta_number)
		AND invnumber = in_invoice_number;
	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function is_leapyear(in_date date) -->
    <section id="public.function.is-leapyear-in-date-date"
             xreflabel="publicis_leapyear(in_date date)">
      <title id="public.function.is-leapyear-in-date-date-title">
       is_leapyear(in_date date)
      </title>
      <titleabbrev id="public.function.is-leapyear-in-date-date-titleabbrev">
       is_leapyear(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if date is in a leapyear.  False if not.  Uses the built-in 
PostgreSQL date handling, and no direct detection is done in our code.
        <programlisting>
    select extract(&#39;day&#39; FROM (
                           (extract(&#39;year&#39; FROM $1)::text 
                           || &#39;-02-28&#39;)::date + &#39;1 day&#39;::interval)::date) 
           = 29;
</programlisting>
      </para>
    </section>

<!-- Function is_same_month(in_date2 date, in_date1 date) -->
    <section id="public.function.is-same-month-in-date2-date-in-date1-date"
             xreflabel="publicis_same_month(in_date2 date, in_date1 date)">
      <title id="public.function.is-same-month-in-date2-date-in-date1-date-title">
       is_same_month(in_date2 date, in_date1 date)
      </title>
      <titleabbrev id="public.function.is-same-month-in-date2-date-in-date1-date-titleabbrev">
       is_same_month(in_date2 date, in_date1 date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the two dates are in the same month and year. False 
otherwise.
        <programlisting>
SELECT is_same_year($1, $2) 
       and extract (&#39;MONTH&#39; from $1) = extract (&#39;MONTH&#39; from $2);
</programlisting>
      </para>
    </section>

<!-- Function is_same_year(in_date2 date, in_date1 date) -->
    <section id="public.function.is-same-year-in-date2-date-in-date1-date"
             xreflabel="publicis_same_year(in_date2 date, in_date1 date)">
      <title id="public.function.is-same-year-in-date2-date-in-date1-date-title">
       is_same_year(in_date2 date, in_date1 date)
      </title>
      <titleabbrev id="public.function.is-same-year-in-date2-date-in-date1-date-titleabbrev">
       is_same_year(in_date2 date, in_date1 date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the two dates are in the same year, false otherwise.
        <programlisting>
SELECT  extract (&#39;YEAR&#39; from $1) = extract (&#39;YEAR&#39; from $2);
</programlisting>
      </para>
    </section>

<!-- Function je_get_default_lines() -->
    <section id="public.function.je-get-default-lines"
             xreflabel="publicje_get_default_lines()">
      <title id="public.function.je-get-default-lines-title">
       je_get_default_lines()
      </title>
      <titleabbrev id="public.function.je-get-default-lines-titleabbrev">
       je_get_default_lines()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>character varying</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT value FROM menu_attribute where node_id = 74 and attribute = &#39;rowcount&#39;;
</programlisting>
      </para>
    </section>

<!-- Function je_set_default_lines(in_rowcount integer) -->
    <section id="public.function.je-set-default-lines-in-rowcount-integer"
             xreflabel="publicje_set_default_lines(in_rowcount integer)">
      <title id="public.function.je-set-default-lines-in-rowcount-integer-title">
       je_set_default_lines(in_rowcount integer)
      </title>
      <titleabbrev id="public.function.je-set-default-lines-in-rowcount-integer-titleabbrev">
       je_set_default_lines(in_rowcount integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
    UPDATE menu_attribute set value = $1 
     where node_id = 74 and attribute=&#39;rowcount&#39;;

    IF NOT FOUND THEN
         INSERT INTO menu_attribute (node_id, attribute, value)
              values (74, &#39;rowcount&#39;, $1);
    END IF;
    RETURN $1; 
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean) -->
    <section id="public.function.journal-add-in-is-template-text-in-approved-text-in-transaction-date-integer-in-entry-type-date-in-description-boolean-in-source-boolean"
             xreflabel="publicjournal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean)">
      <title id="public.function.journal-add-in-is-template-text-in-approved-text-in-transaction-date-integer-in-entry-type-date-in-description-boolean-in-source-boolean-title">
       journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean)
      </title>
      <titleabbrev id="public.function.journal-add-in-is-template-text-in-approved-text-in-transaction-date-integer-in-entry-type-date-in-description-boolean-in-source-boolean-titleabbrev">
       journal__add(in_is_template text, in_approved text, in_transaction_date integer, in_entry_type date, in_description boolean, in_source boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>journal_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval journal_entry;
BEGIN
	INSERT INTO journal_entry (source, description, entry_type, transaction_date,
			approved, is_template)
	VALUES (in_source, in_description, in_entry_type, in_transaction_date,
			coalesce(in_approved, false), 
			coalesce(in_is_template, false));

	SELECT * INTO retval FROM journal_entry WHERE id = currval(&#39;journal_id_seq&#39;);
	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[]) -->
    <section id="public.function.journal-add-line-in-business-units-integer-in-memo-integer-in-cleared-numeric-in-amount-boolean-in-journal-id-text-in-account-id-integerARRAY"
             xreflabel="publicjournal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[])">
      <title id="public.function.journal-add-line-in-business-units-integer-in-memo-integer-in-cleared-numeric-in-amount-boolean-in-journal-id-text-in-account-id-integerARRAY-title">
       journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[])
      </title>
      <titleabbrev id="public.function.journal-add-line-in-business-units-integer-in-memo-integer-in-cleared-numeric-in-amount-boolean-in-journal-id-text-in-account-id-integerARRAY-titleabbrev">
       journal__add_line(in_business_units integer, in_memo integer, in_cleared numeric, in_amount boolean, in_journal_id text, in_account_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>journal_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval journal_line;
BEGIN
	INSERT INTO journal_line(account_id, journal_id, amount, cleared, memo)
	VALUES (in_account_id, in_journal_id, in_amount, 
		coalesce(in_cleared, false), in_memo);

        INSERT INTO business_unit_jl(entry_id, bu_class, bu_id)
        SELECT currval(&#39;journal_line_line_id_seq&#39;), business_unit_class, bu
          FROM business_unit
         WHERE id = any(in_business_units);

	SELECT * INTO retval FROM journal_line where line_id = currval(&#39;journal_line_line_id_seq&#39;);
	return retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__get_entry(in_id integer) -->
    <section id="public.function.journal-get-entry-in-id-integer"
             xreflabel="publicjournal__get_entry(in_id integer)">
      <title id="public.function.journal-get-entry-in-id-integer-title">
       journal__get_entry(in_id integer)
      </title>
      <titleabbrev id="public.function.journal-get-entry-in-id-integer-titleabbrev">
       journal__get_entry(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>journal_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM journal_entry where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function journal__get_invoice(in_id integer) -->
    <section id="public.function.journal-get-invoice-in-id-integer"
             xreflabel="publicjournal__get_invoice(in_id integer)">
      <title id="public.function.journal-get-invoice-in-id-integer-title">
       journal__get_invoice(in_id integer)
      </title>
      <titleabbrev id="public.function.journal-get-invoice-in-id-integer-titleabbrev">
       journal__get_invoice(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>eca_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM eca_invoice where journal_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function journal__lines(in_id integer) -->
    <section id="public.function.journal-lines-in-id-integer"
             xreflabel="publicjournal__lines(in_id integer)">
      <title id="public.function.journal-lines-in-id-integer-title">
       journal__lines(in_id integer)
      </title>
      <titleabbrev id="public.function.journal-lines-in-id-integer-titleabbrev">
       journal__lines(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF journal_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
select * from journal_line where journal_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying) -->
    <section id="public.function.journal-make-invoice-in-language-code-integer-in-credit-id-integer-in-reverse-boolean-in-on-hold-boolean-in-journal-id-integer-in-order-id-character-varying"
             xreflabel="publicjournal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying)">
      <title id="public.function.journal-make-invoice-in-language-code-integer-in-credit-id-integer-in-reverse-boolean-in-on-hold-boolean-in-journal-id-integer-in-order-id-character-varying-title">
       journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying)
      </title>
      <titleabbrev id="public.function.journal-make-invoice-in-language-code-integer-in-credit-id-integer-in-reverse-boolean-in-on-hold-boolean-in-journal-id-integer-in-order-id-character-varying-titleabbrev">
       journal__make_invoice(in_language_code integer, in_credit_id integer, in_reverse boolean, in_on_hold boolean, in_journal_id integer, in_order_id character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval eca_invoice;
BEGIN	
	INSERT INTO eca_invoice (order_id, journal_id, on_hold, reverse,
		credit_id, language_code)
	VALUES (in_order_id, in_journal_id, coalesce(in_on_hold, false), 
		in_reverse, in_credit_id, in_language_code);

	SELECT * INTO retval FROM eca_invoice WHERE journal_id = in_journal_id;

	RETURN retval;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer) -->
    <section id="public.function.journal-search-in-entity-class-text-in-meta-number-text-in-is-template-integer-in-department-id-date-in-approved-boolean-in-transaction-date-integer-in-entry-type-boolean-in-description-text-in-source-integer"
             xreflabel="publicjournal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer)">
      <title id="public.function.journal-search-in-entity-class-text-in-meta-number-text-in-is-template-integer-in-department-id-date-in-approved-boolean-in-transaction-date-integer-in-entry-type-boolean-in-description-text-in-source-integer-title">
       journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer)
      </title>
      <titleabbrev id="public.function.journal-search-in-entity-class-text-in-meta-number-text-in-is-template-integer-in-department-id-date-in-approved-boolean-in-transaction-date-integer-in-entry-type-boolean-in-description-text-in-source-integer-titleabbrev">
       journal__search(in_entity_class text, in_meta_number text, in_is_template integer, in_department_id date, in_approved boolean, in_transaction_date integer, in_entry_type boolean, in_description text, in_source integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF journal_search_result</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval journal_search_result;
BEGIN
	FOR retval IN 
		SELECT j.id, j.source, j.description, j.entry_type, 
			j.transaction_date, j.approved, 
			j.is_template, eca.meta_number, 
			e.name, ec.class
		FROM journal_entry j
		LEFT JOIN eca_invoice i ON (i.journal_id = j.id)
		LEFT JOIN entity_credit_account eca ON (eca.id = credit_id)
		LEFT JOIN entity e ON (eca.entity_id = e.id)
		LEFT JOIN entity_class ec ON (eca.entity_class = ec.id)
		WHERE (in_source IS NULL OR in_source = j.source) AND
			(in_description IS NULL 
				or in_description = j.description) AND
			(in_entry_type is null or in_entry_type = j.entry_type)
			and (in_transaction_date is null 
				or in_transaction_date = j.transaction_date) and
			j.approved = coalesce(in_approved, true) and
			j.is_template = coalesce(in_is_template, false) and
			(in_department_id is null 
				or j.department_id = in_department_id) and
			(in_meta_number is null 
				or eca.meta_number = in_meta_number) and
			(in_entity_class is null
				or eca.entity_class = in_entity_class)
	LOOP
		RETURN NEXT retval;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function journal__validate_entry(in_id integer) -->
    <section id="public.function.journal-validate-entry-in-id-integer"
             xreflabel="publicjournal__validate_entry(in_id integer)">
      <title id="public.function.journal-validate-entry-in-id-integer-title">
       journal__validate_entry(in_id integer)
      </title>
      <titleabbrev id="public.function.journal-validate-entry-in-id-integer-titleabbrev">
       journal__validate_entry(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
	SELECT sum(amount) = 0 FROM journal_line WHERE journal_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function lastcost(integer) -->
    <section id="public.function.lastcost-integer"
             xreflabel="publiclastcost(integer)">
      <title id="public.function.lastcost-integer-title">
       lastcost(integer)
      </title>
      <titleabbrev id="public.function.lastcost-integer-titleabbrev">
       lastcost(integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>double precision</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE

v_cost float;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost sellprice FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id
  ORDER BY a.transdate desc, a.id desc
  LIMIT 1;

  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

RETURN v_cost;
END;
</programlisting>
      </para>
    </section>

<!-- Function leap_days(in_year_to integer, in_year_from integer) -->
    <section id="public.function.leap-days-in-year-to-integer-in-year-from-integer"
             xreflabel="publicleap_days(in_year_to integer, in_year_from integer)">
      <title id="public.function.leap-days-in-year-to-integer-in-year-from-integer-title">
       leap_days(in_year_to integer, in_year_from integer)
      </title>
      <titleabbrev id="public.function.leap-days-in-year-to-integer-in-year-from-integer-titleabbrev">
       leap_days(in_year_to integer, in_year_from integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns the number of leap years between the two year inputs, inclusive.
        <programlisting>
   SELECT count(*)::int
   FROM generate_series($1, $2)
   WHERE is_leapyear((generate_series::text || &#39;-01-01&#39;)::date);
</programlisting>
      </para>
    </section>

<!-- Function list_taxforms(in_entity_id integer) -->
    <section id="public.function.list-taxforms-in-entity-id-integer"
             xreflabel="publiclist_taxforms(in_entity_id integer)">
      <title id="public.function.list-taxforms-in-entity-id-integer-title">
       list_taxforms(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.list-taxforms-in-entity-id-integer-titleabbrev">
       list_taxforms(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
       Returns a list of tax forms for the entity&apos;s country.
        <programlisting>
DECLARE t_country_tax_form country_tax_form;
BEGIN

	FOR t_country_tax_form IN 

		      SELECT * 
		            FROM country_tax_form where country_id in(SELECT country_id from entity where id=in_entity_id)
        LOOP

	RETURN NEXT t_country_tax_form;
	
	END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function location__deactivate(in_id integer) -->
    <section id="public.function.location-deactivate-in-id-integer"
             xreflabel="publiclocation__deactivate(in_id integer)">
      <title id="public.function.location-deactivate-in-id-integer-title">
       location__deactivate(in_id integer)
      </title>
      <titleabbrev id="public.function.location-deactivate-in-id-integer-titleabbrev">
       location__deactivate(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>location</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

UPDATE location set active = false, inactive_date = now()
 WHERE id = $1;

SELECT * FROM location WHERE id = 1;

</programlisting>
      </para>
    </section>

<!-- Function location__get(in_id integer) -->
    <section id="public.function.location-get-in-id-integer"
             xreflabel="publiclocation__get(in_id integer)">
      <title id="public.function.location-get-in-id-integer-title">
       location__get(in_id integer)
      </title>
      <titleabbrev id="public.function.location-get-in-id-integer-titleabbrev">
       location__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the location specified by in_id.
        <programlisting>
DECLARE
	out_location location%ROWTYPE;
BEGIN
	SELECT * INTO out_location FROM location WHERE id = in_id;
	RETURN out_location;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_delete(in_id integer) -->
    <section id="public.function.location-delete-in-id-integer"
             xreflabel="publiclocation_delete(in_id integer)">
      <title id="public.function.location-delete-in-id-integer-title">
       location_delete(in_id integer)
      </title>
      <titleabbrev id="public.function.location-delete-in-id-integer-titleabbrev">
       location_delete(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>void</seg>
        </seglistitem>
       </segmentedlist>
 
        DELETES the location specified by in_id.  Does not return a value.
        <programlisting>
BEGIN
	DELETE FROM location WHERE id = in_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_all() -->
    <section id="public.function.location-list-all"
             xreflabel="publiclocation_list_all()">
      <title id="public.function.location-list-all-title">
       location_list_all()
      </title>
      <titleabbrev id="public.function.location-list-all-titleabbrev">
       location_list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all locations, ordered by country, state, and city. 
        <programlisting>
DECLARE 
	out_location location%ROWTYPE;
BEGIN
	FOR out_location IN
		SELECT * FROM location 
		ORDER BY country, state, city
	LOOP
		RETURN NEXT out_location;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_class() -->
    <section id="public.function.location-list-class"
             xreflabel="publiclocation_list_class()">
      <title id="public.function.location-list-class-title">
       location_list_class()
      </title>
      <titleabbrev id="public.function.location-list-class-titleabbrev">
       location_list_class()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_class</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists location classes, by default in order entered.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM location_class ORDER BY id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_list_country() -->
    <section id="public.function.location-list-country"
             xreflabel="publiclocation_list_country()">
      <title id="public.function.location-list-country-title">
       location_list_country()
      </title>
      <titleabbrev id="public.function.location-list-country-titleabbrev">
       location_list_country()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF country</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists countries, by default in alphabetical order.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT * FROM country ORDER BY name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer) -->
    <section id="public.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer"
             xreflabel="publiclocation_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)">
      <title id="public.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer-title">
       location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)
      </title>
      <titleabbrev id="public.function.location-save-in-country-integer-in-zipcode-text-in-state-text-in-city-text-in-address3-text-in-address2-text-in-address1-text-in-location-id-integer-titleabbrev">
       location_save(in_country integer, in_zipcode text, in_state text, in_city text, in_address3 text, in_address2 text, in_address1 text, in_location_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Note that this does NOT override the data in the database unless in_location_id is specified.
Instead we search for locations matching the desired specifications and if none 
are found, we insert one.  Either way, the return value of the location can be
used for mapping to other things.  This is necessary because locations are 
only loosly coupled with entities, etc.
        <programlisting>
DECLARE
	location_id integer;
	location_row RECORD;
BEGIN
	
	IF in_location_id IS NULL THEN
	    SELECT id INTO location_id FROM location
	    WHERE line_one = in_address1 AND line_two = in_address2
	          AND line_three = in_address3 AND in_city = city 
	          AND in_state = state AND in_zipcode = mail_code
	          AND in_country = country_id 
	    LIMIT 1;

	    IF NOT FOUND THEN
	    -- Straight insert.
	    location_id = nextval(&#39;location_id_seq&#39;);
	    INSERT INTO location (
	        id, 
	        line_one, 
	        line_two,
	        line_three,
	        city,
	        state,
	        mail_code,
	        country_id)
	    VALUES (
	        location_id,
	        in_address1,
	        in_address2,
	        in_address3,
	        in_city,
	        in_state,
	        in_zipcode,
	        in_country
	        );
	    END IF;
	    return location_id;
	ELSE
	    RAISE NOTICE &#39;Overwriting location id %&#39;, in_location_id;
	    -- Test it.
	    SELECT * INTO location_row FROM location WHERE id = in_location_id;
	    IF NOT FOUND THEN
	        -- Tricky users are lying to us.
	        RAISE EXCEPTION &#39;location_save called with nonexistant location ID %&#39;, in_location_id;
	    ELSE
	        -- Okay, we&#39;re good.
	        
	        UPDATE location SET
	            line_one = in_address1,
	            line_two = in_address2,
	            line_three = in_address3,
	            city = in_city, 
	            state = in_state,
	            mail_code = in_zipcode,
	            country_id = in_country
	        WHERE id = in_location_id;
	        return in_location_id;
	    END IF;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying) -->
    <section id="public.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying"
             xreflabel="publiclocation_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)">
      <title id="public.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying-title">
       location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)
      </title>
      <titleabbrev id="public.function.location-search-in-country-character-varying-in-zipcode-character-varying-in-state-character-varying-in-city-character-varying-in-address2-character-varying-in-address1-character-varying-titleabbrev">
       location_search(in_country character varying, in_zipcode character varying, in_state character varying, in_city character varying, in_address2 character varying, in_address1 character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns matching locations.  All matches may be partial.
        <programlisting>
DECLARE
	out_location location%ROWTYPE;
BEGIN
	FOR out_location IN
		SELECT * FROM location 
		WHERE address1 ilike &#39;%&#39; || in_address1 || &#39;%&#39;
			AND address2 ilike &#39;%&#39; || in_address2 || &#39;%&#39;
			AND in_city ilike &#39;%&#39; || in_city || &#39;%&#39;
			AND in_state ilike &#39;%&#39; || in_state || &#39;%&#39;
			AND in_zipcode ilike &#39;%&#39; || in_zipcode || &#39;%&#39;
			AND in_country ilike &#39;%&#39; || in_country || &#39;%&#39;
	LOOP
		RETURN NEXT out_location;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function lock_record(in_session_id integer, in_id integer) -->
    <section id="public.function.lock-record-in-session-id-integer-in-id-integer"
             xreflabel="publiclock_record(in_session_id integer, in_id integer)">
      <title id="public.function.lock-record-in-session-id-integer-in-id-integer-title">
       lock_record(in_session_id integer, in_id integer)
      </title>
      <titleabbrev id="public.function.lock-record-in-session-id-integer-in-id-integer-titleabbrev">
       lock_record(in_session_id integer, in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function seeks to lock a record with an id of in_id to a session with an
id of in_session_id.  If possible, it returns true.  If it is already locked,
false.  These are not hard locks and the application is free to disregard or 
not even ask.  They time out when the session is destroyed.

        <programlisting>
declare
   locked int;
begin
   SELECT locked_by into locked from transactions where id = $1;
   IF NOT FOUND THEN
	RETURN FALSE;
   ELSEIF locked is not null AND locked &lt;&gt; $2 THEN
        RETURN FALSE;
   END IF;
   UPDATE transactions set locked_by = $2 where id = $1;
   RETURN TRUE;
end;
</programlisting>
      </para>
    </section>

<!-- Function lsmb__decompose_timestamp(in_timestamp timestamp with time zone) -->
    <section id="public.function.lsmb-decompose-timestamp-in-timestamp-timestamp-with-time-zone"
             xreflabel="publiclsmb__decompose_timestamp(in_timestamp timestamp with time zone)">
      <title id="public.function.lsmb-decompose-timestamp-in-timestamp-timestamp-with-time-zone-title">
       lsmb__decompose_timestamp(in_timestamp timestamp with time zone)
      </title>
      <titleabbrev id="public.function.lsmb-decompose-timestamp-in-timestamp-timestamp-with-time-zone-titleabbrev">
       lsmb__decompose_timestamp(in_timestamp timestamp with time zone)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>lsmb_date_fields</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT extract(&#39;century&#39; from $1) as century, 
       extract(&#39;decade&#39; from $1) as decade,
       extract(&#39;year&#39; from $1) as year,
       extract(&#39;month&#39; from $1) as month,
       extract(&#39;day&#39; from $1) as day,
       extract(&#39;hour&#39; from $1) as hour,
       extract(&#39;minute&#39; from $1) as minute,
       extract(&#39;second&#39; from $1) as second,
       extract(&#39;quarter&#39; from $1) as quarter,
       extract(&#39;doy&#39; from $1) as doy,
       extract(&#39;dow&#39; from $1) as dow,
       extract(&#39;week&#39; from $1) as week,
       extract(&#39;epoch&#39; from $1) as epoch,
       $1::date as as_date,
       $1::time as as_time;
</programlisting>
      </para>
    </section>

<!-- Function lsmb_module__get(in_id integer) -->
    <section id="public.function.lsmb-module-get-in-id-integer"
             xreflabel="publiclsmb_module__get(in_id integer)">
      <title id="public.function.lsmb-module-get-in-id-integer-title">
       lsmb_module__get(in_id integer)
      </title>
      <titleabbrev id="public.function.lsmb-module-get-in-id-integer-titleabbrev">
       lsmb_module__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>lsmb_module</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a single module&apos;s info by id. 
        <programlisting> SELECT * FROM lsmb_module where id = $1; </programlisting>
      </para>
    </section>

<!-- Function lsmb_module__list() -->
    <section id="public.function.lsmb-module-list"
             xreflabel="publiclsmb_module__list()">
      <title id="public.function.lsmb-module-list-title">
       lsmb_module__list()
      </title>
      <titleabbrev id="public.function.lsmb-module-list-titleabbrev">
       lsmb_module__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF lsmb_module</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of all defined modules, ordered by id. 
        <programlisting> SELECT * FROM lsmb_module ORDER BY id </programlisting>
      </para>
    </section>

<!-- Function menu_children(in_parent_id integer) -->
    <section id="public.function.menu-children-in-parent-id-integer"
             xreflabel="publicmenu_children(in_parent_id integer)">
      <title id="public.function.menu-children-in-parent-id-integer-title">
       menu_children(in_parent_id integer)
      </title>
      <titleabbrev id="public.function.menu-children-in-parent-id-integer-titleabbrev">
       menu_children(in_parent_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF menu_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns all menu  items which are children of in_parent_id 
(the only input parameter). 

It is thus similar to menu_generate() but it only returns the menu items 
associated with nodes directly descendant from the parent.  It is used for
menues for frameless browsers.
        <programlisting>
SELECT * FROM menu_generate() where parent = $1;
</programlisting>
      </para>
    </section>

<!-- Function menu_generate() -->
    <section id="public.function.menu-generate"
             xreflabel="publicmenu_generate()">
      <title id="public.function.menu-generate-title">
       menu_generate()
      </title>
      <titleabbrev id="public.function.menu-generate-titleabbrev">
       menu_generate()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF menu_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function returns the complete menu tree.  It is used to generate nested
menus for the web interface.

        <programlisting>
DECLARE 
	item menu_item;
	arg menu_attribute%ROWTYPE;
BEGIN
	FOR item IN 
               WITH RECURSIVE tree (path, id, parent, level, positions)
                               AS (select id::text as path, id, parent, 
                                           0 as level, position::text
                                      FROM menu_node where parent is null
                                     UNION 
                                    select path || &#39;,&#39; || n.id::text, n.id, 
                                           n.parent,
                                           t.level + 1, 
                                           t.positions || &#39;,&#39; || n.position
                                      FROM menu_node n
                                      JOIN tree t ON t.id = n.parent) 
		SELECT n.position, n.id, c.level, n.label, c.path, n.parent,
                       to_args(array[ma.attribute, ma.value])
		FROM tree c
		JOIN menu_node n USING(id)
                JOIN menu_attribute ma ON (n.id = ma.node_id)
               WHERE n.id IN (select node_id 
                                FROM menu_acl acl
                          LEFT JOIN pg_roles pr on pr.rolname = acl.role_name
                               WHERE CASE WHEN role_name 
                                                           ilike &#39;public&#39;
                                                      THEN true
                                                      WHEN rolname IS NULL
                                                      THEN FALSE
                                                      ELSE pg_has_role(rolname,
                                                                       &#39;USAGE&#39;)
                                      END
                            GROUP BY node_id
                              HAVING bool_and(CASE WHEN acl_type ilike &#39;DENY&#39;
                                                   THEN FALSE
                                                   WHEN acl_type ilike &#39;ALLOW&#39;
                                                   THEN TRUE
                                                END))
                    or exists (select cn.id, cc.path
                                 FROM tree cc
                                 JOIN menu_node cn USING(id)
                                WHERE cn.id IN 
                                      (select node_id 
                                         FROM menu_acl acl
                                    LEFT JOIN pg_roles pr 
                                              on pr.rolname = acl.role_name
                                        WHERE CASE WHEN rolname 
                                                           ilike &#39;public&#39;
                                                      THEN true
                                                      WHEN rolname IS NULL
                                                      THEN FALSE
                                                      ELSE pg_has_role(rolname,
                                                                       &#39;USAGE&#39;)
                                                END
                                     GROUP BY node_id
                                       HAVING bool_and(CASE WHEN acl_type 
                                                                 ilike &#39;DENY&#39;
                                                            THEN false
                                                            WHEN acl_type 
                                                                 ilike &#39;ALLOW&#39;
                                                            THEN TRUE
                                                         END))
                                       and cc.path::text 
                                           like c.path::text || &#39;,%&#39;)
            GROUP BY n.position, n.id, c.level, n.label, c.path, c.positions,
                     n.parent
            ORDER BY string_to_array(c.positions, &#39;,&#39;)::int[]
	LOOP
		RETURN NEXT item;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function menu_insert(in_label integer, in_position integer, in_parent_id text) -->
    <section id="public.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text"
             xreflabel="publicmenu_insert(in_label integer, in_position integer, in_parent_id text)">
      <title id="public.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text-title">
       menu_insert(in_label integer, in_position integer, in_parent_id text)
      </title>
      <titleabbrev id="public.function.menu-insert-in-label-integer-in-position-integer-in-parent-id-text-titleabbrev">
       menu_insert(in_label integer, in_position integer, in_parent_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function inserts menu items at arbitrary positions.  The arguments are, in
order:  parent, position, label.  The return value is the id number of the menu
item created. 
        <programlisting>
DECLARE
	new_id int;
BEGIN
	UPDATE menu_node 
	SET position = position * -1
	WHERE parent = in_parent_id
		AND position &gt;= in_position;

	INSERT INTO menu_node (parent, position, label)
	VALUES (in_parent_id, in_position, in_label);

	SELECT INTO new_id currval(&#39;menu_node_id_seq&#39;);

	UPDATE menu_node 
	SET position = (position * -1) + 1
	WHERE parent = in_parent_id
		AND position &lt; 0;

	RETURN new_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function months_passed(in_end timestamp without time zone, in_start timestamp without time zone) -->
    <section id="public.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone"
             xreflabel="publicmonths_passed(in_end timestamp without time zone, in_start timestamp without time zone)">
      <title id="public.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone-title">
       months_passed(in_end timestamp without time zone, in_start timestamp without time zone)
      </title>
      <titleabbrev id="public.function.months-passed-in-end-timestamp-without-time-zone-in-start-timestamp-without-time-zone-titleabbrev">
       months_passed(in_end timestamp without time zone, in_start timestamp without time zone)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the number of months between in_start and in_end.
        <programlisting>

-- The addition of one day is so that it will return &#39;1&#39; when run on the end
-- day of consecutive months.

select (extract (months from age($2 + &#39;1 day&#39;, $1 + &#39;1 day&#39;))
       + extract (years from age($2, $1)) * 12)::int;
</programlisting>
      </para>
    </section>

<!-- Function next_leap_year_calc(is_end date, in_date boolean) -->
    <section id="public.function.next-leap-year-calc-is-end-date-in-date-boolean"
             xreflabel="publicnext_leap_year_calc(is_end date, in_date boolean)">
      <title id="public.function.next-leap-year-calc-is-end-date-in-date-boolean-title">
       next_leap_year_calc(is_end date, in_date boolean)
      </title>
      <titleabbrev id="public.function.next-leap-year-calc-is-end-date-in-date-boolean-titleabbrev">
       next_leap_year_calc(is_end date, in_date boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Next relevant leap year calculation for a daily depreciation calculation
        <programlisting>
SELECT 
          (CASE WHEN extract(&#39;doy&#39; FROM $1) &lt; 59
          THEN extract(&#39;year&#39; FROM $1)
          ELSE extract(&#39;year&#39; FROM $1) + 1
          END)::int
          -
          CASE WHEN $2 THEN 1 ELSE 0 END;
</programlisting>
      </para>
    </section>

<!-- Function order__combine(in_ids integer[]) -->
    <section id="public.function.order-combine-in-ids-integerARRAY"
             xreflabel="publicorder__combine(in_ids integer[])">
      <title id="public.function.order-combine-in-ids-integerARRAY-title">
       order__combine(in_ids integer[])
      </title>
      <titleabbrev id="public.function.order-combine-in-ids-integerARRAY-titleabbrev">
       order__combine(in_ids integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF oe</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE retval oe;
        ordercount int;
        ids int[];
        loop_info record;
        settings text[];
        my_person_id int;
BEGIN

SELECT id INTO my_person_id 
  FROM person 
 WHERE entity_id = person__get_my_entity_id();

settings := ARRAY[&#39;sonumber&#39;, &#39;ponumber&#39;, &#39;sqnumber&#39;, &#39;rfqnumber&#39;];
ids := array[]::int[];

-- This approach of looping through insert/select operations will break down 
-- if overly complex order consolidation jobs are run (think, hundreds of 
-- combined orders in the *output*
--
-- The tradeoff is that if we address the huge complex runs here, then we have
-- the possibility of having to lock the whole table which poses other issues.
-- For that reason, I am going with this approach for now. --CT

FOR loop_info IN
       SELECT max(id) as id, taxincluded, entity_credit_account, oe_class_id,
              curr
         FROM oe WHERE id = any(in_ids)
     GROUP BY taxincluded, entity_credit_account, oe_class_id, curr
LOOP

INSERT INTO oe
       (ordnumber, transdate,   amount,        netamount,
        reqdate,   taxincluded, shippingpoint, notes,
        curr,      person_id,   closed,        quotation, 
        quonumber, intnotes,    shipvia,       language_code,
        ponumber,  terms,       oe_class_id,   entity_credit_account)
SELECT CASE WHEN oe_class_id IN (1, 2) 
            THEN setting_increment(settings[oe_class_id])
            ELSE NULL
        END,          now()::date,        sum(amount),        sum(netamount),
        min(reqdate), taxincluded,        min(shippingpoint), &#39;&#39;,
        curr,         my_person_id, false, false,
        CASE WHEN oe_class_id IN (3, 4)
            THEN setting_increment(settings[oe_class_id])
            ELSE NULL
        END,          NULL,      NULL,          NULL,
        null,       min(terms),  oe_class_id,  entity_credit_account
  FROM oe 
 WHERE id = any (in_ids)
       AND taxincluded = loop_info.taxincluded
       AND entity_credit_account = loop_info.entity_credit_account
       AND oe_class_id = loop_info.oe_class_id
 GROUP BY curr, taxincluded, oe_class_id, entity_credit_account;


INSERT INTO orderitems
       (trans_id,      parts_id,        description,         qty,
        sellprice,     precision,       discount,            unit,
        reqdate,       ship,            serialnumber,        notes)
SELECT currval(&#39;oe_id_seq&#39;), oi.parts_id, oi.description,     oi.qty,
       oi.sellprice,   oi.precision,    oi.discount,         oi.unit,
       oi.reqdate,     oi.ship,         oi.serialnumber,     oi.notes
  FROM orderitems oi
  JOIN oe ON oi.trans_id = oe.id
 WHERE oe.id = any (in_ids)
       AND taxincluded = loop_info.taxincluded
       AND entity_credit_account = loop_info.entity_credit_account
       AND oe_class_id = loop_info.oe_class_id;

ids := ids || currval(&#39;oe_id_seq&#39;)::int;

END LOOP;

UPDATE oe SET closed = true WHERE id = any(in_ids);

FOR retval IN select * from oe WHERE id =any(ids)
LOOP
   RETURN NEXT retval;
END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function order__search(in_buisness_units integer, in_shippable text, in_date_to text, in_date_from text, in_description text, in_shipvia boolean, in_closed boolean, in_open text, in_ordnumber text, in_ponumber date, in_legal_name date, in_meta_number boolean, in_oe_class_id integer[]) -->
    <section id="public.function.order-search-in-buisness-units-integer-in-shippable-text-in-date-to-text-in-date-from-text-in-description-text-in-shipvia-boolean-in-closed-boolean-in-open-text-in-ordnumber-text-in-ponumber-date-in-legal-name-date-in-meta-number-boolean-in-oe-class-id-integerARRAY"
             xreflabel="publicorder__search(in_buisness_units integer, in_shippable text, in_date_to text, in_date_from text, in_description text, in_shipvia boolean, in_closed boolean, in_open text, in_ordnumber text, in_ponumber date, in_legal_name date, in_meta_number boolean, in_oe_class_id integer[])">
      <title id="public.function.order-search-in-buisness-units-integer-in-shippable-text-in-date-to-text-in-date-from-text-in-description-text-in-shipvia-boolean-in-closed-boolean-in-open-text-in-ordnumber-text-in-ponumber-date-in-legal-name-date-in-meta-number-boolean-in-oe-class-id-integerARRAY-title">
       order__search(in_buisness_units integer, in_shippable text, in_date_to text, in_date_from text, in_description text, in_shipvia boolean, in_closed boolean, in_open text, in_ordnumber text, in_ponumber date, in_legal_name date, in_meta_number boolean, in_oe_class_id integer[])
      </title>
      <titleabbrev id="public.function.order-search-in-buisness-units-integer-in-shippable-text-in-date-to-text-in-date-from-text-in-description-text-in-shipvia-boolean-in-closed-boolean-in-open-text-in-ordnumber-text-in-ponumber-date-in-legal-name-date-in-meta-number-boolean-in-oe-class-id-integerARRAY-titleabbrev">
       order__search(in_buisness_units integer, in_shippable text, in_date_to text, in_date_from text, in_description text, in_shipvia boolean, in_closed boolean, in_open text, in_ordnumber text, in_ponumber date, in_legal_name date, in_meta_number boolean, in_oe_class_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF order_search_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE retval order_search_line;

BEGIN

FOR retval IN
       SELECT o.id, 
              CASE WHEN oe_class_id IN (1, 2) THEN o.ordnumber
                   WHEN oe_class_id IN (3, 4) THEN o.quonumber
                   ELSE NULL
               END as ordnumber, o.transdate, o.reqdate,
              o.amount, c.legal_name AS name, o.netamount, 
              o.entity_credit_account, o.closed, o.quonumber, o.shippingpoint,
              CASE WHEN ct.entity_class = 2 THEN ex.buy ELSE ex.sell END
              AS exchangerate, o.shipvia, pe.first_name || &#39; &#39; || pe.last_name 
              AS employee, pm.first_name || &#39; &#39; || pm.last_name AS manager, 
              o.curr, o.ponumber, ct.meta_number, c.entity_id
         FROM oe o
         JOIN entity_credit_account ct ON (o.entity_credit_account = ct.id)
         JOIN company c ON (c.entity_id = ct.entity_id)
    LEFT JOIN person pe ON (o.person_id = pe.id)
    LEFT JOIN entity_employee e ON (pe.entity_id = e.entity_id)
    LEFT JOIN person pm ON (e.manager_id = pm.id)
    LEFT JOIN entity_employee m ON (pm.entity_id = m.entity_id)
    LEFT JOIN exchangerate ex 
              ON (ex.curr = o.curr AND ex.transdate = o.transdate)
        WHERE o.oe_class_id = in_oe_class_id
             AND (in_meta_number IS NULL 
                   or ct.meta_number ILIKE in_meta_number || &#39;%&#39;)
             AND (in_legal_name IS NULL OR
                     c.legal_name @@ plainto_tsquery(in_legal_name))
             AND (in_ponumber IS NULL OR o.ponumber ILIKE in_ponumber || &#39;%&#39;)
            AND (in_ordnumber IS NULL 
                     OR o.ordnumber ILIKE in_ordnumber || &#39;%&#39;)
             AND (in_open is true or o.closed is false)
             AND (in_closed is true or o.closed is true)
             AND (in_shipvia IS NULL 
                      OR o.shipvia @@ plainto_tsquery(in_shipvia))
             AND (in_description IS NULL AND in_shippable IS NULL OR
                     EXISTS (SELECT 1 
                               FROM orderitems oi 
                               JOIN parts p ON p.id = oi.parts_id
                              WHERE trans_id = o.id
                                    AND (in_description IS NULL OR 
                                        oi.description 
                                        @@ plainto_tsquery(in_description))
                                    AND (in_shippable IS NULL OR
                                         p.assembly OR 
                                         p.inventory_accno_id IS NOT NULL))
                 )
             AND (in_date_from IS NULL OR o.transdate &gt;= in_date_from)
             AND (in_date_to IS NULL OR o.transdate &lt;= in_date_to)
                                    
LOOP
   RETURN NEXT retval;
END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function parse_date(in_date date) -->
    <section id="public.function.parse-date-in-date-date"
             xreflabel="publicparse_date(in_date date)">
      <title id="public.function.parse-date-in-date-date-title">
       parse_date(in_date date)
      </title>
      <titleabbrev id="public.function.parse-date-in-date-date-titleabbrev">
       parse_date(in_date date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>date</seg>
        </seglistitem>
       </segmentedlist>
 
        Simple way to cast a Perl string to a
date format of known type. 
        <programlisting> select $1; </programlisting>
      </para>
    </section>

<!-- Function parts__get_by_id(in_id integer) -->
    <section id="public.function.parts-get-by-id-in-id-integer"
             xreflabel="publicparts__get_by_id(in_id integer)">
      <title id="public.function.parts-get-by-id-in-id-integer-title">
       parts__get_by_id(in_id integer)
      </title>
      <titleabbrev id="public.function.parts-get-by-id-in-id-integer-titleabbrev">
       parts__get_by_id(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM parts WHERE id = $1;
</programlisting>
      </para>
    </section>

<!-- Function parts__get_by_partnumber(in_partnumber text) -->
    <section id="public.function.parts-get-by-partnumber-in-partnumber-text"
             xreflabel="publicparts__get_by_partnumber(in_partnumber text)">
      <title id="public.function.parts-get-by-partnumber-in-partnumber-text-title">
       parts__get_by_partnumber(in_partnumber text)
      </title>
      <titleabbrev id="public.function.parts-get-by-partnumber-in-partnumber-text-titleabbrev">
       parts__get_by_partnumber(in_partnumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM PARTS WHERE partnumber = $1 and obsolete is not true; 
</programlisting>
      </para>
    </section>

<!-- Function parts__search_lite(in_description text, in_partnumber text) -->
    <section id="public.function.parts-search-lite-in-description-text-in-partnumber-text"
             xreflabel="publicparts__search_lite(in_description text, in_partnumber text)">
      <title id="public.function.parts-search-lite-in-description-text-in-partnumber-text-title">
       parts__search_lite(in_description text, in_partnumber text)
      </title>
      <titleabbrev id="public.function.parts-search-lite-in-description-text-in-partnumber-text-titleabbrev">
       parts__search_lite(in_description text, in_partnumber text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * 
  FROM parts 
 WHERE ($1 IS NULL OR (partnumber like $1 || &#39;%&#39;))
       AND ($2 IS NULL 
            OR (description
                @@
                plainto_tsquery(get_default_lang()::regconfig, $2)))
       AND not obsolete
ORDER BY partnumber;
</programlisting>
      </para>
    </section>

<!-- Function payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar) -->
    <section id="public.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar"
             xreflabel="publicpayment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)">
      <title id="public.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar-title">
       payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)
      </title>
      <titleabbrev id="public.function.payment-reverse-in-currency-text-in-exchangerate-date-in-voucher-id-integer-in-batch-id-text-in-account-class-date-in-date-reversed-integer-in-cash-accno-integer-in-credit-id-integer-in-date-paid-numeric-in-source-bpchar-titleabbrev">
       payment__reverse(in_currency text, in_exchangerate date, in_voucher_id integer, in_batch_id text, in_account_class date, in_date_reversed integer, in_cash_accno integer, in_credit_id integer, in_date_paid numeric, in_source bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
Reverses a payment.  All fields are mandatory except batch_id and voucher_id
because they determine the identity of the payment to be reversed.

        <programlisting>
DECLARE
	pay_row record;
        t_voucher_id int;
        t_voucher_inserted bool;
        t_currs text[];
        t_rev_fx numeric;
        t_fxgain_id int;
        t_fxloss_id int;
        t_paid_fx numeric;
BEGIN
        SELECT * INTO t_rev_fx FROM currency_get_exchangerate(
              in_currency, in_date_reversed, in_account_class);

        SELECT * INTO t_paid_fx FROM currency_get_exchangerate(
              in_currency, in_date_paid, in_account_class);

       select value::int INTO t_fxgain_id FROM setting_get(&#39;fxgain_accno_id&#39;);
       select value::int INTO t_fxloss_id FROM setting_get(&#39;fxloss_accno_id&#39;);

       SELECT string_to_array(value, &#39;:&#39;) into t_currs
          from defaults
         where setting_key = &#39;curr&#39;;

        IF in_currency IS NULL OR in_currency = t_currs[1] THEN
                t_rev_fx := 1;
                t_paid_fx := 1;
        ELSIF t_rev_fx IS NULL THEN
                t_rev_fx := in_exchangerate;
                PERFORM payments_set_exchangerate(in_account_class,
                                                  in_exchangerate,
                                                  in_currency,
                                                  in_date_reversed);
        ELSIF t_rev_fx &lt;&gt; in_exchangerate THEN
                RAISE EXCEPTION &#39;Exchange rate different than on file&#39;;
        END IF;
        IF t_rev_fx IS NULL THEN
            RAISE EXCEPTION &#39;No exchangerate provided and not default currency&#39;;
        END IF;


        IF in_batch_id IS NOT NULL THEN
		t_voucher_id := nextval(&#39;voucher_id_seq&#39;);
		t_voucher_inserted := FALSE;
	END IF;
	FOR pay_row IN 
		SELECT a.*, c.ar_ap_account_id, arap.curr, arap.fxrate
		FROM acc_trans a
		JOIN (select id, curr, entity_credit_account, 
                             CASE WHEN curr = t_currs[1] THEN 1
                                   ELSE buy END as fxrate
			FROM ar 
                   LEFT JOIN exchangerate USING (transdate, curr)
                       WHERE in_account_class = 2
			UNION
			SELECT id, curr, entity_credit_account, 
                               CASE WHEN curr = t_currs[1] THEN 1
                                    ELSE sell END as fxrate
			FROM ap
                   LEFT JOIN exchangerate USING (transdate, curr)
                       WHERE in_account_class = 1
		) arap ON (a.trans_id = arap.id)
		JOIN entity_credit_account c 
			ON (arap.entity_credit_account = c.id)
		JOIN account ch ON (a.chart_id = ch.id)
		WHERE a.source IS NOT DISTINCT FROM in_source
			AND a.transdate = in_date_paid
			AND in_credit_id = arap.entity_credit_account
			AND in_cash_accno = ch.accno
                        and in_voucher_id IS NOT DISTINCT FROM voucher_id
	LOOP
                IF pay_row.curr = t_currs[1] THEN
                   pay_row.fxrate = 1;
                END IF;

		IF in_batch_id IS NOT NULL 
			AND t_voucher_inserted IS NOT TRUE
		THEN
			INSERT INTO voucher 
			(id, trans_id, batch_id, batch_class)
			VALUES
			(t_voucher_id, pay_row.trans_id, in_batch_id,
				CASE WHEN in_account_class = 1 THEN 4
				     WHEN in_account_class = 2 THEN 7
				END);

			t_voucher_inserted := TRUE;
		END IF;

		INSERT INTO acc_trans
		(trans_id, chart_id, amount, transdate, source, memo, approved,
			voucher_id) 
		VALUES 
		(pay_row.trans_id, pay_row.chart_id, 
                        pay_row.amount / t_paid_fx * -1 * t_rev_fx, 
			in_date_reversed, in_source, &#39;Reversing &#39; || 
			COALESCE(in_source, &#39;&#39;), 
			case when in_batch_id is not null then false 
			else true end, t_voucher_id),
                 (pay_row.trans_id, pay_row.ar_ap_account_id, 
                        pay_row.amount / t_paid_fx * pay_row.fxrate,
			in_date_reversed, in_source, &#39;Reversing &#39; ||
			COALESCE(in_source, &#39;&#39;), 
			case when in_batch_id is not null then false 
			else true end, t_voucher_id),
                 (pay_row.trans_id, 
                  case when pay_row.fxrate &gt; t_rev_fx 
                       THEN t_fxloss_id ELSE t_fxgain_id END, 
                  pay_row.amount / t_paid_fx * (t_rev_fx - pay_row.fxrate),
                  in_date_reversed, in_source, &#39;Reversing &#39; ||  
                                                COALESCE(in_source, &#39;&#39;),
                   case when in_batch_id is not null then false
                        else true end, t_voucher_id);

                   
	END LOOP;
	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment__search(in_currency text, in_entity_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar) -->
    <section id="public.function.payment-search-in-currency-text-in-entity-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar"
             xreflabel="publicpayment__search(in_currency text, in_entity_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)">
      <title id="public.function.payment-search-in-currency-text-in-entity-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar-title">
       payment__search(in_currency text, in_entity_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)
      </title>
      <titleabbrev id="public.function.payment-search-in-currency-text-in-entity-class-date-in-cash-accno-date-in-credit-id-integer-in-date-to-text-in-date-from-integer-in-source-bpchar-titleabbrev">
       payment__search(in_currency text, in_entity_class date, in_cash_accno date, in_credit_id integer, in_date_to text, in_date_from integer, in_source bpchar)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_record</seg>
        </seglistitem>
       </segmentedlist>
 
       This searches for payments.  in_date_to and _date_from specify the acceptable
date range.  All other matches are exact except that null matches all values.

Currently (and to support earlier data) we define a payment as a collection of
acc_trans records against the same credit account and cash account, on the same
day with the same source number, and optionally the same voucher id.
        <programlisting>
DECLARE 
	out_row payment_record;
BEGIN
	FOR out_row IN 
		select sum(CASE WHEN c.entity_class = 1 then a.amount
				ELSE a.amount * -1 END), c.meta_number, 
			c.id, co.legal_name,
			compound_array(ARRAY[ARRAY[ch.id::text, ch.accno, 
				ch.description]]), a.source, 
			b.control_code, b.description, a.voucher_id, a.transdate
		FROM entity_credit_account c
		JOIN ( select entity_credit_account, id, curr
			FROM ar WHERE in_entity_class = 2
			UNION
			SELECT entity_credit_account, id, curr
			FROM ap WHERE in_entity_class = 1
			) arap ON (arap.entity_credit_account = c.id)
		JOIN acc_trans a ON (arap.id = a.trans_id)
		JOIN chart ch ON (ch.id = a.chart_id)
		JOIN company co ON (c.entity_id = co.entity_id)
		LEFT JOIN voucher v ON (v.id = a.voucher_id)
		LEFT JOIN batch b ON (b.id = v.batch_id)
		WHERE (ch.accno = in_cash_accno)
                        AND (in_currency IS NULL OR in_currency = arap.curr)
			AND (c.id = in_credit_id OR in_credit_id IS NULL)
			AND (a.transdate &gt;= in_date_from 
				OR in_date_from IS NULL)
			AND (a.transdate &lt;= in_date_to OR in_date_to IS NULL)
			AND (source = in_source OR in_source IS NULL)
		GROUP BY c.meta_number, c.id, co.legal_name, a.transdate, 
			a.source, a.memo, b.id, b.control_code, b.description, 
                        voucher_id
		ORDER BY a.transdate, c.meta_number, a.source
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text) -->
    <section id="public.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text"
             xreflabel="publicpayment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)">
      <title id="public.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text-title">
       payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)
      </title>
      <titleabbrev id="public.function.payment-bulk-post-in-currency-numericARRAY-in-exchangerate-integer-in-account-class-text-in-payment-date-numeric-in-cash-accno-text-in-ar-ap-accno-text-in-total-date-in-source-integer-in-batch-id-numeric-in-transactions-text-titleabbrev">
       payment_bulk_post(in_currency numeric[], in_exchangerate integer, in_account_class text, in_payment_date numeric, in_cash_accno text, in_ar_ap_accno text, in_total date, in_source integer, in_batch_id numeric, in_transactions text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        This posts the payments for large batch workflows.

Note that in_transactions is a two-dimensional numeric array.  Of each 
sub-array, the first element is the (integer) transaction id, and the second
is the amount for that transaction.  
        <programlisting>
DECLARE 
        out_count int;
        t_voucher_id int;
        t_trans_id int;
        t_amount numeric;
        t_ar_ap_id int;
        t_cash_id int;
        t_currs text[];
        t_exchangerate numeric;
        t_cash_sign int;
BEGIN

        SELECT * INTO t_exchangerate FROM currency_get_exchangerate(
              in_currency, in_payment_date, in_account_class);

        IF in_batch_id IS NULL THEN
                -- t_voucher_id := NULL;
                RAISE EXCEPTION &#39;Bulk Post Must be from Batch!&#39;;
        ELSE
                INSERT INTO voucher (batch_id, batch_class, trans_id)
                values (in_batch_id,
                (SELECT batch_class_id FROM batch WHERE id = in_batch_id),
                in_transactions[1][1]);

                t_voucher_id := currval(&#39;voucher_id_seq&#39;);
        END IF;

        SELECT string_to_array(value, &#39;:&#39;) into t_currs 
          from defaults 
         where setting_key = &#39;curr&#39;;

        IF (in_currency IS NULL OR in_currency = t_currs[1]) THEN
                t_exchangerate := 1;
        ELSIF t_exchangerate IS NULL THEN
                t_exchangerate := in_exchangerate;
                PERFORM payments_set_exchangerate(in_account_class,
                                                  in_exchangerate, 
                                                  in_currency,
                                                  in_payment_date);
        ELSIF t_exchangerate &lt;&gt; in_exchangerate THEN
                RAISE EXCEPTION &#39;Exchange rate different than on file&#39;;
        END IF;
        IF t_exchangerate IS NULL THEN
            RAISE EXCEPTION &#39;No exchangerate provided and not default currency&#39;;
        END IF;

        CREATE TEMPORARY TABLE bulk_payments_in
           (id int, amount numeric, fxrate numeric, gain_loss_accno int);

        select id into t_ar_ap_id from chart where accno = in_ar_ap_accno;
        select id into t_cash_id from chart where accno = in_cash_accno;

        FOR out_count IN 
                        array_lower(in_transactions, 1) ..
                        array_upper(in_transactions, 1)
        LOOP
            -- Fill the bulk payments table
            INSERT INTO bulk_payments_in(id, amount)
            VALUES (in_transactions[out_count][1],
                    in_transactions[out_count][2]);
        END LOOP;

        IF in_account_class = 1 THEN
            t_cash_sign := 1;
        ELSE
            t_cash_sign := -1;
        END IF;

        IF (in_currency IS NULL OR in_currency = t_currs[1]) THEN
            UPDATE bulk_payments_in
               SET fxrate = 1;
        ELSE
            UPDATE bulk_payments_in
               SET fxrate =
                (SELECT CASE WHEN in_account_class = 1 THEN sell
                             ELSE buy
                        END
                   FROM exchangerate e
                   JOIN (SELECT transdate, id, curr FROM ar
                         UNION
                         SELECT transdate, id, curr FROM ap) a
                     ON (e.transdate = a.transdate
                         AND e.curr = a.curr)
                   WHERE a.id = bulk_payments_in.id);
            UPDATE bulk_payments_in
               SET gain_loss_accno =
                (SELECT value::int FROM defaults
                  WHERE setting_key = &#39;fxgain_accno_id&#39;)
             WHERE ((t_exchangerate - bulk_payments_in.fxrate) * t_cash_sign) &lt; 0;
            UPDATE bulk_payments_in
               SET gain_loss_accno = (SELECT value::int FROM defaults
                  WHERE setting_key = &#39;fxloss_accno_id&#39;)
             WHERE ((t_exchangerate - bulk_payments_in.fxrate) * t_cash_sign) &gt; 0;
            -- explicitly leave zero gain/loss accno_id entries at NULL
            -- so we have an easy check for which 
        END IF;

        -- Insert cash side
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, t_cash_id, amount * t_cash_sign * t_exchangerate/fxrate,
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in  where amount &lt;&gt; 0;

        -- early payment discounts
        INSERT INTO acc_trans
               (trans_id, chart_id, amount, approved,
               voucher_id, transdate, source)
        SELECT bpi.id, eca.discount_account_id, 
               amount * t_cash_sign * t_exchangerate/fxrate 
               / (1 - discount::numeric/100) 
               * (discount::numeric/100),
               CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
               t_voucher_id, in_payment_date, in_source
          FROM bulk_payments_in bpi
          JOIN (select entity_credit_account, id, transdate FROM ar 
                 WHERE in_account_class = 2
                 UNION
                SELECT entity_credit_account, id, transdate FROM ap
                 WHERE in_account_class = 1) gl ON gl.id = bpi.id
          JOIN entity_credit_account eca ON gl.entity_credit_account = eca.id
         WHERE bpi.amount &lt;&gt; 0 
               AND extract(&#39;days&#39; from age(gl.transdate)) &lt; eca.discount_terms;

        INSERT INTO acc_trans
               (trans_id, chart_id, amount, approved,
               voucher_id, transdate, source)
        SELECT bpi.id, t_ar_ap_id, 
               amount * t_cash_sign * -1 * t_exchangerate/fxrate 
               / (1 - discount::numeric/100) 
               * (discount::numeric/100),
               CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
               t_voucher_id, in_payment_date, in_source
          FROM bulk_payments_in bpi
          JOIN (select entity_credit_account, id, transdate FROM ar 
                 WHERE in_account_class = 2
                 UNION
                SELECT entity_credit_account, id, transdate FROM ap
                 WHERE in_account_class = 1) gl ON gl.id = bpi.id
          JOIN entity_credit_account eca ON gl.entity_credit_account = eca.id
         WHERE bpi.amount &lt;&gt; 0 
               AND extract(&#39;days&#39; from age(gl.transdate)) &lt; eca.discount_terms;

        -- Insert ar/ap side
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, t_ar_ap_id,
                  amount * -1 * t_cash_sign,
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in where amount &lt;&gt; 0;

        -- Insert fx gain/loss effects, if applicable
        INSERT INTO acc_trans
             (trans_id, chart_id, amount, approved,
              voucher_id, transdate, source)
           SELECT id, gain_loss_accno,
                  amount * t_cash_sign * (1 - t_exchangerate/fxrate),
                  CASE WHEN t_voucher_id IS NULL THEN true
                       ELSE false END,
                  t_voucher_id, in_payment_date, in_source
             FROM bulk_payments_in
            WHERE amount &lt;&gt; 0 AND gain_loss_accno IS NOT NULL;

        DROP TABLE bulk_payments_in;
        perform unlock_all();
        return out_count;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_gather_header_info(in_payment_id integer, in_account_class integer) -->
    <section id="public.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer"
             xreflabel="publicpayment_gather_header_info(in_payment_id integer, in_account_class integer)">
      <title id="public.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer-title">
       payment_gather_header_info(in_payment_id integer, in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-gather-header-info-in-payment-id-integer-in-account-class-integer-titleabbrev">
       payment_gather_header_info(in_payment_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_header_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function finds a payment based on the id and retrieves the record, 
it is usefull for printing payments :) 
        <programlisting>
 DECLARE out_payment payment_header_item;
 BEGIN
 FOR out_payment IN 
   SELECT p.id as payment_id, p.reference as payment_reference, p.payment_date,  
          c.legal_name as legal_name, am.amount as amount, em.first_name, em.last_name, p.currency, p.notes
   FROM payment p
   JOIN entity_employee ent_em ON (ent_em.entity_id = p.employee_id)
   JOIN person em ON (ent_em.entity_id = em.entity_id)
   JOIN entity_credit_account eca ON (eca.id = p.entity_credit_id)
   JOIN company c ON   (c.entity_id  = eca.entity_id)
   JOIN payment_links pl ON (p.id = pl.payment_id)
   LEFT JOIN (  SELECT sum(a.amount) as amount
 		FROM acc_trans a
 		JOIN account acc ON (a.chart_id = acc.id)
                JOIN account_link al ON (acc.id =al.account_id)
 		JOIN payment_links pl ON (pl.entry_id=a.entry_id)
 		WHERE al.description in  
                       (&#39;AP_paid&#39;, &#39;AP_discount&#39;, &#39;AR_paid&#39;, &#39;AR_discount&#39;) 
                       and ((in_account_class = 1 AND al.description like &#39;AP%&#39;)
                       or (in_account_class = 2 AND al.description like &#39;AR%&#39;))
             ) am ON (true)
   WHERE p.id = in_payment_id
 LOOP
     RETURN NEXT out_payment;
 END LOOP;

 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_gather_line_info(in_payment_id integer, in_account_class integer) -->
    <section id="public.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer"
             xreflabel="publicpayment_gather_line_info(in_payment_id integer, in_account_class integer)">
      <title id="public.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer-title">
       payment_gather_line_info(in_payment_id integer, in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-gather-line-info-in-payment-id-integer-in-account-class-integer-titleabbrev">
       payment_gather_line_info(in_payment_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_line_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This function finds a payment based on the id and retrieves all the line records, 
it is usefull for printing payments and build reports :) 
        <programlisting>
 DECLARE out_payment_line payment_line_item;
 BEGIN
   FOR out_payment_line IN 
     SELECT pl.payment_id, ac.entry_id, pl.type as link_type, ac.trans_id, a.invnumber as invoice_number,
     ac.chart_id, ch.accno as chart_accno, ch.description as chart_description, ch.link as chart_link,
     ac.amount,  ac.transdate as trans_date, ac.source, ac.cleared_on, ac.fx_transaction, ac.project_id,
     ac.memo, ac.invoice_id, ac.approved, ac.cleared_on, ac.reconciled_on
     FROM acc_trans ac
     JOIN payment_links pl ON (pl.entry_id = ac.entry_id )
     JOIN chart         ch ON (ch.id = ac.chart_id)
     LEFT JOIN (SELECT id,invnumber
                 FROM ar WHERE in_account_class = 2
                 UNION
                 SELECT id,invnumber
                 FROM ap WHERE in_account_class = 1
                ) a ON (ac.trans_id = a.id)
     WHERE pl.payment_id = in_payment_id
   LOOP
      RETURN NEXT out_payment_line;
   END LOOP;  
 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_get_all_accounts(in_account_class integer) -->
    <section id="public.function.payment-get-all-accounts-in-account-class-integer"
             xreflabel="publicpayment_get_all_accounts(in_account_class integer)">
      <title id="public.function.payment-get-all-accounts-in-account-class-integer-title">
       payment_get_all_accounts(in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-get-all-accounts-in-account-class-integer-titleabbrev">
       payment_get_all_accounts(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        This function takes a single argument (1 for vendor, 2 for customer as 
always) and returns all entities with accounts of the appropriate type. 
        <programlisting>
DECLARE out_entity entity%ROWTYPE;
BEGIN
	FOR out_entity IN
		SELECT  ec.id, 
			e.name, e.entity_class, e.created 
		FROM entity e
		JOIN entity_credit_account ec ON (ec.entity_id = e.id)
				WHERE e.entity_class = in_account_class
	LOOP
		RETURN NEXT out_entity;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text) -->
    <section id="public.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text"
             xreflabel="publicpayment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)">
      <title id="public.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text-title">
       payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)
      </title>
      <titleabbrev id="public.function.payment-get-all-contact-invoices-in-meta-number-integer-in-ar-ap-accno-integer-in-batch-id-bpchar-in-date-to-date-in-date-from-date-in-currency-integer-in-business-id-text-in-account-class-text-titleabbrev">
       payment_get_all_contact_invoices(in_meta_number integer, in_ar_ap_accno integer, in_batch_id bpchar, in_date_to date, in_date_from date, in_currency integer, in_business_id text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_contact_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes the following arguments (all prefaced with in_ in the db):
account_class: 1 for vendor, 2 for customer
business_type: integer of business.id.
currency: char(3) of currency (for example &apos;USD&apos;)
date_from, date_to:  These dates are inclusive.
batch_id:  For payment batches, where fees are concerned.
ar_ap_accno:  The AR/AP account number.

This then returns a set of contact information with a 2 dimensional array 
cnsisting of outstanding invoices.

Note that the payment selection logic is that this returns all invoices which are
either approved or in the batch_id specified.  It also locks the invoices using 
the LedgerSMB discretionary locking framework, and if not possible, returns the 
username of the individual who has the lock.

        <programlisting>
DECLARE payment_item payment_contact_invoice;
BEGIN
        FOR payment_item IN
                  SELECT c.id AS contact_id, e.control_code as econtrol_code, 
                        c.description as eca_description, 
                        e.name AS contact_name,
                         c.meta_number AS account_number,
                         sum( case when u.username IS NULL or 
                                       u.username = SESSION_USER 
                             THEN 
                              coalesce(p.due::numeric, 0) -
                              CASE WHEN c.discount_terms 
                                        &gt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due::numeric, 0)) * 
                                        coalesce(c.discount::numeric, 0) / 100
                              END
                             ELSE 0::numeric
                             END) AS total_due,
                         compound_array(ARRAY[[
                              a.id::text, a.invnumber, a.transdate::text, 
                              a.amount::text, (a.amount - p.due)::text,
                              (CASE WHEN c.discount_terms 
                                        &lt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due, 0) * coalesce(c.discount, 0) / 100)
                              END)::text, 
                              (coalesce(p.due, 0) -
                              (CASE WHEN c.discount_terms 
                                        &lt; extract(&#39;days&#39; FROM age(a.transdate))
                                   THEN 0
                                   ELSE (coalesce(p.due, 0)) * coalesce(c.discount, 0) / 100
                              END))::text,
                                case when u.username IS NOT NULL 
                                          and u.username &lt;&gt; SESSION_USER 
                                     THEN 0::text
                                     ELSE 1::text
                                END,
                                COALESCE(u.username, 0::text)
                                ]]),
                              sum(case when a.batch_id = in_batch_id then 1
                                  else 0 END),
                              bool_and(lock_record(a.id, (select max(session_id)
                                FROM &quot;session&quot; where users_id = (
                                        select id from users WHERE username =
                                        SESSION_USER))))
                           
                    FROM entity e
                    JOIN entity_credit_account c ON (e.id = c.entity_id)
                    JOIN (SELECT ap.id, invnumber, transdate, amount, entity_id, 
                                 curr, 1 as invoice_class,
                                 entity_credit_account, on_hold, v.batch_id,
                                 approved, paid
                            FROM ap
                       LEFT JOIN (select * from voucher where batch_class = 1) v 
                                 ON (ap.id = v.trans_id)
                           WHERE in_account_class = 1
                                 AND (v.batch_class = 1 or v.batch_id IS NULL)
                           UNION
                          SELECT ar.id, invnumber, transdate, amount, entity_id,
                                 curr, 2 as invoice_class,
                                 entity_credit_account, on_hold, v.batch_id,
                                 approved, paid
                            FROM ar
                       LEFT JOIN (select * from voucher where batch_class = 2) v 
                                 ON (ar.id = v.trans_id)
                           WHERE in_account_class = 2
                                 AND (v.batch_class = 2 or v.batch_id IS NULL)
                        ORDER BY transdate
                         ) a ON (a.entity_credit_account = c.id)
                    JOIN transactions t ON (a.id = t.id)
                    JOIN (SELECT acc_trans.trans_id, 
                                 sum(CASE WHEN in_account_class = 1 THEN amount
                                          WHEN in_account_class = 2 
                                          THEN amount * -1
                                     END) AS due 
                            FROM acc_trans 
                            JOIN account coa ON (coa.id = acc_trans.chart_id)
                            JOIN account_link al ON (al.account_id = coa.id)
                       LEFT JOIN voucher v ON (acc_trans.voucher_id = v.id)
                           WHERE ((al.description = &#39;AP&#39; AND in_account_class = 1)
                                 OR (al.description = &#39;AR&#39; AND in_account_class = 2))
                           AND (approved IS TRUE or v.batch_class IN (3, 6))
                        GROUP BY acc_trans.trans_id) p ON (a.id = p.trans_id)
                LEFT JOIN &quot;session&quot; s ON (s.&quot;session_id&quot; = t.locked_by)
                LEFT JOIN users u ON (u.id = s.users_id)
                   WHERE (a.batch_id = in_batch_id
                          OR (a.invoice_class = in_account_class
                             AND a.approved
                         AND due &lt;&gt; 0
                         AND NOT a.on_hold
                         AND a.curr = in_currency
                         AND EXISTS (select trans_id FROM acc_trans
                                      WHERE trans_id = a.id AND
                                            chart_id = (SELECT id from account
                                                         WHERE accno
                                                               = in_ar_ap_accno)
                                    )))
                         AND (in_meta_number IS NULL OR 
                             in_meta_number = c.meta_number)
                GROUP BY c.id, e.name, c.meta_number, c.threshold, 
                        e.control_code, c.description
                  HAVING  (sum(p.due) &gt;= c.threshold
                        OR sum(case when a.batch_id = in_batch_id then 1
                                  else 0 END) &gt; 0)
        ORDER BY c.meta_number ASC
        LOOP
                RETURN NEXT payment_item;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer) -->
    <section id="public.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer"
             xreflabel="publicpayment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)">
      <title id="public.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer-title">
       payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-get-available-overpayment-amount-in-entity-credit-id-integer-in-account-class-integer-titleabbrev">
       payment_get_available_overpayment_amount(in_entity_credit_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_overpayments_available_amount</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_overpayment payment_overpayments_available_amount;
BEGIN
      FOR out_overpayment IN
              SELECT chart_id, accno,   chart_description, abs(sum(available))
              FROM overpayments
              WHERE payment_class  = in_account_class 
              AND entity_credit_id = in_entity_credit_id 
              AND available &lt;&gt; 0
              GROUP BY chart_id, accno, chart_description
      LOOP
           RETURN NEXT out_overpayment;
      END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_entity_account_payment_info(in_entity_credit_id integer) -->
    <section id="public.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer"
             xreflabel="publicpayment_get_entity_account_payment_info(in_entity_credit_id integer)">
      <title id="public.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer-title">
       payment_get_entity_account_payment_info(in_entity_credit_id integer)
      </title>
      <titleabbrev id="public.function.payment-get-entity-account-payment-info-in-entity-credit-id-integer-titleabbrev">
       payment_get_entity_account_payment_info(in_entity_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns payment information on the entity credit account as
  required to for discount calculations and payment processing. 
        <programlisting>
 SELECT ec.id, cp.legal_name ||
        coalesce(&#39;:&#39; || ec.description,&#39;&#39;) as name,
        e.entity_class, ec.discount_account_id, ec.meta_number
 FROM entity_credit_account ec
 JOIN entity e ON (ec.entity_id = e.id)
 JOIN company cp ON (cp.entity_id = e.id)
 WHERE ec.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text) -->
    <section id="public.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text"
             xreflabel="publicpayment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)">
      <title id="public.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text-title">
       payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)
      </title>
      <titleabbrev id="public.function.payment-get-entity-accounts-in-vc-idn-integer-in-vc-name-text-in-account-class-text-titleabbrev">
       payment_get_entity_accounts(in_vc_idn integer, in_vc_name text, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a minimal set of information about customer or vendor accounts
as needed for discount calculations and the like.
        <programlisting>
 DECLARE out_entity payment_vc_info;
 

 BEGIN
 	FOR out_entity IN
              SELECT ec.id, cp.legal_name || 
                     coalesce(&#39;:&#39; || ec.description,&#39;&#39;) as name, 
                     e.entity_class, ec.discount_account_id, ec.meta_number
 		FROM entity_credit_account ec
 		JOIN entity e ON (ec.entity_id = e.id)
 		JOIN company cp ON (cp.entity_id = e.id)
		WHERE ec.entity_class = in_account_class
		AND (cp.legal_name ilike coalesce(&#39;%&#39;||in_vc_name||&#39;%&#39;,&#39;%%&#39;) OR cp.tax_id = in_vc_idn)
	LOOP
		RETURN NEXT out_entity;
	END LOOP;
 END;
 </programlisting>
      </para>
    </section>

<!-- Function payment_get_open_accounts(in_account_class integer) -->
    <section id="public.function.payment-get-open-accounts-in-account-class-integer"
             xreflabel="publicpayment_get_open_accounts(in_account_class integer)">
      <title id="public.function.payment-get-open-accounts-in-account-class-integer-title">
       payment_get_open_accounts(in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-get-open-accounts-in-account-class-integer-titleabbrev">
       payment_get_open_accounts(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity</seg>
        </seglistitem>
       </segmentedlist>
 
        This function takes a single argument (1 for vendor, 2 for customer as 
always) and returns all entities with open accounts of the appropriate type. 
        <programlisting>
DECLARE out_entity entity%ROWTYPE;
BEGIN
        FOR out_entity IN
                SELECT ec.id, cp.legal_name as name, e.entity_class, e.created
                FROM entity e
                JOIN entity_credit_account ec ON (ec.entity_id = e.id)
                JOIN company cp ON (cp.entity_id = e.id)
                        WHERE ec.entity_class = in_account_class
                        AND CASE WHEN in_account_class = 1 THEN
                                ec.id IN
                                (SELECT entity_credit_account
                                   FROM acc_trans
                                   JOIN chart ON (acc_trans.chart_id = chart.id)
                                   JOIN ap ON (acc_trans.trans_id = ap.id)
                                   WHERE link = &#39;AP&#39;
                                   GROUP BY chart_id,
                                         trans_id, entity_credit_account
                                   HAVING SUM(acc_trans.amount) &lt;&gt; 0)
                               WHEN in_account_class = 2 THEN
                                ec.id IN (SELECT entity_credit_account
                                   FROM acc_trans
                                   JOIN chart ON (acc_trans.chart_id = chart.id)
                                   JOIN ar ON (acc_trans.trans_id = ar.id)
                                   WHERE link = &#39;AR&#39;
                                   GROUP BY chart_id,
                                         trans_id, entity_credit_account
                                   HAVING SUM(acc_trans.amount) &lt;&gt; 0)
                          END
        LOOP
                RETURN NEXT out_entity;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text) -->
    <section id="public.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text"
             xreflabel="publicpayment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)">
      <title id="public.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text-title">
       payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)
      </title>
      <titleabbrev id="public.function.payment-get-open-invoice-in-invnumber-integer-in-department-id-integer-in-amountto-bpchar-in-amountfrom-date-in-dateto-date-in-datefrom-numeric-in-curr-numeric-in-entity-credit-id-integer-in-account-class-text-titleabbrev">
       payment_get_open_invoice(in_invnumber integer, in_department_id integer, in_amountto bpchar, in_amountfrom date, in_dateto date, in_datefrom numeric, in_curr numeric, in_entity_credit_id integer, in_account_class text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
        
This function is based on payment_get_open_invoices and returns only one invoice if the in_invnumber is set. 
if no in_invnumber is passed this function behaves the same as payment_get_open_invoices

        <programlisting>
DECLARE payment_inv payment_invoice;
BEGIN
	FOR payment_inv IN
		SELECT * from payment_get_open_invoices(in_account_class, in_entity_credit_id, in_curr, in_datefrom, in_dateto, in_amountfrom,
		in_amountto, in_department_id)
		WHERE (invnumber like in_invnumber OR in_invnumber IS NULL)
	LOOP
		RETURN NEXT payment_inv;
	END LOOP;
END;

</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer) -->
    <section id="public.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer"
             xreflabel="publicpayment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)">
      <title id="public.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer-title">
       payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-get-open-invoices-in-department-id-integer-in-amountto-integer-in-amountfrom-bpchar-in-dateto-date-in-datefrom-date-in-curr-numeric-in-entity-credit-id-numeric-in-account-class-integer-titleabbrev">
       payment_get_open_invoices(in_department_id integer, in_amountto integer, in_amountfrom bpchar, in_dateto date, in_datefrom date, in_curr numeric, in_entity_credit_id numeric, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_invoice</seg>
        </seglistitem>
       </segmentedlist>
 
        This function is the base for get_open_invoice and returns all open invoices for the entity_credit_id
it has a lot of options to enable filtering and use the same logic for entity_class_id and currency. 
        <programlisting>
DECLARE payment_inv payment_invoice;
BEGIN
	FOR payment_inv IN
		SELECT a.id AS invoice_id, a.invnumber AS invnumber,a.invoice AS invoice, 
		       a.transdate AS invoice_date, a.amount AS amount, 
		       a.amount/
		       (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		        ELSE
		        (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		        END) as amount_fx, 
		       (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END) AS discount,
		        (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END)/
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		        ELSE
		        (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		        END) as discount_fx,		        
		        ac.due - (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END) AS due,
		        (ac.due - (CASE WHEN c.discount_terms &lt; extract(&#39;days&#39; FROM age(a.transdate))
		        THEN 0 
		        ELSE (coalesce(ac.due, a.amount)) * coalesce(c.discount, 0) / 100
		        END))/
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
                         THEN 1
		         ELSE
		         (CASE WHEN in_account_class = 2
		              THEN ex.buy
		              ELSE ex.sell END)
		         END) AS due_fx,
		        (CASE WHEN a.curr = (SELECT * from defaults_get_defaultcurrency())
		         THEN 1
		         ELSE
		        (CASE WHEN in_account_class = 2
		         THEN ex.buy
		         ELSE ex.sell END)
		         END) AS exchangerate
                 --TODO HV prepare drop entity_id from ap,ar
                 --FROM  (SELECT id, invnumber, transdate, amount, entity_id,
                 FROM  (SELECT id, invnumber, invoice, transdate, amount,
		               1 as invoice_class, curr,
		               entity_credit_account, department_id, approved
		          FROM ap
                         UNION
		         --SELECT id, invnumber, transdate, amount, entity_id,
		         SELECT id, invnumber, invoice, transdate, amount,
		               2 AS invoice_class, curr,
		               entity_credit_account, department_id, approved
		         FROM ar
		         ) a 
		JOIN (SELECT trans_id, chart_id, sum(CASE WHEN in_account_class = 1 THEN amount
		                                  WHEN in_account_class = 2 
		                             THEN amount * -1
		                             END) as due
		        FROM acc_trans 
		        GROUP BY trans_id, chart_id) ac ON (ac.trans_id = a.id)
		        JOIN chart ON (chart.id = ac.chart_id)
		        LEFT JOIN exchangerate ex ON ( ex.transdate = a.transdate AND ex.curr = a.curr )         
		        JOIN entity_credit_account c ON (c.id = a.entity_credit_account)
                --        OR (a.entity_credit_account IS NULL and a.entity_id = c.entity_id))
	 	        WHERE ((chart.link = &#39;AP&#39; AND in_account_class = 1)
		              OR (chart.link = &#39;AR&#39; AND in_account_class = 2))
              	        AND a.invoice_class = in_account_class
		        AND c.entity_class = in_account_class
		        AND c.id = in_entity_credit_id
                        --### short term: ignore fractional cent differences
		        AND a.curr = in_curr
		        AND (a.transdate &gt;= in_datefrom 
		             OR in_datefrom IS NULL)
		        AND (a.transdate &lt;= in_dateto
		             OR in_dateto IS NULL)
		        AND (a.amount &gt;= in_amountfrom 
		             OR in_amountfrom IS NULL)
		        AND (a.amount &lt;= in_amountto
		             OR in_amountto IS NULL)
		        AND (a.department_id = in_department_id
		             OR in_department_id IS NULL)
		        AND due &lt;&gt; 0 
		        AND a.approved = true         
		        GROUP BY a.invnumber, a.transdate, a.amount, amount_fx, discount, discount_fx, ac.due, a.id, c.discount_terms, ex.buy, ex.sell, a.curr, a.invoice
	LOOP
		RETURN NEXT payment_inv;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_open_overpayment_entities(in_account_class integer) -->
    <section id="public.function.payment-get-open-overpayment-entities-in-account-class-integer"
             xreflabel="publicpayment_get_open_overpayment_entities(in_account_class integer)">
      <title id="public.function.payment-get-open-overpayment-entities-in-account-class-integer-title">
       payment_get_open_overpayment_entities(in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-get-open-overpayment-entities-in-account-class-integer-titleabbrev">
       payment_get_open_overpayment_entities(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_vc_info</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
 DECLARE out_entity payment_vc_info;
 BEGIN
	FOR out_entity IN
    		SELECT DISTINCT entity_credit_id, legal_name, e.entity_class, discount, o.meta_number
    		FROM overpayments o
    		JOIN entity e ON (e.id=o.entity_id)
    		WHERE available &lt;&gt; 0 AND in_account_class = payment_class
        LOOP
                RETURN NEXT out_entity;
        END LOOP;
 END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer) -->
    <section id="public.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer"
             xreflabel="publicpayment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)">
      <title id="public.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer-title">
       payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)
      </title>
      <titleabbrev id="public.function.payment-get-unused-overpayment-in-chart-id-integer-in-entity-credit-id-integer-in-account-class-integer-titleabbrev">
       payment_get_unused_overpayment(in_chart_id integer, in_entity_credit_id integer, in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF overpayments</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of available overpayments
        <programlisting>
DECLARE out_overpayment overpayments%ROWTYPE;
BEGIN
      FOR out_overpayment IN
              SELECT DISTINCT * 
              FROM overpayments
              WHERE payment_class  = in_account_class 
              AND entity_credit_id = in_entity_credit_id 
              AND available &lt;&gt; 0
              AND (in_chart_id IS NULL OR chart_id = in_chart_id )
              ORDER BY payment_date
            
      LOOP
           RETURN NEXT out_overpayment;
      END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer) -->
    <section id="public.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer"
             xreflabel="publicpayment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)">
      <title id="public.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer-title">
       payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)
      </title>
      <titleabbrev id="public.function.payment-get-vc-info-in-location-class-id-integer-in-entity-credit-id-integer-titleabbrev">
       payment_get_vc_info(in_location_class_id integer, in_entity_credit_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        This function returns vendor or customer info 
        <programlisting>
DECLARE out_row payment_location_result;
	BEGIN
		FOR out_row IN
                SELECT l.id, l.line_one, l.line_two, l.line_three, l.city,
                       l.state, l.mail_code, c.name, lc.class
                FROM location l
                JOIN entity_to_location ctl ON (ctl.location_id = l.id)
                JOIN entity cp ON (ctl.entity_id = cp.id)
                JOIN location_class lc ON (ctl.location_class = lc.id)
                JOIN country c ON (c.id = l.country_id)
                JOIN entity_credit_account ec ON (ec.entity_id = cp.entity_id)
                WHERE ec.id = in_entity_credit_id AND
                      lc.id = in_location_class_id
                ORDER BY lc.id, l.id, c.name
                LOOP
                	RETURN NEXT out_row;
		END LOOP;
	END;
</programlisting>
      </para>
    </section>

<!-- Function payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean) -->
    <section id="public.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean"
             xreflabel="publicpayment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)">
      <title id="public.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean-title">
       payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)
      </title>
      <titleabbrev id="public.function.payment-post-in-approved-date-in-ovp-payment-id-integer-in-op-account-id-integer-in-op-memo-bpchar-in-op-source-text-in-op-cash-account-id-integer-in-op-amount-text-in-transaction-id-integerARRAY-in-memo-numericARRAY-in-source-booleanARRAY-in-cash-approved-textARRAY-in-amount-textARRAY-in-cash-account-id-integerARRAY-in-gl-description-numericARRAY-in-department-id-integerARRAY-in-notes-textARRAY-in-curr-textARRAY-in-entity-credit-id-integerARRAY-in-account-class-integerARRAY-in-datepaid-boolean-titleabbrev">
       payment_post(in_approved date, in_ovp_payment_id integer, in_op_account_id integer, in_op_memo bpchar, in_op_source text, in_op_cash_account_id integer, in_op_amount text, in_transaction_id integer[], in_memo numeric[], in_source boolean[], in_cash_approved text[], in_amount text[], in_cash_account_id integer[], in_gl_description numeric[], in_department_id integer[], in_notes text[], in_curr text[], in_entity_credit_id integer[], in_account_class integer[], in_datepaid boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Posts a payment.  in_op_* arrays are cross-indexed with eachother.
Other arrays are cross-indexed with eachother.

This API will probably change in 1.4 as we start looking at using more custom
complex types and arrays of those (requires Pg 8.4 or higher).

        <programlisting>
DECLARE var_payment_id int;
DECLARE var_gl_id int;
DECLARE var_entry record;
DECLARE var_entry_id int[];
DECLARE out_count int;
DECLARE coa_id record;
DECLARE var_employee int;
DECLARE var_account_id int;
DECLARE default_currency char(3);
DECLARE current_exchangerate numeric;
DECLARE old_exchangerate numeric;
DECLARE fx_gain_loss_amount numeric;
BEGIN
      IF array_upper(in_amount, 1) &lt;&gt; array_upper(in_cash_account_id, 1) THEN
          RAISE EXCEPTION &#39;Wrong number of accounts&#39;;
      END IF;
        
        SELECT * INTO default_currency  FROM defaults_get_defaultcurrency(); 
        SELECT * INTO current_exchangerate FROM currency_get_exchangerate(in_curr, in_datepaid, in_account_class);


        SELECT INTO var_employee p.id 
        FROM users u
        JOIN person p ON (u.entity_id=p.entity_id)
        WHERE username = SESSION_USER LIMIT 1;
        -- 
        -- WE HAVE TO INSERT THE PAYMENT, USING THE GL INFORMATION
        -- THE ID IS GENERATED BY payment_id_seq
        --
   	INSERT INTO payment (reference, payment_class, payment_date,
	                      employee_id, currency, notes, department_id, entity_credit_id) 
	VALUES ((CASE WHEN in_account_class = 1 THEN
	                                setting_increment(&#39;rcptnumber&#39;) -- I FOUND THIS ON sql/modules/Settings.sql 
			             ELSE 						-- and it is very usefull				
			                setting_increment(&#39;paynumber&#39;) 
			             END),
	         in_account_class, in_datepaid, var_employee,
                 in_curr, in_notes, in_department_id, in_entity_credit_id);
        SELECT currval(&#39;payment_id_seq&#39;) INTO var_payment_id; -- WE&#39;LL NEED THIS VALUE TO USE payment_link table
        -- WE&#39;LL NEED THIS VALUE TO JOIN WITH PAYMENT
        -- NOW COMES THE HEAVY PART, STORING ALL THE POSSIBLE TRANSACTIONS... 
        --
        -- FIRST WE SHOULD INSERT THE CASH ACCOUNTS
        --
        -- WE SHOULD HAVE THE DATA STORED AS (ACCNO, AMOUNT), SO
     IF (array_upper(in_cash_account_id, 1) &gt; 0) THEN
	FOR out_count IN 
			array_lower(in_cash_account_id, 1) ..
			array_upper(in_cash_account_id, 1)
	LOOP
	        INSERT INTO acc_trans (chart_id, amount,
		                       trans_id, transdate, approved, source, memo)
		VALUES (in_cash_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_amount[out_count]*current_exchangerate  
		        ELSE (in_amount[out_count]*current_exchangerate)* - 1
		        END,
		        in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true), 
		        in_source[out_count], in_memo[out_count]);
                INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 1);
		IF (in_ovp_payment_id IS NOT NULL AND in_ovp_payment_id[out_count] IS NOT NULL) THEN
                	INSERT INTO payment_links
                	VALUES (in_ovp_payment_id[out_count], currval(&#39;acc_trans_entry_id_seq&#39;), 0);
		END IF;
		
	END LOOP;
	-- NOW LETS HANDLE THE AR/AP ACCOUNTS
	-- WE RECEIVED THE TRANSACTIONS_ID AND WE CAN OBTAIN THE ACCOUNT FROM THERE
	FOR out_count IN
		     array_lower(in_transaction_id, 1) ..
		     array_upper(in_transaction_id, 1)
       LOOP
               SELECT INTO var_account_id chart_id FROM acc_trans as ac
	        JOIN chart as c ON (c.id = ac.chart_id) 
       	        WHERE 
       	        trans_id = in_transaction_id[out_count] AND
       	        ( c.link = &#39;AP&#39; OR c.link = &#39;AR&#39; );
        -- We need to know the exchangerate of this transaction
	-- ### BUG: we don&#39;t have a guarantee that the transaction is
	--          the same currency as in_curr, so, we can&#39;t use
	--          current_exchangerate as the basis for fx gain/loss
	--          calculations
        IF (in_curr = default_currency) THEN 
           old_exchangerate := 1;
        ELSIF (in_account_class = 2) THEN
           SELECT buy INTO old_exchangerate 
           FROM exchangerate e
           JOIN ar a ON (a.transdate = e.transdate)
                        AND (a.curr = e.curr)
           WHERE a.id = in_transaction_id[out_count];
        ELSE 
           SELECT sell INTO old_exchangerate 
           FROM exchangerate e
           JOIN ap a ON (a.transdate = e.transdate)
                        AND (a.curr = e.curr)
           WHERE a.id = in_transaction_id[out_count];
        END IF;
        -- Now we post the AP/AR transaction
        INSERT INTO acc_trans (chart_id, amount,
                                trans_id, transdate, approved, source, memo)
		VALUES (var_account_id, 
		        CASE WHEN in_account_class = 1 THEN 
		        
		        (in_amount[out_count]*old_exchangerate) * -1 
		        ELSE in_amount[out_count]*old_exchangerate
		        END,
		        in_transaction_id[out_count], in_datepaid,  coalesce(in_approved, true), 
		        in_source[out_count], in_memo[out_count]);
        -- Lets set the gain/loss, if  fx_gain_loss_amount equals zero then we dont need to post
        -- any transaction
       fx_gain_loss_amount := in_amount[out_count]*current_exchangerate - in_amount[out_count]*old_exchangerate;
       IF (in_account_class = 1) THEN
         -- in case of vendor invoices, the invoice amounts have been negated, do the same with the diff
         fx_gain_loss_amount := fx_gain_loss_amount * -1;
       END IF;

       IF (fx_gain_loss_amount &lt; 0) THEN
           INSERT INTO acc_trans (chart_id, amount, trans_id, transdate, approved, source)
            VALUES ((select value::int from defaults WHERE setting_key = &#39;fxgain_accno_id&#39;),
                    fx_gain_loss_amount, in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true),
                    in_source[out_count]);
        ELSIF (fx_gain_loss_amount &gt; 0) THEN
            INSERT INTO acc_trans (chart_id, amount, trans_id, transdate, approved, source)
            VALUES ((select value::int from defaults WHERE setting_key = &#39;fxloss_accno_id&#39;),
                    fx_gain_loss_amount, in_transaction_id[out_count], in_datepaid, coalesce(in_approved, true),
                    in_source[out_count]);
        END IF; 
        -- Now we set the links
         INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 1);
      END LOOP;
     END IF; -- END IF 
--
-- WE NEED TO HANDLE THE OVERPAYMENTS NOW
--
       --
       -- FIRST WE HAVE TO MAKE THE GL TO HOLD THE OVERPAYMENT TRANSACTIONS
       -- THE ID IS GENERATED BY gl_id_seq
       --
       
  IF (array_upper(in_op_cash_account_id, 1) &gt; 0) THEN
       INSERT INTO gl (reference, description, transdate,
                       person_id, notes, approved, department_id) 
              VALUES (setting_increment(&#39;glnumber&#39;),
	              in_gl_description, in_datepaid, var_employee,
	              in_notes, in_approved, in_department_id);
       SELECT currval(&#39;id&#39;) INTO var_gl_id;   
--
-- WE NEED TO SET THE GL_ID FIELD ON PAYMENT&#39;S TABLE
--
       UPDATE payment SET gl_id = var_gl_id 
       WHERE id = var_payment_id;
       -- NOW COMES THE HEAVY PART, STORING ALL THE POSSIBLE TRANSACTIONS... 
       --
       -- FIRST WE SHOULD INSERT THE OVERPAYMENT CASH ACCOUNTS
       --
	FOR out_count IN 
			array_lower(in_op_cash_account_id, 1) ..
			array_upper(in_op_cash_account_id, 1)
	LOOP
	        INSERT INTO acc_trans (chart_id, amount,
		                       trans_id, transdate, approved, source, memo)
		VALUES (in_op_cash_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_op_amount[out_count]  
		        ELSE in_op_amount[out_count] * - 1
		        END,
		        var_gl_id, in_datepaid, coalesce(in_approved, true), 
		        in_op_source[out_count], in_op_memo[out_count]);
	        INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 2);
		
	END LOOP;
	-- NOW LETS HANDLE THE OVERPAYMENT ACCOUNTS
	FOR out_count IN
		     array_lower(in_op_account_id, 1) ..
		     array_upper(in_op_account_id, 1)
	LOOP
         INSERT INTO acc_trans (chart_id, amount,
                                trans_id, transdate, approved, source, memo)
		VALUES (in_op_account_id[out_count], 
		        CASE WHEN in_account_class = 1 THEN in_op_amount[out_count] * -1 
		        ELSE in_op_amount[out_count]
		        END,
		        var_gl_id, in_datepaid,  coalesce(in_approved, true), 
		        in_op_source[out_count], in_op_memo[out_count]);
		INSERT INTO payment_links 
		VALUES (var_payment_id, currval(&#39;acc_trans_entry_id_seq&#39;), 2);
	END LOOP;	        
 END IF;  
 return var_payment_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_type__get_label(in_payment_type_id integer) -->
    <section id="public.function.payment-type-get-label-in-payment-type-id-integer"
             xreflabel="publicpayment_type__get_label(in_payment_type_id integer)">
      <title id="public.function.payment-type-get-label-in-payment-type-id-integer-title">
       payment_type__get_label(in_payment_type_id integer)
      </title>
      <titleabbrev id="public.function.payment-type-get-label-in-payment-type-id-integer-titleabbrev">
       payment_type__get_label(in_payment_type_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_type</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns all information on a payment type by the id.  This should be renamed
to account for its behavior in future versions.
        <programlisting>
DECLARE out_row payment_type%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM payment_type where id=in_payment_type_id LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payment_type__list() -->
    <section id="public.function.payment-type-list"
             xreflabel="publicpayment_type__list()">
      <title id="public.function.payment-type-list-title">
       payment_type__list()
      </title>
      <titleabbrev id="public.function.payment-type-list-titleabbrev">
       payment_type__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payment_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE out_row payment_type%ROWTYPE;
BEGIN
	FOR out_row IN SELECT * FROM payment_type LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payments_get_open_currencies(in_account_class integer) -->
    <section id="public.function.payments-get-open-currencies-in-account-class-integer"
             xreflabel="publicpayments_get_open_currencies(in_account_class integer)">
      <title id="public.function.payments-get-open-currencies-in-account-class-integer-title">
       payments_get_open_currencies(in_account_class integer)
      </title>
      <titleabbrev id="public.function.payments-get-open-currencies-in-account-class-integer-titleabbrev">
       payments_get_open_currencies(in_account_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF bpchar</seg>
        </seglistitem>
       </segmentedlist>
 
        This does a sparse scan to find currencies attached to open invoices.

It should scale per the number of currencies used rather than the size of the 
ar or ap tables.

        <programlisting>
DECLARE result char(3);
BEGIN
select min(curr) into result from ar WHERE in_account_class = 2
union 
select min(curr) from ap WHERE in_account_class = 1;


LOOP
   EXIT WHEN result IS NULL;
   return next result;

   SELECT min(curr) INTO result from ar 
    where in_account_class = 2 and curr &gt; result
            union 
   select min(curr) from ap 
    WHERE in_account_class = 1 and curr &gt; result
    LIMIT 1;

END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date) -->
    <section id="public.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date"
             xreflabel="publicpayments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)">
      <title id="public.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date-title">
       payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)
      </title>
      <titleabbrev id="public.function.payments-set-exchangerate-in-datepaid-integer-in-curr-numeric-in-exchangerate-bpchar-in-account-class-date-titleabbrev">
       payments_set_exchangerate(in_datepaid integer, in_curr numeric, in_exchangerate bpchar, in_account_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        1.3 only.  This will be replaced by a more generic function in 1.4.

This sets the exchange rate for a class of transactions (payable, receivable) 
to a certain rate for a specific date.
        <programlisting>
DECLARE current_exrate  exchangerate%ROWTYPE;
BEGIN
select  * INTO current_exrate
        FROM  exchangerate 
        WHERE transdate = in_datepaid
              AND curr = in_curr;
IF current_exrate.transdate = in_datepaid THEN
   IF in_account_class = 2 THEN 
      UPDATE exchangerate set buy = in_exchangerate  where transdate = in_datepaid;
   ELSE
      UPDATE exchangerate set sell = in_exchangerate where transdate = in_datepaid;
   END IF;
   RETURN 0; 
ELSE
    IF in_account_class = 2 THEN
     INSERT INTO exchangerate (curr, transdate, buy) values (in_curr, in_datepaid, in_exchangerate);
  ELSE   
     INSERT INTO exchangerate (curr, transdate, sell) values (in_curr, in_datepaid, in_exchangerate);
  END IF;                                       
RETURN 0;
END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function payroll_deduction_type__search(in_unit integer, in_label integer, in_country_id integer, in_pdc_id text, in_account_id text) -->
    <section id="public.function.payroll-deduction-type-search-in-unit-integer-in-label-integer-in-country-id-integer-in-pdc-id-text-in-account-id-text"
             xreflabel="publicpayroll_deduction_type__search(in_unit integer, in_label integer, in_country_id integer, in_pdc_id text, in_account_id text)">
      <title id="public.function.payroll-deduction-type-search-in-unit-integer-in-label-integer-in-country-id-integer-in-pdc-id-text-in-account-id-text-title">
       payroll_deduction_type__search(in_unit integer, in_label integer, in_country_id integer, in_pdc_id text, in_account_id text)
      </title>
      <titleabbrev id="public.function.payroll-deduction-type-search-in-unit-integer-in-label-integer-in-country-id-integer-in-pdc-id-text-in-account-id-text-titleabbrev">
       payroll_deduction_type__search(in_unit integer, in_label integer, in_country_id integer, in_pdc_id text, in_account_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_deduction_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
SELECT * 
  FROM payroll_deduction_type 
 where (account_id = $1 OR $1 IS NULL) AND
       (pdc_id = $2 OR $2 IS NULL) AND
       (country_id = $3 OR $3 IS NULL) AND
       ($4 IS NULL OR label LIKE $4 || &#39;%&#39;) AND
       (unit = $5 or $5 IS NULL);
</programlisting>
      </para>
    </section>

<!-- Function payroll_income_category__list() -->
    <section id="public.function.payroll-income-category-list"
             xreflabel="publicpayroll_income_category__list()">
      <title id="public.function.payroll-income-category-list-title">
       payroll_income_category__list()
      </title>
      <titleabbrev id="public.function.payroll-income-category-list-titleabbrev">
       payroll_income_category__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_income_category</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM payroll_income_category order by id;
</programlisting>
      </para>
    </section>

<!-- Function payroll_income_class__for_country(in_country_id integer) -->
    <section id="public.function.payroll-income-class-for-country-in-country-id-integer"
             xreflabel="publicpayroll_income_class__for_country(in_country_id integer)">
      <title id="public.function.payroll-income-class-for-country-in-country-id-integer-title">
       payroll_income_class__for_country(in_country_id integer)
      </title>
      <titleabbrev id="public.function.payroll-income-class-for-country-in-country-id-integer-titleabbrev">
       payroll_income_class__for_country(in_country_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_income_class</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
SELECT * FROM payroll_income_class where country_id = $1
ORDER BY label;
</programlisting>
      </para>
    </section>

<!-- Function payroll_income_type__get(in_id integer) -->
    <section id="public.function.payroll-income-type-get-in-id-integer"
             xreflabel="publicpayroll_income_type__get(in_id integer)">
      <title id="public.function.payroll-income-type-get-in-id-integer-title">
       payroll_income_type__get(in_id integer)
      </title>
      <titleabbrev id="public.function.payroll-income-type-get-in-id-integer-titleabbrev">
       payroll_income_type__get(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>payroll_income_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM payroll_income_type WHERE id  = $1;
</programlisting>
      </para>
    </section>

<!-- Function payroll_income_type__save(in_default_amount integer, in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text, in_id numeric) -->
    <section id="public.function.payroll-income-type-save-in-default-amount-integer-in-unit-integer-in-label-integer-in-country-id-integer-in-pic-id-text-in-account-id-text-in-id-numeric"
             xreflabel="publicpayroll_income_type__save(in_default_amount integer, in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text, in_id numeric)">
      <title id="public.function.payroll-income-type-save-in-default-amount-integer-in-unit-integer-in-label-integer-in-country-id-integer-in-pic-id-text-in-account-id-text-in-id-numeric-title">
       payroll_income_type__save(in_default_amount integer, in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text, in_id numeric)
      </title>
      <titleabbrev id="public.function.payroll-income-type-save-in-default-amount-integer-in-unit-integer-in-label-integer-in-country-id-integer-in-pic-id-text-in-account-id-text-in-id-numeric-titleabbrev">
       payroll_income_type__save(in_default_amount integer, in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text, in_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>payroll_income_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

   DECLARE retval payroll_income_type;

BEGIN
   UPDATE payroll_income_type
      SET account_id = in_account_id,
          pic_id = in_pic_id,
          country_id = in_country_id,
          label = in_label,
          unit = in_unit,
          default_amount = in_default_amount
    WHERE id = in_id;

   IF FOUND THEN
       retval := payroll_income_type__get(in_id);
       RETURN retval;
   END IF;

   INSERT INTO payroll_income_type
          (account_id, pic_id, country_id, label, unit, default_amount)
   VALUES (in_account_id, in_pic_id, in_country_id, in_label, in_unit, 
           in_default_amount);

   retval := payroll_income_type__get(currval(&#39;payroll_income_type_id_seq&#39;)::int);
   RETURN retval;

END;
</programlisting>
      </para>
    </section>

<!-- Function payroll_income_type__search(in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text) -->
    <section id="public.function.payroll-income-type-search-in-unit-integer-in-label-integer-in-country-id-integer-in-pic-id-text-in-account-id-text"
             xreflabel="publicpayroll_income_type__search(in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text)">
      <title id="public.function.payroll-income-type-search-in-unit-integer-in-label-integer-in-country-id-integer-in-pic-id-text-in-account-id-text-title">
       payroll_income_type__search(in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text)
      </title>
      <titleabbrev id="public.function.payroll-income-type-search-in-unit-integer-in-label-integer-in-country-id-integer-in-pic-id-text-in-account-id-text-titleabbrev">
       payroll_income_type__search(in_unit integer, in_label integer, in_country_id integer, in_pic_id text, in_account_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_income_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
SELECT * 
  FROM payroll_income_type 
 where (account_id = $1 OR $1 IS NULL) AND
       (pic_id = $2 OR $2 IS NULL) AND
       (country_id = $3 OR $3 IS NULL) AND
       ($4 IS NULL OR label LIKE $4 || &#39;%&#39;) AND
       (unit = $5 or $5 IS NULL);
</programlisting>
      </para>
    </section>

<!-- Function periods_get() -->
    <section id="public.function.periods-get"
             xreflabel="publicperiods_get()">
      <title id="public.function.periods-get-title">
       periods_get()
      </title>
      <titleabbrev id="public.function.periods-get-titleabbrev">
       periods_get()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF periods</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns dates for year to date, and last year.
        <programlisting>
SELECT * FROM periods ORDER BY id
</programlisting>
      </para>
    </section>

<!-- Function person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text) -->
    <section id="public.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text"
             xreflabel="publicperson__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)">
      <title id="public.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text-title">
       person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)
      </title>
      <titleabbrev id="public.function.person-delete-contact-in-contact-integer-in-contact-class-id-integer-in-person-id-text-titleabbrev">
       person__delete_contact(in_contact integer, in_contact_class_id integer, in_person_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes a contact record specified for the person.  Returns true if a record
was found and deleted, false if not.
        <programlisting>
BEGIN

DELETE FROM entity_to_contact
 WHERE person_id = (SELECT entity_id FROM person WHERE id = in_person_id) 
       and contact_class_id = in_contact_class_id
       and contact= in_contact;
RETURN FOUND;

END;

</programlisting>
      </para>
    </section>

<!-- Function person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer) -->
    <section id="public.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer"
             xreflabel="publicperson__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)">
      <title id="public.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer-title">
       person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)
      </title>
      <titleabbrev id="public.function.person-delete-location-in-location-class-integer-in-location-id-integer-in-person-id-integer-titleabbrev">
       person__delete_location(in_location_class integer, in_location_id integer, in_person_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Deletes a location mapping to a person.  Returns true if found, false if no
data deleted.
        <programlisting>
BEGIN

DELETE FROM entity_to_location
 WHERE person_id = (select entity_id from person where id = in_person_id) 
       AND location_id = in_location_id 
       AND location_class = in_location_class;

RETURN FOUND;

END;
</programlisting>
      </para>
    </section>

<!-- Function person__get(in_entity_id integer) -->
    <section id="public.function.person-get-in-entity-id-integer"
             xreflabel="publicperson__get(in_entity_id integer)">
      <title id="public.function.person-get-in-entity-id-integer-title">
       person__get(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-get-in-entity-id-integer-titleabbrev">
       person__get(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>person_entity</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT e.id, e.control_code, e.name, e.country_id, c.name, 
       p.first_name, p.middle_name, p.last_name
  FROM entity e
  JOIN country c ON c.id = e.country_id
  JOIN person p ON p.entity_id = e.id
 WHERE e.id = $1;
</programlisting>
      </para>
    </section>

<!-- Function person__get_by_cc(in_control_code text) -->
    <section id="public.function.person-get-by-cc-in-control-code-text"
             xreflabel="publicperson__get_by_cc(in_control_code text)">
      <title id="public.function.person-get-by-cc-in-control-code-text-title">
       person__get_by_cc(in_control_code text)
      </title>
      <titleabbrev id="public.function.person-get-by-cc-in-control-code-text-titleabbrev">
       person__get_by_cc(in_control_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>person_entity</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT e.id, e.control_code, e.name, e.country_id, c.name, 
       p.first_name, p.middle_name, p.last_name
  FROM entity e
  JOIN country c ON c.id = e.country_id
  JOIN person p ON p.entity_id = e.id
 WHERE e.control_code = $1;
</programlisting>
      </para>
    </section>

<!-- Function person__get_my_entity_id() -->
    <section id="public.function.person-get-my-entity-id"
             xreflabel="publicperson__get_my_entity_id()">
      <title id="public.function.person-get-my-entity-id-title">
       person__get_my_entity_id()
      </title>
      <titleabbrev id="public.function.person-get-my-entity-id-titleabbrev">
       person__get_my_entity_id()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the entity_id of the current, logged in user.
        <programlisting>
	SELECT entity_id from users where username = SESSION_USER;
</programlisting>
      </para>
    </section>

<!-- Function person__list_bank_account(in_entity_id integer) -->
    <section id="public.function.person-list-bank-account-in-entity-id-integer"
             xreflabel="publicperson__list_bank_account(in_entity_id integer)">
      <title id="public.function.person-list-bank-account-in-entity-id-integer-title">
       person__list_bank_account(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-list-bank-account-in-entity-id-integer-titleabbrev">
       person__list_bank_account(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_bank_account</seg>
        </seglistitem>
       </segmentedlist>
 
        Lists bank accounts for a person
        <programlisting>
DECLARE out_row entity_bank_account%ROWTYPE;
BEGIN
	FOR out_row IN
		SELECT * from entity_bank_account where entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_contacts(in_entity_id integer) -->
    <section id="public.function.person-list-contacts-in-entity-id-integer"
             xreflabel="publicperson__list_contacts(in_entity_id integer)">
      <title id="public.function.person-list-contacts-in-entity-id-integer-title">
       person__list_contacts(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-list-contacts-in-entity-id-integer-titleabbrev">
       person__list_contacts(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF contact_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of contacts attached to the function.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN 
		SELECT cc.class, cc.id, c.description, c.contact
		FROM entity_to_contact c
		JOIN contact_class cc ON (c.contact_class_id = cc.id)
		JOIN person p ON (c.person_id = p.entity_id)
		WHERE p.entity_id = in_entity_id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_languages() -->
    <section id="public.function.person-list-languages"
             xreflabel="publicperson__list_languages()">
      <title id="public.function.person-list-languages-title">
       person__list_languages()
      </title>
      <titleabbrev id="public.function.person-list-languages-titleabbrev">
       person__list_languages()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF language</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of languages ordered by code
        <programlisting> SELECT * FROM language ORDER BY code ASC </programlisting>
      </para>
    </section>

<!-- Function person__list_locations(in_entity_id integer) -->
    <section id="public.function.person-list-locations-in-entity-id-integer"
             xreflabel="publicperson__list_locations(in_entity_id integer)">
      <title id="public.function.person-list-locations-in-entity-id-integer-title">
       person__list_locations(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-list-locations-in-entity-id-integer-titleabbrev">
       person__list_locations(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF location_result</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of locations specified attached to the person.
        <programlisting>
DECLARE out_row RECORD;
BEGIN
	FOR out_row IN
		SELECT l.id, l.line_one, l.line_two, l.line_three, l.city, 
			l.state, l.mail_code, c.id, c.name, lc.id, lc.class
		FROM location l
		JOIN entity_to_location ctl ON (ctl.location_id = l.id)
		JOIN person p ON (ctl.person_id = p.entity_id)
		JOIN location_class lc ON (ctl.location_class = lc.id)
		JOIN country c ON (c.id = l.country_id)
		WHERE p.entity_id = in_entity_id
		ORDER BY lc.id, l.id, c.name
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_notes(in_entity_id integer) -->
    <section id="public.function.person-list-notes-in-entity-id-integer"
             xreflabel="publicperson__list_notes(in_entity_id integer)">
      <title id="public.function.person-list-notes-in-entity-id-integer-title">
       person__list_notes(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-list-notes-in-entity-id-integer-titleabbrev">
       person__list_notes(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF entity_note</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of notes attached to a person.
        <programlisting>
DECLARE out_row record;
BEGIN
	FOR out_row IN
		SELECT *
		FROM entity_note
		WHERE ref_key = in_entity_id
		ORDER BY created
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__list_salutations() -->
    <section id="public.function.person-list-salutations"
             xreflabel="publicperson__list_salutations()">
      <title id="public.function.person-list-salutations-title">
       person__list_salutations()
      </title>
      <titleabbrev id="public.function.person-list-salutations-titleabbrev">
       person__list_salutations()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF salutation</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of salutations ordered by id.
        <programlisting> SELECT * FROM salutation ORDER BY id ASC </programlisting>
      </para>
    </section>

<!-- Function person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer) -->
    <section id="public.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer"
             xreflabel="publicperson__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)">
      <title id="public.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer-title">
       person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-save-in-country-id-integer-in-last-name-integer-in-middle-name-text-in-first-name-text-in-salutation-id-text-in-entity-id-integer-titleabbrev">
       person__save(in_country_id integer, in_last_name integer, in_middle_name text, in_first_name text, in_salutation_id text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves the person with the information specified.  Returns the entity_id
of the record saved.
        <programlisting>

    DECLARE
        e_id int;
        e entity;
        loc location;
        l_id int;
        p_id int;
    BEGIN
    
    select * into e from entity where id = in_entity_id and entity_class = 3;
    e_id := in_entity_id; 
    
    IF FOUND THEN
        UPDATE entity 
           SET name = in_first_name || &#39; &#39; || in_last_name,
               country_id = in_country_id
         WHERE id = in_entity_id; 
    ELSE
        INSERT INTO entity (name, entity_class, country_id) 
	values (in_first_name || &#39; &#39; || in_last_name, 3, in_country_id);
	e_id := currval(&#39;entity_id_seq&#39;);
       
    END IF;
    
      
    UPDATE person SET
            salutation_id = in_salutation_id,
            first_name = in_first_name,
            last_name = in_last_name,
            middle_name = in_middle_name
    WHERE
            entity_id = in_entity_id;
    IF FOUND THEN
	RETURN in_entity_id;
    ELSE 
        -- Do an insert
        
        INSERT INTO person (salutation_id, first_name, last_name, entity_id)
	VALUES (in_salutation_id, in_first_name, in_last_name, e_id);

        RETURN e_id;
    
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer) -->
    <section id="public.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer"
             xreflabel="publicperson__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)">
      <title id="public.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer-title">
       person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-save-contact-in-old-contact-class-integer-in-description-integer-in-contact-new-text-in-old-contact-text-in-contact-class-text-in-entity-id-integer-titleabbrev">
       person__save_contact(in_old_contact_class integer, in_description integer, in_contact_new text, in_old_contact text, in_contact_class text, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves saves contact info.  Returns 1 if a row was inserted, 0 if it was 
updated. 
        <programlisting>
DECLARE 
    out_id int;
    v_orig entity_to_contact;
BEGIN
    
    SELECT cc.* into v_orig 
      FROM entity_to_contact cc
      JOIN person p ON (p.entity_id = cc.entity_id)
     WHERE p.entity_id = in_entity_id 
    and cc.contact_class_id = in_old_contact_class
    AND cc.contact = in_old_contact;
    
    IF NOT FOUND THEN
    
        -- create
        INSERT INTO entity_to_contact
               (entity_id, contact_class_id, contact, description)
        VALUES (in_entity_id, in_contact_class, in_contact_new, in_description);

        return 1;
    ELSE
        -- edit.
        UPDATE entity_to_contact
           SET contact = in_contact_new, description = in_description
         WHERE contact = in_old_contact
               AND entity_id = in_entity_id
               AND contact_class_id = in_old_contact_class;
        return 0;
    END IF;
    
END;
</programlisting>
      </para>
    </section>

<!-- Function person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer) -->
    <section id="public.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer"
             xreflabel="publicperson__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)">
      <title id="public.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer-title">
       person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)
      </title>
      <titleabbrev id="public.function.person-save-location-in-old-location-class-integer-in-country-code-integer-in-mail-code-integer-in-state-text-in-city-text-in-line-three-text-in-line-two-text-in-line-one-text-in-location-class-text-in-location-id-integer-in-entity-id-integer-titleabbrev">
       person__save_location(in_old_location_class integer, in_country_code integer, in_mail_code integer, in_state text, in_city text, in_line_three text, in_line_two text, in_line_one text, in_location_class text, in_location_id integer, in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves a location mapped to the person with the specified information.
Returns the location id saved.
        <programlisting>

    DECLARE
        l_row location;
        l_id INT;
	    t_person_id int;
    BEGIN
	SELECT id INTO t_person_id
	FROM person WHERE entity_id = in_entity_id;

    UPDATE entity_to_location
       SET location_class = in_location_class
     WHERE entity_id = in_entity_id
           AND location_class = in_old_location_class
           AND location_id = in_location_id;
    
    
    IF NOT FOUND THEN
        -- Create a new one.
        l_id := location_save(
            in_location_id, 
    	    in_line_one, 
    	    in_line_two, 
    	    in_line_three, 
    	    in_city,
    		in_state, 
    		in_mail_code, 
    		in_country_code);
    	
        INSERT INTO entity_to_location 
    		(entity_id, location_id, location_class)
    	VALUES  (in_entity_id, l_id, in_location_class);
    ELSE
        l_id := location_save(
            in_location_id, 
    	    in_line_one, 
    	    in_line_two, 
    	    in_line_three, 
    	    in_city,
    		in_state, 
    		in_mail_code, 
    		in_country_code);
        -- Update the old one.
    END IF;
    return l_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function pnl__customer(in_to_date integer, in_from_date date, in_id date) -->
    <section id="public.function.pnl-customer-in-to-date-integer-in-from-date-date-in-id-date"
             xreflabel="publicpnl__customer(in_to_date integer, in_from_date date, in_id date)">
      <title id="public.function.pnl-customer-in-to-date-integer-in-from-date-date-in-id-date-title">
       pnl__customer(in_to_date integer, in_from_date date, in_id date)
      </title>
      <titleabbrev id="public.function.pnl-customer-in-to-date-integer-in-from-date-date-in-id-date-titleabbrev">
       pnl__customer(in_to_date integer, in_from_date date, in_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH gl (id) AS
 ( SELECT id FROM ap WHERE approved is true AND entity_credit_account = $1
UNION ALL
   SELECT id FROM ar WHERE approved is true AND entity_credit_account = $1
)
SELECT a.id, a.accno, a.description, a.category, 
       ah.id, ah.accno, ah.description,
       CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END * sum(ac.amount)
  FROM account a
  JOIN account_heading ah on a.heading = ah.id
  JOIN acc_trans ac ON a.id = ac.chart_id
  JOIN gl ON ac.trans_id = gl.id
 WHERE ac.approved is true 
          AND ($2 IS NULL OR ac.transdate &gt;= $2) 
          AND ($3 IS NULL OR ac.transdate &lt;= $3)
          AND a.category IN (&#39;I&#39;, &#39;E&#39;)
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__income_statement_accrual(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[]) -->
    <section id="public.function.pnl-income-statement-accrual-in-business-units-date-in-ignore-yearend-date-in-to-date-text-in-from-date-integerARRAY"
             xreflabel="publicpnl__income_statement_accrual(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[])">
      <title id="public.function.pnl-income-statement-accrual-in-business-units-date-in-ignore-yearend-date-in-to-date-text-in-from-date-integerARRAY-title">
       pnl__income_statement_accrual(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[])
      </title>
      <titleabbrev id="public.function.pnl-income-statement-accrual-in-business-units-date-in-ignore-yearend-date-in-to-date-text-in-from-date-integerARRAY-titleabbrev">
       pnl__income_statement_accrual(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, parent, path) AS (
      SELECT id, null, row(array[id])::tree_record FROM business_unit
       WHERE id = any($4)
      UNION ALL
      SELECT bu.id, parent, row((path).t || bu.id)::tree_record
        FROM business_unit bu
        JOIN bu_tree ON bu.parent_id = bu_tree.id
)
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END * sum(ac.amount)
     FROM account a
     JOIN account_heading ah on a.heading = ah.id
     JOIN acc_trans ac ON a.id = ac.chart_id AND ac.approved
     JOIN tx_report gl ON ac.trans_id = gl.id
LEFT JOIN (select array_agg(path) as bu_ids, entry_id
             FROM business_unit_ac buac
             JOIN bu_tree ON bu_tree.id = buac.bu_id
        GROUP BY buac.entry_id) bu
          ON (ac.entry_id = bu.entry_id)
    WHERE ac.approved is true 
          AND ($1 IS NULL OR ac.transdate &gt;= $1) 
          AND ($2 IS NULL OR ac.transdate &lt;= $2)
          AND ($4 = &#39;{}&#39; 
              OR $4 is null or in_tree($4, bu_ids))
          AND a.category IN (&#39;I&#39;, &#39;E&#39;)
          AND ($3 = &#39;none&#39; 
               OR ($3 = &#39;all&#39; 
                   AND NOT EXISTS (SELECT * FROM yearend WHERE trans_id = gl.id
                   ))
               OR ($3 = &#39;last&#39;
                   AND NOT EXISTS (SELECT 1 FROM yearend 
                                   HAVING max(trans_id) = gl.id))
              )
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__income_statement_cash(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[]) -->
    <section id="public.function.pnl-income-statement-cash-in-business-units-date-in-ignore-yearend-date-in-to-date-text-in-from-date-integerARRAY"
             xreflabel="publicpnl__income_statement_cash(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[])">
      <title id="public.function.pnl-income-statement-cash-in-business-units-date-in-ignore-yearend-date-in-to-date-text-in-from-date-integerARRAY-title">
       pnl__income_statement_cash(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[])
      </title>
      <titleabbrev id="public.function.pnl-income-statement-cash-in-business-units-date-in-ignore-yearend-date-in-to-date-text-in-from-date-integerARRAY-titleabbrev">
       pnl__income_statement_cash(in_business_units date, in_ignore_yearend date, in_to_date text, in_from_date integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, parent, path) AS (
      SELECT id, null, row(array[id])::tree_record FROM business_unit
       WHERE id = any($4)
      UNION ALL
      SELECT bu.id, parent, row((path).t || bu.id)::tree_record
        FROM business_unit bu
        JOIN bu_tree ON bu.parent_id = bu_tree.id
)
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END 
               * sum(ac.amount * ca.portion)
     FROM account a
     JOIN account_heading ah on a.heading = ah.id
     JOIN acc_trans ac ON a.id = ac.chart_id AND ac.approved
     JOIN tx_report gl ON ac.trans_id = gl.id
     JOIN (SELECT id, sum(portion) as portion
             FROM cash_impact ca 
            WHERE ($1 IS NULL OR ca.transdate &gt;= $1)
                  AND ($2 IS NULL OR ca.transdate &lt;= $2)
           GROUP BY id
          ) ca ON gl.id = ca.id 
LEFT JOIN (select array_agg(path) as bu_ids, entry_id
             FROM business_unit_ac buac
             JOIN bu_tree ON bu_tree.id = buac.bu_id
         GROUP BY entry_id) bu 
          ON (ac.entry_id = bu.entry_id)
    WHERE ac.approved is true 
          AND ($4 = &#39;{}&#39; 
              OR $4 is null or in_tree($4, bu_ids))
          AND a.category IN (&#39;I&#39;, &#39;E&#39;)
          AND ($3 = &#39;none&#39; 
               OR ($3 = &#39;all&#39; 
                   AND NOT EXISTS (SELECT * FROM yearend WHERE trans_id = gl.id
                   ))
               OR ($3 = &#39;last&#39;
                   AND NOT EXISTS (SELECT 1 FROM yearend 
                                   HAVING max(trans_id) = gl.id))
              )
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__invoice(in_id integer) -->
    <section id="public.function.pnl-invoice-in-id-integer"
             xreflabel="publicpnl__invoice(in_id integer)">
      <title id="public.function.pnl-invoice-in-id-integer-title">
       pnl__invoice(in_id integer)
      </title>
      <titleabbrev id="public.function.pnl-invoice-in-id-integer-titleabbrev">
       pnl__invoice(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT a.id, a.accno, a.description, a.category, 
       ah.id, ah.accno, ah.description,
       CASE WHEN a.category = &#39;E&#39; THEN -1 ELSE 1 END * sum(ac.amount)
  FROM account a
  JOIN account_heading ah on a.heading = ah.id
  JOIN acc_trans ac ON a.id = ac.chart_id
 WHERE ac.approved AND ac.trans_id = $1 AND a.category IN (&#39;I&#39;, &#39;E&#39;)
 GROUP BY a.id, a.accno, a.description, a.category, 
          ah.id, ah.accno, ah.description
 ORDER BY a.category DESC, a.accno ASC;
</programlisting>
      </para>
    </section>

<!-- Function pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[]) -->
    <section id="public.function.pnl-product-in-business-units-date-in-parts-id-date-in-to-date-integer-in-from-date-integerARRAY"
             xreflabel="publicpnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[])">
      <title id="public.function.pnl-product-in-business-units-date-in-parts-id-date-in-to-date-integer-in-from-date-integerARRAY-title">
       pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[])
      </title>
      <titleabbrev id="public.function.pnl-product-in-business-units-date-in-parts-id-date-in-to-date-integer-in-from-date-integerARRAY-titleabbrev">
       pnl__product(in_business_units date, in_parts_id date, in_to_date integer, in_from_date integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pnl_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, parent, path) AS (
      SELECT id, null, row(array[id])::tree_record FROM business_unit
       WHERE id = any($4)
      UNION ALL
      SELECT bu.id, parent, row((path).t || bu.id)::tree_record
        FROM business_unit bu
        JOIN bu_tree ON bu.parent_id = bu_tree.id
)
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          sum(ac.amount) * -1 
     FROM account a
     JOIN account_heading ah on a.heading = ah.id
     JOIN acc_trans ac ON ac.chart_id = a.id
     JOIN invoice i ON i.id = ac.invoice_id
     JOIN account_link l ON l.account_id = a.id
     JOIN ar ON ar.id = ac.trans_id 
LEFT JOIN (select as_array(bu.path) as bu_ids, entry_id
             from business_unit_inv bui 
             JOIN bu_tree bu ON bui.bu_id = bu.id
         GROUP BY entry_id) bui ON bui.entry_id = i.id
    WHERE i.parts_id = $3
          AND (ac.transdate &gt;= $1 OR $1 IS NULL) 
          AND (ac.transdate &lt;= $2 OR $2 IS NULL)
          AND ar.approved
          AND l.description = &#39;IC_expense&#39;
          AND ($4 is null or $4 = &#39;{}&#39; OR in_tree($4, bu_ids))
 GROUP BY a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description
    UNION
   SELECT a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description, 
          sum(i.sellprice * i.qty * (1 - coalesce(i.discount, 0)))
     FROM parts p
     JOIN invoice i ON i.id = p.id
     JOIN acc_trans ac ON ac.invoice_id = i.id
     JOIN account a ON p.income_accno_id = a.id
     JOIN ar ON ar.id = ac.trans_id
     JOIN account_heading ah on a.heading = ah.id
LEFT JOIN (select as_array(bu.path) as bu_ids, entry_id
             from business_unit_inv bui 
             JOIN bu_tree bu ON bui.bu_id = bu.id
         GROUP BY entry_id) bui ON bui.entry_id = i.id
    WHERE i.parts_id = $3
          AND (ac.transdate &gt;= $1 OR $1 IS NULL) 
          AND (ac.transdate &lt;= $2 OR $2 IS NULL)
          AND ar.approved
          AND ($4 is null or $4 = &#39;{}&#39; OR in_tree($4, bu_ids))
 GROUP BY a.id, a.accno, a.description, a.category, ah.id, ah.accno,
          ah.description
</programlisting>
      </para>
    </section>

<!-- Function pricegroup__list() -->
    <section id="public.function.pricegroup-list"
             xreflabel="publicpricegroup__list()">
      <title id="public.function.pricegroup-list-title">
       pricegroup__list()
      </title>
      <titleabbrev id="public.function.pricegroup-list-titleabbrev">
       pricegroup__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pricegroup</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an alphabetically ordered pricegroup list.
        <programlisting>
SELECT * FROM pricegroup ORDER BY pricegroup;
</programlisting>
      </para>
    </section>

<!-- Function pricegroups__list() -->
    <section id="public.function.pricegroups-list"
             xreflabel="publicpricegroups__list()">
      <title id="public.function.pricegroups-list-title">
       pricegroups__list()
      </title>
      <titleabbrev id="public.function.pricegroups-list-titleabbrev">
       pricegroups__list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF pricegroup</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM pricegroup;
</programlisting>
      </para>
    </section>

<!-- Function pricelist__delete(credit_id integer, entry_id integer) -->
    <section id="public.function.pricelist-delete-credit-id-integer-entry-id-integer"
             xreflabel="publicpricelist__delete(credit_id integer, entry_id integer)">
      <title id="public.function.pricelist-delete-credit-id-integer-entry-id-integer-title">
       pricelist__delete(credit_id integer, entry_id integer)
      </title>
      <titleabbrev id="public.function.pricelist-delete-credit-id-integer-entry-id-integer-titleabbrev">
       pricelist__delete(credit_id integer, entry_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
delete from partscustomer where entry_id = $1 and credit_id = $2;
delete from partsvendor where entry_id = $1 and credit_id = $2;
select true;
</programlisting>
      </para>
    </section>

<!-- Function pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer) -->
    <section id="public.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer"
             xreflabel="publicpricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)">
      <title id="public.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-title">
       pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </title>
      <titleabbrev id="public.function.pricelist-save-in-entry-id-integer-in-curr-integer-in-validto-numeric-in-validfrom-numeric-in-partnumber-smallint-in-lead-time-text-in-price-date-in-pricebreak-date-in-credit-id-bpchar-in-parts-id-integer-titleabbrev">
       pricelist__save(in_entry_id integer, in_curr integer, in_validto numeric, in_validfrom numeric, in_partnumber smallint, in_lead_time text, in_price date, in_pricebreak date, in_credit_id bpchar, in_parts_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>eca__pricematrix</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
   retval eca__pricematrix;
   t_insert bool;
   t_entity_class int;

BEGIN

t_insert := false;

SELECT entity_class INTO t_entity_class FROM entity_credit_account 
  WHERE id = in_credit_id;

IF t_entity_class = 1 THEN -- VENDOR
    UPDATE partsvendor
       SET lastcost = in_price,
           leadtime = in_lead_time,
           partnumber = in_partnumber,
           curr = in_curr
     WHERE credit_id = in_credit_id AND entry_id = in_entry_id;

    IF NOT FOUND THEN
        INSERT INTO partsvendor
               (parts_id, credit_id, lastcost, leadtime, partnumber, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_leadtime::int2, 
               in_partnumber, in_curr);
    END IF;

    SELECT pv.parts_id, p.partnumber, p.description, pv.credit_id, NULL, NULL,
           pv.lastcost, pv.leadtime::int, pv.partnumber, NULL, NULL, pv.curr, 
           pv.entry_id
      INTO retval
      FROM partsvendor pv
      JOIN parts p ON p.id = pv.parts_id
     WHERE parts_id = in_parts_id and credit_id = in_credit_id;

    RETURN retval;

ELSIF t_entity_class = 2 THEN -- CUSTOMER
    UPDATE partscustomer
       SET pricebreak = in_pricebreak,
           sellprice  = in_price,
           validfrom  = in_validfrom,
           validto    = in_validto,
           curr       = in_curr
     WHERE entry_id = in_entry_id and credit_id = in_credit_id;

    IF NOT FOUND THEN
        INSERT INTO partscustomer
               (parts_id, credit_id, sellprice, validfrom, validto, curr)
        VALUES (in_parts_id, in_credit_id, in_price, in_validfrom, in_validto, 
                in_curr);

        t_insert := true;
    END IF;

    SELECT pc.parts_id, p.partnumber, p.description, pc.credit_id, 
           pc.pricebreak, pc.sellprice, NULL, NULL, NULL, pc.validfrom, 
           pc.validto, pc.curr, pc.entry_id
      INTO retval
      FROM partscustomer pc
      JOIN parts p on pc.parts_id = p.id
     WHERE entry_id = CASE WHEN t_insert 
                           THEN currval(&#39;partscustomer_entry_id_seq&#39;) 
                           ELSE in_entry_id 
                      END;
                           
    RETURN retval;

ELSE

RAISE EXCEPTION &#39;No valid entity credit account found&#39;;

END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__account_list() -->
    <section id="public.function.reconciliation-account-list"
             xreflabel="publicreconciliation__account_list()">
      <title id="public.function.reconciliation-account-list-title">
       reconciliation__account_list()
      </title>
      <titleabbrev id="public.function.reconciliation-account-list-titleabbrev">
       reconciliation__account_list()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF recon_accounts</seg>
        </seglistitem>
       </segmentedlist>
 
        returns set of accounts set up for reconciliation.  Currently we pull the 
account number and description from the account table.
        <programlisting>
    SELECT
        coa.accno || &#39; &#39; || coa.description as name,
        coa.accno, coa.id as id
    FROM account coa
         JOIN cr_coa_to_account cta ON cta.chart_id = coa.id
    ORDER BY coa.accno;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric) -->
    <section id="public.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric"
             xreflabel="publicreconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)">
      <title id="public.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric-title">
       reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)
      </title>
      <titleabbrev id="public.function.reconciliation-add-entry-in-amount-integer-in-date-text-in-type-text-in-scn-timestamp-without-time-zone-in-report-id-numeric-titleabbrev">
       reconciliation__add_entry(in_amount integer, in_date text, in_type text, in_scn timestamp without time zone, in_report_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        
This function is used for automatically matching entries from an external source
like a bank-produced csv file.

This function is very sensitive to ordering of inputs.  NULL or empty in_scn values MUST be submitted after meaningful scns.  It is also highly recommended 
that within each category, one submits in order of amount.  We should therefore
wrap it in another function which can operate on a set, perhaps in 1.4....
        <programlisting>
    
    DECLARE
	in_account int;
        la RECORD;
        t_errorcode INT;
        our_value NUMERIC;
        lid INT;
	in_count int;
	t_scn TEXT;
	t_uid int;
	t_prefix text;
        t_amount numeric;
    BEGIN
        SELECT CASE WHEN a.category in (&#39;A&#39;, &#39;E&#39;) THEN in_amount * -1
                    ELSE in_amount
               END into t_amount
          FROM cr_report r JOIN account a ON r.chart_id = a.id
         WHERE r.id = in_report_id; 

	SELECT value into t_prefix FROM defaults WHERE setting_key = &#39;check_prefix&#39;;

	t_uid := person__get_my_entity_id();
	IF in_scn = &#39;&#39; THEN 
		t_scn := NULL;
	ELSE 
		t_scn := t_prefix || in_scn;
	END IF;
	IF t_scn IS NOT NULL THEN
                -- could this be changed to update, if not found insert?
		SELECT count(*) INTO in_count FROM cr_report_line
		WHERE scn ilike t_scn AND report_id = in_report_id 
			AND their_balance = 0;

		IF in_count = 0 THEN
			INSERT INTO cr_report_line
			(report_id, scn, their_balance, our_balance, clear_time,
				&quot;user&quot;, trans_type)
			VALUES 
			(in_report_id, t_scn, t_amount, 0, in_date, t_uid,
				in_type);
		ELSIF in_count = 1 THEN
			UPDATE cr_report_line
			SET their_balance = t_amount, clear_time = in_date,
				cleared = true
			WHERE t_scn = scn AND report_id = in_report_id
				AND their_balance = 0;
		ELSE 
			SELECT count(*) INTO in_count FROM cr_report_line
			WHERE t_scn ilike scn AND report_id = in_report_id
				AND our_value = t_amount and their_balance = 0;

			IF in_count = 0 THEN -- no match among many of values
				SELECT id INTO lid FROM cr_report_line
                        	WHERE t_scn ilike scn AND report_id = in_report_id
				ORDER BY our_balance ASC limit 1;

				UPDATE cr_report_line
                                SET their_balance = t_amount, 
					clear_time = in_date,
					trans_type = in_type,
					cleared = true
                                WHERE id = lid;

			ELSIF in_count = 1 THEN -- EXECT MATCH
				UPDATE cr_report_line
				SET their_balance = t_amount, 
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
				WHERE t_scn = scn AND report_id = in_report_id
                                	AND our_value = t_amount 
					AND their_balance = 0;
			ELSE -- More than one match
				SELECT id INTO lid FROM cr_report_line
                        	WHERE t_scn ilike scn AND report_id = in_report_id
                                	AND our_value = t_amount
				ORDER BY id ASC limit 1;

				UPDATE cr_report_line
                                SET their_balance = t_amount,
					trans_type = in_type,
					cleared = true,
					clear_time = in_date
                                WHERE id = lid;
				
			END IF;
		END IF;
	ELSE -- scn IS NULL, check on amount instead
		SELECT count(*) INTO in_count FROM cr_report_line
		WHERE report_id = in_report_id AND our_balance = t_amount
			AND their_balance = 0 and post_date = in_date
			and scn NOT LIKE t_prefix || &#39;%&#39;;

		IF in_count = 0 THEN -- no match
			INSERT INTO cr_report_line
			(report_id, scn, their_balance, our_balance, clear_time,
			&quot;user&quot;, trans_type)
			VALUES 
			(in_report_id, t_scn, t_amount, 0, in_date, t_uid,
			in_type);
		ELSIF in_count = 1 THEN -- perfect match
			UPDATE cr_report_line SET their_balance = t_amount,
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
			WHERE report_id = in_report_id AND our_balance = t_amount
                        	AND their_balance = 0 and
				in_scn NOT LIKE t_prefix || &#39;%&#39;;
		ELSE -- more than one match
			SELECT min(id) INTO lid FROM cr_report_line
			WHERE report_id = in_report_id AND our_balance = t_amount
                        	AND their_balance = 0 and post_date = in_date
				AND scn NOT LIKE t_prefix || &#39;%&#39;
			LIMIT 1;

			UPDATE cr_report_line SET their_balance = t_amount,
					trans_type = in_type,
					clear_time = in_date,
					cleared = true
			WHERE id = lid;
			
		END IF;
	END IF;
        return 1; 
        
    END;    
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_my_report(in_report_id integer) -->
    <section id="public.function.reconciliation-delete-my-report-in-report-id-integer"
             xreflabel="publicreconciliation__delete_my_report(in_report_id integer)">
      <title id="public.function.reconciliation-delete-my-report-in-report-id-integer-title">
       reconciliation__delete_my_report(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-delete-my-report-in-report-id-integer-titleabbrev">
       reconciliation__delete_my_report(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       This function allows a user to delete his or her own unsubmitted, unapproved
reconciliation reports only.  This is designed to allow a user to back out of
the reconciliation process without cluttering up the search results for others.

        <programlisting>
BEGIN
    DELETE FROM cr_report_line
     WHERE report_id = in_report_id
           AND report_id IN (SELECT id FROM cr_report
                              WHERE entered_username = SESSION_USER
                                    AND submitted IS NOT TRUE
                                    and approved IS NOT TRUE);
    DELETE FROM cr_report
     WHERE id = in_report_id AND entered_username = SESSION_USER
           AND submitted IS NOT TRUE AND approved IS NOT TRUE;
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__delete_unapproved(in_report_id integer) -->
    <section id="public.function.reconciliation-delete-unapproved-in-report-id-integer"
             xreflabel="publicreconciliation__delete_unapproved(in_report_id integer)">
      <title id="public.function.reconciliation-delete-unapproved-in-report-id-integer-title">
       reconciliation__delete_unapproved(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-delete-unapproved-in-report-id-integer-titleabbrev">
       reconciliation__delete_unapproved(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       This function deletes any specified unapproved transaction.
        <programlisting>
BEGIN
    DELETE FROM cr_report_line
     WHERE report_id = in_report_id
           AND report_id IN (SELECT id FROM cr_report
                              WHERE approved IS NOT TRUE);
    DELETE FROM cr_report
     WHERE id = in_report_id AND approved IS NOT TRUE;
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_cleared_balance(in_chart_id integer) -->
    <section id="public.function.reconciliation-get-cleared-balance-in-chart-id-integer"
             xreflabel="publicreconciliation__get_cleared_balance(in_chart_id integer)">
      <title id="public.function.reconciliation-get-cleared-balance-in-chart-id-integer-title">
       reconciliation__get_cleared_balance(in_chart_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-get-cleared-balance-in-chart-id-integer-titleabbrev">
       reconciliation__get_cleared_balance(in_chart_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets the cleared balance of the account specified by chart_id.
This is specified in normal format (i.e. positive numbers for debits for asset
and espense accounts, and positive numbers for credits in other accounts 

Note that currently contra accounts will show negative balances.
        <programlisting>
	select CASE WHEN c.category in(&#39;A&#39;, &#39;E&#39;) THEN sum(ac.amount) * -1 ELSE
		sum(ac.amount) END
	FROM account c
	JOIN acc_trans ac ON (ac.chart_id = c.id)
	JOIN (select id from ar where approved
		union
		select id from ap where approved
		union
		select id from gl where approved) g on (g.id = ac.trans_id)
	WHERE c.id = $1 AND ac.cleared is true and ac.approved is true
		GROUP BY c.id, c.category;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_current_balance(in_date integer, in_account_id date) -->
    <section id="public.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date"
             xreflabel="publicreconciliation__get_current_balance(in_date integer, in_account_id date)">
      <title id="public.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date-title">
       reconciliation__get_current_balance(in_date integer, in_account_id date)
      </title>
      <titleabbrev id="public.function.reconciliation-get-current-balance-in-date-integer-in-account-id-date-titleabbrev">
       reconciliation__get_current_balance(in_date integer, in_account_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>numeric</seg>
        </seglistitem>
       </segmentedlist>
 
        Gets the current balance of all approved transactions against a specific 
account.  For asset and expense accounts this is the debit balance, for others
this is the credit balance.
        <programlisting>
DECLARE outval NUMERIC;
BEGIN
	SELECT CASE WHEN (select category FROM account WHERE id = in_account_id)
			IN (&#39;A&#39;, &#39;E&#39;) THEN sum(a.amount) * -1
		ELSE sum(a.amount) END
	FROM acc_trans a
	JOIN (
		SELECT id FROM ar
		WHERE approved is true
		UNION
		SELECT id FROM ap
		WHERE approved is true
		UNION
		SELECT id FROM gl
		WHERE approved is true
	) gl ON a.trans_id = gl.id
	WHERE a.approved IS TRUE 
		AND a.chart_id = in_account_id
		AND a.transdate &lt;= in_date;

	RETURN outval;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__get_total(in_report_id integer) -->
    <section id="public.function.reconciliation-get-total-in-report-id-integer"
             xreflabel="publicreconciliation__get_total(in_report_id integer)">
      <title id="public.function.reconciliation-get-total-in-report-id-integer-title">
       reconciliation__get_total(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-get-total-in-report-id-integer-titleabbrev">
       reconciliation__get_total(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves all header info from the reconciliation report.
        <programlisting>

    DECLARE
        row cr_report;
    BEGIN
    
        SELECT * INTO row FROM cr_report 
        where id = in_report_id 
        AND scn = -1;
        
        IF NOT FOUND THEN -- I think this is a fairly major error condition
            RAISE EXCEPTION &#39;Bad report id.&#39;;
        ELSE
            return next row;
        END IF;
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean) -->
    <section id="public.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean"
             xreflabel="publicreconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)">
      <title id="public.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean-title">
       reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)
      </title>
      <titleabbrev id="public.function.reconciliation-new-report-id-in-recon-fx-integer-in-end-date-numeric-in-total-date-in-chart-id-boolean-titleabbrev">
       reconciliation__new_report_id(in_recon_fx integer, in_end_date numeric, in_total date, in_chart_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Inserts creates a new report and returns the id.
        <programlisting>

    INSERT INTO cr_report(chart_id, their_total, end_date, recon_fx) 
    values ($1, $2, $3, $4);
    SELECT currval(&#39;cr_report_id_seq&#39;)::int;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric) -->
    <section id="public.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric"
             xreflabel="publicreconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)">
      <title id="public.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric-title">
       reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)
      </title>
      <titleabbrev id="public.function.reconciliation-pending-transactions-in-their-total-date-in-report-id-integer-in-chart-id-integer-in-end-date-numeric-titleabbrev">
       reconciliation__pending_transactions(in_their_total date, in_report_id integer, in_chart_id integer, in_end_date numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Ensures that the list of pending transactions in the report is up to date. 
        <programlisting>
    
    DECLARE
        gl_row RECORD;
        t_recon_fx BOOL;
    BEGIN
                SELECT recon_fx INTO t_recon_fx FROM cr_report WHERE id = in_report_id;
 
		INSERT INTO cr_report_line (report_id, scn, their_balance, 
			our_balance, &quot;user&quot;, voucher_id, ledger_id, post_date)
		SELECT in_report_id, 
		       CASE WHEN ac.source IS NULL OR ac.source = &#39;&#39; 
                            THEN gl.ref
                            ELSE ac.source END,
		       0, 
		       sum(amount / CASE WHEN t_recon_fx IS NOT TRUE OR gl.table = &#39;gl&#39;
                                         THEN 1
                                         WHEN t_recon_fx and gl.table = &#39;ap&#39; 
                                         THEN ex.sell
                                         WHEN t_recon_fx and gl.table = &#39;ar&#39; 
                                         THEN ex.buy
                                    END) AS amount,
				(select entity_id from users 
				where username = CURRENT_USER),
			ac.voucher_id, min(ac.entry_id), ac.transdate
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, curr, 
                             transdate, &#39;ar&#39; as table 
                        FROM ar where approved
			UNION
		      select id, entity_credit_account::text, curr, 
                             transdate, &#39;ap&#39; as table 
                        FROM ap WHERE approved
			UNION
		      select id, reference, &#39;&#39;, 
                             transdate, &#39;gl&#39; as table 
                        FROM gl WHERE approved) gl 
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)))
                LEFT JOIN exchangerate ex ON gl.transdate = ex.transdate
		WHERE ac.cleared IS FALSE
			AND ac.approved IS TRUE
			AND ac.chart_id = in_chart_id
			AND ac.transdate &lt;= in_end_date
                        AND ((t_recon_fx is not true 
                                and ac.fx_transaction is not true) 
                            OR (t_recon_fx is true 
                                AND (gl.table &lt;&gt; &#39;gl&#39; OR ac.fx_transaction
                                                      IS TRUE))) 
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table, 
                        case when gl.table = &#39;gl&#39; then gl.id else 1 end
		HAVING count(rl.id) = 0;

		UPDATE cr_report set updated = now(),
			their_total = coalesce(in_their_total, their_total)
		where id = in_report_id;
    RETURN in_report_id;
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_approve(in_report_id integer) -->
    <section id="public.function.reconciliation-report-approve-in-report-id-integer"
             xreflabel="publicreconciliation__report_approve(in_report_id integer)">
      <title id="public.function.reconciliation-report-approve-in-report-id-integer-title">
       reconciliation__report_approve(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-report-approve-in-report-id-integer-titleabbrev">
       reconciliation__report_approve(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Marks the report approved and marks all cleared transactions in it cleared.
        <programlisting>
    
    -- Does some basic checks before allowing the approval to go through; 
    -- moves the approval to &quot;cr_report_line&quot;, I guess, or some other &quot;final&quot; table.
    --
    -- Pending may just be a single flag in the database to mark that it is
    -- not finalized. Will need to discuss with Chris.
    
    DECLARE
        current_row RECORD;
        completed cr_report_line;
        total_errors INT;
        in_user TEXT;
	ac_entries int[];
    BEGIN
        in_user := current_user;
        
        -- so far, so good. Different user, and no errors remain. Therefore, 
        -- we can move it to completed reports.
        --
        -- User may not be necessary - I would think it better to use the 
        -- in_user, to note who approved the report, than the user who
        -- filed it. This may require clunkier syntax..
        
        -- 
	ac_entries := &#39;{}&#39;;
        update cr_report set approved = &#39;t&#39;,
		approved_by = person__get_my_entity_id(),
		approved_username = SESSION_USER
	where id = in_report_id;

	FOR current_row IN 
		SELECT compound_array(entries) AS entries FROM (
			select as_array(ac.entry_id) as entries
		FROM acc_trans ac
		JOIN transactions t on (ac.trans_id = t.id)
		JOIN (select id, entity_credit_account::text as ref, &#39;ar&#39; as table FROM ar
			UNION
		      select id, entity_credit_account::text, &#39;ap&#39; as table FROM ap
			UNION
		      select id, reference, &#39;gl&#39; as table FROM gl) gl
			ON (gl.table = t.table_name AND gl.id = t.id)
		LEFT JOIN cr_report_line rl ON (rl.report_id = in_report_id
			AND ((rl.ledger_id = ac.entry_id 
				AND ac.voucher_id IS NULL) 
				OR (rl.voucher_id = ac.voucher_id)) and rl.cleared is true)
		WHERE ac.cleared IS FALSE
			AND ac.chart_id = (select chart_id from cr_report where id = in_report_id)
		GROUP BY gl.ref, ac.source, ac.transdate,
			ac.memo, ac.voucher_id, gl.table
		HAVING count(rl.report_id) &gt; 0) a
	LOOP
		ac_entries := ac_entries || current_row.entries;
	END LOOP;

	UPDATE acc_trans SET cleared = TRUE 
	where entry_id = any(ac_entries);
        
        return 1;        
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_details(in_report_id integer) -->
    <section id="public.function.reconciliation-report-details-in-report-id-integer"
             xreflabel="publicreconciliation__report_details(in_report_id integer)">
      <title id="public.function.reconciliation-report-details-in-report-id-integer-title">
       reconciliation__report_details(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-report-details-in-report-id-integer-titleabbrev">
       reconciliation__report_details(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the details of the report. 
        <programlisting>

    DECLARE
        row cr_report_line;
    BEGIN    
        FOR row IN 
		select * from cr_report_line where report_id = in_report_id 
		order by scn, post_date
	LOOP
        
            RETURN NEXT row;
        
        END LOOP;    
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_details_payee(in_report_id integer) -->
    <section id="public.function.reconciliation-report-details-payee-in-report-id-integer"
             xreflabel="publicreconciliation__report_details_payee(in_report_id integer)">
      <title id="public.function.reconciliation-report-details-payee-in-report-id-integer-title">
       reconciliation__report_details_payee(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-report-details-payee-in-report-id-integer-titleabbrev">
       reconciliation__report_details_payee(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF recon_payee</seg>
        </seglistitem>
       </segmentedlist>
 
        Pulls the payee information for the reconciliation report.
        <programlisting>
   DECLARE
        row recon_payee;
    BEGIN    
        FOR row IN 
        	select * from recon_payee where report_id = in_report_id 
        	order by scn, post_date
        LOOP
          RETURN NEXT row;
        END LOOP;    
    END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__report_summary(in_report_id integer) -->
    <section id="public.function.reconciliation-report-summary-in-report-id-integer"
             xreflabel="publicreconciliation__report_summary(in_report_id integer)">
      <title id="public.function.reconciliation-report-summary-in-report-id-integer-title">
       reconciliation__report_summary(in_report_id integer)
      </title>
      <titleabbrev id="public.function.reconciliation-report-summary-in-report-id-integer-titleabbrev">
       reconciliation__report_summary(in_report_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

    DECLARE
        row cr_report;
    BEGIN    
        select * into row from cr_report where id = in_report_id;
        
        RETURN row;
        
    END;

</programlisting>
      </para>
    </section>

<!-- Function reconciliation__save_set(in_line_ids integer, in_report_id integer[]) -->
    <section id="public.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY"
             xreflabel="publicreconciliation__save_set(in_line_ids integer, in_report_id integer[])">
      <title id="public.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY-title">
       reconciliation__save_set(in_line_ids integer, in_report_id integer[])
      </title>
      <titleabbrev id="public.function.reconciliation-save-set-in-line-ids-integer-in-report-id-integerARRAY-titleabbrev">
       reconciliation__save_set(in_line_ids integer, in_report_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Sets which lines of the report are cleared.
        <programlisting>
BEGIN
	UPDATE cr_report_line SET cleared = false
	WHERE report_id = in_report_id;

	UPDATE cr_report_line SET cleared = true
	WHERE report_id = in_report_id AND id = ANY(in_line_ids);
	RETURN found;
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean) -->
    <section id="public.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean"
             xreflabel="publicreconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)">
      <title id="public.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean-title">
       reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)
      </title>
      <titleabbrev id="public.function.reconciliation-search-in-approved-date-in-submitted-date-in-chart-id-numeric-in-balance-to-numeric-in-balance-from-integer-in-date-to-boolean-in-date-from-boolean-titleabbrev">
       reconciliation__search(in_approved date, in_submitted date, in_chart_id numeric, in_balance_to numeric, in_balance_from integer, in_date_to boolean, in_date_from boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF cr_report</seg>
        </seglistitem>
       </segmentedlist>
 
        Searches for reconciliation reports.
NULLs match all values.
in_date_to and in_date_from give a range of reports.  All other inputs are
exact matches.

        <programlisting>
DECLARE report cr_report;
BEGIN
	FOR report IN
		SELECT r.* FROM cr_report r
		JOIN account c ON (r.chart_id = c.id)
		WHERE 
			(in_date_from IS NULL OR in_date_from &lt;= end_date) and
			(in_date_to IS NULL OR in_date_to &gt;= end_date) AND
			(in_balance_from IS NULL 
				or in_balance_from &lt;= their_total ) AND
			(in_balance_to IS NULL 
				OR in_balance_to &gt;= their_total) AND
			(in_chart_id IS NULL OR in_chart_id = chart_id) AND
			(in_submitted IS NULL or in_submitted = submitted) AND
			(in_approved IS NULL OR in_approved = approved) AND
			(r.deleted IS FALSE)
		ORDER BY c.accno, end_date, their_total
	LOOP
		RETURN NEXT report;
	END LOOP; 
END;
</programlisting>
      </para>
    </section>

<!-- Function reconciliation__submit_set(in_line_ids integer, in_report_id integer[]) -->
    <section id="public.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY"
             xreflabel="publicreconciliation__submit_set(in_line_ids integer, in_report_id integer[])">
      <title id="public.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY-title">
       reconciliation__submit_set(in_line_ids integer, in_report_id integer[])
      </title>
      <titleabbrev id="public.function.reconciliation-submit-set-in-line-ids-integer-in-report-id-integerARRAY-titleabbrev">
       reconciliation__submit_set(in_line_ids integer, in_report_id integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Submits a reconciliation report for approval. 
in_line_ids is used to specify which report lines are cleared, finalizing the
report.
        <programlisting>
BEGIN
	UPDATE cr_report set submitted = true where id = in_report_id;
	PERFORM reconciliation__save_set(in_report_id, in_line_ids);

	RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__aa_outstanding(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date) -->
    <section id="public.function.report-aa-outstanding-in-date-to-integer-in-date-from-integer-in-on-hold-text-in-ship-via-text-in-business-units-integer-in-employee-id-integerARRAY-in-meta-number-text-in-entity-name-boolean-in-account-id-date-in-entity-class-date"
             xreflabel="publicreport__aa_outstanding(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date)">
      <title id="public.function.report-aa-outstanding-in-date-to-integer-in-date-from-integer-in-on-hold-text-in-ship-via-text-in-business-units-integer-in-employee-id-integerARRAY-in-meta-number-text-in-entity-name-boolean-in-account-id-date-in-entity-class-date-title">
       report__aa_outstanding(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date)
      </title>
      <titleabbrev id="public.function.report-aa-outstanding-in-date-to-integer-in-date-from-integer-in-on-hold-text-in-ship-via-text-in-business-units-integer-in-employee-id-integerARRAY-in-meta-number-text-in-entity-name-boolean-in-account-id-date-in-entity-class-date-titleabbrev">
       report__aa_outstanding(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF aa_transactions_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

SELECT null::int as id, null::bool as invoice, entity_id, meta_number, 
       entity_name, null::date as transdate, count(*)::text as invnumber, 
       sum(amount) as amount, sum(netamount) as netamount, sum(tax) as tax, 
       sum(paid) as paid, sum(due) as due, max(last_payment) as last_payment, 
       null::date as duedate, null::text as notes, null::text as till, 
       null::text as salesperson, null::text as manager, 
       null::text as shipping_point, null::text as ship_via, 
       null::text[] as business_units
  FROM report__aa_outstanding_details($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
 GROUP BY meta_number, entity_name, entity_id;

</programlisting>
      </para>
    </section>

<!-- Function report__aa_outstanding_details(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date) -->
    <section id="public.function.report-aa-outstanding-details-in-date-to-integer-in-date-from-integer-in-on-hold-text-in-ship-via-text-in-business-units-integer-in-employee-id-integerARRAY-in-meta-number-text-in-entity-name-boolean-in-account-id-date-in-entity-class-date"
             xreflabel="publicreport__aa_outstanding_details(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date)">
      <title id="public.function.report-aa-outstanding-details-in-date-to-integer-in-date-from-integer-in-on-hold-text-in-ship-via-text-in-business-units-integer-in-employee-id-integerARRAY-in-meta-number-text-in-entity-name-boolean-in-account-id-date-in-entity-class-date-title">
       report__aa_outstanding_details(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date)
      </title>
      <titleabbrev id="public.function.report-aa-outstanding-details-in-date-to-integer-in-date-from-integer-in-on-hold-text-in-ship-via-text-in-business-units-integer-in-employee-id-integerARRAY-in-meta-number-text-in-entity-name-boolean-in-account-id-date-in-entity-class-date-titleabbrev">
       report__aa_outstanding_details(in_date_to integer, in_date_from integer, in_on_hold text, in_ship_via text, in_business_units integer, in_employee_id integer[], in_meta_number text, in_entity_name boolean, in_account_id date, in_entity_class date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF aa_transactions_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval aa_transactions_line;

BEGIN

FOR retval IN
SELECT a.id, a.invoice, eeca.id, eca.meta_number, eeca.name, a.transdate,
       a.invnumber, a.amount, a.netamount, a.netamount - a.amount as tax, 
       a.amount - p.due as paid, p.due, p.last_payment, a.duedate, a.notes,
       a.till, ee.name, me.name, a.shippingpoint, a.shipvia, 
       &#39;{}&#39; as business_units -- TODO
  FROM (select id, transdate, invnumber, amount, netamount, duedate, notes, 
               till, person_id, entity_credit_account, invoice, shippingpoint,
               shipvia, ordnumber, ponumber, description, on_hold
          FROM ar
         WHERE in_entity_class = 2 and approved
         UNION
        SELECT id, transdate, invnumber, amount, netamount, duedate, notes,
               null, person_id, entity_credit_account, invoice, shippingpoint,
               shipvia, ordnumber, ponumber, description, on_hold
          FROM ap 
         WHERE in_entity_class = 1 and approved) a 
  JOIN (SELECT trans_id, sum(amount) * 
               CASE WHEN in_entity_class = 1 THEN 1 ELSE -1 END AS due,
               max(transdate) as last_payment
          FROM acc_trans ac
          JOIN account_link al ON ac.chart_id = al.account_id
         WHERE approved AND al.description IN (&#39;AR&#39;, &#39;AP&#39;)
               AND (in_date_to is null or transdate &lt;= in_date_to)
      GROUP BY trans_id) p ON p.trans_id = a.id
  JOIN entity_credit_account eca ON a.entity_credit_account = eca.id
  JOIN entity eeca ON eca.entity_id = eeca.id
  JOIN entity_employee ON entity_employee.entity_id = a.person_id
  JOIN entity ee ON entity_employee.entity_id = ee.id
  LEFT
  JOIN entity me ON entity_employee.manager_id = me.id
 WHERE (in_account_id IS NULL 
          OR EXISTS (select 1 FROM acc_trans 
                      WHERE trans_id = a.id and chart_id = in_account_id))
       AND (in_entity_name IS NULL 
           OR eeca.name @@ plainto_tsquery(in_entity_name))
       AND (in_meta_number IS NULL 
          OR eca.meta_number ilike in_meta_number || &#39;%&#39;)
       AND (in_employee_id IS NULL OR ee.id = in_employee_id)
       AND (in_ship_via IS NULL
          OR a.shipvia @@ plainto_tsquery(in_ship_via))
       AND (in_on_hold IS NULL OR in_on_hold = a.on_hold)
       AND (in_date_from IS NULL OR a.transdate &gt;= in_date_from)
       AND (in_date_to IS NULL OR a.transdate &lt;= in_date_to)
       AND p.due::numeric(100,2) &lt;&gt; 0
LOOP
   RETURN NEXT retval;
END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__aa_transactions(in_tax_account_id integer, in_taxable integer, in_on_hold text, in_date_to text, in_date_from integer, in_shipvia integer, in_notes text, in_description text, in_source text, in_ponumber text, in_ordnumber text, in_invnumber text, in_manager_id text, in_employee_id date, in_meta_number date, in_entity_name boolean, in_account_id boolean, in_entity_class integer) -->
    <section id="public.function.report-aa-transactions-in-tax-account-id-integer-in-taxable-integer-in-on-hold-text-in-date-to-text-in-date-from-integer-in-shipvia-integer-in-notes-text-in-description-text-in-source-text-in-ponumber-text-in-ordnumber-text-in-invnumber-text-in-manager-id-text-in-employee-id-date-in-meta-number-date-in-entity-name-boolean-in-account-id-boolean-in-entity-class-integer"
             xreflabel="publicreport__aa_transactions(in_tax_account_id integer, in_taxable integer, in_on_hold text, in_date_to text, in_date_from integer, in_shipvia integer, in_notes text, in_description text, in_source text, in_ponumber text, in_ordnumber text, in_invnumber text, in_manager_id text, in_employee_id date, in_meta_number date, in_entity_name boolean, in_account_id boolean, in_entity_class integer)">
      <title id="public.function.report-aa-transactions-in-tax-account-id-integer-in-taxable-integer-in-on-hold-text-in-date-to-text-in-date-from-integer-in-shipvia-integer-in-notes-text-in-description-text-in-source-text-in-ponumber-text-in-ordnumber-text-in-invnumber-text-in-manager-id-text-in-employee-id-date-in-meta-number-date-in-entity-name-boolean-in-account-id-boolean-in-entity-class-integer-title">
       report__aa_transactions(in_tax_account_id integer, in_taxable integer, in_on_hold text, in_date_to text, in_date_from integer, in_shipvia integer, in_notes text, in_description text, in_source text, in_ponumber text, in_ordnumber text, in_invnumber text, in_manager_id text, in_employee_id date, in_meta_number date, in_entity_name boolean, in_account_id boolean, in_entity_class integer)
      </title>
      <titleabbrev id="public.function.report-aa-transactions-in-tax-account-id-integer-in-taxable-integer-in-on-hold-text-in-date-to-text-in-date-from-integer-in-shipvia-integer-in-notes-text-in-description-text-in-source-text-in-ponumber-text-in-ordnumber-text-in-invnumber-text-in-manager-id-text-in-employee-id-date-in-meta-number-date-in-entity-name-boolean-in-account-id-boolean-in-entity-class-integer-titleabbrev">
       report__aa_transactions(in_tax_account_id integer, in_taxable integer, in_on_hold text, in_date_to text, in_date_from integer, in_shipvia integer, in_notes text, in_description text, in_source text, in_ponumber text, in_ordnumber text, in_invnumber text, in_manager_id text, in_employee_id date, in_meta_number date, in_entity_name boolean, in_account_id boolean, in_entity_class integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF aa_transactions_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

DECLARE retval aa_transactions_line;

BEGIN

FOR retval IN

SELECT a.id, a.invoice, eeca.id, eca.meta_number, eeca.name,
       a.transdate, a.invnumber, a.amount, a.netamount, 
       a.amount - a.netamount as tax, a.amount - p.due, p.due, p.last_payment, 
       a.duedate, a.notes,
       a.till, eee.name as employee, mee.name as manager, a.shippingpoint, 
       a.shipvia, &#39;{}&#39;
       
  FROM (select id, transdate, invnumber, amount, netamount, duedate, notes, 
               till, person_id, entity_credit_account, invoice, shippingpoint,
               shipvia, ordnumber, ponumber, description, on_hold
          FROM ar
         WHERE in_entity_class = 2 and approved
         UNION
        SELECT id, transdate, invnumber, amount, netamount, duedate, notes,
               null, person_id, entity_credit_account, invoice, shippingpoint,
               shipvia, ordnumber, ponumber, description, on_hold
          FROM ap 
         WHERE in_entity_class = 1 and approved) a 
  JOIN (select sum(amount) * case when in_entity_class = 1 THEN 1 ELSE -1 END
               as due, trans_id, max(transdate) as last_payment
          FROM acc_trans ac
          JOIN account_link l ON ac.chart_id = l.account_id
         WHERE l.description IN (&#39;AR&#39;, &#39;AP&#39;)
      GROUP BY ac.trans_id
       ) p ON p.trans_id = a.id
  JOIN entity_employee ee ON ee.entity_id = a.person_id
  JOIN entity eee ON eee.id = ee.entity_id
  JOIN entity_credit_account eca ON a.entity_credit_account = eca.id
  JOIN entity eeca ON eca.entity_id = eeca.id
  LEFT
  JOIN entity mee ON ee.manager_id = mee.id
 WHERE (in_account_id IS NULL OR 
       EXISTS (select * from acc_trans 
                where trans_id = a.id AND chart_id = in_account_id))
       AND (in_entity_name IS NULL 
           OR eeca.name ilike in_entity_name || &#39;%&#39;)
       AND (in_meta_number IS NULL OR eca.meta_number ilike in_meta_number)
       AND (in_employee_id = ee.entity_id OR in_employee_id IS NULL)
       AND (in_manager_id = mee.id OR in_manager_id IS NULL)
       AND (a.invnumber ilike in_invnumber || &#39;%&#39; OR in_invnumber IS NULL)
       AND (a.ordnumber ilike in_ordnumber || &#39;%&#39; OR in_ordnumber IS NULL)
       AND (a.ponumber ilike in_ponumber || &#39;%&#39; OR in_ponumber IS NULL)
       AND (in_source IS NULL OR
           EXISTS (
              SELECT * from acc_trans where trans_id = a.id 
                     AND source ilike in_source || &#39;%&#39;
           ))
       AND (in_description IS NULL 
              OR a.description @@ plainto_tsquery(in_description))
       AND (in_notes IS NULL OR a.notes @@ plainto_tsquery(in_notes))
       AND (in_shipvia IS NULL OR a.shipvia @@ plainto_tsquery(in_shipvia))
       AND (in_date_from IS NULL OR a.transdate &gt;= in_date_from)
       AND (in_date_to IS NULL OR a.transdate &lt;= in_date_to)
       AND (in_on_hold IS NULL OR in_on_hold = a.on_hold)
       AND (in_taxable IS NULL 
            OR (in_taxable 
              AND (in_tax_account_id IS NULL 
                 OR EXISTS (SELECT 1 FROM acc_trans 
                             WHERE trans_id = a.id 
                                   AND chart_id = in_tax_account_id)
            ))
            OR (NOT in_taxable
                  AND NOT EXISTS (SELECT 1 
                                    FROM acc_trans ac
                                    JOIN account_link al 
                                      ON al.account_id = ac.chart_id
                                   WHERE ac.trans_id = a.id 
                                         AND al.description ilike &#39;%tax&#39;))
            )

LOOP

  RETURN NEXT retval;

END LOOP;

END;
</programlisting>
      </para>
    </section>

<!-- Function report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text) -->
    <section id="public.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text"
             xreflabel="publicreport__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)">
      <title id="public.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text-title">
       report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)
      </title>
      <titleabbrev id="public.function.report-cash-summary-in-to-accno-date-in-from-accno-date-in-date-to-text-in-date-from-text-titleabbrev">
       report__cash_summary(in_to_accno date, in_from_accno date, in_date_to text, in_date_from text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF cash_summary_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT a.id, a.accno, a.is_heading, a.description, t.label, 
       sum(CASE WHEN ac.amount &lt; 0 THEN ac.amount * -1 ELSE NULL END),
       sum(CASE WHEN ac.amount &gt; 0 THEN ac.amount ELSE NULL END)
  FROM (select id, accno, false as is_heading, description FROM account
       UNION
        SELECT id, accno, true, description FROM account_heading) a
  LEFT
  JOIN acc_trans ac ON ac.chart_id = a.id 
  LEFT
  JOIN (select id, case when table_name ilike &#39;ar&#39; THEN &#39;rcpt&#39;
                        when table_name ilike &#39;ap&#39; THEN &#39;pmt&#39;
                        when table_name ilike &#39;gl&#39; THEN &#39;xfer&#39;
                    END AS label
          FROM transactions) t ON t.id = ac.trans_id
 WHERE accno BETWEEN $3 AND $4
        and ac.transdate BETWEEN $1 AND $2
GROUP BY a.id, a.accno, a.is_heading, a.description, t.label
ORDER BY accno;

</programlisting>
      </para>
    </section>

<!-- Function report__coa() -->
    <section id="public.function.report-coa"
             xreflabel="publicreport__coa()">
      <title id="public.function.report-coa-title">
       report__coa()
      </title>
      <titleabbrev id="public.function.report-coa-titleabbrev">
       report__coa()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF coa_entry</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

WITH ac (chart_id, amount) AS (
     SELECT chart_id, CASE WHEN acc_trans.approved and gl.approved THEN amount
                           ELSE 0 
                       END
       FROM acc_trans
       JOIN (select id, approved from ar union all
             select id, approved from ap union all
             select id, approved from gl) gl ON gl.id = acc_trans.trans_id
),
l(account_id, link) AS (
     SELECT account_id, array_to_string(array_agg(description), &#39;:&#39;)
       FROM account_link
   GROUP BY account_id
)
SELECT a.id, a.is_heading, a.accno, a.description, a.gifi_accno, 
       CASE WHEN sum(ac.amount) &lt; 0 THEN sum(amount) * -1 ELSE null::numeric
        END,
       CASE WHEN sum(ac.amount) &gt; 0 THEN sum(amount) ELSE null::numeric END,
       count(ac.*), l.link
  FROM (SELECT id,false as is_heading, accno, description, gifi_accno
          FROM account
         UNION
        SELECT id, true, accno, description, null::text 
          FROM account_heading) a

 LEFT JOIN ac ON ac.chart_id = a.id AND not a.is_heading
 LEFT JOIN l ON l.account_id = a.id AND NOT a.is_heading
  GROUP BY a.id, a.is_heading, a.accno, a.description, a.gifi_accno, l.link
  ORDER BY a.accno;

</programlisting>
      </para>
    </section>

<!-- Function report__general_balance(in_date_to date, in_date_from date) -->
    <section id="public.function.report-general-balance-in-date-to-date-in-date-from-date"
             xreflabel="publicreport__general_balance(in_date_to date, in_date_from date)">
      <title id="public.function.report-general-balance-in-date-to-date-in-date-from-date-title">
       report__general_balance(in_date_to date, in_date_from date)
      </title>
      <titleabbrev id="public.function.report-general-balance-in-date-to-date-in-date-from-date-titleabbrev">
       report__general_balance(in_date_to date, in_date_from date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF general_balance_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>

SELECT a.id, a.accno, a.description,
      sum(CASE WHEN ac.transdate &lt; $1 THEN abs(amount) ELSE null END),
      sum(CASE WHEN ac.transdate &gt;= $1 AND ac.amount &lt; 0 
               THEN ac.amount * -1 ELSE null END),
      SUM(CASE WHEN ac.transdate &gt;= $1 AND ac.amount &gt; 0
               THEN ac.amount ELSE null END),
      SUM(ABS(ac.amount))
 FROM account a 
 LEFT
 JOIN acc_trans ac ON ac.chart_id = a.id
 LEFT 
 JOIN (select id, approved from ar UNION
       SELECT id, approved from ap UNION
       SELECT id, approved FROM gl) gl ON ac.trans_id = gl.id
WHERE gl.approved and ac.approved
      and ac.transdate &lt;= $2 
GROUP BY a.id, a.accno, a.description
ORDER BY a.accno;

</programlisting>
      </para>
    </section>

<!-- Function report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[]) -->
    <section id="public.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY"
             xreflabel="publicreport__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])">
      <title id="public.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY-title">
       report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])
      </title>
      <titleabbrev id="public.function.report-gl-in-business-units-text-in-to-amount-text-in-from-amount-bpchar-in-approved-text-in-to-date-text-in-from-date-text-in-description-date-in-memo-date-in-source-boolean-in-category-numeric-in-accno-numeric-in-reference-integerARRAY-titleabbrev">
       report__gl(in_business_units text, in_to_amount text, in_from_amount bpchar, in_approved text, in_to_date text, in_from_date text, in_description date, in_memo date, in_source boolean, in_category numeric, in_accno numeric, in_reference integer[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF gl_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE 
         retval gl_report_item;
         t_balance numeric;
         t_chart_id int;
BEGIN

IF in_from_date IS NULL THEN
   t_balance := 0;
ELSIF in_accno IS NOT NULL THEN
   SELECT id INTO t_chart_id FROM account WHERE accno  = in_accno;
   t_balance := account__obtain_balance(in_from_date , 
                                       (select id from account 
                                         where accno = in_accno));
ELSE
   t_balance := null;
END IF;

FOR retval IN
       WITH RECURSIVE bu_tree (id, path) AS (
            SELECT id, id::text AS path
              FROM business_unit
             WHERE parent_id is null
            UNION
            SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id
              FROM business_unit bu
              JOIN bu_tree ON bu_tree.id = bu.parent_id
            )
       SELECT g.id, g.type, g.invoice, g.reference, g.description, ac.transdate,
              ac.source, ac.amount, c.accno, c.gifi_accno, 
              g.till, ac.cleared, ac.memo, c.description AS accname, 
              ac.chart_id, ac.entry_id, 
              sum(ac.amount) over (rows unbounded preceding) + t_balance 
                as running_balance,
              compound_array(ARRAY[ARRAY[bac.class_id, bac.bu_id]])
         FROM (select id, &#39;gl&#39; as type, false as invoice, reference, 
                      description, approved,
                      null::text as till 
                 FROM gl
               UNION
               SELECT ar.id, &#39;ar&#39;, invoice, invnumber, e.name, approved, till
                 FROM ar
                 JOIN entity_credit_account eca ON ar.entity_credit_account
                      = eca.id
                 JOIN entity e ON e.id = eca.entity_id
               UNION
               SELECT ap.id, &#39;ap&#39;, invoice, invnumber, e.name, approved,
                      null as till
                 FROM ap
                 JOIN entity_credit_account eca ON ap.entity_credit_account 
                      = eca.id
                 JOIN entity e ON e.id = eca.entity_id) g
         JOIN acc_trans ac ON ac.trans_id = g.id
         JOIN account c ON ac.chart_id = c.id
    LEFT JOIN business_unit_ac bac ON ac.entry_id = bac.entry_id 
    LEFT JOIN bu_tree ON bac.bu_id = bu_tree.id
        WHERE (g.reference ilike in_reference || &#39;%&#39; or in_reference is null)
              AND (c.accno = in_accno OR in_accno IS NULL)
              AND (ac.source ilike &#39;%&#39; || in_source || &#39;%&#39; 
                   OR in_source is null)
              AND (ac.memo ilike &#39;%&#39; || in_memo || &#39;%&#39; OR in_memo is null)
             AND (in_description IS NULL OR
                  g.description
                  @@
                  plainto_tsquery(get_default_lang()::regconfig, in_description))
              AND (transdate BETWEEN in_from_date AND in_to_date
                   OR (transdate &gt;= in_from_date AND  in_to_date IS NULL)
                   OR (transdate &lt;= in_to_date AND in_from_date IS NULL)
                   OR (in_to_date IS NULL AND in_from_date IS NULL))
              AND (in_approved is false OR (g.approved AND ac.approved))
              AND (in_from_amount IS NULL OR ac.amount &gt;= in_from_amount)
              AND (in_to_amount IS NULL OR ac.amount &lt;= in_to_amount)
              AND (in_category = c.category OR in_category IS NULL)
     GROUP BY g.id, g.type, g.invoice, g.reference, g.description, ac.transdate,
              ac.source, ac.amount, c.accno, c.gifi_accno,
              g.till, ac.cleared, ac.memo, c.description,
              ac.chart_id, ac.entry_id, ac.trans_id
       HAVING in_business_units is null or in_business_units 
                &lt;@ compound_array(string_to_array(bu_tree.path, &#39;,&#39;)::int[])
     ORDER BY ac.transdate, ac.trans_id, c.accno
LOOP
   RETURN NEXT retval;
END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean) -->
    <section id="public.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean"
             xreflabel="publicreport__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)">
      <title id="public.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-title">
       report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </title>
      <titleabbrev id="public.function.report-invoice-aging-detail-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-titleabbrev">
       report__invoice_aging_detail(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF report_aging_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
	item report_aging_item;
BEGIN
	FOR item IN
                  WITH RECURSIVE bu_tree (id, path) AS (
                SELECT id, id::text AS path
                  FROM business_unit
                 WHERE id = any(in_business_units)
                 UNION
                SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id
                  FROM business_unit bu
                  JOIN bu_tree ON bu_tree.id = bu.parent_id
                       )
		SELECT c.entity_id, c.meta_number, e.name,
		       e.name as contact_name, 
	               a.invnumber, a.transdate, a.till, a.ordnumber, 
		       a.ponumber, a.notes, 
		       CASE WHEN a.age/30 = 0
		                 THEN (a.sign * sum(ac.amount)) 
                            ELSE 0 END
		            as c0, 
		       CASE WHEN a.age/30 = 1
		                 THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c30, 
		       CASE WHEN a.age/30 = 2
		            THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c60, 
		       CASE WHEN a.age/30 &gt; 2
		            THEN (a.sign * sum(ac.amount))
                            ELSE 0 END
		            as c90, 
		       a.duedate, a.id, a.curr,
		       COALESCE((SELECT sell FROM exchangerate ex
		         WHERE a.curr = ex.curr
		              AND ex.transdate = a.transdate), 1)
		       AS exchangerate,
			(SELECT compound_array(ARRAY[[p.partnumber,
					i.description, i.qty::text]])
				FROM parts p 
				JOIN invoice i ON (i.parts_id = p.id)
				WHERE i.trans_id = a.id) AS line_items,
                   (coalesce(in_to_date, now())::date - a.transdate) as age
		  FROM (select id, invnumber, till, ordnumber, amount, duedate,
                               curr, ponumber, notes, entity_credit_account,
                               -1 AS sign, transdate,
                               CASE WHEN in_use_duedate 
                                    THEN coalesce(in_to_date, now())::date
                                         - duedate
                                    ELSE coalesce(in_to_date, now())::date
                                         - transdate 
                               END as age
                          FROM ar
                         WHERE in_entity_class = 2
                         UNION 
                        SELECT id, invnumber, null, ordnumber, amount, duedate,
                               curr, ponumber, notes, entity_credit_account,
                               1 as sign, transdate,
                               CASE WHEN in_use_duedate 
                                    THEN coalesce(in_to_date, now())::date
                                         - duedate
                                    ELSE coalesce(in_to_date, now())::date
                                         - transdate 
                               END as age
                          FROM ap
                         WHERE in_entity_class = 1) a
                  JOIN acc_trans ac ON ac.trans_id = a.id
                  JOIN account acc ON ac.chart_id = acc.id
                  JOIN account_link acl ON acl.account_id = acc.id
                       AND ((in_entity_class = 1 
                              AND acl.description = &#39;AP&#39;)
                           OR (in_entity_class = 2
                              AND acl.description = &#39;AR&#39;))
		  JOIN entity_credit_account c 
                       ON a.entity_credit_account = c.id
		  JOIN entity e ON (e.id = c.entity_id)
             LEFT JOIN business_unit_ac buac ON ac.entry_id = buac.entry_id
             LEFT JOIN bu_tree ON buac.bu_id = bu_tree.id
	     LEFT JOIN entity_to_location e2l 
                       ON e.id = e2l.entity_id 
                       AND e2l.location_class = 3
             LEFT JOIN location l ON l.id = e2l.location_id
	     LEFT JOIN country ON (country.id = l.country_id)
                 WHERE (e.id = in_entity_id OR in_entity_id IS NULL)
                       AND (in_accno IS NULL or acc.accno = in_accno)
              GROUP BY c.entity_id, c.meta_number, e.name,
                       l.line_one, l.line_two, l.line_three,
                       l.city, l.state, l.mail_code, country.name,
                       a.invnumber, a.transdate, a.till, a.ordnumber,
                       a.ponumber, a.notes, a.amount, a.sign,
                       a.duedate, a.id, a.curr, a.age
                HAVING in_business_units is null or in_business_units 
                       &lt;@ compound_array(string_to_array(bu_tree.path, 
                                         &#39;,&#39;)::int[])
	      ORDER BY entity_id, curr, transdate, invnumber
	LOOP
		return next item;
        END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean) -->
    <section id="public.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean"
             xreflabel="publicreport__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)">
      <title id="public.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-title">
       report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </title>
      <titleabbrev id="public.function.report-invoice-aging-summary-in-use-duedate-integer-in-business-units-integer-in-to-date-text-in-accno-date-in-entity-class-integerARRAY-in-entity-id-boolean-titleabbrev">
       report__invoice_aging_summary(in_use_duedate integer, in_business_units integer, in_to_date text, in_accno date, in_entity_class integer[], in_entity_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF report_aging_item</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT entity_id, account_number, name, contact_name, null::text, null::date, 
       null::text, null::text, null::text, null::text, 
       sum(c0), sum(c30), sum(c60), sum(c90), null::date, null::int, curr,
       null::numeric, null::text[], null::int
  FROM report__invoice_aging_detail($1, $2, $3, $4, $5, $6)
 GROUP BY entity_id, account_number, name, contact_name, curr
 ORDER BY account_number
</programlisting>
      </para>
    </section>

<!-- Function report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean) -->
    <section id="public.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean"
             xreflabel="publicreport_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)">
      <title id="public.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean-title">
       report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)
      </title>
      <titleabbrev id="public.function.report-trial-balance-in-gifi-date-in-project-id-date-in-department-id-integer-in-dateto-integer-in-datefrom-boolean-titleabbrev">
       report_trial_balance(in_gifi date, in_project_id date, in_department_id integer, in_dateto integer, in_datefrom boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF trial_balance_line</seg>
        </seglistitem>
       </segmentedlist>
 
        This is a simple routine to generate trial balances for the full
company, for a project, or for a department.
        <programlisting>
DECLARE out_row trial_balance_line;
BEGIN
	IF in_department_id IS NULL THEN
		FOR out_row IN
			SELECT c.id, c.accno, c.description, 
				SUM(CASE WHEN ac.transdate &lt; in_datefrom 
				              AND c.category IN (&#39;I&#39;, &#39;L&#39;, &#39;Q&#39;)
				    THEN ac.amount
				    ELSE ac.amount * -1
				    END), 
			        SUM(CASE WHEN ac.transdate &gt;= in_date_from 
				              AND ac.amount &gt; 0 
			            THEN ac.amount
			            ELSE 0 END),
			        SUM(CASE WHEN ac.transdate &gt;= in_date_from 
				              AND ac.amount &lt; 0
			            THEN ac.amount
			            ELSE 0 END) * -1,
				SUM(CASE WHEN ac.transdate &gt;= in_date_from
					AND c.charttype IN (&#39;I&#39;)
				    THEN ac.amount
				    WHEN ac.transdate &gt;= in_date_from
				              AND c.category IN (&#39;I&#39;, &#39;L&#39;, &#39;Q&#39;)
				    THEN ac.amount
				    ELSE ac.amount * -1
				    END)
				FROM acc_trans ac
				JOIN (select id, approved FROM ap
					UNION ALL 
					select id, approved FROM gl
					UNION ALL
					select id, approved FROM ar) g
					ON (g.id = ac.trans_id)
				JOIN chart c ON (c.id = ac.chart_id)
				WHERE ac.transdate &lt;= in_date_to
					AND ac.approved AND g.approved
					AND (in_project_id IS NULL 
						OR in_project_id = ac.project_id)
				GROUP BY c.id, c.accno, c.description
				ORDER BY c.accno
				
		LOOP
			RETURN NEXT out_row;
		END LOOP;
	ELSE 
		FOR out_row IN
			SELECT 1
		LOOP
			RETURN NEXT out_row;
		END LOOP;
	END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function save_taxform(in_taxform_name integer, in_country_code text) -->
    <section id="public.function.save-taxform-in-taxform-name-integer-in-country-code-text"
             xreflabel="publicsave_taxform(in_taxform_name integer, in_country_code text)">
      <title id="public.function.save-taxform-in-taxform-name-integer-in-country-code-text-title">
       save_taxform(in_taxform_name integer, in_country_code text)
      </title>
      <titleabbrev id="public.function.save-taxform-in-taxform-name-integer-in-country-code-text-titleabbrev">
       save_taxform(in_taxform_name integer, in_country_code text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves tax form information. Returns true or raises exception.
        <programlisting>
BEGIN
	INSERT INTO country_tax_form(country_id, form_name) 
	values (in_country_code, in_taxform_name);

	RETURN true;
END;
</programlisting>
      </para>
    </section>

<!-- Function session_check(in_token integer, in_session_id text) -->
    <section id="public.function.session-check-in-token-integer-in-session-id-text"
             xreflabel="publicsession_check(in_token integer, in_session_id text)">
      <title id="public.function.session-check-in-token-integer-in-session-id-text-title">
       session_check(in_token integer, in_session_id text)
      </title>
      <titleabbrev id="public.function.session-check-in-token-integer-in-session-id-text-titleabbrev">
       session_check(in_token integer, in_session_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>session</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a session row.  If no session exists, it returns null
        <programlisting>
DECLARE out_row session%ROWTYPE;
BEGIN
	DELETE FROM session
	 WHERE last_used &lt; now() - coalesce((SELECT value FROM defaults
                                    WHERE setting_key = &#39;session_timeout&#39;)::interval,
	                            &#39;90 minutes&#39;::interval);
        UPDATE session 
           SET last_used = now()
         WHERE session_id = in_session_id
               AND token = in_token
	       AND users_id = (select id from users 
			where username = SESSION_USER);
	IF FOUND THEN
		SELECT * INTO out_row FROM session WHERE session_id = in_session_id;
	ELSE
		DELETE FROM SESSION 
		WHERE users_id IN (select id from users
                        where username = SESSION_USER); 
		-- the above query also releases all discretionary locks by the
                -- session

               PERFORM * 
                  FROM defaults
                 WHERE setting_key = &#39;auto_logout&#39; and value = &#39;1&#39;;

                IF FOUND THEN
                    RAISE NOTICE &#39;auto logout&#39;;
                    RETURN NULL;
                ELSE
                    INSERT INTO session (users_id, token)
                    SELECT id, md5(random()::text)
                      FROM users 
                     WHERE username = SESSION_USER;

                    SELECT * INTO out_row FROM SESSION 
                     WHERE users_id = (select id from users
                                             where username = SESSION_USER);
                    RETURN out_row;
               END IF;
	END IF;
	RETURN out_row;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting__get_currencies() -->
    <section id="public.function.setting-get-currencies"
             xreflabel="publicsetting__get_currencies()">
      <title id="public.function.setting-get-currencies-title">
       setting__get_currencies()
      </title>
      <titleabbrev id="public.function.setting-get-currencies-titleabbrev">
       setting__get_currencies()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns an array of currencies from the defaults table.
        <programlisting>
SELECT string_to_array(value, &#39;:&#39;) from defaults where setting_key = &#39;curr&#39;;
</programlisting>
      </para>
    </section>

<!-- Function setting__set(in_value character varying, in_setting_key character varying) -->
    <section id="public.function.setting-set-in-value-character-varying-in-setting-key-character-varying"
             xreflabel="publicsetting__set(in_value character varying, in_setting_key character varying)">
      <title id="public.function.setting-set-in-value-character-varying-in-setting-key-character-varying-title">
       setting__set(in_value character varying, in_setting_key character varying)
      </title>
      <titleabbrev id="public.function.setting-set-in-value-character-varying-in-setting-key-character-varying-titleabbrev">
       setting__set(in_value character varying, in_setting_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        sets a value in the defaults thable and returns true if successful.
        <programlisting>
BEGIN
	UPDATE defaults SET value = in_value WHERE setting_key = in_setting_key;
        IF NOT FOUND THEN
             INSERT INTO defaults (setting_key, value) 
                  VALUES (in_setting_key, in_value);
        END IF;
	RETURN TRUE;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_get(in_key character varying) -->
    <section id="public.function.setting-get-in-key-character-varying"
             xreflabel="publicsetting_get(in_key character varying)">
      <title id="public.function.setting-get-in-key-character-varying-title">
       setting_get(in_key character varying)
      </title>
      <titleabbrev id="public.function.setting-get-in-key-character-varying-titleabbrev">
       setting_get(in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>defaults</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the value of the setting in the defaults table.
        <programlisting>
SELECT * FROM defaults WHERE setting_key = $1;
</programlisting>
      </para>
    </section>

<!-- Function setting_get_default_accounts() -->
    <section id="public.function.setting-get-default-accounts"
             xreflabel="publicsetting_get_default_accounts()">
      <title id="public.function.setting-get-default-accounts-title">
       setting_get_default_accounts()
      </title>
      <titleabbrev id="public.function.setting-get-default-accounts-titleabbrev">
       setting_get_default_accounts()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF defaults</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of settings for default accounts.
        <programlisting>
DECLARE
	account defaults%ROWTYPE;
BEGIN
	FOR account IN 
		SELECT * FROM defaults 
		WHERE setting_key like &#39;%accno_id&#39;
                ORDER BY setting_key
	LOOP
		RETURN NEXT account;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function setting_increment(in_key character varying) -->
    <section id="public.function.setting-increment-in-key-character-varying"
             xreflabel="publicsetting_increment(in_key character varying)">
      <title id="public.function.setting-increment-in-key-character-varying-title">
       setting_increment(in_key character varying)
      </title>
      <titleabbrev id="public.function.setting-increment-in-key-character-varying-titleabbrev">
       setting_increment(in_key character varying)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>character varying</seg>
        </seglistitem>
       </segmentedlist>
 
       This function takes a value for a sequence in the defaults table and increments
it.  Leading zeroes and spaces are preserved as placeholders.  Currently &lt;?lsmb
parsing is not supported in this routine though it may be added at a later date.

        <programlisting>
DECLARE
	base_value VARCHAR;
	raw_value VARCHAR;
	increment INTEGER;
	inc_length INTEGER;
	new_value VARCHAR;
BEGIN
	SELECT value INTO raw_value FROM defaults 
	WHERE setting_key = in_key
	FOR UPDATE;

	SELECT substring(raw_value from  &#39;(&#39; || E&#39;\\&#39; || &#39;d*)(&#39; || E&#39;\\&#39; || &#39;D*|&lt;&#39; || E&#39;\\&#39; || &#39;?lsmb [^&lt;&gt;] &#39; || E&#39;\\&#39; || &#39;?&gt;)*$&#39;)
	INTO base_value;

	IF base_value like &#39;0%&#39; THEN
		increment := base_value::integer + 1;
		SELECT char_length(increment::text) INTO inc_length;

		SELECT overlay(base_value placing increment::varchar
			from (select char_length(base_value) 
				- inc_length + 1) for inc_length)
		INTO new_value;
	ELSE
		new_value := base_value::integer + 1;
	END IF;
	SELECT regexp_replace(raw_value, base_value, new_value) INTO new_value;
	UPDATE defaults SET value = new_value WHERE setting_key = in_key;

	return new_value;	
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__get(in_form_id integer) -->
    <section id="public.function.tax-form-get-in-form-id-integer"
             xreflabel="publictax_form__get(in_form_id integer)">
      <title id="public.function.tax-form-get-in-form-id-integer-title">
       tax_form__get(in_form_id integer)
      </title>
      <titleabbrev id="public.function.tax-form-get-in-form-id-integer-titleabbrev">
       tax_form__get(in_form_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves specified tax form information from the database.
        <programlisting>
SELECT * FROM country_tax_form where id = $1;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__list_all() -->
    <section id="public.function.tax-form-list-all"
             xreflabel="publictax_form__list_all()">
      <title id="public.function.tax-form-list-all-title">
       tax_form__list_all()
      </title>
      <titleabbrev id="public.function.tax-form-list-all-titleabbrev">
       tax_form__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF country_tax_form</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a set of all tax forms, ordered by country_id and id
        <programlisting>
SELECT * FROM country_tax_form ORDER BY country_id, id;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__list_ext() -->
    <section id="public.function.tax-form-list-ext"
             xreflabel="publictax_form__list_ext()">
      <title id="public.function.tax-form-list-ext-title">
       tax_form__list_ext()
      </title>
      <titleabbrev id="public.function.tax-form-list-ext-titleabbrev">
       tax_form__list_ext()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF taxform_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns a list of tax forms with an added field, country_name, to specify the
name of the country.
        <programlisting>
SELECT t.id, t.form_name, t.country_id, c.name, t.default_reportable, 
       t.is_accrual
  FROM country_tax_form t
  JOIN country c ON c.id = t.country_id
 ORDER BY c.name, t.form_name;
</programlisting>
      </para>
    </section>

<!-- Function tax_form__save(in_is_accrual integer, in_default_reportable integer, in_form_name text, in_country_id boolean, in_id boolean) -->
    <section id="public.function.tax-form-save-in-is-accrual-integer-in-default-reportable-integer-in-form-name-text-in-country-id-boolean-in-id-boolean"
             xreflabel="publictax_form__save(in_is_accrual integer, in_default_reportable integer, in_form_name text, in_country_id boolean, in_id boolean)">
      <title id="public.function.tax-form-save-in-is-accrual-integer-in-default-reportable-integer-in-form-name-text-in-country-id-boolean-in-id-boolean-title">
       tax_form__save(in_is_accrual integer, in_default_reportable integer, in_form_name text, in_country_id boolean, in_id boolean)
      </title>
      <titleabbrev id="public.function.tax-form-save-in-is-accrual-integer-in-default-reportable-integer-in-form-name-text-in-country-id-boolean-in-id-boolean-titleabbrev">
       tax_form__save(in_is_accrual integer, in_default_reportable integer, in_form_name text, in_country_id boolean, in_id boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       Saves tax form information to the database.
        <programlisting>
BEGIN
        UPDATE country_tax_form 
           SET country_id = in_country_id,
               form_name =in_form_name,
               default_reportable = coalesce(in_default_reportable,false),
               is_accrual = coalesce(in_is_accrual, false)
         WHERE id = in_id;

        IF FOUND THEN
           RETURN in_id;
        END IF;

	insert into country_tax_form(country_id,form_name, default_reportable) 
	values (in_country_id, in_form_name, 
                coalesce(in_default_reportable, false), 
                coalesce(in_is_accrual, false));

	RETURN currval(&#39;country_tax_form_id_seq&#39;);
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text) -->
    <section id="public.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text"
             xreflabel="publictax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)">
      <title id="public.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-title">
       tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </title>
      <titleabbrev id="public.function.tax-form-details-report-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-titleabbrev">
       tax_form_details_report(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_detail_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides a list of invoices and transactions that a report hits.  This 
is intended to allow an organization to adjust what is reported on the 1099 
before printing them.
        <programlisting>
DECLARE
	out_row tax_form_report_detail_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 then 0 
                              when relation = &#39;acc_trans&#39;
                          THEN ac.reportable_amount * pmt.amount
                                / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 then 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount * pmt.amount
                               / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     SUM(CASE WHEN gl.amount = 0 THEN 0 
                              ELSE ac.reportable_amount * pmt.amount
                               / gl.amount 
                              END
                         * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end 
                         * CASE WHEN relation = &#39;invoice&#39; THEN -1 ELSE 1 END),
                     gl.invnumber, gl.duedate::text, gl.id
                FROM (select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ar&#39; as class
                        FROM ar 
                       UNION 
                      select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ap&#39; as class
                        FROM ap
                     ) gl 
                JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                   LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                   LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id)
		JOIN entity_credit_account ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
                JOIN (SELECT ac.trans_id, sum(ac.amount) as amount,
                             as_array(entry_id) as entry_ids, 
                             as_array(chart_id) as chart_ids,
                             count(*) as num
                        FROM acc_trans ac
                       where chart_id in (select account_id
                                            from account_link
                                           where description like &#39;%paid&#39;)
                          AND transdate BETWEEN in_begin AND in_end
                     group by ac.trans_id
                     ) pmt ON  (pmt.trans_id = gl.id)
		WHERE country_tax_form.id = in_tax_form_id AND meta_number = in_meta_number
		GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, gl.invnumber, gl.duedate, gl.id, entity_credit_account.id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_details_report_accrual(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text) -->
    <section id="public.function.tax-form-details-report-accrual-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text"
             xreflabel="publictax_form_details_report_accrual(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)">
      <title id="public.function.tax-form-details-report-accrual-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-title">
       tax_form_details_report_accrual(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </title>
      <titleabbrev id="public.function.tax-form-details-report-accrual-in-meta-number-integer-in-end-date-in-begin-date-in-tax-form-id-text-titleabbrev">
       tax_form_details_report_accrual(in_meta_number integer, in_end date, in_begin date, in_tax_form_id text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_detail_item</seg>
        </seglistitem>
       </segmentedlist>
 
        This provides a list of invoices and transactions that a report hits.  This 
is intended to allow an organization to adjust what is reported on the 1099 
before printing them.
        <programlisting>
DECLARE
	out_row tax_form_report_detail_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 then 0 
                              when relation = &#39;acc_trans&#39;
                          THEN ac.reportable_amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 then 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     SUM(CASE WHEN gl.amount = 0 
                                   THEN 0 
                              ELSE ac.reportable_amount
                              END
                         * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end 
                         * CASE WHEN relation = &#39;invoice&#39; THEN -1 ELSE 1 END),
                     gl.invnumber, gl.duedate::text, gl.id
                FROM (select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ar&#39; as class
                        FROM ar 
                       WHERE transdate BETWEEN in_begin AND in_end
                       UNION 
                      select id, entity_credit_account, invnumber, duedate, 
                             amount, transdate, &#39;ap&#39; as class
                        FROM ap
                       WHERE transdate BETWEEN in_begin AND in_end
                     ) gl 
                JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                   LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                   LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id)
		JOIN entity_credit_account ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
		WHERE country_tax_form.id = in_tax_form_id AND meta_number = in_meta_number
		GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, gl.invnumber, gl.duedate, gl.id, entity_credit_account.id
	LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date) -->
    <section id="public.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date"
             xreflabel="publictax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)">
      <title id="public.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date-title">
       tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)
      </title>
      <titleabbrev id="public.function.tax-form-summary-report-in-end-integer-in-begin-date-in-tax-form-id-date-titleabbrev">
       tax_form_summary_report(in_end integer, in_begin date, in_tax_form_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       This provides the total reportable value per vendor.  As per 1099 forms, these
are cash-basis documents and show amounts paid.
        <programlisting>
DECLARE
	out_row tax_form_report_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;acc_trans&#39; 
                          THEN ac.reportable_amount * pmt.amount
                                / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount * pmt.amount
                               / gl.amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                          ELSE ac.reportable_amount * pmt.amount
                                / gl.amount
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end
                      * CASE WHEN ac.relation = &#39;invoice&#39; then -1 else 1 end)
                         
		FROM (select id, transdate, entity_credit_account, invoice, 
                             amount, &#39;ar&#39; as class FROM ar 
                       UNION 
                      select id, transdate, entity_credit_account, invoice, 
                              amount, &#39;ap&#39; as class from ap
                     ) gl
               JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                    LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                    LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id 
                             AND ((gl.invoice is true and ac.relation=&#39;invoice&#39;)
                                  OR (gl.invoice is false 
                                     and ac.relation=&#39;acc_trans&#39;)))
                JOIN (SELECT ac.trans_id, sum(ac.amount) as amount,
                             as_array(entry_id) as entry_ids, 
                             as_array(chart_id) as chart_ids,
                             count(*) as num
                        FROM acc_trans ac
                       where chart_id in (select account_id
                                            from account_link
                                           where description like &#39;%paid&#39;)
                          AND transdate BETWEEN in_begin AND in_end
                     group by ac.trans_id
                     ) pmt ON  (pmt.trans_id = gl.id)
		JOIN entity_credit_account 
                  ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
               WHERE country_tax_form.id = in_tax_form_id
             GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, entity_credit_account.id
    LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function tax_form_summary_report_accrual(in_end integer, in_begin date, in_tax_form_id date) -->
    <section id="public.function.tax-form-summary-report-accrual-in-end-integer-in-begin-date-in-tax-form-id-date"
             xreflabel="publictax_form_summary_report_accrual(in_end integer, in_begin date, in_tax_form_id date)">
      <title id="public.function.tax-form-summary-report-accrual-in-end-integer-in-begin-date-in-tax-form-id-date-title">
       tax_form_summary_report_accrual(in_end integer, in_begin date, in_tax_form_id date)
      </title>
      <titleabbrev id="public.function.tax-form-summary-report-accrual-in-end-integer-in-begin-date-in-tax-form-id-date-titleabbrev">
       tax_form_summary_report_accrual(in_end integer, in_begin date, in_tax_form_id date)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF tax_form_report_item</seg>
        </seglistitem>
       </segmentedlist>
 
       This provides the total reportable value per vendor.  As per 1099 forms, these
are cash-basis documents and show amounts paid.
        <programlisting>
DECLARE
	out_row tax_form_report_item;
BEGIN
	FOR out_row IN 
              SELECT entity_credit_account.id,
                     company.legal_name, company.entity_id, 
                     entity_credit_account.entity_class, entity.control_code, 
                     entity_credit_account.meta_number, 
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;acc_trans&#39; 
                          THEN ac.reportable_amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                              WHEN relation = &#39;invoice&#39;
                          THEN ac.reportable_amount
                          ELSE 0
                      END * CASE WHEN gl.class = &#39;ar&#39; THEN -1 else 1 end),
                     sum(CASE WHEN gl.amount = 0 THEN 0
                          ELSE ac.reportable_amount
                      END * CASE WHEN gl.class = &#39;ap&#39; THEN -1 else 1 end
                      * CASE WHEN ac.relation = &#39;invoice&#39; then -1 else 1 end)
                         
		FROM (select id, transdate, entity_credit_account, invoice, 
                             amount, &#39;ar&#39; as class FROM ar 
                       WHERE transdate BETWEEN in_begin AND in_end
                       UNION 
                      select id, transdate, entity_credit_account, invoice, 
                              amount, &#39;ap&#39; as class from ap
                       WHERE transdate BETWEEN in_begin AND in_end
                     ) gl
               JOIN (select trans_id, &#39;acc_trans&#39; as relation, 
                             sum(amount) as amount,
                             sum(case when atf.reportable then amount else 0
                                 end) as reportable_amount
                        FROM  acc_trans
                    LEFT JOIN ac_tax_form atf
                          ON (acc_trans.entry_id = atf.entry_id)
                       GROUP BY trans_id
                       UNION
                      select trans_id, &#39;invoice&#39; as relation, 
                             sum(sellprice * qty) as amount,
                             sum(case when itf.reportable 
                                      then sellprice * qty
                                      else 0
                                 end) as reportable_amount
                        FROM invoice
                    LEFT JOIN invoice_tax_form itf
                          ON (invoice.id = itf.invoice_id)
                       GROUP BY trans_id
                     ) ac ON (ac.trans_id = gl.id 
                             AND ((gl.invoice is true and ac.relation=&#39;invoice&#39;)
                                  OR (gl.invoice is false 
                                     and ac.relation=&#39;acc_trans&#39;)))
		JOIN entity_credit_account 
                  ON (gl.entity_credit_account = entity_credit_account.id) 
		JOIN entity ON (entity.id = entity_credit_account.entity_id) 
		JOIN company ON (entity.id = company.entity_id)
		JOIN country_tax_form ON (entity_credit_account.taxform_id = country_tax_form.id)
               WHERE country_tax_form.id = in_tax_form_id
             GROUP BY legal_name, meta_number, company.entity_id, entity_credit_account.entity_class, entity.control_code, entity_credit_account.id
    LOOP
		RETURN NEXT out_row;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function test_get_account_id(in_accno text) -->
    <section id="public.function.test-get-account-id-in-accno-text"
             xreflabel="publictest_get_account_id(in_accno text)">
      <title id="public.function.test-get-account-id-in-accno-text-title">
       test_get_account_id(in_accno text)
      </title>
      <titleabbrev id="public.function.test-get-account-id-in-accno-text-titleabbrev">
       test_get_account_id(in_accno text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
SELECT id FROM chart WHERE accno = $1; 
</programlisting>
      </para>
    </section>

<!-- Function tg_enforce_perms_eclass() -->
    <section id="public.function.tg-enforce-perms-eclass"
             xreflabel="publictg_enforce_perms_eclass()">
      <title id="public.function.tg-enforce-perms-eclass-title">
       tg_enforce_perms_eclass()
      </title>
      <titleabbrev id="public.function.tg-enforce-perms-eclass-titleabbrev">
       tg_enforce_perms_eclass()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE
   r_eclass entity_class;
   roll_pfx text;
BEGIN
IF TG_OP = &#39;DELETE&#39; THEN
   RETURN OLD;
ELSE 
   SELECT value INTO roll_pfx FROM defaults WHERE setting_key = &#39;roll_prefix&#39;;
   SELECT * INTO r_eclass from entity_class WHERE id = NEW.entity_class;
   IF pg_has_role(SESSION_USER, coalesce(roll_pfx, 
                                         &#39;lsmb_&#39; || current_database() || &#39;__&#39;)
                                || &#39;contact_class_&#39; || lower(regexp_replace(
                                                        r_eclass.class, 
                                                        &#39; &#39;, 
                                                        &#39;_&#39;)), &#39;USAGE&#39;)
   THEN
      RETURN NEW;
   ELSE
      RAISE EXCEPTION &#39;Access Denied for class&#39;;
   END IF;
END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function timecard__get(id integer) -->
    <section id="public.function.timecard-get-id-integer"
             xreflabel="publictimecard__get(id integer)">
      <title id="public.function.timecard-get-id-integer-title">
       timecard__get(id integer)
      </title>
      <titleabbrev id="public.function.timecard-get-id-integer-titleabbrev">
       timecard__get(id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>jcitems</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> SELECT * FROM jcitems WHERE id = $1; </programlisting>
      </para>
    </section>

<!-- Function timecard__parts(in_service boolean, in_timecard boolean) -->
    <section id="public.function.timecard-parts-in-service-boolean-in-timecard-boolean"
             xreflabel="publictimecard__parts(in_service boolean, in_timecard boolean)">
      <title id="public.function.timecard-parts-in-service-boolean-in-timecard-boolean-title">
       timecard__parts(in_service boolean, in_timecard boolean)
      </title>
      <titleabbrev id="public.function.timecard-parts-in-service-boolean-in-timecard-boolean-titleabbrev">
       timecard__parts(in_service boolean, in_timecard boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF parts</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * 
  FROM parts
 WHERE not obsolete
       AND ($1 OR inventory_accno_id IS NULL)
       AND ($2 OR (income_accno_id IS NOT NULL 
             AND inventory_accno_id IS NULL))
 ORDER BY partnumber;
</programlisting>
      </para>
    </section>

<!-- Function timecard__report(in_closed integer[], in_open text, in_date_to integer, in_date_from date, in_person_id date, in_partnumber boolean, in_business_units boolean) -->
    <section id="public.function.timecard-report-in-closed-integerARRAY-in-open-text-in-date-to-integer-in-date-from-date-in-person-id-date-in-partnumber-boolean-in-business-units-boolean"
             xreflabel="publictimecard__report(in_closed integer[], in_open text, in_date_to integer, in_date_from date, in_person_id date, in_partnumber boolean, in_business_units boolean)">
      <title id="public.function.timecard-report-in-closed-integerARRAY-in-open-text-in-date-to-integer-in-date-from-date-in-person-id-date-in-partnumber-boolean-in-business-units-boolean-title">
       timecard__report(in_closed integer[], in_open text, in_date_to integer, in_date_from date, in_person_id date, in_partnumber boolean, in_business_units boolean)
      </title>
      <titleabbrev id="public.function.timecard-report-in-closed-integerARRAY-in-open-text-in-date-to-integer-in-date-from-date-in-person-id-date-in-partnumber-boolean-in-business-units-boolean-titleabbrev">
       timecard__report(in_closed integer[], in_open text, in_date_to integer, in_date_from date, in_person_id date, in_partnumber boolean, in_business_units boolean)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF timecard_report_line</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
WITH RECURSIVE bu_tree (id, path) AS (
     SELECT id, id::text AS path, control_code, description
       FROM business_unit
      WHERE id = any($1)
      UNION
     SELECT bu.id, bu_tree.path || &#39;,&#39; || bu.id, bu.control_code, bu.description
       FROM business_unit bu
       JOIN bu_tree ON bu_tree.id = bu.parent_id
)
SELECT j.id, j.description, j.qty, j.allocated, j.checkedin::time as checkedin,
       j.checkedout::time as checkedout, j.checkedin::date as transdate,
       extract(&#39;dow&#39; from j.checkedin) as weekday, 
       extract(&#39;week&#39; from j.checkedin) as workweek,
       p.partnumber, bu.control_code as business_unit_code, 
       bu.description AS businessunit_description,
       ee.employeenumber, e.name AS employee, j.parts_id, j.sellprice
  FROM jcitems j
  JOIN parts p ON p.id = j.parts_id
  JOIN person ON person.id = j.person_id
  JOIN entity_employee ee ON ee.entity_id = person.entity_id
  JOIN entity e ON ee.entity_id = e.id
  JOIN bu_tree bu ON bu.id = j.business_unit_id
 WHERE (p.partnumber = $2 OR $2 IS NULL)
       AND (ee.entity_id = $3 OR $3 IS NULL)
       AND (j.checkedin::date &lt;= $4 OR $4 IS NULL)
       AND (j.checkedin::date &gt;= $5 OR $5 IS NULL)
       AND (j.qty &gt; j.allocated AND $6)
       AND (j.qty &lt;= j.allocated AND $7);
</programlisting>
      </para>
    </section>

<!-- Function timecard__save(in_non_billable integer, in_total integer, in_notes integer, in_person_id text, in_checkedout numeric, in_checkedin numeric, in_serialnumber numeric, in_fxsellprice numeric, in_sellprice text, in_allocated timestamp with time zone, in_qty timestamp with time zone, in_description integer, in_parts_id text, in_business_unit_id numeric, in_id numeric) -->
    <section id="public.function.timecard-save-in-non-billable-integer-in-total-integer-in-notes-integer-in-person-id-text-in-checkedout-numeric-in-checkedin-numeric-in-serialnumber-numeric-in-fxsellprice-numeric-in-sellprice-text-in-allocated-timestamp-with-time-zone-in-qty-timestamp-with-time-zone-in-description-integer-in-parts-id-text-in-business-unit-id-numeric-in-id-numeric"
             xreflabel="publictimecard__save(in_non_billable integer, in_total integer, in_notes integer, in_person_id text, in_checkedout numeric, in_checkedin numeric, in_serialnumber numeric, in_fxsellprice numeric, in_sellprice text, in_allocated timestamp with time zone, in_qty timestamp with time zone, in_description integer, in_parts_id text, in_business_unit_id numeric, in_id numeric)">
      <title id="public.function.timecard-save-in-non-billable-integer-in-total-integer-in-notes-integer-in-person-id-text-in-checkedout-numeric-in-checkedin-numeric-in-serialnumber-numeric-in-fxsellprice-numeric-in-sellprice-text-in-allocated-timestamp-with-time-zone-in-qty-timestamp-with-time-zone-in-description-integer-in-parts-id-text-in-business-unit-id-numeric-in-id-numeric-title">
       timecard__save(in_non_billable integer, in_total integer, in_notes integer, in_person_id text, in_checkedout numeric, in_checkedin numeric, in_serialnumber numeric, in_fxsellprice numeric, in_sellprice text, in_allocated timestamp with time zone, in_qty timestamp with time zone, in_description integer, in_parts_id text, in_business_unit_id numeric, in_id numeric)
      </title>
      <titleabbrev id="public.function.timecard-save-in-non-billable-integer-in-total-integer-in-notes-integer-in-person-id-text-in-checkedout-numeric-in-checkedin-numeric-in-serialnumber-numeric-in-fxsellprice-numeric-in-sellprice-text-in-allocated-timestamp-with-time-zone-in-qty-timestamp-with-time-zone-in-description-integer-in-parts-id-text-in-business-unit-id-numeric-in-id-numeric-titleabbrev">
       timecard__save(in_non_billable integer, in_total integer, in_notes integer, in_person_id text, in_checkedout numeric, in_checkedin numeric, in_serialnumber numeric, in_fxsellprice numeric, in_sellprice text, in_allocated timestamp with time zone, in_qty timestamp with time zone, in_description integer, in_parts_id text, in_business_unit_id numeric, in_id numeric)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>jcitems</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
DECLARE retval jcitems;

BEGIN

UPDATE jcitems 
   SET description = in_description,
       qty = in_qty,
       allocated = in_allocated,
       serialnumber = in_serialnumber,
       checkedin = in_checkedin,
       checkedout = in_checkedout,
       person_id = person__get_my_entity_id(),
       notes = in_notes,
       total = in_total,
       non_billable = in_non_billable
 WHERE id = in_id;

IF FOUND THEN
  SELECT * INTO retval WHERE id = in_id;
  return retval;
END IF;

INSERT INTO jcitems 
(business_unit_id, parts_id, description, qty, allocated, sellprice,
  fxsellprice, serialnumber, checkedin, checkedout, person_id, notes,
  total, non_billable)
VALUES
(in_business_unit_id, in_parts_id, in_description, in_qty, in_allocated, 
  in_sellprice, in_fxsellprice, in_serialnumber, in_checkedin, in_checkedout, 
  in_person_id, in_notes, in_total, in_non_billable);

SELECT * INTO retval WHERE id = currval(&#39;jcitems_id_seq&#39;)::int;

RETURN retval;

END;
</programlisting>
      </para>
    </section>

<!-- Function to_args(in_args text[], in_base text[]) -->
    <section id="public.function.to-args-in-args-textARRAY-in-base-textARRAY"
             xreflabel="publicto_args(in_args text[], in_base text[])">
      <title id="public.function.to-args-in-args-textARRAY-in-base-textARRAY-title">
       to_args(in_args text[], in_base text[])
      </title>
      <titleabbrev id="public.function.to-args-in-args-textARRAY-in-base-textARRAY-titleabbrev">
       to_args(in_args text[], in_base text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
       
This function takes two arguments.  The first is a one-dimensional array 
representing the  base state of the argument array.  The second is a two 
element array of {key, value}.

If either of the args is null, it returns the first argument.  Otherwise it 
returns the first initial array, concatenated with key || &apos;=&apos; || value.

It primarily exists for the to_args aggregate.

        <programlisting>
SELECT CASE WHEN $2[1] IS NULL OR $2[2] IS NULL THEN $1 
            ELSE $1 || ($2[1]::text || &#39;=&#39; || $2[2]::text)
       END;
</programlisting>
      </para>
    </section>

<!-- Function to_args(text[]) -->
    <section id="public.function.to-args-textARRAY"
             xreflabel="publicto_args(text[])">
      <title id="public.function.to-args-textARRAY-title">
       to_args(text[])
      </title>
      <titleabbrev id="public.function.to-args-textARRAY-titleabbrev">
       to_args(text[])
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>INTERNAL</seg>
         <seg>text[]</seg>
        </seglistitem>
       </segmentedlist>
 
        Turns a setof ARRAY[key,value] into an 
ARRAY[key||&apos;=&apos;||value, key||&apos;=&apos;||value,...]

        <programlisting>aggregate_dummy</programlisting>
      </para>
    </section>

<!-- Function track_global_sequence() -->
    <section id="public.function.track-global-sequence"
             xreflabel="publictrack_global_sequence()">
      <title id="public.function.track-global-sequence-title">
       track_global_sequence()
      </title>
      <titleabbrev id="public.function.track-global-sequence-titleabbrev">
       track_global_sequence()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
        This trigger is used to track the id sequence entries across the 
transactions table, and with the ar, ap, and gl tables.  This is necessary 
because these have not been properly refactored yet.

        <programlisting>
BEGIN
	IF tg_op = &#39;INSERT&#39; THEN
		INSERT INTO transactions (id, table_name, approved) 
		VALUES (new.id, TG_RELNAME, new.approved);
	ELSEIF tg_op = &#39;UPDATE&#39; THEN
		IF new.id = old.id AND new.approved = old.approved THEN
			return new;
		ELSE
			UPDATE transactions SET id = new.id, 
                                                approved = new.approved
                         WHERE id = old.id;
		END IF;
	ELSE 
		DELETE FROM transactions WHERE id = old.id;
	END IF;
	RETURN new;
END;
</programlisting>
      </para>
    </section>

<!-- Function trigger_parts_short() -->
    <section id="public.function.trigger-parts-short"
             xreflabel="publictrigger_parts_short()">
      <title id="public.function.trigger-parts-short-title">
       trigger_parts_short()
      </title>
      <titleabbrev id="public.function.trigger-parts-short-titleabbrev">
       trigger_parts_short()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>trigger</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
BEGIN
  IF NEW.onhand &gt;= NEW.rop THEN
    NOTIFY parts_short;
  END IF;
  RETURN NEW;
END;
</programlisting>
      </para>
    </section>

<!-- Function unlock(in_id integer) -->
    <section id="public.function.unlock-in-id-integer"
             xreflabel="publicunlock(in_id integer)">
      <title id="public.function.unlock-in-id-integer-title">
       unlock(in_id integer)
      </title>
      <titleabbrev id="public.function.unlock-in-id-integer-titleabbrev">
       unlock(in_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Releases a pessimistic locks against a transaction, if that transaciton, as 
identified by in_id exists, and if  it is locked by the current session. 
These locks are again only advisory, and the application may choose to handle 
them or not.

Returns true if the transaction was unlocked by this routine, false 
otherwise.
        <programlisting>
BEGIN
    UPDATE transactions SET locked_by = NULL WHERE id = in_id 
           AND locked_by IN (SELECT session_id FROM session WHERE users_id =
		(SELECT id FROM users WHERE username = SESSION_USER));
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function unlock_all() -->
    <section id="public.function.unlock-all"
             xreflabel="publicunlock_all()">
      <title id="public.function.unlock-all-title">
       unlock_all()
      </title>
      <titleabbrev id="public.function.unlock-all-titleabbrev">
       unlock_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
       Releases all pessimistic locks against transactions.  These locks are again
only advisory, and the application may choose to handle them or not.

Returns true if any transactions were unlocked, false otherwise.
        <programlisting>
BEGIN
    UPDATE transactions SET locked_by = NULL 
    where locked_by IN 
          (select session_id from session WHERE users_id = 
                  (SELECT id FROM users WHERE username = SESSION_USER));

    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__change_password(in_new_password text) -->
    <section id="public.function.user-change-password-in-new-password-text"
             xreflabel="publicuser__change_password(in_new_password text)">
      <title id="public.function.user-change-password-in-new-password-text-title">
       user__change_password(in_new_password text)
      </title>
      <titleabbrev id="public.function.user-change-password-in-new-password-text-titleabbrev">
       user__change_password(in_new_password text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Alloes a user to change his or her own password.  The password is set to 
expire setting_get(&apos;password_duration&apos;) days after the password change.
        <programlisting>
DECLARE
	t_expires timestamp;
        t_password_duration text;
BEGIN
    SELECT value INTO t_password_duration FROM defaults 
     WHERE setting_key = &#39;password_duration&#39;;
    IF t_password_duration IS NULL or t_password_duration=&#39;&#39; THEN
        t_expires := &#39;infinity&#39;;
    ELSE
        t_expires := now() 
                     + (t_password_duration::numeric::text || &#39; days&#39;)::interval;
    END IF;


    UPDATE users SET notify_password = DEFAULT where username = SESSION_USER;

    EXECUTE &#39;ALTER USER &#39; || quote_ident(SESSION_USER) || 
            &#39; with ENCRYPTED password &#39; || quote_literal(in_new_password) ||
                 &#39; VALID UNTIL &#39;|| quote_literal(t_expires);
    return 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__check_my_expiration() -->
    <section id="public.function.user-check-my-expiration"
             xreflabel="publicuser__check_my_expiration()">
      <title id="public.function.user-check-my-expiration-title">
       user__check_my_expiration()
      </title>
      <titleabbrev id="public.function.user-check-my-expiration-titleabbrev">
       user__check_my_expiration()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>interval</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the time when password of the current logged in user is set to 
expire.
        <programlisting>
DECLARE
    outval interval;
BEGIN
    SELECT CASE WHEN isfinite(rolvaliduntil) is not true THEN &#39;1 year&#39;::interval
                ELSE rolvaliduntil - now() END AS expiration INTO outval 
    FROM pg_roles WHERE rolname = SESSION_USER;
    RETURN outval;
end;
</programlisting>
      </para>
    </section>

<!-- Function user__expires_soon() -->
    <section id="public.function.user-expires-soon"
             xreflabel="publicuser__expires_soon()">
      <title id="public.function.user-expires-soon-title">
       user__expires_soon()
      </title>
      <titleabbrev id="public.function.user-expires-soon-titleabbrev">
       user__expires_soon()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns true if the password of the current logged in user is set to expire 
within on week.
        <programlisting>
   SELECT user__check_my_expiration() &lt; &#39;1 week&#39;;
</programlisting>
      </para>
    </section>

<!-- Function user__get_all_users() -->
    <section id="public.function.user-get-all-users"
             xreflabel="publicuser__get_all_users()">
      <title id="public.function.user-get-all-users-title">
       user__get_all_users()
      </title>
      <titleabbrev id="public.function.user-get-all-users-titleabbrev">
       user__get_all_users()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF user_listable</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
    
    select * from user_listable;
    
</programlisting>
      </para>
    </section>

<!-- Function user__get_preferences(in_user_id integer) -->
    <section id="public.function.user-get-preferences-in-user-id-integer"
             xreflabel="publicuser__get_preferences(in_user_id integer)">
      <title id="public.function.user-get-preferences-in-user-id-integer-title">
       user__get_preferences(in_user_id integer)
      </title>
      <titleabbrev id="public.function.user-get-preferences-in-user-id-integer-titleabbrev">
       user__get_preferences(in_user_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF user_preference</seg>
        </seglistitem>
       </segmentedlist>
 
        Returns the preferences row for the user.
        <programlisting>
    
declare
    v_row user_preference;
BEGIN
    select * into v_row from user_preference where id = in_user_id;
    
    IF NOT FOUND THEN
    
        RAISE EXCEPTION &#39;Could not find user preferences for id %&#39;, in_user_id;
    ELSE
        return next v_row;
    END IF;
END;
</programlisting>
      </para>
    </section>

<!-- Function user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text) -->
    <section id="public.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text"
             xreflabel="publicuser__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)">
      <title id="public.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text-title">
       user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)
      </title>
      <titleabbrev id="public.function.user-save-preferences-in-printer-text-in-stylesheet-text-in-language-text-in-numberformat-text-in-dateformat-text-titleabbrev">
       user__save_preferences(in_printer text, in_stylesheet text, in_language text, in_numberformat text, in_dateformat text)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>boolean</seg>
        </seglistitem>
       </segmentedlist>
 
        Saves user preferences.  Returns true if successful, false if no preferences
were found to update.
        <programlisting>
BEGIN
    UPDATE user_preference
    SET dateformat = in_dateformat,
        numberformat = in_numberformat,
        language = in_language,
        stylesheet = in_stylesheet,
        printer = in_printer
    WHERE id = (select id from users where username = SESSION_USER);
    RETURN FOUND;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher__delete(in_voucher_id integer) -->
    <section id="public.function.voucher-delete-in-voucher-id-integer"
             xreflabel="publicvoucher__delete(in_voucher_id integer)">
      <title id="public.function.voucher-delete-in-voucher-id-integer-title">
       voucher__delete(in_voucher_id integer)
      </title>
      <titleabbrev id="public.function.voucher-delete-in-voucher-id-integer-titleabbrev">
       voucher__delete(in_voucher_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>integer</seg>
        </seglistitem>
       </segmentedlist>
 
        Deletes the specified voucher from the batch.
        <programlisting>
DECLARE 
	voucher_row RECORD;
BEGIN
	SELECT * INTO voucher_row FROM voucher WHERE id = in_voucher_id;
	IF voucher_row.batch_class IN (1, 2, 5) THEN
        DELETE FROM ac_tax_form WHERE entry_id IN (
               SELECT entry_id
                 FROM acc_trans
               WHERE trans_id = voucher_row.trans_id);
 
		DELETE FROM acc_trans WHERE trans_id = voucher_row.trans_id;
		DELETE FROM ar WHERE id = voucher_row.trans_id;
		DELETE FROM ap WHERE id = voucher_row.trans_id;
		DELETE FROM gl WHERE id = voucher_row.trans_id;
		DELETE FROM voucher WHERE id = voucher_row.id;
		-- DELETE FROM transactions WHERE id = voucher_row.trans_id;
	ELSE 
		update ar set paid = amount + 
			(select sum(amount) from acc_trans 
			join chart ON (acc_trans.chart_id = chart.id)
			where link = &#39;AR&#39; AND trans_id = ar.id
				AND (voucher_id IS NULL 
				OR voucher_id &lt;&gt; voucher_row.id))
		where id in (select trans_id from acc_trans 
				where voucher_id = voucher_row.id);

		update ap set paid = amount - (select sum(amount) from acc_trans 
			join chart ON (acc_trans.chart_id = chart.id)
			where link = &#39;AP&#39; AND trans_id = ap.id
				AND (voucher_id IS NULL 
				OR voucher_id &lt;&gt; voucher_row.id))
		where id in (select trans_id from acc_trans 
				where voucher_id = voucher_row.id);
                DELETE FROM ac_tax_form WHERE entry_id IN
                       (select entry_id from acc_trans 
                         where voucher_id = voucher_row.id);

		DELETE FROM acc_trans where voucher_id = voucher_row.id;
	END IF;
	RETURN 1;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher__list(in_batch_id integer) -->
    <section id="public.function.voucher-list-in-batch-id-integer"
             xreflabel="publicvoucher__list(in_batch_id integer)">
      <title id="public.function.voucher-list-in-batch-id-integer-title">
       voucher__list(in_batch_id integer)
      </title>
      <titleabbrev id="public.function.voucher-list-in-batch-id-integer-titleabbrev">
       voucher__list(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF voucher_list</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves a list of vouchers and amounts attached to the batch.
        <programlisting>
declare voucher_item record;
BEGIN
    	FOR voucher_item IN
		SELECT v.id, a.invoice, a.invnumber, e.name, 
			v.batch_id, v.trans_id, 
			a.amount, a.transdate, &#39;Payable&#39;
		FROM voucher v
		JOIN ap a ON (v.trans_id = a.id)
		JOIN entity_credit_account eca 
			ON (eca.id = a.entity_credit_account)
		JOIN entity e ON (eca.entity_id = e.id)
		WHERE v.batch_id = in_batch_id 
			AND v.batch_class = (select id from batch_class 
					WHERE class = &#39;ap&#39;)
		UNION
		SELECT v.id, a.invoice, a.invnumber, e.name, 
			v.batch_id, v.trans_id, 
			a.amount, a.transdate, &#39;Receivable&#39;
		FROM voucher v
		JOIN ar a ON (v.trans_id = a.id)
		JOIN entity_credit_account eca 
			ON (eca.id = a.entity_credit_account)
		JOIN entity e ON (eca.entity_id = e.id)
		WHERE v.batch_id = in_batch_id 
			AND v.batch_class = (select id from batch_class 
					WHERE class = &#39;ar&#39;)
		UNION ALL
		-- TODO:  Add the class labels to the class table.
		SELECT v.id, false, a.source, 
			cr.meta_number || &#39;--&#39;  || co.legal_name , 
			v.batch_id, v.trans_id, 
			sum(CASE WHEN bc.class LIKE &#39;payment%&#39; THEN a.amount * -1
			     ELSE a.amount  END), a.transdate, 
			CASE WHEN bc.class = &#39;payment&#39; THEN &#39;Payment&#39;
			     WHEN bc.class = &#39;payment_reversal&#39; 
			     THEN &#39;Payment Reversal&#39;
			END
		FROM voucher v
		JOIN acc_trans a ON (v.id = a.voucher_id)
                JOIN batch_class bc ON (bc.id = v.batch_class)
		JOIN chart c ON (a.chart_id = c.id)
		JOIN ap ON (ap.id = a.trans_id)
		JOIN entity_credit_account cr 
			ON (ap.entity_credit_account = cr.id)
		JOIN company co ON (cr.entity_id = co.entity_id)
		WHERE v.batch_id = in_batch_id 
			AND a.voucher_id = v.id
			AND (bc.class like &#39;payment%&#39; AND c.link = &#39;AP&#39;)
		GROUP BY v.id, a.source, cr.meta_number, co.legal_name ,
                        v.batch_id, v.trans_id, a.transdate, bc.class

		UNION ALL
		SELECT v.id, false, a.source, a.memo, 
			v.batch_id, v.trans_id, 
			CASE WHEN bc.class LIKE &#39;receipt%&#39; THEN sum(a.amount) * -1
			     ELSE sum(a.amount)  END, a.transdate, 
			CASE WHEN bc.class = &#39;receipt&#39; THEN &#39;Receipt&#39;
			     WHEN bc.class = &#39;receipt_reversal&#39; 
			     THEN &#39;Receipt Reversal&#39;
			END
		FROM voucher v
		JOIN acc_trans a ON (v.id = a.voucher_id)
                JOIN batch_class bc ON (bc.id = v.batch_class)
		JOIN chart c ON (a.chart_id = c.id)
		JOIN ar ON (ar.id = a.trans_id)
		JOIN entity_credit_account cr 
			ON (ar.entity_credit_account = cr.id)
		JOIN company co ON (cr.entity_id = co.entity_id)
		WHERE v.batch_id = in_batch_id 
			AND a.voucher_id = v.id
			AND (bc.class like &#39;receipt%&#39; AND c.link = &#39;AR&#39;)
		GROUP BY v.id, a.source, cr.meta_number, co.legal_name ,
                        a.memo, v.batch_id, v.trans_id, a.transdate, bc.class
		UNION ALL
		SELECT v.id, false, g.reference, g.description, 
			v.batch_id, v.trans_id,
			sum(a.amount), g.transdate, &#39;GL&#39;
		FROM voucher v
		JOIN gl g ON (g.id = v.trans_id)
		JOIN acc_trans a ON (v.trans_id = a.trans_id)
		WHERE a.amount &gt; 0
			AND v.batch_id = in_batch_id
			AND v.batch_class IN (select id from batch_class 
					where class = &#39;gl&#39;)
		GROUP BY v.id, g.reference, g.description, v.batch_id, 
			v.trans_id, g.transdate
		ORDER BY 7, 1
	LOOP
		RETURN NEXT voucher_item;
	END LOOP;
END;
</programlisting>
      </para>
    </section>

<!-- Function voucher_get_batch(in_batch_id integer) -->
    <section id="public.function.voucher-get-batch-in-batch-id-integer"
             xreflabel="publicvoucher_get_batch(in_batch_id integer)">
      <title id="public.function.voucher-get-batch-in-batch-id-integer-title">
       voucher_get_batch(in_batch_id integer)
      </title>
      <titleabbrev id="public.function.voucher-get-batch-in-batch-id-integer-titleabbrev">
       voucher_get_batch(in_batch_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>batch</seg>
        </seglistitem>
       </segmentedlist>
 
        Retrieves basic batch information based on batch_id.
        <programlisting>
DECLARE
	batch_out batch%ROWTYPE;
BEGIN
	SELECT * INTO batch_out FROM batch b WHERE b.id = in_batch_id;
	RETURN batch_out;
END;
</programlisting>
      </para>
    </section>

<!-- Function wage__list_for_entity(in_entity_id integer) -->
    <section id="public.function.wage-list-for-entity-in-entity-id-integer"
             xreflabel="publicwage__list_for_entity(in_entity_id integer)">
      <title id="public.function.wage-list-for-entity-in-entity-id-integer-title">
       wage__list_for_entity(in_entity_id integer)
      </title>
      <titleabbrev id="public.function.wage-list-for-entity-in-entity-id-integer-titleabbrev">
       wage__list_for_entity(in_entity_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_wage</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM payroll_wage WHERE entity_id = $1;
</programlisting>
      </para>
    </section>

<!-- Function wage__list_types(in_country_id integer) -->
    <section id="public.function.wage-list-types-in-country-id-integer"
             xreflabel="publicwage__list_types(in_country_id integer)">
      <title id="public.function.wage-list-types-in-country-id-integer-title">
       wage__list_types(in_country_id integer)
      </title>
      <titleabbrev id="public.function.wage-list-types-in-country-id-integer-titleabbrev">
       wage__list_types(in_country_id integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF payroll_income_type</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
SELECT * FROM payroll_income_type where country_id = $1
</programlisting>
      </para>
    </section>

<!-- Function wage__save(in_type_id numeric, in_entity_id integer, in_rate integer) -->
    <section id="public.function.wage-save-in-type-id-numeric-in-entity-id-integer-in-rate-integer"
             xreflabel="publicwage__save(in_type_id numeric, in_entity_id integer, in_rate integer)">
      <title id="public.function.wage-save-in-type-id-numeric-in-entity-id-integer-in-rate-integer-title">
       wage__save(in_type_id numeric, in_entity_id integer, in_rate integer)
      </title>
      <titleabbrev id="public.function.wage-save-in-type-id-numeric-in-entity-id-integer-in-rate-integer-titleabbrev">
       wage__save(in_type_id numeric, in_entity_id integer, in_rate integer)
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>PLPGSQL</seg>
         <seg>SET OF payroll_wage</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting> 
BEGIN

UPDATE payroll_wage
   SET rate = in_rate
 WHERE entity_id = in_entity_id and in_type_id;


IF NOT FOUND THEN
    INSERT INTO payroll_wage (entity_id, type_id, rate)
    VALUES (in_entity_id, in_type_id, in_rate);
END IF;
  
RETURN QUERY SELECT * FROM payroll_wage 
             WHERE entity_id = in_entity_id and in_type_id;
END;
</programlisting>
      </para>
    </section>

<!-- Function warehouse__list_all() -->
    <section id="public.function.warehouse-list-all"
             xreflabel="publicwarehouse__list_all()">
      <title id="public.function.warehouse-list-all-title">
       warehouse__list_all()
      </title>
      <titleabbrev id="public.function.warehouse-list-all-titleabbrev">
       warehouse__list_all()
      </titleabbrev>

      <para>
       <segmentedlist>
        <title>Function Properties</title>
        <?dbhtml list-presentation="list"?>
        <segtitle>Language</segtitle>
        <segtitle>Return Type</segtitle>
        <seglistitem>
         <seg>SQL</seg>
         <seg>SET OF warehouse</seg>
        </seglistitem>
       </segmentedlist>
 
       
        <programlisting>
SELECT * FROM warehouse order by description;
</programlisting>
      </para>
    </section>

  </chapter>

</book>

